id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711276,Integrability,Integrat,IntegratorMultiDim,711276,"= std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for nu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711346,Integrability,Integrat,IntegratorMultiDim,711346,"ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Compu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711416,Integrability,Integrat,IntegratorMultiDim,711416,"al = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711505,Integrability,integrat,integration,711505,"abs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711567,Integrability,Integrat,IntegratorMultiDimOptions,711567,"abs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711743,Integrability,Integrat,IntegratorMultiDimOptions,711743,"d::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GS",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711808,Integrability,Integrat,IntegratorMultiDimOptions,711808,"f,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package wri",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711854,Integrability,Integrat,Integrator,711854,"bs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711994,Integrability,Depend,Depending,711994,"bs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712170,Integrability,integrat,integration,712170,"tion name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712306,Integrability,integrat,integration,712306,"th:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712627,Integrability,integrat,integration,712627,"s are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712693,Integrability,integrat,integration,712693,"torMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712792,Integrability,integrat,integration,712792,"torMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712858,Integrability,integrat,integration,712858,"ute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712899,Integrability,integrat,integration,712899,"ute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713189,Integrability,Integrat,IntegratorMultiDim,713189,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713208,Integrability,interface,interface,713208,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713256,Integrability,Integrat,IntegratorMultiDimOptions,713256,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713452,Integrability,wrap,wrapping,713452,"user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. Numerical Minimization classes. 13.10.1 One-Dimensional Minimization; These algorithms are for finding the mini",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713464,Integrability,integrat,integration,713464,"user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. Numerical Minimization classes. 13.10.1 One-Dimensional Minimization; These algorithms are for finding the mini",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713577,Integrability,integrat,integration,713577,".; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. Numerical Minimization classes. 13.10.1 One-Dimensional Minimization; These algorithms are for finding the minimum of a one-dimensional minimization function. The function to minimize must be given to the class implem",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713767,Integrability,integrat,integration,713767,"e QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. Numerical Minimization classes. 13.10.1 One-Dimensional Minimization; These algorithms are for finding the minimum of a one-dimensional minimization function. The function to minimize must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. The algorithms supported are only bracketing algorithm which do not use derivatives information.; Two classes exist. One in the MathCore library implementi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:715841,Integrability,wrap,wraps,715841,"library implementing several different methods, using in some case the derivatives.; 13.10.1.1 ROOT::Math::BrentMinimizer1D; This class implements the Brent method to minimize one-dimensional function. An interval containing the function minimum must be provided. Here is an example where we define the function to minimize as a lambda function (requires C++11). The function to minimize must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object.; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the Minimize call, the maximum number of function calls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:716536,Integrability,interface,interface,716536,"le x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the Minimize call, the maximum number of function calls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dim",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:717430,Integrability,interface,interface,717430," the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Histogram chapter.; 13.11 ROOT Finder Algorithms; The function must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. Some of the algorithm requires the derivatives of the function. In that case a ROOT::Math::IGradientFunctionOneDim object must be provided.; 13.12 Generic Vectors for 2, 3 and 4 Dimensions (GenVector); GenVector is a package intended to represent vectors and their operations and transformations, such as rotations and Lorentz transformations, in 3 and 4 dimensions. The 3D space is used to describe the geometry vectors and points, while the 4D space-time is used for physics vectors representing relativistic particles. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:724539,Integrability,interface,interface,724539,"ator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or transla",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725017,Integrability,Interface,Interface,725017,"ationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming conv",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725054,Integrability,interface,interface,725054,"ationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming conv",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725838,Integrability,interface,interface,725838,"(class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). 13.12.1.8 Compatibility with CLHEP Vector Classes. For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessorsx(), y(), and z() (and t() for the 4D).; We provide vector member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). 13.12.1.9 Connection to Linear Algebra Package; In some use cases, like in track reconstruction, it is needed to use the content of the vector and rot",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:726955,Integrability,depend,dependency,726955,"s part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). 13.12.1.8 Compatibility with CLHEP Vector Classes. For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessorsx(), y(), and z() (and t() for the 4D).; We provide vector member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). 13.12.1.9 Connection to Linear Algebra Package; In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:737406,Integrability,interface,interface,737406,"le precision. The metric used for all the LorentzVector is (-,-,-,+) .; 13.12.4.1 Constructors and Assignment; The following declarations are available:; // create an empty vector (x=0, y=0, z=0, t=0); XYZTVector v1;; // vector with x=1, y=2, z=3, t=4; XYZTVector v2(1,2,3,4);; // vector with pt=1, eta=2, phi=PI, E=5; PtEtaPhiEVector v3(1,2,PI,5);; Note that each type of vector is constructed by passing its coordinate representation, so a XYZTVector(1,2,3,4) is different from a PtEtaPhiEVector(1,2,3,4). In addition, the Vector classes can be constructed by any vector, which implements the accessors x(), y(), z() and t().; This can be another ROOT::Math::LorentzVector based on a different coordinate system or any vector of a different package, like the CLHEP HepLorentzVector that implements the required signature.; XYZTVector v1(1,2,3,4);; PtEtaPhiEVector v2(v1);; CLHEP::HepLorentzVector q(1,2,3,4);; XYZTVector v3(q);; 13.12.4.2 Coordinate Accessors; All the same coordinate accessors are available through the interface of ROOT::Math::LorentzVector. For example:; //returns cartesian components for the cartesian vector v1; v1.X(); v1.X(); v1.Z(); v1.T();; //returns cartesian components for the cylindrical vector v2; v2.Px(); v2.Py(); v2.Pz(); v2.E();; //returns other components for the cartesian vector v1; v1.Pt(); v1.Eta(); v1.Phi(); v1.M(); In addition, all 4 vector coordinates can be retrieved with the GetCoordinates method:; double d[4];; //fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:745700,Integrability,depend,depending,745700,"nd then Y axis; It is also possible to invert all the transformation or return their inverse:; Rotation3D r1(...);; r1.Invert(); //invert the rotation modifying its content; Rotation3D r2 =r1.Inverse(); //return the inverse in a new; //rotation class; We have used rotation as examples, but all these operations can be applied to all the transformation classes.; 13.12.5.3 Set/GetComponents Methods; Common methods to all transformations are Get and SetComponents. They can be used to retrieve all the scalar values on which the transformation is based.; RotationX rx;; rx.SetComponents(1.); //set agle of the X rotation; double d[9] = {........};; Rotation3D r;; r.SetComponents(d,d+9); //set 9 components of 3D rotation; double d[16];; LorentzRotation lr;; lr.GetComponents(d,d+16); //get 16 components of a LorentzRotation; TMatrixD(3,4) m;; Transform3D t;; t.GetComponens(m); //fill 3x4 matrix with components of t; TheGetComponents and SetComponents methods can be used with a signature based iterators or by using any foreign matrix which implements the operator(i,j) or a different signatures depending on the transformation type. For more details on all methods see the reference documentation of any specific transformation class.; 13.12.6 Example with External Packages; 13.12.6.1 Connection to Linear Algebra Classes; It is possible to use the vector and rotation classes together with the linear algebra classes and to set and get the contents of any 3D or 4D vector from a linear algebra vector class which implements an iterator or something which behaves like an iterator. For example a pointer to a C array (double*) behaves like an iterator. It is then assumed that the coordinates, like (x,y,z) will be stored contiguously.; TVectorD r2(N); //ROOT Linear Algebra Vector containing; //many vectors; XYZVector v2;; //construct vector from x=r[INDEX], y=r[INDEX+1], z=r[INDEX+2]; v2.SetCoordinates(&r2[INDEX],&r2[index]+3);; To fill a linear algebra vector from a 3D or 4D vector, with",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:752046,Integrability,interface,interface,752046,"tor; The following constructors are available to create a vector:. Default constructor for a zero vector (all elements equal to zero).; Constructor (and assignment) from a vector expression, like v=p*q+w. Due to the expression template technique, no temporary objects are created in this operation.; Constructor by passing directly the elements. This is possible only for vectors up to size 10.; Constructor from an iterator copying the data referred by the iterator. It is possible to specify the begin and end of the iterator or the begin and the size. Note that for the Vector the iterator is not generic and must be of type T*, where T is the type of the contained elements. In the following example we assume that we are using the namespace ROOT::Math; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the operator[i], operator(i) or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator.; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:757446,Integrability,interface,interface,757446,"OOT::Math::SMatrix<double,3,3,; ROOT::Math::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); Example to fill a symmetric matrix from an std::vector:; std::vector<double> v(6);; for (int i = 0; i<6; ++i) v[i] = double(i+1);; SMatrixSym3 s(v.begin(),v.end()) // this will produce the; // symmetric matrix; // ( 1 2 4 ); // ( 2 3 5 ); // ( 4 5 6 ); //create a general matrix from a symmetric matrix (the opposite; // will not compile); SMatrix33 m2 = s;; 13.13.2.2 Accessing and Setting Methods; The matrix elements can be set using the operator()(irow,icol), where irow and icol are the row and column indexes or by using the iterator interface. Notice that the indexes start from zero and not from one as in FORTRAN. Furthermore, all the matrix elements can be set also by using the SetElements function passing a generic iterator. The elements can be accessed by the same methods as well as by using the function ROOT::Math::SMatrix::apply. The apply(i) has exactly the same behavior for general and symmetric matrices; in contrast to the iterator access methods which behave differently (it follows the data order).; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m; double x = m(2,1); // return the element in 3; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices; //(note the difference in behav",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:760774,Integrability,rout,routine,760774,"SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; 13.13.2.3 Linear Algebra Matrix Functions (Inversion, Determinant); Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N>6)symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N>6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine dinv.; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; 13.13.3 Example: Matrix and Vector Functions and Operators; 13.13.3.1 Matrix and Vector Operators; The ROOT::Math::SVector and ROOT::Math::SMatrix classes define the following operators described below. The m1, m2, m3 are vectors or matrices of the same type (and size) and a is a scalar value:; m1 == m2 // returns whether m1 is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:765878,Integrability,wrap,wrapped,765878,"T Statistics Classes; 13.14.1 Classes for Computing Limits and Confidence Levels; TFeldmanCousins class calculates the CL upper/lower limit for a Poisson process using the Feldman-Cousins method (as described in PRD V57 #7, p3873-3889). No treatment is provided in this method for the uncertainties in the signal or the background.; TRolke computes confidence intervals for the rate of a Poisson process in the presence of background and efficiency, using the profile likelihood technique for treating the uncertainties in the efficiency and background estimate. The signal is always assumed to be Poisson; background may be Poisson, Gaussian, or user-supplied; efficiency may be Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum. Meth. A551:493-503,2005.; TLimit class computes 95% C.L. limits using the Likelihood ratio semi-Bayesian method ( method; see e.g. T. Junk, NIM A434, p. 435-443, 1999). It takes signal background and data histograms wrapped in a TLimitDataSource as input, and runs a set of Monte Carlo experiments in order to compute the limits. If needed, inputs are fluctuated according to systematic.; 13.14.2 Specialized Classes for Fitting; TFractionFitter fits Monte Carlo (MC) fractions to data histogram (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228). It takes into account both data and Monte Carlo statistical uncertainties through a likelihood fit using Poisson statistics. However, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.; TMultiDimFit implements multi-dimensional function parametrization for multi-dimensional data by fitting them to multi-dimensiona",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:769359,Integrability,interface,interface,769359,"F, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matri",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:788848,Integrability,interface,interface,788848,"umns of a Haar -matrix of order order are indeed orthogonal:; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; Multiplying part of a matrix with another part of that matrix (they can overlap); TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; 14.6 Matrix Decompositions; The linear algebra package offers several classes to assist in matrix decompositions. Each of the decomposition methods performs a set of matrix transformations to facilitate solving a system of linear equations, the formation of inverses as well as the estimation of determinants and condition numbers. More specifically the classes TDecompLU, TDecompBK, TDecompChol, TDecompQRH and TDecompSVD give a simple and consistent interface to the LU, Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes are derived from the base class TDecompBase of which the important methods are listed in next table:. Method; Action. Bool_t Decompose(); perform the matrix decomposition. Double_t Condition(); calculate ||A||1 ||A-1||1, see “Condition number”. void Det(Double_t &d1,Double_t &d2); the determinant is d1 \(2^{d_{2}}\). Expressing the determinant this way makes under/over-flow very unlikely. Bool_t Solve(TVectorD &b); solve Ax=b; vectorb is supplied through the argument and replaced with solution x. TVectorD Solve(const TVectorD &b,Bool_t &ok); solve Ax=b; x is returned. Bool_t Solve(TMatrixDColumn &b); solve Ax=column(B,j);column(B,j) is supplied through the argument and replaced with solution x. Bool_t TransSolve(TVectorD &b); solve \(A^Tx=b;\) vector b is supplied through the argument and replaced with solution x. TVectorD TransSolve(const TVectorD b, Bool_t &ok); solve",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:800324,Integrability,depend,depends,800324,"ty matrix. The columns of \(V\) represent the eigenvectors in the sense that \(A.V = V.D\). If \(A\) is not symmetric, the eigenvalue matrix \(D\) is block diagonal with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues, a+i*b, in 2-by-2 blocks, [a,b;-b,a]. That is, if the complex eigenvalues look like:; \[; \left(\begin{array}{cccccc}; u+iv & . & . & . & . & . \\; . & u-iv & . & . & . & . \\; . & . & a+ib & . & . & . \\; . & . & . & a-ib & . & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); \] then \(D\) looks like: \[; \left(\begin{array}{cccccc}; u & v & . & . & . & . \\; -v & u & . & . & . & . \\; . & . & a & b & . & . \\; . & . & . & -b & a & . \\; . & . & . & . & x & . \\; . & . & . & . & . & y; \end{array}\right); \]; This keeps \(V\) a real matrix in both symmetric and non-symmetric cases, and \(A.V = V.D\). The matrix \(V\) may be badly conditioned, or even singular, so the validity of the equation \(A = V.D.V^{-1}\) depends upon the condition number of \(V\). Next table shows the methods of the classes TMatrixDEigen and TMatrixDSymEigen to obtain the eigenvalues and eigenvectors. Obviously, MatrixDSymEigen constructors can only be called with TMatrixDSym:. Format; Output; Description. eig.GetEigenVectors (); TMatrixD; eigenvectors for both TMatrixDEigen and TMatrixDSymEigen. eig.GetEigenValues (); TVectorD; eigenvalues vector for TMatrixDSymEigen. eig.GetEigenValues(); TMatrixD; eigenvalues matrix for TMatrixDEigen. eig.GetEigenValuesRe (); TVectorD; real part of eigenvalues for TMatrixDEigen. eig.GetEigenValuesIm (); TVectorD; imaginary part of eigenvalues for; TMatrixDEigen. Below, usage of the eigenvalue class is shown in an example where it is checked that the square of the singular values of a matrix \(c\) are identical to the eigenvalues of \(c^{T}\). \(c\):; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:801868,Integrability,depend,dependence,801868,"eal part of eigenvalues for TMatrixDEigen. eig.GetEigenValuesIm (); TVectorD; imaginary part of eigenvalues for; TMatrixDEigen. Below, usage of the eigenvalue class is shown in an example where it is checked that the square of the singular values of a matrix \(c\) are identical to the eigenvalues of \(c^{T}\). \(c\):; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802203,Integrability,rout,routines,802203,"; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802737,Integrability,rout,routine,802737,"ns as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the LU Crout result. In ROOT v4.0, the user can choose between the Invert() and IvertFast() routines, where the latter is using the Cramer algorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:803553,Integrability,rout,routines,803553,"orithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the LU Crout result. In ROOT v4.0, the user can choose between the Invert() and IvertFast() routines, where the latter is using the Cramer algorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving the linear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a C library like GSL. Speed comparison between the different matrix packages. 15 Adding a Class; 15.1 The Role of TObject; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:804623,Integrability,protocol,protocol,804623,"lgorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving the linear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a C library like GSL. Speed comparison between the different matrix packages. 15 Adding a Class; 15.1 The Role of TObject; The light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:804700,Integrability,interface,interface,804700,"ear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a C library like GSL. Speed comparison between the different matrix packages. 15 Adding a Class; 15.1 The Role of TObject; The light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:804803,Integrability,interface,interface,804803,"y 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as stable.; \((A^{T}*A)^{-1}*A^{T}\) timing results for calculation of the pseudo inverse of matrix a. The sequence of operations measures the impact of several calls to constructors and destructors in the C++ packages versus a C library like GSL. Speed comparison between the different matrix packages. 15 Adding a Class; 15.1 The Role of TObject; The light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:806942,Integrability,interface,interface,806942,"tify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be executed.; 15.1.3 Input/Output; The TObject::Write method is the interface to the ROOT I/O system. It streams the object into a buffer using the Streamer method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.; 15.1.4 Paint/Draw; These graphics methods are defaults; their implementation in TObject does not use the graphics subsystem. The TObject::Draw method is simply a call to AppendPad. The Paint method is empty. The default is provided so that one can call Paint in a collection. The method GetDrawOption returns the draw option that was used when the object was drawn on the canvas. This is especially relevant with histograms and graphs.; 15.1.5 Clone/DrawClone; Two useful methods are Clone and DrawClone. The Clone method takes a snapshot of the object with the Streamer and creates a new object. The DrawClone method does the same thing and in addition draws the clone.; 15.1.6 Browse; This method is called if the object is browse-able and is to be displayed in the object browser. For example the TTree implementa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:810865,Integrability,depend,depending,810865,"n different class hierarchies.; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; For example, the bits kMustCleanup and kCanDelete are used in TObject. See “The kCanDelete Bit” and “The kMustCleanup Bit”. They can be set by any object and should not be reused. Make sure not to overlap them in any given hierarchy. The bit 13 (kInvalidObject) is set when an object could not be read from a ROOT file. It will check this bit and will skip to the next object on the file.; The TObject constructor initializes the fBits to zero depending if the object is created on the stack or allocated on the heap. When the object is created on the stack, the kCanDelete bit is set to false to protect from deleting objects on the stack. The high 8 bits are reserved for the system usage; the low 24 bits are user settable. fUniqueID is a data member used to give a unique identification number to an object. It is initialized to zero by the TObject constructor. ROOT does not use this data member. The two data members (fBits and fUniqueID) are streamed out when writing an object to disk. If you do not use them, you can save some space and time by specifying:; MyClass::Class()->IgnoreTObjectStreamer();; This sets a bit in the TClass object. If the file is compressed, the savings are minimal since most values are zero; however, it saves some space when the file is not compressed. A call toIgnoreTObjectStreamer also prevents the creation of two additional branches when splitting the object. If left alone, two branches called fBits and fUniqu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:811924,Integrability,integrat,integrate,811924,"he stack. The high 8 bits are reserved for the system usage; the low 24 bits are user settable. fUniqueID is a data member used to give a unique identification number to an object. It is initialized to zero by the TObject constructor. ROOT does not use this data member. The two data members (fBits and fUniqueID) are streamed out when writing an object to disk. If you do not use them, you can save some space and time by specifying:; MyClass::Class()->IgnoreTObjectStreamer();; This sets a bit in the TClass object. If the file is compressed, the savings are minimal since most values are zero; however, it saves some space when the file is not compressed. A call toIgnoreTObjectStreamer also prevents the creation of two additional branches when splitting the object. If left alone, two branches called fBits and fUniqueID will appear.; 15.2 Motivation; If you want to integrate and use your classes with ROOT, to enjoy features like, extensive RTTI (Run Time Type Information) and ROOT object I/O and inspection, you have to add the following line to your class header files:; ClassDef(ClassName,ClassVersionID); //The class title; For example in TLine.h we have:; ClassDef(TLine,1); //A line segment; The ClassVersionID is used by the ROOT I/O system. It is written on the output stream and during reading you can check this version ID and take appropriate action depending on the value of the ID. See “Streamers”. Every time you change the data members of a class, you should increase its ClassVersionID by one. The ClassVersionID should be >=1. Set ClassVersionID=0 in case you don’t need object I/O. To be able to generate properly documentation for your classes using THtml you must add the statement:; ClassImp(ClassName); For example in TLine.cxx:; ClassImp(TLine); Note that you should provide a default constructor for your classes, i.e. a constructor with zero parameters or with one or more parameters all with default values in case you want to use object I/O. If do not provide such ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:812421,Integrability,depend,depending,812421,"t when writing an object to disk. If you do not use them, you can save some space and time by specifying:; MyClass::Class()->IgnoreTObjectStreamer();; This sets a bit in the TClass object. If the file is compressed, the savings are minimal since most values are zero; however, it saves some space when the file is not compressed. A call toIgnoreTObjectStreamer also prevents the creation of two additional branches when splitting the object. If left alone, two branches called fBits and fUniqueID will appear.; 15.2 Motivation; If you want to integrate and use your classes with ROOT, to enjoy features like, extensive RTTI (Run Time Type Information) and ROOT object I/O and inspection, you have to add the following line to your class header files:; ClassDef(ClassName,ClassVersionID); //The class title; For example in TLine.h we have:; ClassDef(TLine,1); //A line segment; The ClassVersionID is used by the ROOT I/O system. It is written on the output stream and during reading you can check this version ID and take appropriate action depending on the value of the ID. See “Streamers”. Every time you change the data members of a class, you should increase its ClassVersionID by one. The ClassVersionID should be >=1. Set ClassVersionID=0 in case you don’t need object I/O. To be able to generate properly documentation for your classes using THtml you must add the statement:; ClassImp(ClassName); For example in TLine.cxx:; ClassImp(TLine); Note that you should provide a default constructor for your classes, i.e. a constructor with zero parameters or with one or more parameters all with default values in case you want to use object I/O. If do not provide such a default constructor, you MUST implement an I/O constructor. If not you will get a compile time error. See the “The Default Constructor” paragraph in this chapter. The ClassDef and ClassImp macros are defined in the file Rtypes.h. This file is referenced by all ROOT include files, so you will automatically get them if you use ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:834886,Integrability,interface,interface,834886,"n. // file2.h. #ifdef __ROOTCLING__; #pragma link off all classes;; #pragma link off all functions;; #pragma link off all globals;. #pragma link off all typedef;; #pragma link C++ defined_in file1.h;; #endif; The next pragma statements turn on or off the dictionary generation of the object defined in a specific scope. The [scope_name] should be class name, struct name or namespace name. When using these pragmas, it is recommended to use also:; #pragma link C++ nestedclass; Otherwise, definitions in enclosed scope do not appear in the dictionary.; #pragma link [C|C++|off] defined_in [scope_name];; #pragma link [C|C++|off] defined_in; [class|struct|namespace] [scope_name];; Example:; namespace ns {; int a;; double b;; };; The pragma statements are:; #ifdef __ROOTCLING__; #pragma link C++ defined_in ns;; #pragma link C++ nestedclass;; #endif; This statements controls default link mode for rootcling.; #pragma link default [on|off]; By turning default ‘on’, all language constructs in given header files will be included in generated Cling dictionary (interface method source file). If default is set to ‘off’, nothing will be included in the generated dictionary. The next statement explicitly set linkage to each item:; #pragma link [C|C++|off] [class|function|global]; This pragma statement must be given before rootcling reads any C/C++ definitions from header files. Example:; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; 15.5.1.2.1 Compilation; Step 4: Compile the class using the Makefile.In the Makefile call rootcling to make the dictionary for the class. Call it SClassDict.cxx. The rootcling utility generates the methods Streamer, TBuffer &operator>>() and ShowMembersfor ROOT classes.; gmake -f Makefile; Load the shared library:; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:836086,Integrability,Interface,Interface,836086,"pragma statement must be given before rootcling reads any C/C++ definitions from header files. Example:; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; 15.5.1.2.1 Compilation; Step 4: Compile the class using the Makefile.In the Makefile call rootcling to make the dictionary for the class. Call it SClassDict.cxx. The rootcling utility generates the methods Streamer, TBuffer &operator>>() and ShowMembersfor ROOT classes.; gmake -f Makefile; Load the shared library:; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; For more information on rootcling see the $ROOTSYS/test directory Makefile, Event.cxx, and Event.h for an example, or follow this link: http://root.cern.ch/root/RootCintMan.html; 15.6 genreflex: A Comfortable Interface to rootcling; Version 5 supported both Cint and Reflex dictionaries. The tool to create Reflex dictionaries was a Python script called genreflex and was very successful in the user community. Even if version 6 has only one type of dictionaries, cling dictionaries, a re-implementation of genreflex is provided. More precisely, in ROOT6, genreflex is nothing but a wrapper around rootcling, which offers an identical CLI and behaviour to the old Python tool. The input to genreflex is a C++ header file, a set of switches and a selection XML file. The output, as for rootcling, is a C++ dictionary source and a pcm files. An exhaustive documentation of the CLI switches of genreflex can be inspected with the genreflex --help command.; The entity corresponding to the LinkDef file for genreflex is the selection XML file, also called selection XML or simply selection file. A selection XML file allows to describe a list of classes for which the dictionaries are to be created. In addition, it allows to specify prope",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:836460,Integrability,wrap,wrapper,836460,"s using the Makefile.In the Makefile call rootcling to make the dictionary for the class. Call it SClassDict.cxx. The rootcling utility generates the methods Streamer, TBuffer &operator>>() and ShowMembersfor ROOT classes.; gmake -f Makefile; Load the shared library:; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; For more information on rootcling see the $ROOTSYS/test directory Makefile, Event.cxx, and Event.h for an example, or follow this link: http://root.cern.ch/root/RootCintMan.html; 15.6 genreflex: A Comfortable Interface to rootcling; Version 5 supported both Cint and Reflex dictionaries. The tool to create Reflex dictionaries was a Python script called genreflex and was very successful in the user community. Even if version 6 has only one type of dictionaries, cling dictionaries, a re-implementation of genreflex is provided. More precisely, in ROOT6, genreflex is nothing but a wrapper around rootcling, which offers an identical CLI and behaviour to the old Python tool. The input to genreflex is a C++ header file, a set of switches and a selection XML file. The output, as for rootcling, is a C++ dictionary source and a pcm files. An exhaustive documentation of the CLI switches of genreflex can be inspected with the genreflex --help command.; The entity corresponding to the LinkDef file for genreflex is the selection XML file, also called selection XML or simply selection file. A selection XML file allows to describe a list of classes for which the dictionaries are to be created. In addition, it allows to specify properties of classes or data members, without the need to add comments in the source code. This is of primary importance when dictionaries must be created for classes residing in code which cannot be modified. For a complete description of the structure of the selection XML files and the way in which attributes can be set, refer to the genreflex --help command.; It is i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:840175,Integrability,interface,interface,840175,"erial will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines. A set of widgets for a graphical user interface can be placed in a collection. A geometrical model can be described by collections of shapes, materials and rotation matrices. Collections can themselves be placed in collections. Collections act as flexible alternatives to traditional data structures of computers science such as arrays, lists and trees.; 16.1.1 General Characteristics; The ROOT collections are polymorphic containers that hold pointers to TObjects, so:. They can only hold objects that inherit from TObject; They return pointers to TObjects, that have to be cast back to the correct subclass. Collections are dynamic; they can grow in size as required. Collections themselves are descendants of TObject so can themselves be held in collections. It is possible to nest one type of collection inside another to any level to produce structures of arbitrary complexity.; Collections do not own the objects they hold for the very good reason that the same object could be a member of more than one collection. Object ownership",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:844822,Integrability,wrap,wrapper,844822,"added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the members of a collection is generic, i.e. independent of any specific representation of a collection. To process each object in a collection one needs some type of cursor that is initialized and then steps over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TList TListIter; TMap TMapIter. 16.3 Foundation Classes; All collections are based on the fundamental classes: TCollection and TIterator. They are so generic that it is not possible to create objects from them; they are only used as base classes for other classes (i.e. they are abstract base classes).; The TCollection class provides the basic protocol (i.e. the minimum set of member functions) that all collection classes have to implement. These include:. Add Adds another object to the collection.; GetSize Returns the number of objects in the collection.; Clear Clears out the collection, but does not delete the removed objects.; Delete Clears out the collection and deletes the removed objects. This should only be used if the collection owns its objects (which are not normally the case).; FindObject Finds an object given either its name or address.; MakeIterator Returns an iterator associated with the collection.; Remove Removes an object fr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:845196,Integrability,protocol,protocol,845196,"over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TList TListIter; TMap TMapIter. 16.3 Foundation Classes; All collections are based on the fundamental classes: TCollection and TIterator. They are so generic that it is not possible to create objects from them; they are only used as base classes for other classes (i.e. they are abstract base classes).; The TCollection class provides the basic protocol (i.e. the minimum set of member functions) that all collection classes have to implement. These include:. Add Adds another object to the collection.; GetSize Returns the number of objects in the collection.; Clear Clears out the collection, but does not delete the removed objects.; Delete Clears out the collection and deletes the removed objects. This should only be used if the collection owns its objects (which are not normally the case).; FindObject Finds an object given either its name or address.; MakeIterator Returns an iterator associated with the collection.; Remove Removes an object from the collection. The code example below shows a class containing three lists, where the fTracks list is the owning collection and the other two lists are used to store a sub-set of the track objects. In the destructor of the class, the method Delete is called for the owning collection to delete correctly its entire track objects. To delete the objects in the container use",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:847500,Integrability,depend,depending,847500,"delete fVertex2;; }; The TIterator class defines the minimum set of member functions that all iterators must support. These include:. Next Returns the next member of the collection or 0 if no more members.; Reset Resets the iterator so that Next returns the first object. 16.4 A Collectable Class; By default, all objects of TObject derived classes can be stored in ROOT containers. However, the TObject class provides some member functions that allow you to tune the behavior of objects in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the address of the object. It is essential to choose a good hash function. The example below shows how to use and override these member functions.; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRU",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:849547,Integrability,wrap,wrapper,849547,"onst; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as follows:. To create a TIter object its constructor must be passed an object that inherits from TCollection. The TIter constructor calls the MakeIterator() method of this collection to get the appropriate iterator object that inherits from TIterator.; The Next() and Reset() methods of TIter simply call the Next() and Reset() methods of the iterator object. Therefore, TIter simply acts as a wrapper for an object of a concrete class inheriting from TIterator.; To see this working in practice, consider the TObjArray collection. Its associated iterator is TObjArrayIter. Suppose myarray is a pointer to a TObjArray that contains MyClass objects, i.e.; TObjArray *myarray;; To create a TIter object called myiter:; TIter myiter(myarray);. As shown in the diagram, this results in several methods being called:. The TIter constructor is passed a TObjArray; TIter asks embedded TCollection to make an iterator; TCollection asks TObjArray to make an iterator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member of the TObjArray:; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; The heart of this is the myiter.Next() expression which does the following:. The Next() method of the TIter object myiter is called; The TIter forwards the call to the TIterator embedded in the TObjArrayIter; TIterator forwards the call t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:851082,Integrability,wrap,wrapped,851082,"erator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member of the TObjArray:; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; The heart of this is the myiter.Next() expression which does the following:. The Next() method of the TIter object myiter is called; The TIter forwards the call to the TIterator embedded in the TObjArrayIter; TIterator forwards the call to the TObjArrayIter; TObjArrayIter finds the next MyClass object and returns it; TIter passes the MyClass object back to the caller. Sometimes the TIter object is called next, and then instead of writing: next.Next()which is legal, but looks rather odd, iteration is written as next(). This works because the function operator() is defined for the TIter class to be equivalent to the Next() method.; 16.6 The TList Collection; A TList is a doubly linked list. Before being inserted into the list the object pointer is wrapped in a TObjLink object that contains, besides the object pointer also a previous and next pointer.; Objects are typically added using:. Add(); AddFirst(), AddLast(); AddBefore(), AddAfter(). Main features ofTList: very low cost of adding/removing elements anywhere in the list.; Overhead per element: 1 TObjLink, i.e. two 4 (or 8) byte pointers + pointer to vtable = 12 (or 24) bytes.; Next figure shows the internal data structure of a TList. The internal data structure of a TList. 16.6.1 Iterating Over a TList; There are four ways to iterate over a TList:. Using the ForEach script:. GetListOfPrimitives()->ForEach(TObject,Draw)();. Using the TList iterator TListIter (via the wrapper class TIter):. TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();. Using the TObjLink list entries (that wrap the TObject*):. TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }. Using the TList’s After() and Before() member fu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:851769,Integrability,wrap,wrapper,851769,"of writing: next.Next()which is legal, but looks rather odd, iteration is written as next(). This works because the function operator() is defined for the TIter class to be equivalent to the Next() method.; 16.6 The TList Collection; A TList is a doubly linked list. Before being inserted into the list the object pointer is wrapped in a TObjLink object that contains, besides the object pointer also a previous and next pointer.; Objects are typically added using:. Add(); AddFirst(), AddLast(); AddBefore(), AddAfter(). Main features ofTList: very low cost of adding/removing elements anywhere in the list.; Overhead per element: 1 TObjLink, i.e. two 4 (or 8) byte pointers + pointer to vtable = 12 (or 24) bytes.; Next figure shows the internal data structure of a TList. The internal data structure of a TList. 16.6.1 Iterating Over a TList; There are four ways to iterate over a TList:. Using the ForEach script:. GetListOfPrimitives()->ForEach(TObject,Draw)();. Using the TList iterator TListIter (via the wrapper class TIter):. TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();. Using the TObjLink list entries (that wrap the TObject*):. TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }. Using the TList’s After() and Before() member functions:. TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; Method 1 uses internally method 2.; Method 2 works for all collection classes. TIter overloads operator().; Methods 3 and 4 are specific for TList.; Methods 2, 3 and 4 can also easily iterate backwards using either a backward TIter (using argument kIterBackward) or by using LastLink() and lnk>Prev() or by using the Before() method.; 16.7 The TObjArray Collection; A TObjArray is a collection which supports traditional array semantics via the overloading of operator[]. Objects can be directly accessed via an index. The array expands automatical",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:851918,Integrability,wrap,wrap,851918,"the TIter class to be equivalent to the Next() method.; 16.6 The TList Collection; A TList is a doubly linked list. Before being inserted into the list the object pointer is wrapped in a TObjLink object that contains, besides the object pointer also a previous and next pointer.; Objects are typically added using:. Add(); AddFirst(), AddLast(); AddBefore(), AddAfter(). Main features ofTList: very low cost of adding/removing elements anywhere in the list.; Overhead per element: 1 TObjLink, i.e. two 4 (or 8) byte pointers + pointer to vtable = 12 (or 24) bytes.; Next figure shows the internal data structure of a TList. The internal data structure of a TList. 16.6.1 Iterating Over a TList; There are four ways to iterate over a TList:. Using the ForEach script:. GetListOfPrimitives()->ForEach(TObject,Draw)();. Using the TList iterator TListIter (via the wrapper class TIter):. TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();. Using the TObjLink list entries (that wrap the TObject*):. TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }. Using the TList’s After() and Before() member functions:. TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; Method 1 uses internally method 2.; Method 2 works for all collection classes. TIter overloads operator().; Methods 3 and 4 are specific for TList.; Methods 2, 3 and 4 can also easily iterate backwards using either a backward TIter (using argument kIterBackward) or by using LastLink() and lnk>Prev() or by using the Before() method.; 16.7 The TObjArray Collection; A TObjArray is a collection which supports traditional array semantics via the overloading of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877112,Integrability,interface,interface,877112,"is master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:878380,Integrability,message,messages,878380," to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this exa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:889058,Integrability,interface,interfaced,889058,"able->FindElement(""Copper"");; Materials made of single elements can be defined by their atomic mass (A), charge (Z) and density (rho). One can also create a material by specifying the element that it is made of. Optionally the radiation and absorption lengths can be also provided; otherwise they can be computed on-demand [G3]. The class representing them is TGeoMaterial:; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); Any material or derived class is automatically indexed after creation. The assigned index is corresponding to the last entry in the list of materials owned by TGeoManager class. This can be changed using the TGeoMaterial::SetIndex() method, however it is not recommended while using the geometry package interfaced with a transport MC. Radiation and absorption lengths can be set using:; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);. radlen: radiation length. If radlen<=0 the value is computed using GSMATE algorithm in GEANT3; intlen: absorption length. Material state, temperature and pressure can be changed via setters. Another material property is transparency. It can be defined and used while viewing the geometry with OpenGL.; void SetTransparency (Char_t transparency = 0). transparency: between 0 (opaque default) to 100 (fully transparent). One can attach to a material a user-defined object storing Cerenkov properties. Another hook for material shading properties is currently not in use. Mixtures are materials made of several elements. They are represented by the class TGeoMixture, deriving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; E",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:890910,Integrability,interface,interfaces,890910,"ving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891099,Integrability,depend,depend,891099,"oid TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:894199,Integrability,depend,depending,894199,"4 stable; To create a radioactive material based on a radionuclide, one should use the constructor:; TGeoMaterial(const char *name, TGeoElement *elem, Double_t density); To create a radioactive mixture, one can use radionuclides as well as stable elements:; TGeoMixture(const char *name, Int_t nelements, Double_t density);; TGeoMixture::AddElement(TGeoElement *elem,; Double_t weight_fraction);; Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:. TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001). To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. Concentration of C14 derived elements. The population list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:. TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001). The method will create the mixture that result from the decay of a initial material/mixture at time, while all resulting elements having a fractional weight less than precision are excluded.; A demo macro for radioactive material features is $ROOTSYS/tutorials/geom/RadioNuclides.C It demonstrates also the decay of a mixture made of radionuclides. Con",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:895927,Integrability,interface,interface,895927,"cayMaterial(Double_t time, Double_t precision=0.001). The method will create the mixture that result from the decay of a initial material/mixture at time, while all resulting elements having a fractional weight less than precision are excluded.; A demo macro for radioactive material features is $ROOTSYS/tutorials/geom/RadioNuclides.C It demonstrates also the decay of a mixture made of radionuclides. Concentracion of elements derived fromCa53+Sr78. 18.2.3 Tracking Media; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:896348,Integrability,Interface,Interface,896348,"dium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement addition",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:898944,Integrability,interface,interface,898944,"es). This allows the creation of a quite large number of different shape topologies and combinations. You can have a look and run the tutorial: http://root.cern.ch/root/html/examples/geodemo.C.html. Primitive Shapes - the general inheritance scheme. Shapes are named objects and all primitives have constructors like:; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; Naming shape primitive is mandatory only for the primitives used in Boolean composites (see “Composite Shapes”). For the sake of simplicity, we will describe only the constructors in the second form.; 18.3.1 Units; The length units used in the geometry are arbitrary. However, there are certain functionalities that work with the assumption that the used lengths are expressed in centimeters. This is the case for shape capacity or volume weight computation. The same is valid when using the ROOT geometry as navigator for an external transport MC package (e.g. GEANT) via the VMC interface.; Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in degrees. Material density is expressed in [g/cm3].; 18.3.2 Primitive Shapes; 18.3.2.1 Boxes - TGeoBBox Class; Normally a box has to be built only with 3 parameters: DX,DY,DZ representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: -DX to DX on X-axis, from -DY to DY on Y and from -DZ to DZ on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from TGeoBBox. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation (Ox,Oy,Oz). All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:903898,Integrability,depend,dependent,903898,"tra class; A twisted trapezoid is a general trapezoid defined in the same way but that is twisted along the Z-axis. The twist is defined as the rotation angle between the lower and the higher Z faces.; TGeoGtra(Double_t dz,Double_t theta,Double_t phi,Double_t twist,; Double_t h1,Double_t bl1,Double_t tl1,Double_t alpha1,; Double_t h2,Double_t bl2,Double_t tl2,Double_t alpha2 );. TGeoGtra class. 18.3.2.6 Arbitrary 8 vertices shapes - TGeoArb8 class; An Arb8 is defined by two quadrilaterals sitting on parallel planes, at dZ. These are defined each by 4 vertices having the coordinates (Xi,Yi,+/-dZ),i=0,3. The lateral surface of the Arb8 is defined by the 4 pairs of edges corresponding to vertices (i,i+1) on both -dZ and +dZ. If M and M’ are the middles of the segments (i,i+1) at -dZ and +dZ, a lateral surface is obtained by sweeping the edge at -dZ along MM’ so that it will match the corresponding one at +dZ. Since the points defining the edges are arbitrary, the lateral surfaces are not necessary planes - but twisted planes having a twist angle linear-dependent on Z.; TGeoArb8::TGeoArb8(Double_t dz,Double_t ivert);. dz: half-length in Z;; ivert = [0,7]. Vertices have to be defined clockwise in the XY pane, both at +dz and -dz. The quadrilateral at -dz is defined by indices [0,3], whereas the one at +dz by vertices [4,7]. The vertex with index=7 has to be defined last, since it triggers the computation of the bounding box of the shape. Any two or more vertices in each Z plane can have the same (X,Y) coordinates. It this case, the top and bottom quadrilaterals become triangles, segments or points. The lateral surfaces are not necessary defined by a pair of segments, but by pair segment-point (making a triangle) or point-point (making a line). Any choice is valid as long as at one of the end-caps is at least a triangle. TGeoArb8 class. 18.3.2.7 Tubes - TGeoTube Class; Tubes have Z as their symmetry axis. They have a range in Z, a minimum and a maximum radius:; TGeoTube(D",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:906606,Integrability,rout,rout,906606,"onstructor has the form:; TGeoCtub(Double_t rmin,Double_t rmax,Double_t dz,; Double_t phi1,Double_t phi2,; Double_t nxlow,Double_t nylow,Double_t nzlow, Double_t nxhi,; Double_t nyhi,Double_t nzhi);. TGeoCtub Class. A cut tube is a tube segment cut with two planes. The centers of the 2 sections are positioned at dZ. Each cut plane is therefore defined by a point (0,0,dZ) and its normal unit vector pointing outside the shape:; Nlow=(Nx,Ny,Nz<0), Nhigh=(Nx',Ny',Nz'>0).; 18.3.2.10 Elliptical Tubes - TGeoEltu Class; An elliptical tube is defined by the two semi-axes A and B. It ranges from -dZ to +dZ as all other tubes:; TGeoEltu(Double_t a,Double_t b,Double_t dz);. TGeoEltu Class. 18.3.2.11 Hyperboloids - TGeoHype Class; A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907029,Integrability,rout,rout,907029," Tubes - TGeoEltu Class; An elliptical tube is defined by the two semi-axes A and B. It ranges from -dZ to +dZ as all other tubes:; TGeoEltu(Double_t a,Double_t b,Double_t dz);. TGeoEltu Class. 18.3.2.11 Hyperboloids - TGeoHype Class; A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907307,Integrability,rout,rout,907307,"id limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi2.; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; Parametersphi1 and phi2 have the same meaning and convention as for tube segments. TGeoConeSeg Class. 18.3.2.14 Sphere - TGeoSphere Class; Spheres in T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907313,Integrability,rout,rout,907313,"id limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi2.; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; Parametersphi1 and phi2 have the same meaning and convention as for tube segments. TGeoConeSeg Class. 18.3.2.14 Sphere - TGeoSphere Class; Spheres in T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:916146,Integrability,interface,interface,916146,". Building a complete geometry in this style is virtually possible but highly not recommended.; 18.3.3.1 The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure. Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look like. We do this only for understanding how to create them in a proper way, since the user interface for this purpose is in fact very simple. We will ignore for the time being the positioning of components. The definition of a composite shape takes an expression where the identifiers are shape names. The expression is parsed and decomposed in 2 sub-expressions and the top-level Boolean operator. Union: A+B+C. Just to illustrate the Boolean expression parsing and the composite shape structure, let’s take a simple example. We will describe the union of A, B and C. Both union operators are at the same level. Since:; A+B+C = (A+B)+C = A+(B+C); The first(+) is taken as separator, hence the expression split in: A and (B+C). A Boolean node of type TGeoUnion(""A"",""B+C"") is created. This tries to replace the 2 expressions by actual pointers to corresponding shapes. The first expression (A) contains no operators therefore is interpreted as representing a shape. The shape named “A” is searched into the list of shapes handled by the manager class and stored as the “left",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:955641,Integrability,message,message,955641," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.; In the example above all the resulting slices had the same shape as the divided volume (box). This is not always the case. For instance, dividing a volume with TUBE shape on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:964260,Integrability,interface,interface,964260,"0 & 1 \end{array} \right|\). \(r_{ij}\) are the 3x3 rotation matrix components; \(t_x\),\(t_y\),\(t_z\) are the translation components; \(s_x\), \(s_y\), \(s_z\) are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translations would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the same basic abstract class and handling its specific data and point/vector transformation algorithms.; The base class TGeoMatrix defines abstract methods for:. Translation, rotation and scale getters. Every derived class stores only its specific data, e.g. a translation stores an array of 3 doubles and a rotation an array of 9. However, getting the TGeoTranslation rotation array through the base TGeoMatrix interface is a legal operation. The answer in this case is a pointer to a global constant array representing an identity rotation. Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;. Master-to-local and local-to-master point and vector transformations :. void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); Here master and local are arrays of size 3. These methods allow correct conversion also for reflections. Transformation type finding:. Bool_t TGeoMatrix::IsIdentity() const;; Bool_t TGeoMatrix::IsTranslation() const;; Bool_t TGeoMatrix::IsRotation() const;; Bool_t TGeoMatrix::IsScale() const;; Bool_t TGeoMatrix::IsCombi() const; // (t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:968018,Integrability,message,message,968018,"The only data member is: Double_t fTranslation[3]. Translations can be added or subtracted. TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psiabout the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3],TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. 18.4.4 Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971217,Integrability,interface,interface,971217,"ge (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Up",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971444,Integrability,interface,interface,971444,"sition \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; g",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971640,Integrability,interface,interface,971640,"es. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigatio",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:973331,Integrability,interface,interfaced,973331,", but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; 18.5.3 Initializing the Direction; In order to move inside geometry starting with the current point, the modeller needs to know the current direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a direction in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; The direction can be initialized in a similar manner as the current ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:976719,Integrability,interface,interface,976719," call the ‘Where am I?' method:; gGeoManager->FindNode();; In order to have more flexibility, there are in fact several alternative ways of initializing a modeller state:; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the ‘Where am I?' geometrical query representing the basic navigation functionality provided by the modeller.; 18.5.5 Checking the Current State; The current state and all variables related to this are essential during tracking and have to be checked several times. Besides the current point and direction, the following additional information can be retrieved from TGeoManager interface:. The current path. This represents a string containing the names and copy numbers of all positioned objects in the current branch written in the /folder/folder/…/folder/file fashion. The final node pointed by the path is the deepest object containing the current point and is representative for the current state. All intermediate folders in the path are in fact also nodes “touched” by the current point, but having some “touched” containment. The current path can be retrieved only after the state was initialized and is useful for getting an idea of the current point location. const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1. The current node,volume and material. In order to take decisions on post-step or further stepping actions, one has to know these. In order to get a pointer to the current node one can do:. TGeoNode *cnode = gGeoManager->GetCurrentNode();; // then:;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:980950,Integrability,interface,interfaces,980950,"rally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the TGeoManager corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; 18.5.6 Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also all",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:992884,Integrability,interface,interfaced,992884,"m the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle object (may be a TParticle).; A track has a list of daughters that have to be filled using the following method:; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; The method above is pure virtual and have to create a track daughter object. Tracks are fully customizable objects when inheriting from TVirtualGeoTrack class. We will describe the structure and functionality provided by the default implementation of these, which are TGeoTrack obj",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:999145,Integrability,depend,dependent,999145," scheme used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. Extruding volumes. A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable results during tracking. If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an extrusion. When navigating from outside to inside (trying to enter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:999640,Integrability,depend,depends,999640," they lead to unpredictable results during tracking. If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an extrusion. When navigating from outside to inside (trying to enter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illega",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1017703,Integrability,Depend,Depending,1017703,"ode branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; The call to pn1->Align() will invalidate the pointer to the node B_1 in pn2 object.. The way out is to either call pn1->Align() before the creation of pn2, either to use a global method that will correct all existing physical nodes:; void RefreshPhysicalNodes(Bool_t lock = kTRUE); The method above will optionally lock the possibility of doing any further misalignment.; 18.9 Geometry I/O; Once geometry is successfully built, it can be saved in a root file, as C++ macro or as GDML file by calling:; TGeoManager::Export(const char *filename,const char*keyname="""",; Option_t *opt=""vg""). Filenameis the name of the file to be written (mandatory). Depending on the extension of the file, the geometry is exported either as ,root file or .C(.cxx) macro or GDML file in case extension is .gdml.; keynameis the name of the key in the file (default """"); opt = ""v"" is an export voxelization (default), otherwise voxelization is recomputed after loading the geometry, ""g"" this option (default) is taken into account only for exporting to gdml file and it ensures compatibility with Geant4 (e.g. it adds extra plane to incorrectly set polycone, it checks whether offset of Phi division is in (-360;0> range, …), for this gdml export there are two more option, that are not set by default: ""f"" and ""n"". If none of this two options are set, then names of solids and volumes in resulting gdml file will have incremental suffix (e.g. TGeoBBox_0x1, TGeoBBox_0x2, …). If ""f"" option is set then then suffix will contain pointer of object (e.g. TGeoBBox_0xAAAAA01, …). Finally if option ""n"" is set then no suffix will be added, though in this case uniqueness of the names is not ensured and it can cause that",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1020860,Integrability,depend,depending,1020860,"ll always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to TGeoVolume objects):; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; Importing will append the volume to the current TGeoManager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; 18.9.1 GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call.; 18.10 Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1031923,Integrability,Interface,Interface,1031923,"to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1032180,Integrability,interface,interface,1032180,"r = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1032356,Integrability,interface,interfaces,1032356,"te. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geome",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1033893,Integrability,interface,interface,1033893,"tion_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1034214,Integrability,depend,depending,1034214,"try manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. 18.11.3 Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1034400,Integrability,interface,interface,1034400,"to memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. 18.11.3 Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1035178,Integrability,interface,interface,1035178,"is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. 18.11.3 Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc. Selection dialogs for different TGeo objects. Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be des",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1035373,Integrability,interface,interfaces,1035373,"interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. 18.11.3 Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc. Selection dialogs for different TGeo objects. Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together.; ; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the “Apply” button only if the check button “Delayed draw” is checked, ot",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037671,Integrability,depend,depend,1037671,": In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037849,Integrability,interface,interface,1037849,"aterial properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows viewing all volumes down to the selected depth. “Leaves” will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. “Only” will allow drawing only the edited volume. The check button “Raytrace” will just draw the current selection in solid mode using the ray-tracing algorit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1039744,Integrability,interface,interface,1039744,"” will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. . Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled “From”, “Step” and “Nslices” correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors.; 18.11.6 How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the “Materials” shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the “Shapes” category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the “Medium” category. You will notice that some categories as “Volume” and “Medium” are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the “Volumes” category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to “General” category and select the newly created volume as the top one (you can do it also from the volume category). This is ju",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1040948,Integrability,interface,interface,1040948,"e “Shapes” category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the “Medium” category. You will notice that some categories as “Volume” and “Medium” are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the “Volumes” category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to “General” category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Py",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1041172,Integrability,Interface,Interface,1041172,"gory. You will notice that some categories as “Volume” and “Medium” are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the “Volumes” category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to “General” category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1041283,Integrability,interoperab,interoperability,1041283,"es are dynamically activated once all the required components are defined.; Create a volume from the “Volumes” category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to “General” category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046508,Integrability,depend,depends,1046508,"d vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057057,Integrability,message,message,1057057,"tatic void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1066167,Integrability,depend,depends,1066167,"It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the __call__ member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall contain the x, y, z, and t values for the call. The second array, which is optional and its size depends on the number given to the TF1 constructor, contains the values that parameterize the function. For more details, see the TF1 documentation and the examples below.; 19.1.8.1 Plotting Python Function; This is an example of a parameter less Python function that is plotted on a default canvas:; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); Because no number of parameters is given to the TF1 constructor, ‘0’ (the default) is assumed. This way, the ‘identity' function need not handle a second argument, which would normally be used to pass the function parameters. Note that the argument’x’ is an array of size 4. The following is an example of a parameterized Python callable instance that is plotted on a default canvas:; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function with offset 5, and pitch 2; f =",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1075888,Integrability,interface,interface,1075888,"ch brings up the button bar shown on the left. You can click on any button to execute another example. To see the source, open the corresponding source file (for example fit1.C). Once you are done, and want to quit the ROOT session, you can do so by typing .q.; root[] .x demos.C; root[] .q; 20.2 $ROOTSYS/test; The test directory contains a set of examples that represent all areas of the framework. When a new release is cut, the examples in this directory are compiled and run to test the new release’s backward compatibility.; We see these source files:. Makefile; Makefile to build all test programs. hsimple.cxx; Simple test program that creates and saves some histograms. MainEvent.cxx; Simple test program that creates a ROOT Tree object and fills it with some simple structures but also with complete histograms. This program uses the files Event.cxx, EventCint.cxx and Event.h. An example of a procedure to link this program is in bind_Event. Note that the Makefile invokes the rootcling utility to generate the Cling interface EventCint.cxx. Event.cxx; Implementation for classes Event and Track. minexam.cxx; Simple test program for data fitting. tcollex.cxx; Example usage of the ROOT collection classes. tcollbm.cxx; Benchmarks of ROOT collection classes. ctorture.cxx; Test program for the class TComplex. tstring.cxx; Example usage of the ROOT string class. vmatrix.cxx; Verification program for the TMatrix class. vvector.cxx; Verification program for the TVectorclass. vlazy.cxx; Verification program for lazy matrices. hworld.cxx; Small program showing basic graphics. guitest.cxx; Example usage of the ROOT GUI classes. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1086098,Integrability,Interface,Interface,1086098,"f stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; 20.2.3 guitest - A Graphical User Interface. The guitest example, created by compiling guitest.cxx, tests and illustrates the use of the native GUI widgets such as cascading menus, dialog boxes, sliders and tab panels. It is a very useful example to study when designing a GUI. Some examples of the output of guitest are shown next. To run it type guitest at the system prompt in the $ROOTSYS/test directory. We have included an entire chapter on this subject where we explore guitest in detail and use it to explain how to build our own ROOT application with a GUI. See “Writing a Graphical User Interface”. Native GUI widgets. 21 Example Analysis; This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the TSelector class.; 21.1 Explanation; This script uses four large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT web site at: ftp://root.cern.ch/root/h1analysis/; The physics plots generated by ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1086661,Integrability,Interface,Interface,1086661,"*********************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; 20.2.3 guitest - A Graphical User Interface. The guitest example, created by compiling guitest.cxx, tests and illustrates the use of the native GUI widgets such as cascading menus, dialog boxes, sliders and tab panels. It is a very useful example to study when designing a GUI. Some examples of the output of guitest are shown next. To run it type guitest at the system prompt in the $ROOTSYS/test directory. We have included an entire chapter on this subject where we explore guitest in detail and use it to explain how to build our own ROOT application with a GUI. See “Writing a Graphical User Interface”. Native GUI widgets. 21 Example Analysis; This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the TSelector class.; 21.1 Explanation; This script uses four large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT web site at: ftp://root.cern.ch/root/h1analysis/; The physics plots generated by this example cannot be produced using smaller data sets.; There are several ways to analyze data stored in a ROOT Tree. Using TTree::Draw:; This is very convenient and efficient for small tasks. A TTree::Draw call produces one histogram at the time. The histogram is automatically generated. The selection expression may be specified in the command line.; Using the TTreeViewer:; This is a graphical interface to TTree::Draw with the same functionality.; Using the code generated by TTree::MakeClass:; In this case, the user creates an instance of the analysis c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1087489,Integrability,interface,interface,1087489," entire chapter on this subject where we explore guitest in detail and use it to explain how to build our own ROOT application with a GUI. See “Writing a Graphical User Interface”. Native GUI widgets. 21 Example Analysis; This chapter is an example of a typical physics analysis. Large data files are chained together and analyzed using the TSelector class.; 21.1 Explanation; This script uses four large data sets from the H1 collaboration at DESY Hamburg. One can access these data sets (277 Mbytes) from the ROOT web site at: ftp://root.cern.ch/root/h1analysis/; The physics plots generated by this example cannot be produced using smaller data sets.; There are several ways to analyze data stored in a ROOT Tree. Using TTree::Draw:; This is very convenient and efficient for small tasks. A TTree::Draw call produces one histogram at the time. The histogram is automatically generated. The selection expression may be specified in the command line.; Using the TTreeViewer:; This is a graphical interface to TTree::Draw with the same functionality.; Using the code generated by TTree::MakeClass:; In this case, the user creates an instance of the analysis class. They have the control over the event loop and can generate an unlimited number of histograms.; Using the code generated by TTree::MakeSelector: Like for the code generated by TTree::MakeClass, the user can do complex analysis. However, they cannot control the event loop. The event loop is controlled by TTree::Process called by the user. This solution is illustrated by the code below. The advantage of this method is that it can be run in a parallel environment using PROOF (the Parallel Root Facility). A chain of four files (originally converted from PAW ntuples) is used to illustrate the various ways to loop on ROOT data sets. Each contains a ROOT Tree named “h42”. The class definition in h1analysis.h has been generated automatically by the ROOT utility TTree::MakeSelector using one of the files with:; h42->MakeSelector(""h1an",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1098459,Integrability,message,message,1098459," TServerSocket to wait for a connection request over the network. If the request is accepted, it returns a full-duplex socket. Once the connection is accepted, we can communicate to the client that we are ready to go by sending the string “go”, and we can close the server socket.; { // server; TServerSocket *ss = new TServerSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; On the clientside, we create a socket and ask the socket to receive input.; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; 22.2 Sending Objects over the Network; We have just established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and no",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1098780,Integrability,message,message,1098780,"erverSocket(9090,kTRUE);; TSocket *socket = ss->Accept();; socket->Send(""go"");; ss->Close();; }; On the clientside, we create a socket and ask the socket to receive input.; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; 22.2 Sending Objects over the Network; We have just established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we cl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1098828,Integrability,message,message,1098828,"->Send(""go"");; ss->Close();; }; On the clientside, we create a socket and ask the socket to receive input.; { // client; TSocket *socket = new TSocket(""localhost"",9090);; Char str[32];; socket->Recv(str,32);; }; 22.2 Sending Objects over the Network; We have just established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->C",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099032,Integrability,message,message,1099032,"v(str,32);; }; 22.2 Sending Objects over the Network; We have just established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099088,Integrability,message,message,1099088,"t established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099104,Integrability,message,message,1099104,"t established a connection and you just saw how to send and receive a string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099143,Integrability,message,message,1099143,"string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099165,Integrability,message,message,1099165,"string with the example “go”. Now let’s send a histogram.; To send an object (in our case on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099277,Integrability,message,message,1099277,"se on the client side) it has to derive from TObject class because it uses the Streamers to fill a buffer that is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and dis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099318,Integrability,message,message,1099318,"hat is then sent over the connection. On the receiving side, the Streamers are used to read the object from the message sent via the socket. For network communication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099487,Integrability,message,message,1099487,"unication, we have a specialized TBuffer, a descendant of TBuffer called TMessage. In the following example, we create a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Ac",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099576,Integrability,message,message,1099576,"e a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099599,Integrability,message,message,1099599,"e a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099625,Integrability,message,message,1099625,"e a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099645,Integrability,message,message,1099645,"e a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1099675,Integrability,message,message,1099675,"e a TMessage with the intention to store an object, hence the constant kMESS_OBJECT in the constructor. We create and fill the histogram and write it into the message. Then we call TSocket::Send to send the message with the histogram.; ...; // create an object to be sent; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-4,4);; hpx->FillRandom(""gaus"",1000);. // create a TMessage to send the object; TMessage message(kMESS_OBJECT);. // write the histogram into the message buffer; message.WriteObject(hpx);. // send the message; socket->Send(message);; ...; On the receiving end (in our case the server side), we write a while loop to wait and receive a message with a histogram. Once we have a message, we call TMessage::ReadObject, which returns a pointer to TObject. We have to cast it to a TH1 pointer, and now we have a histogram. At the end of the loop, the message is deleted, and another one is created at the beginning.; while (1) {; TMessage *message;; socket->Recv(message);; TH1 *h = (TH1*)message->ReadObject(message->GetClass());; delete message;; }; 22.3 Closing the Connection; Once we are done sending objects, we close the connection by closing the sockets at both ends.; Socket->Close();; This diagram summarizes the steps we just covered:. Server - Client setting-up and closing the connection. 22.4 A Server with Multiple Sockets; Chances are that your server has to be able to receive data from multiple clients. The class we need for this is TMonitor. It lets you add sockets and the TMonitor::Select method returns the socket with data waiting. Sockets can be added, removed, or enabled and disabled. Here is an example of a server that has a TMonitor to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101993,Integrability,message,message,1101993,"ead is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1103498,Integrability,rout,routine,1103498,"e, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementati",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1103719,Integrability,interface,interface,1103719,"example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent imple",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104092,Integrability,depend,depend,1104092,"Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104475,Integrability,depend,dependent,1104475,"multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104665,Integrability,depend,dependent,1104665,"platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Ma",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104870,Integrability,depend,dependent,1104870,"as operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. L",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105019,Integrability,synchroniz,synchronize,1105019,"nux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105053,Integrability,depend,dependent,1105053,".so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107515,Integrability,synchroniz,synchronize,1107515,"gs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking met",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1108140,Integrability,synchroniz,synchronize,1108140," Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to act",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1108817,Integrability,synchroniz,synchronization,1108817,"() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since be",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1109515,Integrability,depend,depending,1109515,"s required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to activate a further thread another MyCondition.Signal() is required, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110241,Integrability,synchroniz,synchronized,1110241,"uired, etc.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Broadcast() all threads waiting for MyCondition are activated at once. In some tests of MyCondition using an internal mutex, Broadcast() activated only one thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110511,Integrability,message,messages,1110511,"ne thread (probably depending whether MyCondition had been signaled before). MyCondition.TimedWait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1110562,Integrability,depend,depends,1110562,"ait(secs,nanosecs) waits for MyCondition until the absolute time in seconds and nanoseconds since beginning of the epoch (January, 1st, 1970) is reached; to use relative timeouts ‘‘delta’‘, it is required to calculate the absolute time at the beginning of waiting ‘‘now’’; for example:. Ulong_t now,then,delta; // seconds; TDatime myTime; // root daytime class; myTime.Set(); // myTime set to ""now""; now=myTime.Convert(); // to seconds since 1970. Return value wait of MyCondition.TimedWait should be 0, if MyCondition.Signal() was received, and should be nonzero, if timeout was reached. The conditions example shows how three threaded functions are synchronized using TCondition: a ROOT script condstart.C starts the threads, which are defined in a shared library (conditions.cxx, conditions.h).; 23.2.4.3 Xlib Connections; Usually Xlib is not thread safe. This means that calls to the X could fail, when it receives X-messages from different threads. The actual result depends strongly on which version of Xlib has been installed on your system. The only thing we can do here within ROOT is calling a special function XInitThreads()(which is part of the Xlib), which should (!) prepare the Xlib for the usage with threads.; To avoid further problems within ROOT some redefinition of the gPad pointer was done (that’s the main reason for the recompilation). When a thread creates a TCanvas, this object is actually created in the main thread; this should be transparent to the user. Actions on the canvas are controlled via a function, which returns a pointer to either thread specific data (TSD) or the main thread pointer. This mechanism works currently only for gPad, gDirectory, gFile and will be implemented soon for other global Objects as e.g. gVirtualX.; 23.2.4.4 Canceling a TThread; Canceling of a thread is a rather dangerous action. In TThread canceling is forbidden by default. The user can change this default by calling TThread::SetCancelOn(). There are two cancellation modes: deferr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1118114,Integrability,message,message,1118114,"mework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** message and make a long jump back to the ROOT prompt. No other custom TSignalHandler can be added to these signals.; The kSigAlarm signal handles asynchronous timers. The kSigWindowChanged signal handles the resizing of the terminal window. The other signals have no other behavior then that to call any registered TSignalHandler::Notify().; When building in interactive application the use of the TRint object handles the kSigInterrupt signal. It causes the printing of the message: *** Break *** keyboard interruptand makes a long jump back to the ROOT command prompt. If no TRint object is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1118589,Integrability,message,message,1118589,"icit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; kSigChildkSigPipe; kSigBuskSigAlarm; kSigSegmentationViolationkSigUrgent; kSigIllegalInstructionkSigFloatingException; kSigSystemkSigWindowChanged; The signals kSigFloatingException, kSigSegmentationViolation, kSigIllegalInstruction, and kSigBus cause the printing of the *** Break *** message and make a long jump back to the ROOT prompt. No other custom TSignalHandler can be added to these signals.; The kSigAlarm signal handles asynchronous timers. The kSigWindowChanged signal handles the resizing of the terminal window. The other signals have no other behavior then that to call any registered TSignalHandler::Notify().; When building in interactive application the use of the TRint object handles the kSigInterrupt signal. It causes the printing of the message: *** Break *** keyboard interruptand makes a long jump back to the ROOT command prompt. If no TRint object is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions be",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1121018,Integrability,Synchroniz,Synchronization,1121018,"tion contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1121162,Integrability,Synchroniz,Synchronization,1121162,"res a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1121519,Integrability,synchroniz,synchronization,1121519,"ursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At that time the semaphore count is decremented and the thread continues. When a thread releases semaphore, the semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1122013,Integrability,synchroniz,synchronization,1122013,"ork that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At that time the semaphore count is decremented and the thread continues. When a thread releases semaphore, the semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simultaneous read access by many threads while restricting write access to only one thread at a time. When any thread holds the lock for reading, other threads can also acquire the lock reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a po",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1127111,Integrability,Interface,Interface,1127111,"thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI fully cross-platform. Originally the GUI classes were based on Hector Peraza’s Xclass’95 widget library http://xclass.sourceforge.net/; 25.1 The ROOT GUI Classes; Features of the GUI classes in a nutshell:. Originally based on the Xclass’95 widget library; A rich and complete set of widgets; Win’95 look and feel; All machine dependent graphics calls abstracted via the TVirtualX “abstract” class; Completely scriptable via the C++ interpreter (fast prototyping); Supports signal/slot event handling as pioneered by Trolltech’s Qt; Full class documentation is generated automatically (as for all ROOT classes); Code generation for variety of GUI’s. 25.2 Widgets and Frames; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1127242,Integrability,interface,interface,1127242,"ted domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI fully cross-platform. Originally the GUI classes were based on Hector Peraza’s Xclass’95 widget library http://xclass.sourceforge.net/; 25.1 The ROOT GUI Classes; Features of the GUI classes in a nutshell:. Originally based on the Xclass’95 widget library; A rich and complete set of widgets; Win’95 look and feel; All machine dependent graphics calls abstracted via the TVirtualX “abstract” class; Completely scriptable via the C++ interpreter (fast prototyping); Supports signal/slot event handling as pioneered by Trolltech’s Qt; Full class documentation is generated automatically (as for all ROOT classes); Code generation for variety of GUI’s. 25.2 Widgets and Frames; The ROOT GUI classes provide of set of components that allow an easy way to develop cross-platform GUI applications with a Windows look and feel.; The main widgets are:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1127752,Integrability,depend,dependent,1127752,"de an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI fully cross-platform. Originally the GUI classes were based on Hector Peraza’s Xclass’95 widget library http://xclass.sourceforge.net/; 25.1 The ROOT GUI Classes; Features of the GUI classes in a nutshell:. Originally based on the Xclass’95 widget library; A rich and complete set of widgets; Win’95 look and feel; All machine dependent graphics calls abstracted via the TVirtualX “abstract” class; Completely scriptable via the C++ interpreter (fast prototyping); Supports signal/slot event handling as pioneered by Trolltech’s Qt; Full class documentation is generated automatically (as for all ROOT classes); Code generation for variety of GUI’s. 25.2 Widgets and Frames; The ROOT GUI classes provide of set of components that allow an easy way to develop cross-platform GUI applications with a Windows look and feel.; The main widgets are:. Simple widgets: labels, icons, push buttons, either with text or pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll bars, list boxes, combo boxes, group frames, text entry widgets, tab widgets, progress bars, sliders, tool tips; Complex widgets: shutter, toolbar, status bar, list view, list tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129127,Integrability,message,messages,1129127,"y to develop cross-platform GUI applications with a Windows look and feel.; The main widgets are:. Simple widgets: labels, icons, push buttons, either with text or pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll bars, list boxes, combo boxes, group frames, text entry widgets, tab widgets, progress bars, sliders, tool tips; Complex widgets: shutter, toolbar, status bar, list view, list tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example progra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129186,Integrability,message,messages,1129186,"y to develop cross-platform GUI applications with a Windows look and feel.; The main widgets are:. Simple widgets: labels, icons, push buttons, either with text or pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll bars, list boxes, combo boxes, group frames, text entry widgets, tab widgets, progress bars, sliders, tool tips; Complex widgets: shutter, toolbar, status bar, list view, list tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example progra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129286,Integrability,interface,interface,1129286,"ext or pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll bars, list boxes, combo boxes, group frames, text entry widgets, tab widgets, progress bars, sliders, tool tips; Complex widgets: shutter, toolbar, status bar, list view, list tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example program is written as a named script. See “Cling the C++ Interpreter”. Remember that the named script can be executed via; root[] .x example.C; only if the filenam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129312,Integrability,depend,dependent,1129312,"ext or pixmaps, check buttons, radio buttons, menu bars and popup menus, scroll bars, list boxes, combo boxes, group frames, text entry widgets, tab widgets, progress bars, sliders, tool tips; Complex widgets: shutter, toolbar, status bar, list view, list tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example program is written as a named script. See “Cling the C++ Interpreter”. Remember that the named script can be executed via; root[] .x example.C; only if the filenam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1129552,Integrability,interface,interface,1129552,"tree; Common dialogs: File Open/Save, File Properties, Font Selection, Color Selection, About; The widgets are shown in frames:; frame, composite frame, main frame, transient frame, group frame; Arranged by layout managers:; horizontal layout, vertical layout, row layout, list layout, tile layout, matrix layout. Using a combination of layout hints:. left, right, center x, center y, top, bottom, expand x, expand y, fixed offsets. Event handling by signals/slots and messaging (as opposed to callbacks):. in response to actions widgets send messages and emit signals; associated frames process these messages or the slot methods connected to the signals are executed. 25.3 TVirtualX; The GUI classes interface to the platform dependent low level graphics system via the semi-abstract graphics base class TVirtualX. Currently concrete implementations exist for X11 and Win32 (MacOS X is fully supported via Apple’s X11 implementation). Thanks to this single graphics interface, porting the ROOT GUI to a new platform requires only the implementation of TVirtualX. 25.4 A Simple Example; We will start with a simple example that builds a small application containing a canvas and two buttons: Draw and Exit. Its functionality will be very simple: every time you click on Draw button, the graphics of the function sin(x)/x will be drawn in randomly chosen interval in the canvas window, if you click on Exit - you close the application. This example shows the basic concepts for almost any GUI-application in ROOT and it is important to understand how it is constructed. The example program is written as a named script. See “Cling the C++ Interpreter”. Remember that the named script can be executed via; root[] .x example.C; only if the filename (without extension) and the function entry point are both the same. We need to say a few words about the parent-children relationship between the widgets before going through the real code. The widgets’ behaviors are based on this relationship. Every pa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1142467,Integrability,interface,interface,1142467," desired functionality; Define widget’s layout and add it to the parent list of children; Set main window attributes; Map all sub windows; Initialize the layout algorithm via Resize(GetDefaultSize()) method; Map the main frame; Execution of the even-processing loop. 25.4.1 A Standalone Version; As usual a standalone program in C++ has to contain a main() function - the starting point for the application execution. In this case it is better to separate the program code creating a program header file example2a.h with the MyMainFrame class declaration and example2a.cxx- with the class methods implementation. To run our simple example as a standalone application we need to create in addition an object of class TApplication. It will make a correct initialization of the dictionaries if it is not yet done. It will be responsible for holding everything together and to handle all events in the application. Its environment provides an interface to the ROOT graphics system and by calling the Run() method the event loop starts and the application program is waiting for the user action. The application exits only if the top level window is not closed. Two header files are used in addition: TApplication.h - for the class TApplication and TGClient.h that is used to make initial connection to the graphics system. The class TApplication must be instantiated only once in any given application. The original list of argument options can be retrieved via the Argc() and Argv() methods.; Note: to have signals/slots working we need to create a dictionary for the class MyMainFrame, i.e. we create the file ex2aLinkDef.h containing the line:; #pragma link C++ class MyMainFrame;; We compile the example:; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; example2a.h; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMai",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1145912,Integrability,contract,contraction,1145912,"#include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40);; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; hframe->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit "",; ""gApplication->Terminate()"");; hframe->AddFrame(exit, new TGLayoutHints(kLHintsCenterX,; 5,5,3,4));; AddFrame(hframe,new TGLayoutHints(kLHintsCenterX,2,2,2,2));. // Sets window name and shows the main frame; SetWindowName(""Simple Example"");; MapSubwindows();; Resize(GetDefaultSize());; MapWindow();; }; 25.5 Widgets Overview; The word widget is a contraction of windows and gadget. Almost all GUI elements are widgets. A button is a widget, a menu item is a widget, a scrollbar is a widget, and a complete dialog box is a widget too. Some widgets may have sub widgets. For example, a dialog box can contain buttons, text fields, a combo-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achiev",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1149092,Integrability,interface,interface,1149092,"and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; The method IsEnabled() - returns kTRUE if the widget has flag kWidgetIsEnabled and it accepts user events. This method is very important for creating a good user interface because it allows you to disable or enable a widget depending on the situation of your application. As a standard all disabled widgets are displayed “grayed out”. HasFocus() - returns kTRUE if the widget has the input focus (i.e. flag kWidgetHasFocus is set). Remember that only one item in a complex widget as a dialog can have the value of HasFocus() sets as true. WantFocus() - returns kTRUE if the flag kWidgetWantFocus is set.; 25.5.3 TGWindow; TGWindow is a ROOT GUI window base class. It inherits from TGObject and TGFrame derives from it. The application does not use it directly. It creates and registers a new window within the system. This window has common characteristics: existing parent, location, size in height and width (it has a default minimum size 1, 1 under which it cannot shrink), border with particular view, state, specific attributes. If there are no specified arguments their values will be taken from the parent. It receives events from the window system and can paint a representation of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1149154,Integrability,depend,depending,1149154,"and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; The method IsEnabled() - returns kTRUE if the widget has flag kWidgetIsEnabled and it accepts user events. This method is very important for creating a good user interface because it allows you to disable or enable a widget depending on the situation of your application. As a standard all disabled widgets are displayed “grayed out”. HasFocus() - returns kTRUE if the widget has the input focus (i.e. flag kWidgetHasFocus is set). Remember that only one item in a complex widget as a dialog can have the value of HasFocus() sets as true. WantFocus() - returns kTRUE if the flag kWidgetWantFocus is set.; 25.5.3 TGWindow; TGWindow is a ROOT GUI window base class. It inherits from TGObject and TGFrame derives from it. The application does not use it directly. It creates and registers a new window within the system. This window has common characteristics: existing parent, location, size in height and width (it has a default minimum size 1, 1 under which it cannot shrink), border with particular view, state, specific attributes. If there are no specified arguments their values will be taken from the parent. It receives events from the window system and can paint a representation of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1155454,Integrability,interface,interface,1155454,"rame(hFrame2,fLayout2);; frame->Resize(frame->GetDefaultSize()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; The state information about a child frame can be obtained from the methods GetState(TGframe *f), IsArranged(TGFrame *f), and IsVisible(TGFrame *f).; The method Cleanup() deletes all objects of the composite frame added via AddFrame(). All TGFrameElement objects (frames and layout hints) must be unique, i.e. cannot be shared.; We already mentioned that TGMainFrame class defines top level windows interacting with the system window manager. It handles applications with a menu bar, toolbar, text entry fields and other widgets surrounding a central area (e.g. a canvas widget). It lays out a set of related widgets and provides the typical application main window behavior. As you can see from the Figure above, it inherits from TGCompositeFrame and is inherited by TGTransientFrame and several ROOT interface classes: TViewerX3D,TRootBrowser, TRootCanvas, TRootControlBar, TTreeViewer.; To fix the size of a top level window you have to use the method TGMainFrame::SetWMSize(). This call tells the Window Manager that it should not resize the window. The option kFixedSize works only for embedded frames like TGCompositeFrame and derived classes (in combination with layout hints).; The TGVerticalFrame and TGHorizontalFrame are composite frames that lay out their child frames in vertical or horizontal way in the same order as they were added and according to their hints preferences.; The TGTransientFrame class defines transient windows that typically are used for dialogs. They extend and complete an interaction within a limited context. Always transient frames are displayed from another window or another dialog. They may appear because of a command button being activated or a menu item being selected. They may also present automatically when an additional input and th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157542,Integrability,message,message,1157542,"ly a group of logically connected widgets: radio buttons, related check boxes, two or more functionally related controls. It is a composite frame with a border and a title. The title explains the purpose of the group and should be a noun or noun phrase. Here is an example taken from guitest.C:; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TGCmpositeFrame. You can easily change the layout manager using the SetLayoutManager(TGLayoutManager *l) method. Setting the proper layout manager for each",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1162719,Integrability,Interface,Interface,1162719,"tsExpandY; specifies the frame to be expanded up to the height of the container frame. If the container frame is a horizontal frame - it will fit the whole height. If the container frame is a vertical frame - after the arrangement of all frames the available “free” height space is shared between the frames having this hint. kLHintsNormal; = kLHintsLeft | kLHintsTop - default hints. Layout policy:; Child frames never modify their container frame. The container frame can (or cannot) adapt its size in the layout process. It can show all or a part of its frames. Every TGFrame object has a default minimum size (1, 1) assured by TGWindow.; 25.7 Event Processing: Signals and Slots; Event handling covers the interaction between different objects and between the user and the objects in an application. There are two general ways for the user to interact with an application: the keyboard and the mouse. The Graphical User Interface is as a bridge between the user and the program - it provides methods to detect the user actions and instruments that do something as a reaction of these actions. The user communicates with an application through the window system. The window system reports interaction events to the application. The application in turn forwards them to the currently active window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1162737,Integrability,bridg,bridge,1162737,"tsExpandY; specifies the frame to be expanded up to the height of the container frame. If the container frame is a horizontal frame - it will fit the whole height. If the container frame is a vertical frame - after the arrangement of all frames the available “free” height space is shared between the frames having this hint. kLHintsNormal; = kLHintsLeft | kLHintsTop - default hints. Layout policy:; Child frames never modify their container frame. The container frame can (or cannot) adapt its size in the layout process. It can show all or a part of its frames. Every TGFrame object has a default minimum size (1, 1) assured by TGWindow.; 25.7 Event Processing: Signals and Slots; Event handling covers the interaction between different objects and between the user and the objects in an application. There are two general ways for the user to interact with an application: the keyboard and the mouse. The Graphical User Interface is as a bridge between the user and the program - it provides methods to detect the user actions and instruments that do something as a reaction of these actions. The user communicates with an application through the window system. The window system reports interaction events to the application. The application in turn forwards them to the currently active window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164021,Integrability,message,message,1164021,". The application in turn forwards them to the currently active window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(cons",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175863,Integrability,interface,interfaces,1175863,"alue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.; There are two main groups of buttons: command buttons with a text or graphics inside that indicate the action to be accomplished and option buttons well known as radio and check buttons that select or change properties. The first group is presented in ROOT by TGPictureButton and TGTextButton classes. They yield an action as soon as they are clicked. It can be opening/closing a dialog box or invoking a specific function in an application. Remember the Draw button from the example. The radio and check buttons from the second group are used to select an option. There is a visual difference between these two groups: the text buttons appear “pressed in” only while they are clicked, while the radio and check buttons change their appearance when they are selected and keep that appearance afterwards.; A text button is ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1194636,Integrability,depend,depends,1194636,"e, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every application success and depends of three main factors:. number of presented items in the menu; how often the menu is used; how often the menu contents may change. 25.8.5 Toolbar. A toolbar (TGToolBar) is a composite frame that contains TGPictureButtonobjects. It provides an easy and fast access to most frequently used commands or options across multiple application screens. Also, it invokes easily a sub application within an application. All its functions can be obtained by application menus. It is located horizontally at the top of the main window just below the menu bar. All other subtask and sub-feature bars are positioned along sides of window.; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",; 0; };; // toolbar tool tip text; const char *tips[] = {; ""X Settings"",; ""Y Settings"",; ""Z Settings"",; 0; };; // toolbar button separator; int separator = 5;. // structure containing toolbar button information; ToolBarData_t t[3];. // creation of a ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1196783,Integrability,message,message,1196783,"LSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; To have a tool bar in your application you do not need to do anything special - only to create objects: a tool bar and its picture buttons. This sample code creates the following three toolbar buttons:. First we need to complete a ToolBarData_t structure for each tool bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was val",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1197932,Integrability,message,messages,1197932," kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was valid). The first parameter is the window to which the button messages will be sent. Lastly, we create an object of class TGHorizontal3DLine - a horizontal 3D line. It will separate the toolbar from the menu bar because the layout hints we define as kLHintsTop | kLHintsExpandX.; It is user friendly to allow the possibility for the tool bar to be turned on or off (via a menu). If you use a single tool bar, it should fill the complete width of its parent. When using more than one, you should also think about setting the bar size to the end of the most right button. This way other bars can be displayed in the same row below the menu bar.; Tool bar buttons should have equal size, meaningful and unique icons, and short meaningful tool tip text. The related buttons should be grouped together by frequency or sequence of use, or importance. Potentially destructive buttons must be separated from them to avoid accidental activation and potentially catastrophic results. Temporarily not available items should be displayed grayed out.; 25.8.6 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1201621,Integrability,rout,routines,1201621,"istBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; We create the list box widget passing the parent window pointer and giving an ID number. Next we add entries with specified string and ID to the list box. Before adding the list box to its parent widget, it should be resized via Resize(width, height) method. The list box width and height are in pixels. The default entry layout hints are kLHintsExpandX | kLHintsTop. If you want to add entries using different ones, call the method:; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; It adds the specified TGLBEntry and TGLayoutHints to the list box. There are several methods providing a flexible entry manipulation: you can insert, add or remove list box items dynamically. The list box entry IDs are used in these methods and also in event processing routines. In our example the integer variables fFirstEntry and fLastEntry contain the information about the first and last entry IDs. You can add or remove a list box entry using them in the following way:; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; A single-selection list box is used for selecting only one item in a list.; A multiple-selection list box permits selection of more than one item. The selected choices should be visible - you have several choices to do this:. to mark selected choices with a check mark or highlight them; to provide a summary list box to the right of the list box, containing the selected choices; to provide a display-only text control indicating the number of selected choi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208365,Integrability,message,message,1208365,"HSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg3->SetFillType(TGProgressBar::kBlockFill);. vframe->AddFrame(fHProg1,new TGLayoutHints(kLHintsTop|kLHintsLeft|; kLHintsExpandX,5,5,5,10));; vframe->AddFrame(fHProg2,new TGLayoutHints(kLHintsTop|kL",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1211790,Integrability,message,message,1211790,"hed by TGClient in order to keep the resource usage low and to improve the efficiency of the client-server windowing systems. TGClient will check whether a pixmap with the same name was already loaded before to register a new picture object. If it finds it, it will return a pointer to the existing object. Also, it will increase the usage counter for the object.; All TGPicture objects are managed by the class TGPicturePool. TGClient creates an object of this type upon initialization. Normally your application program does not deal directly with this class because all manipulations go through TGClient class.; Once you have finished with using of the TGPicture object, you should call the method TGClient::FreePicture(const TGPicture *pic) to free it. The usage counter of the picture object will be decreased and when it reaches zero - the TGPicture object will be deleted.; 25.8.12 Status Bar; The status bar widget is used to display some information about the current application state: what is being viewed in the window, a descriptive message about selected objects, or other no interactive information. It may also be used to explain highlighted menu and tool bar items. An application can only have one status bar at a time.; There is nothing special to create a status bar in your application. You should decide how many fields you need to present the current application state to the user. By default a status bar consists of one part. Multiple parts can be created by SetParts method. Its first parameter is an array of integers that give the percentage size of each part. The second parameter gives the number of status bar parts. Using SetText method you can set a text for any part.; // status bar; Int_t parts[] = {33, 10, 10, 47};; fStatusBar = new TGStatusBar(fMain,50,10,kHorizontalFrame);; fStatusbar->SetParts(parts,4);; fMain->AddFrame(fStatusBar, new TGLayoutHints(kLHintsBottom |; kLHintsLeft | kLHintsExpandX, 0, 0, 2, 0));; . . .; // fill status bar fields with informat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1220860,Integrability,interface,interface,1220860,"etBit(kNoContextMenu);; fEc1->GetCanvas()->Connect(""ProcessedEvent(Int_t,Int_t,Int_t,TObject*)"",; ""MyClass"", this, ""HandleMyCanvas(Int_t,Int_t,Int_t,TObject*)"");. To embed a canvas derived from a TCanvas do the following:; TRootEmbeddedCanvas *embed = new TRootEmbeddedCanvas(0, p, w, h);; // note name must be 0, not null string """"; Int_t wid = embed->GetCanvasWindowId();; TCanvas *myc = new TCanvas(""myname"",10,10,wid);; embed->AdoptCanvas(myc);; // the TCanvas is adopted by the embedded canvas and will be; // destroyed by it; 25.9 The ROOT Graphics Editor (GED); Everything drawn in a ROOT canvas is an object. There are classes for all objects, and they fall into hierarchies. In addition, the ROOT has fully cross-platform GUI classes and provides all standard components for an application environment with common ‘look and feel’. The object-oriented, event-driven programming model supports the modern signals/slots communication mechanism. It handles user interface actions and allows total independence of interacting objects and classes. This mechanism uses the ROOT dictionary information and the Cling the C++ Interpreter to connect signals to slots methods.; Therefore, all necessary elements for an object-oriented editor design are in place. The editor complexity can be reduced by splitting it into discrete units of so-called object editors. Any object editor provides an object specific GUI. The main purpose of the ROOT graphics editor is the organization of the object editors’ appearance and the task sequence between them.; 25.9.1 Object Editors; Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘Editor’ (e.g. for TGraph objects the object editor is TGraphEditor). Thanks to the signals/slots communication mechanism and to the method DistancetoPrimitive() that computes a ‘‘distance’’ to an object from the mouse position, it was possible to implement a signal method of the canvas that says which is the sel",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1222030,Integrability,interface,interface,1222030," and the Cling the C++ Interpreter to connect signals to slots methods.; Therefore, all necessary elements for an object-oriented editor design are in place. The editor complexity can be reduced by splitting it into discrete units of so-called object editors. Any object editor provides an object specific GUI. The main purpose of the ROOT graphics editor is the organization of the object editors’ appearance and the task sequence between them.; 25.9.1 Object Editors; Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘Editor’ (e.g. for TGraph objects the object editor is TGraphEditor). Thanks to the signals/slots communication mechanism and to the method DistancetoPrimitive() that computes a ‘‘distance’’ to an object from the mouse position, it was possible to implement a signal method of the canvas that says which is the selected object and to which pad it belongs. Having this information the graphics editor loads the corresponding object editor and the user interface is ready for use. This way after a click on ‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad editor, etc.; The algorithm in use is simple and is based on the object-oriented relationship and communication. When the user activates the editor, according to the selected object <obj> in the canvas it looks for a class name <obj>Editor. For that reason, the correct naming is very important. If a class with this name is found, the editor verifies that this class derives from the base editor class TGedFrame. If all checks are satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The gr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1222856,Integrability,interface,interface,1222856,"f the canvas that says which is the selected object and to which pad it belongs. Having this information the graphics editor loads the corresponding object editor and the user interface is ready for use. This way after a click on ‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad editor, etc.; The algorithm in use is simple and is based on the object-oriented relationship and communication. When the user activates the editor, according to the selected object <obj> in the canvas it looks for a class name <obj>Editor. For that reason, the correct naming is very important. If a class with this name is found, the editor verifies that this class derives from the base editor class TGedFrame. If all checks are satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The graphics editor gives an intuitive way to edit objects in a canvas with immediate feedback. Complexity of some object editors is reduced by hiding GUI elements and revealing them only on users’ requests.; An object in the canvas is selected by clicking on it with the left mouse button. Its name is displayed on the top of the editor frame in red color. If the editor frame needs more space than the canvas window, a vertical scroll bar appears for easy navigation. Histogram, pad and axis editors. 25.9.2 Editor Design Elements; The next rules describe the path to follow when creating your own object editor that will be recognized and loaded by the graphics editor in ROOT, i.e. it will be included as a part of it. Derive the code of your object editor from the base editor class TGedFrame.; Keep the correct naming convention: the name of the object editor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1225602,Integrability,depend,depending,1225602," GED-frames are constructed during traversal of class hierarchy of the selected object, executed from method TGedEditor::SetModel(). When a new object of a different class is selected, the unneeded GED-frames are cached in memory for potential reuse. The frames are deleted automatically when the editor is closed.; Note: A deep cleanup is assumed for all frames put into the editor. This implies:. do not share the layout-hints among GUI components;; do not delete child widgets in the destructor as this is done automatically. 25.9.2.2 Using Several Tabs; Sometimes you might need to use several tabs to organize properly your class-editor. Each editor tab is a resource shared among all the class-editors. Tabs must be created from the constructor of your editor-class by using the method:; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; It returns a pointer to a new tab container frame ready for use in your class. If you need to hide/show this frame depending on the object’s status, you should store it in a data member. See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re-implementing virtual method void TGedFrame::ActivateBaseClassEditors(TClass *cl). It is called during each compound editor rebuild and the default implementation simply offers all base-classes to the publishing mechanism.; To prevent inclusion of a base-class into the compound editor, call:; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); Pointer to the compound GED-editor is available in TGedFrame‘s data-member:; TGedEditor *fGedEditor; Ordering of base-class editor frames follows the order of the classes in the class hierarchy. This order can be changed by modifying the value of TGedFrame’s data member Int_t fPriority. The default value is 50; smaller values move the frame towards to the top. This priority should be set in the editor constructor.; 25.10 Drag and Drop; Drag an",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1226688,Integrability,protocol,protocol,1226688,". See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re-implementing virtual method void TGedFrame::ActivateBaseClassEditors(TClass *cl). It is called during each compound editor rebuild and the default implementation simply offers all base-classes to the publishing mechanism.; To prevent inclusion of a base-class into the compound editor, call:; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); Pointer to the compound GED-editor is available in TGedFrame‘s data-member:; TGedEditor *fGedEditor; Ordering of base-class editor frames follows the order of the classes in the class hierarchy. This order can be changed by modifying the value of TGedFrame’s data member Int_t fPriority. The default value is 50; smaller values move the frame towards to the top. This priority should be set in the editor constructor.; 25.10 Drag and Drop; Drag and Drop support is introduced for Linux (via Xdnd - the drag and drop protocol for X window system) and for Windows (via Clipboard). Users can selects something in ROOT with a mouse press, drags it (moves the mouse while keeping the mouse button pressed) and releases the mouse button someplace else. When the button is released the selected data is “dropped” at that location. This way, a histogram from an opened ROOT file in the browser can be dragged to any TCanvas. A script file from the browser can be dropped to a TGTextView or TGTextEdit widget in TGTextEditor.; On Linux, it is possible to drag objects between ROOT and an external application. For example to drag a macro file from the ROOT browser to the Kate editor. On Windows, drag and drop works only within a single ROOT application (for the time being), but works also from Windows Explorer to TCanvas ot to TGTextEdit.; 25.10.1 Drag and Drop Data Class; The Drag and Drop Cata class TDNDdata is used to describe and handle the transferred data during an drag and drop operation. It con",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1229670,Integrability,message,messages,1229670,"illRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; Then, set a GUI widget as DND Source, and associate the data. Source widget can be any class inheriting from TGFrame.; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; Setting A Drop Target - set the widget as DND Target, and set the DND types it must be aware of: as SourceWidget, TargetWidget can be any class inheriting from TGFrame.; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; gDNDManager->GetTypeList() returns the list of types recognized by ROOT.; Note that the Widget may receive drag and drop messages with drop-data it does not understand, and thus it should only accept drops of the proper type.; 25.10.2 Handling Drag and Drop Events; Once a widget has been set as DND Target, it has to handle Drag and Drop events.; Atom_t HandleDNDenter(Atom_t *typelist) - this method is used to handle a drag operation entering the widget. The typelist parameter is the list of types the data contains. If the list contains one type the widget understands, it should return this type to notify the manager that the drop would be accepted, i.e. :; for (int i = 0; typelist[i] != kNone; ++i) {; if (typelist[i] == gVirtualX->InternAtom(""application/root"")); // accept ""application/root"" DND type; return typelist[i];; }; // other type not accepted; return kNone;; Atom_t HandleDNDposition(Int_t x,Int_t y,Atom_t action,Int_t xroot, Int_t yroot) - this method should be used to handle the drag position in widget coordinates (x,y) or in root coordinates (xroot,yroot).; // get the pad over which the cursor is; TPad *pad = fCanvas->Pi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1238014,Integrability,interface,interface,1238014," should be placed at the beginning of the prototype string. For example; Connect(button, ""Pressed()"", ""TH1"", hist, ""SetMaximum(=123)"");; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw(=\""LEGO\"")"");. 26.5 Signals; A signal is a normal class method. The first requirement is that it should call an Emit() method. The format of this method is the following:; Emit(""full_method_name""[,arguments]);; where ""full_method_name"" is the method name and prototype string of the signal method. For example, for SetValue(Int_t value) the full method name will be ""SetValue(Int_t)"", where SetValue is the method name and Int_t the prototype string. Note that typedefs will be resolved to facilitate matching of slots to signals. So the slot ""print(int)"" can be connected to the above signal which has an Int_t as argument.; The second requirement is that the method declaration should have the string *SIGNAL* in its comment field. Like:; void SetValue(Int_t x); //*SIGNAL*; This provides an explicit interface specification for the user (this requirement is currently not enforced at run-time).; The third requirement, only necessary if you want to have class signals (i.e. for all objects of a class), is that you have to replace the standard ClassImp macro by ClassImpQ.; Signals are currently implemented for all ROOT GUI classes and the TTimer and TCanvas classes (to find quickly all defined signals do for example: grep '*SIGNAL*' $ROOTSYS/include/*.h).; 26.6 Examples; 26.6.1 A First Time Example (rqfirst.C); This example shows:. How to create interpreted class with signals with different types/number of arguments.; How to connect signals to slots.; How to activate signals. 26.6.2 Histogram Filling with Dynamic State Reported via Signals (rqsimple.C); Based on hsimple this example demonstrates:. All features of the hsimple example.; How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; How to use the TTimer class for emulation of “mul",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1239761,Integrability,interface,interface,1239761,"mple.C); Based on hsimple this example demonstrates:. All features of the hsimple example.; How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; How to use the TTimer class for emulation of “multithreading”.; How to use signals for the concurrent update of pad, file, benchmark facility, etc. 26.6.3 An Example on How to Use Canvas Event Signals (rqfiller.C); This example shows:. How the object communication mechanism can be used for handling the TCanvas’s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. Click the left button or move mouse with button pressed to fill histograms.; Use the right button of the mouse to reset the histograms. 26.6.4 Complex GUI Using Signals and Slots (guitest.C); Based on $ROOTSYS/test/guitest.cxx this example demonstrates:. All features of the original compiled guitest.cxx program.; Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program. 27 Automatic HTML Documentation. THtml is ROOT’s documentation engine. It can be used to document your classes in a reference guide, and to convert your text or source files to HTML.; 27.1 Reference Guide; The Reference Guide for the ROOT classes at http://root.cern.ch/root/html/ has been generated by ROOT’s THtml class. Just as for ROOT’s classes, it can generate (and update) a reference guide for your classes, too. You document your classes using source code comments. All comments will be automatically put into a <pre></pre> environment to keep the indentation and line length. You can write “raw” HTML by enclosing comments in the keywords Begin_Html and End_Html.; To generate documentation for the class TObject you could run the following commands:; root[] THtml h; root[] h.SetInputDir(""$(ROOTSYS)"");; root[] h.MakeClass(""TObject"");; root[] h.CreateJavascript();; root[] h.CreateStylesheet();; The comments follo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1245473,Integrability,inject,inject,1245473,"n.ch/root/html/examples/V5.16.txt.html; To convert the source file MyCode.C to HTML, you can run; root[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; This will create the file htmlout/MyCode.C.html. The HTML page will have the title “Look At My Code”.; 27.3 Special Documentation Elements: Directives; A common documentation problem is the inclusion of images. They are usually generated externally, which poses problems with where to keep the images, and how to keep them up to date. THtml solves this by offering a few special documentation elements: macro and latex directives.; 27.3.1 Latex Directive; Documentation surrounded by the keywords BEGIN_LATEX / END_LATEX will be passed to ROOT Latex engine TLatex. The keywords can be written with small or capital letters (case insensitive). The output will be stored to an image file, which gets automatically included in the documentation.; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; THtml will inject the following picture:. The image file name is generated from the formula and will be unique for all the documentation. It is stored along-side the documentation, and it will be automatically regenerated when the documentation is updated. The handling of the Latex directive is done by the class TDocLatexDirective.; The BEGIN_LATEX keyword can take the following parameters:. fontsize: sets the TLatex font size. The default value is 16.; separator: sets a list of characters for which a new column will be started. This allows aligned, multi-line, multi-column layout, which can be useful for e.g. mathematical derivations. It is unset by default, meaning the Latex directive will only generate one column.; rseparator: like separator, but a regular expression. Columns start with a match of this regular expression. Only one of separator or rseparator can be given.; align: defines the alignment of the columns. Note that the column delim",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1250284,Integrability,interface,interface,1250284,"Html searches for an entry in its map of libraries to documentation URLs. If it finds it, it will create a link to the documentation at that URL for all occurrences of a given class name. One can set the URL ../mylib/ for a library name MyLib by setting Root.Html.MyLib: ../mylib/ or by calling THtml::SetLibURL(""MyLib"", ""../mylib/""). Occurrences of class MyClass of MyLib will now be referenced as ../mylib/MyClass.html.; 27.4.2 Search Engine; THtml can invoke external search engines. The ROOT reference guide sets Root.Html.Search to http://www.google.com/search?q=%s+site%3A%u. Calling THtml::SetSearchStemURL() will set the same. If this URL stem is set, THtml will create search fields in the index pages. It will send the words entered in these search fields as %s in the URL; %u will be replaced by the current document’s path, allowing a site- and directory-specific search.; 27.4.3 ViewCVS; Most code is managed in a version control system like CVS. ViewCVS is a WWW reader interface to the versioning control system that allows e.g. tracking a file’s changes. THtml will reference these pages automatically if the .rootrc variable Root.Html.ViewCVS is set to the URL stem of the ViewCVS. installation. Alternatively, one can call THtml::SetViewCVS().; 27.4.4 Wiki Pages; In some contexts it might be desirable to let users comment on classes, e.g. for suggestions of use or alternatives, details of behavior, and cross references to other relevant classes. A successful example of this is the PHP.net documentation with its user annotations. THtml can include a link to a class’s Wiki page by setting the Wiki base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1251925,Integrability,depend,depending,1251925,"base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1256698,Integrability,interface,interface,1256698,"nc: no; X11.FindBestVisual: yes; Default editor in use.; Unix.*.Editor: vi; WinNT.*.Editor: notepad; Default 3d Viewer. By default 3-D views are shown in the pad, if the next line is activated, the default viewer will be OpenGL.; Viewer3D.DefaultDrawOption: ogl; Default Fitter (current choices are Minuit, Minuit2, Fumili and Fumili2).; Root.Fitter: Minuit; Specify list of file endings which TTabCom (TAB completion) should ignore.; TabCom.FileIgnore: .cpp:.h:.cmz; 28.6.1 TCanvas Specific Settings; Opaque move and resize show full pad during the operation instead of only the outline. Especially for resize you will need serious CPU power. UseScreenFactor=true means to size canvas according to size of screen, so a canvas still looks good on a low resolution laptop screen without having to change canvas size in macros.; Canvas.MoveOpaque: false; Canvas.ResizeOpaque: false; Canvas.UseScreenFactor: true; Hight color 2 is the red one.; Canvas.HighLightColor: 2; Next three settings are related to different user interface parts of canvas window. If they are set to true, the corresponding event status bar, tool bar, graphics editor will be activated by default.; Canvas.ShowEventStatus: false; Canvas.ShowToolBar: false; Canvas.ShowEditor: false; AutoExec allows TExec objects to be executed on mouse and key events.; Canvas.AutoExec: true; Canvas print directory is set to the current one by default:; Canvas.PrintDirectory .; Printer settings:; WinNT.*.Print.Command: AcroRd32.exe; #Unix.*.Print.Command: a2ps -P%p --landscape --columns=2 --margin=30 -rf8.0 %f; Print.Printer: 32-rb20-hp; Print.Directory: .; Print.FileType: pdf; Default histogram binnings used by TTree::Draw() method.; Hist.Binning.1D.x: 100; Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100; Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; Default statistics names used for parameters in TPaveStats:; Hist.Stats.Entries E",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1260515,Integrability,interface,interface,1260515,"is """").; Root.Html.Root: http://root.cern.ch/root/html; Filesystem output directory for generated web pages (default: htmldoc).; Root.Html.OutputDir: htmldoc/; Address of the package’s home page (default: http://root.cern.ch):; Root.Html.HomePage:; Location of user defined header and footer files, see http://root.cern.ch/root/html/THtml#conf:header (defaults are """", example: ../header.txt, ../footer.txt):; Root.Html.Header:; Root.Html.Footer:; Tag for detecting class description comments (default value is set below).; Root.Html.Description: //____________________; Tag for detecting “Author” comment (default value is set below).; Root.Html.Author: // Author:; Tag for detecting “last updated” comment. THtml uses the current date if this tag is not found in a class source file (default value is set below).; Root.Html.LastUpdate: // @(#); Tag for detecting “Copyright” comment (default value is set below).; Root.Html.Copyright: * Copyright; 28.6.3 GUI Specific Settings; Set the “native” ROOT GUI interface to be used in a ROOT session.; Gui.Backend: native; Gui.Factory: native; GUI default fonts in use:; Gui.DefaultFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.MenuHiFont: -adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocFixedFont: -adobe-courier-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.DocPropFont: -adobe-helvetica-medium-r-*-*-12-*-*-*-*-*-iso8859-1; Gui.IconFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Gui.StatusFont: -adobe-helvetica-medium-r-*-*-10-*-*-*-*-*-iso8859-1; Regular background and foreground colors in use:; Gui.BackgroundColor: #c0c0c0; Gui.ForegroundColor: black; Selection background and foreground colors in use:; Gui.SelectBackgroundColor: #000080; Gui.SelectForegroundColor: white; Document background and foreground colors in use:; Gui.DocumentBackgroundColor: white; Gui.DocumentForegroundColor: black; Tooltip background and foreground colors in u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1264627,Integrability,protocol,protocol,1264627,"oofserv:0 - don’t wait; 1 - master proofserv enters wait loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]; Example of custom setting for the Rint application (root.exe). This overrides the default specified above for a generic application. Color 5 is yellow.; Rint.Canvas.HighLightColor: 5; 28.7 Documentation to Download. The latest ROOT Users Guide; https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html; ROOT Referenc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1550,Modifiability,rewrite,rewrite,1550,"cal User Interface; 26 The Signal/Slot Communication Mechanism; 27 Automatic HTML Documentation; 28 Appendix A: Install and Build ROOT. WARNING: This documentation is not maintained anymore. Some part might be obsolete or wrong, some part might be missing but still some valuable information can be found there. Instead please refer to the ROOT Reference Guide and the ROOT Manual. If you think some information should be imported in the ROOT Reference Guide or in the ROOT Manual, please post your request to the ROOT Forum or via a Github Issue. Preface; In late 1994, we decided to learn and investigate Object Oriented programming and C++ to better judge the suitability of these relatively new techniques for scientific programming. We knew that there is no better way to learn a new programming environment than to use it to write a program that can solve a real problem. After a few weeks, we had our first histogramming package in C++. A few weeks later we had a rewrite of the same package using the, at that time, very new template features of C++. Again, a few weeks later we had another rewrite of the package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being used in all major High Energy and Nuclear Physics laboratories around the world to monitor, to store and to analyse data. In the other sciences as well as the medical and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1678,Modifiability,rewrite,rewrite,1678,"ocumentation is not maintained anymore. Some part might be obsolete or wrong, some part might be missing but still some valuable information can be found there. Instead please refer to the ROOT Reference Guide and the ROOT Manual. If you think some information should be imported in the ROOT Reference Guide or in the ROOT Manual, please post your request to the ROOT Forum or via a Github Issue. Preface; In late 1994, we decided to learn and investigate Object Oriented programming and C++ to better judge the suitability of these relatively new techniques for scientific programming. We knew that there is no better way to learn a new programming environment than to use it to write a program that can solve a real problem. After a few weeks, we had our first histogramming package in C++. A few weeks later we had a rewrite of the same package using the, at that time, very new template features of C++. Again, a few weeks later we had another rewrite of the package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being used in all major High Energy and Nuclear Physics laboratories around the world to monitor, to store and to analyse data. In the other sciences as well as the medical and financial industries, many people are using ROOT. We estimate the current user base to be around several thousand people. In 1997, Eric Raymond analysed in his paper “The Cathedral and the Bazaar” the development method that makes Linux such a success. The essence of that method is: “release early, release often and listen to your custo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:10039,Modifiability,variab,variable,10039," user insight into the many capabilities of ROOT. The book begins with the elementary functionality and progresses in complexity reaching the specialized topics at the end. The experienced user looking for special topics may find these chapters useful: see “Networking”, “Writing a Graphical User Interface”, “Threads”, and “PROOF: Parallel Processing”.; 1.3 Conventions Used in This Book; We tried to follow a style convention for the sake of clarity. The styles in used are described below.; To show source code in scripts or source files:; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; To show the ROOT command line, we show the ROOT prompt without numbers. In the interactive system, the ROOT prompt has a line number (root[12]); for the sake of simplicity, the line numbers are left off.; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; Italic bold monotype font indicates a global variable, for example gDirectory.; When a variable term is used, it is shown between angled brackets. In the example below the variable term <library> can be replaced with any library in the $ROOTSYS directory: $ROOTSYS/<library>/inc.; 1.4 The Framework; ROOT is an object-oriented framework aimed at solving the data analysis challenges of high-energy physics. There are two key words in this definition, object oriented and framework. First, we explain what we mean by a framework and then why it is an object-oriented framework.; 1.4.1 What Is a Framework?; Programming inside a framework is a little like living in a city. Plumbing, electricity, telephone, and transportation are services provided by the city. In your house, you have interfaces to the services such as light switches, electrical outlets, and telephones. The details, for example, the routing algorithm of the phone switching system, are transparent to you as the user. You do not care; you are only interested in using",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:10081,Modifiability,variab,variable,10081,"ementary functionality and progresses in complexity reaching the specialized topics at the end. The experienced user looking for special topics may find these chapters useful: see “Networking”, “Writing a Graphical User Interface”, “Threads”, and “PROOF: Parallel Processing”.; 1.3 Conventions Used in This Book; We tried to follow a style convention for the sake of clarity. The styles in used are described below.; To show source code in scripts or source files:; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; To show the ROOT command line, we show the ROOT prompt without numbers. In the interactive system, the ROOT prompt has a line number (root[12]); for the sake of simplicity, the line numbers are left off.; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; Italic bold monotype font indicates a global variable, for example gDirectory.; When a variable term is used, it is shown between angled brackets. In the example below the variable term <library> can be replaced with any library in the $ROOTSYS directory: $ROOTSYS/<library>/inc.; 1.4 The Framework; ROOT is an object-oriented framework aimed at solving the data analysis challenges of high-energy physics. There are two key words in this definition, object oriented and framework. First, we explain what we mean by a framework and then why it is an object-oriented framework.; 1.4.1 What Is a Framework?; Programming inside a framework is a little like living in a city. Plumbing, electricity, telephone, and transportation are services provided by the city. In your house, you have interfaces to the services such as light switches, electrical outlets, and telephones. The details, for example, the routing algorithm of the phone switching system, are transparent to you as the user. You do not care; you are only interested in using the phone to communicate with your collaborators to solve your domain specif",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:10166,Modifiability,variab,variable,10166,"experienced user looking for special topics may find these chapters useful: see “Networking”, “Writing a Graphical User Interface”, “Threads”, and “PROOF: Parallel Processing”.; 1.3 Conventions Used in This Book; We tried to follow a style convention for the sake of clarity. The styles in used are described below.; To show source code in scripts or source files:; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; To show the ROOT command line, we show the ROOT prompt without numbers. In the interactive system, the ROOT prompt has a line number (root[12]); for the sake of simplicity, the line numbers are left off.; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; Italic bold monotype font indicates a global variable, for example gDirectory.; When a variable term is used, it is shown between angled brackets. In the example below the variable term <library> can be replaced with any library in the $ROOTSYS directory: $ROOTSYS/<library>/inc.; 1.4 The Framework; ROOT is an object-oriented framework aimed at solving the data analysis challenges of high-energy physics. There are two key words in this definition, object oriented and framework. First, we explain what we mean by a framework and then why it is an object-oriented framework.; 1.4.1 What Is a Framework?; Programming inside a framework is a little like living in a city. Plumbing, electricity, telephone, and transportation are services provided by the city. In your house, you have interfaces to the services such as light switches, electrical outlets, and telephones. The details, for example, the routing algorithm of the phone switching system, are transparent to you as the user. You do not care; you are only interested in using the phone to communicate with your collaborators to solve your domain specific problems.; Programming outside of a framework may be compared to living in the country. In order t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13144,Modifiability,inherit,inherited,13144,"thm provided by your telephone service. You also have to learn the framework interfaces, which in this analogy is the same as learning how to use a telephone.; If you are interested in doing physics, a good HEP framework will save you much work. Next is a list of the more commonly used components of ROOT: Command Line Interpreter, Histograms and Fitting, Writing a Graphical User Interface, 2D Graphics, Input/Output , Collection Classes, Script Processor.; There are also less commonly used components, as: 3D Graphics, Parallel Processing (PROOF), Run Time Type Identification (RTTI), Socket and Network Communication, Threads.; 1.4.1.1 Advantages of Frameworks; The benefits of frameworks can be summarized as follows:. Less code to write - the programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13901,Modifiability,inherit,inheritance,13901," programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:13933,Modifiability,extend,extend,13933," programmer should be able to use and reuse the majority of the existing code. Basic functionality, such as fitting and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14029,Modifiability,flexible,flexible,14029,"and histogramming are implemented and ready to use and customize.; More reliable and robust code - the code inherited from a framework has already been tested and integrated with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:14296,Modifiability,variab,variables,14296," with the rest of the framework.; More consistent and modular code - the code reuse provides consistency and common capabilities between programs, no matter who writes them. Frameworks make it easier to break programs into smaller pieces.; More focus on areas of expertise - users can concentrate on their particular problem domain. They do not have to be experts at writing user interfaces, graphics, or networking to use the frameworks that provide those services. 1.4.2 Why Object-Oriented?; Object-Oriented Programming offers considerable benefits compared to Procedure-Oriented Programming:. Encapsulation enforces data abstraction and increases opportunity for reuse.; Sub classing and inheritance make it possible to extend and modify objects.; Class hierarchies and containment containment hierarchies provide a flexible mechanism for modeling real-world objects and the relationships among them.; Complexity is reduced because there is little growth of the global state, the state is contained within each object, rather than scattered through the program in the form of global variables.; Objects may come and go, but the basic structure of the program remains relatively static, increases opportunity for reuse of design. 1.5 Installing ROOT. To install ROOT you have the choice to download the binaries or the source. The source is quicker to transfer since it is only ~22 MB, but you will need to compile and link it. The binaries compiled with no debug information range from ~35 MB to ~45 MB depending on the target platform.; The installation and building of ROOT is described in Appendix A: Install and Build ROOT. You can download the binaries, or the source. The GNU g++ compiler on most UNIX platforms can compile ROOT.; Before downloading a binary version make sure your machine contains the right run-time environment. In most cases it is not possible to run a version compiled with, e.g., gcc4.0 on a platform where only gcc 3.2 is installed. In such cases you’ll have to instal",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:16448,Modifiability,variab,variable,16448,"SD (GCC); GNU/Hurd (GCC); HP HP-UX 10.x (IA32) and 11 (IA64) (HP CC, aCC, GCC); IBM AIX 4.1 (xlC compiler, GCC); Sun Solaris for SPARC (SUN C++ compiler, GCC); Sun Solaris for x86 (SUN C++ compiler, KAI/KCC); Compaq Alpha (GCC, KAI/KCC, DEC/CXX); SGI Irix 32 and 64 bits (GCC, KAI/KCC, SGI C++ compiler); Windows >= 95 (Microsoft Visual C++ compiler, Cygwin/GCC); MacOS X PPC, x86-32, x86-64 (GCC, Intel/ICC, IBM/xl); PowerPC with GNU/Linux and GCC, Debian v2; PowerPC64 with GNU/Linux and GCC; ARM with GNU/Linux and GCC; LynxOS. 1.6 The Organization of the ROOT Framework; Now after we know in abstract terms what the ROOT framework is, let us look at the physical directories and files that come with the ROOT installation. You may work on a platform where your system administrator has already installed ROOT. You will need to follow the specific development environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capabil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:17265,Modifiability,config,config,17265,"lopment environment for your setup and you may not have write access to the directories. In any case, you will need an environment variable called ROOTSYS, which holds the path of the top ROOT directory.; > echo $ROOTSYS; /opt/root; In the ROOTSYS directory are examples, executables, tutorials, header tutorials files, and, if you opted to download it, the source is here. The directories of special interest to us are bin, tutorials, lib, test, andinclude. The next figure shows the contents of these directories. ROOT framework directories. 1.6.1 $ROOTSYS/bin; The bin directory contains several executables. root; shows the ROOT splash screen and calls root.exe. root.exe; the executable that root calls, if you use a debugger such as gdb, you will need to run root.exe directly. rootcling; is the utility ROOT uses to create a class dictionary for Cling. rmkdepend; a modified version of makedepend that is used by the ROOT build system. root-config; a script returning the needed compile flags and libraries for projects that compile and link with ROOT. proofd; a small daemon used to authenticate a user of ROOT parallel processing capability (PROOF). proofserv; the actual PROOF process, which is started by proofd after a user, has successfully been authenticated. rootd; is the daemon for remote ROOT file access (see the TNetFile). 1.6.2 $ROOTSYS/lib; There are several ways to use ROOT, one way is to run the executable by typing root at the system prompt another way is to link with the ROOT libraries and make the ROOT classes available in your own program.; Here is a short description of the most relevant libraries, the ones marked with a * are only installed when the options specified them. libAsImage is the image manipulation library; libCling is the C++ interpreter (Cling); libCore is the Base classes; libEG is the abstract event generator interface classes; *libEGPythia is the Pythia5 event generator interface; *libEGPythia6 is the Pythia6 event generator interface; libFitP",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21790,Modifiability,config,config,21790,"-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21848,Modifiability,config,config,21848,"-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21921,Modifiability,config,config,21921,"of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22771,Modifiability,Plugin,Plugin,22771,"rary a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22787,Modifiability,plugin,plugin,22787,"only used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22902,Modifiability,plugin,plugin,22902,"only used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22917,Modifiability,plugin,plugin,22917,"only used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23024,Modifiability,plugin,plugin,23024," if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to g",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23097,Modifiability,plugin,plugin,23097,"le.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23309,Modifiability,Plugin,Plugins,23309,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23360,Modifiability,plugin,plugin,23360,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23379,Modifiability,Plugin,Plugin,23379,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23462,Modifiability,plugin,plugin,23462,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23520,Modifiability,plugin,plugins,23520,"pendency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23585,Modifiability,Plugin,Plugins,23585,"libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23664,Modifiability,plugin,plugin,23664,"citly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23699,Modifiability,plugin,plugin,23699,"citly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23756,Modifiability,plugin,plugin,23756,"eans of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested librar",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23998,Modifiability,plugin,plugin,23998,"ess a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:28788,Modifiability,inherit,inheritance,28788,"and source files, located in the inc and src subdirectories. To see what classes are in a library, you can check the <library>/inc directory for the list of class definitions. For example, the physics library libPhysics.so contains these class definitions:; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; 1.7 How to Find More Information; website The ROOT web site has up to date documentation. The ROOT source code automatically generates this documentation, so each class is explicitly documented on its own web page, which is always up to date with the latest official release of ROOT.; The ROOT Reference Guide web pages can be found at class index reference guide https://root.cern/doc/master/classes.html. Each page contains a class description, and an explanation of each method. It shows the class inheritance tree and lets you jump to the parent class page by clicking on the class name. If you want more details, you can even see the source. There is a help page available in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:29910,Modifiability,Inherit,Inheritance,29910,"ilable in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ expor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:29991,Modifiability,inherit,inherit,29991,"ilable in the little box on the upper right hand side of each class documentation page. You can see on the next page what a typical class documentation web page looks like. The ROOT web site also contains in addition to this Reference Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ expor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30307,Modifiability,variab,variables,30307,"e Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30534,Modifiability,Variab,Variables,30534,"on - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30601,Modifiability,variab,variable,30601,"on - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30676,Modifiability,variab,variables,30676,"on - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30826,Modifiability,variab,variable,30826,"tation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive module, you must set the library path:; $ [ -z ""$LIBPATH"" ] && export LIBPATH=/lib:/usr/lib; $ export LIBPATH=$LIBPATH:$ROOTSYS/lib; On Linux, Solaris, Alpha OSF and SGI, before executing the interactive module, you must set the library path:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib; On Solaris, in case your LD_LIBRARY_PATH is empty, you should set it:; $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ROOTSYS/lib:/usr/dt/lib; If you use the afs version you should set (vers = version number, arch = architecture):; $ export ROOTSYS=/afs/cern.ch/sw/lcg/external/root/vers/arch/root; If ROOT was installed in $HOME/myroot directory on a local machine, one can ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:33242,Modifiability,config,config,33242,"-----; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; To start ROOT you can type root at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (root[0]).; It is possible to launch ROOT with some command line options, as shown below:; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options. -b ROOT session runs in batch mode, without graphics display. This mode is useful in case one does not want to set the DISPLAY or cannot do it for some reason.; -n usually, launching a ROOT session will execute a logon script and quitting will execute a logoff script. This option prevents the execution of these two scripts.; it is also possible to execute a script without entering a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the q",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:33259,Modifiability,config,configure,33259,"rn.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; To start ROOT you can type root at the system prompt. This starts up Cling, the ROOT command line C/C++ interpreter, and it gives you the ROOT prompt (root[0]).; It is possible to launch ROOT with some command line options, as shown below:; % root -?; Usage: root [-l] [-b] [-n] [-q] [dir] [[file:]data.root]; [file1.C ... fileN.C]; Options:; -b : run in batch mode without graphics; -n : do not execute logon and logoff macros as specified in .rootrc; -q : exit after processing command line macro files; -l : do not show splash screen; -x : exit on exception; dir : if dir is a valid directory cd to it before executing. -? : print usage; -h : print usage; --help : print usage; -config : print ./configure options. -b ROOT session runs in batch mode, without graphics display. This mode is useful in case one does not want to set the DISPLAY or cannot do it for some reason.; -n usually, launching a ROOT session will execute a logon script and quitting will execute a logoff script. This option prevents the execution of these two scripts.; it is also possible to execute a script without entering a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a pa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:34689,Modifiability,variab,variables,34689,"a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:; root -b -q 'myMacro.C(""text"")' > myMacro.log; You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “Cling the C++ Interpreter”.; root -b -q myMacro.so > myMacro.log; ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:35806,Modifiability,inherit,inheritance,35806,"objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is the relation between a canvas and a pad? In fact, a canvas is a pad that spans through an entire window. This is nothing else than the notion of inheritance. The TPad class is the parent of the TCanvas class. In ROOT, most objects derive from a base class TObject. This class has a virtual method Draw() such as all objects are supposed to be able to be “drawn”. If several canvases are defined, there is only one active at a time. One draws an object in the active canvas by using the statement:; object.Draw(); This instructs the object “object” to draw itself. If no canvas is opened, a default one (named “c1”) is created. In the next example, the first statement defines a function and the second one draws it. A default canvas is created since there was no opened one. You should see the picture as shown in the next figure.; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1. A canvas with drawing. The following components comprise the canvas window:. Menu bar - contains main menus for global operations with files, print, clear canvas, inspect, etc.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:41157,Modifiability,inherit,inheritance,41157,"cs: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on primitives’ drawing and objects’ editor.; Browser: help on the ROOT objects’ and files’ browser.; Objects: help on DrawClass, Inspect and Dump context menu items.; PostScript: help on how to print a canvas to a PostScript file format.; About ROOT: pops up the ROOT Logo with the version number. 2.3.1.7 Classes Menu. Classes: starts the ClassTree viewer that draws inheritance tree for a list of classes. 2.3.1.8 Toolbar; The following menu shortcuts and utilities are available from the toolbar:; Create a new canvas window.; Popup the Open File dialog.; Popup the Save As… dialog.; Popup the Print dialog.; Interrupts the current drawing process.; Redraw the canvas.; Inspect the gROOT object.; Create a new objects’ browser.; You can create the following graphical objects using the toolbar buttons for primitive drawing. Tool tips are provided for helping your choice.; An Arc or circle: Click on the center of the arc, and then move the mouse. A rubber band circle is shown. Click again with the left button to freeze the arc.; A Line: Click with the left button at the point where you want to start the line, then move the mouse and click again with the left button to freeze the line.; An Arrow:Click with the left button at the point where you want to start the arrow, then move the mouse and click again with the left button to freeze the arrow.; A Di",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:45475,Modifiability,inherit,inheritance,45475,"e up or down to grow or shrink the text respectively. If you position the mouse near the bottom-end of the text, you can rotate it.; A Marker: Click with the left button where to place the marker. The marker can be modified by using the method SetMarkerStyle() of TSystem.; A Graphical Cut: Click with the left button on each point of a polygon delimiting the selected area. Close the cut by double clicking on the last point. A TCutG object is created. It can be used as a selection for a TTree::Draw. You can get a pointer to this object with:; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); Once you are happy with your picture, you can select the Save as canvas.C item in the canvas File menu. This will automatically generate a script with the C++ statements corresponding to the picture. This facility also works if you have other objects not drawn with the graphics editor (histograms for example).; 2.3.2 The Editor Frame; The ROOT graphics editor loads the corresponding object editor objEditor according to the selected object obj in the canvas respecting the class inheritance. An object in the canvas is selected after the left mouse click on it. For example, if the selected object is TAxis, the TAxisEditor will shows up in the editor frame giving the possibility for changing different axis attributes. The graphics editor can be:; Embedded - connected only with the canvas in the application window that appears on the left of the canvas window after been activated via View menu / Editor. It appears on the left side if the canvas window allowing users to edit the attributes of the selected object via provided user interface. The name of the selected object is displayed on the top of the editor frame in red color. If the user interface needs more space then the height of the canvas window, a vertical scroll bar appears for easer navigation. Global - has own application window and can be connected to any created canvas in a ROOT session. It can be activated via the context me",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:54624,Modifiability,variab,variables,54624,"!” for example:. root[] .! ls. C++ commands follow C++ syntax (almost). root[] TBrowser *b = new TBrowser(); 2.4.1 Multi-line Commands; You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket {, and to end it you must type a single right curly bracket }. For example:; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; It is more convenient to edit a script than the command line, and if your multi line commands are getting unmanageable, you may want to start with a script instead.; 2.4.2 Cling Extensions; We should say that some things are not standard C++. The Cling interpreter has several extensions. See “ROOT/Cling Extensions to C++”.; 2.4.3 Helpful Hints for Command Line Typing; The interpreter knows all the classes, functions, variables, and user defined types. This enables ROOT to help users to complete the command line. For example, if we do not know anything about the TLine class, the Tab feature helps us to get a list of all classes starting with TL(where <TAB> means type the Tab key).; root[] l = new TLi<TAB>; TList; TListIter; TLink; TLine; TLimitDataSource; TLimit; To list the different constructors and parameters for TLine use the <TAB> key as follows:; root[] l = new TLine(<TAB>; TLine TLine(); TLine TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); TLine TLine(const TLine& line); 2.4.4 Regular Expression; The meta-characters below can be used in a regular expression:. ‘^’ start-of-line anchor; ‘$’ end-of-line anchor; ‘.’ matches any character; ‘[’ start a character class; ’]’end a character class; ’^’negates character class if first character; ‘*’Kleene closure (matches 0 or more); ’+’Positive closure (1 or more); ‘?’ Optional closure (0 or 1). When using wildcards",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:57432,Modifiability,variab,variables,57432,"(const TString& string,Ssiz_t* len,Ssiz_t i) const; The method finds the first occurrence of the regular expression in the string and returns its position.; 2.5 Conventions; In this paragraph, we will explain some of the conventions used in ROOT source and examples.; 2.5.1 Coding Conventions; From the first days of ROOT development, it was decided to use a set of coding conventions. This allows a consistency throughout the source code. Learning these will help you identify what type of information you are dealing with and enable you to understand the code better and quicker. Of course, you can use whatever convention you want but if you are going to submit some code for inclusion into the ROOT sources, you will need to use these.; These are the coding conventions:. Classes begin with T: TLine, TTree; Non-class types end with _t: Int_t; Data members begin with f: fTree; Member functions begin with a capital: Loop(); Constants begin with k: kInitialSize, kRed; Global variables begin with g: gEnv; Static data members begin with fg: fgTokenClient; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:57916,Modifiability,variab,variables,57916,"ify what type of information you are dealing with and enable you to understand the code better and quicker. Of course, you can use whatever convention you want but if you are going to submit some code for inclusion into the ROOT sources, you will need to use these.; These are the coding conventions:. Classes begin with T: TLine, TTree; Non-class types end with _t: Int_t; Data members begin with f: fTree; Member functions begin with a capital: Loop(); Constants begin with k: kInitialSize, kRed; Global variables begin with g: gEnv; Static data members begin with fg: fgTokenClient; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:58182,Modifiability,Portab,Portable,58182,"e.; These are the coding conventions:. Classes begin with T: TLine, TTree; Non-class types end with _t: Int_t; Data members begin with f: fTree; Member functions begin with a capital: Loop(); Constants begin with k: kInitialSize, kRed; Global variables begin with g: gEnv; Static data members begin with fg: fgTokenClient; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); So",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:58230,Modifiability,Portab,Portable,58230,"e.; These are the coding conventions:. Classes begin with T: TLine, TTree; Non-class types end with _t: Int_t; Data members begin with f: fTree; Member functions begin with a capital: Loop(); Constants begin with k: kInitialSize, kRed; Global variables begin with g: gEnv; Static data members begin with fg: fgTokenClient; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); So",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:58445,Modifiability,variab,variable,58445,"Client; Enumeration types begin with E: EColorLevel; Locals and parameters begin with a lower case: nbytes; Getters and setters begin with Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:58638,Modifiability,inherit,inherit,58638," Get and Set: SetLast(), GetFirst(). 2.5.2 Machine Independent Types; Different machines may have different lengths for the same type. The most famous example is the int type. It may be 16 bits on some old machines and 32 bits on some newer ones. To ensure the size of your variables, use these pre defined types in ROOT:. Char_t Signed Character 1 byte; UChar_t Unsigned Character 1 byte; Short_t Signed Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59464,Modifiability,Inherit,InheritsFrom,59464," bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59532,Modifiability,Variab,Variables,59532," them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gR",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59568,Modifiability,variab,variables,59568," them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gR",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59713,Modifiability,variab,variables,59713,"Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ROOT objects. During a ROOT session, the gROOT keeps a series of collections to manage objects. They can be accessed via gROOT::GetListOf... methods.; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); These methods return a TSeqCollection, meaning a collection of objects, and they can be used to do list opera",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:62767,Modifiability,variab,variable,62767,"the “View” menu, selecting the “Colors” entry.; 2.6.5 gRandom; gRandom is a pointer to the current random number generator. By default, it points to a TRandom3 object, based on the “Mersenne-Twister” generator. This generator is very fast and has very good random proprieties (a very long period of 10600). Setting the seed to 0 implies that the seed will be uniquely generated using the TUUID. Any other value will be used as a constant. The following basic random distributions are provided: Rndm() or Uniform(min,max), Gaus(mean,sigma), Exp(tau), BreitWigner(mean,sigma), Landau(mean,sigma), Poisson(mean), Binomial(ntot,prob). You can customize your ROOT session by replacing the random number generator. You can delete gRandom and recreate it with your own. For example:; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; TRandom2 is another generator, which is also very fast and uses only three words for its state.; 2.6.6 gEnv; gEnv is the global variable (of type TEnv) with all the environment settings for the current session. This variable is set by reading the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseT",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:62855,Modifiability,variab,variable,62855,"er to the current random number generator. By default, it points to a TRandom3 object, based on the “Mersenne-Twister” generator. This generator is very fast and has very good random proprieties (a very long period of 10600). Setting the seed to 0 implies that the seed will be uniquely generated using the TUUID. Any other value will be used as a constant. The following basic random distributions are provided: Rndm() or Uniform(min,max), Gaus(mean,sigma), Exp(tau), BreitWigner(mean,sigma), Landau(mean,sigma), Poisson(mean), Binomial(ntot,prob). You can customize your ROOT session by replacing the random number generator. You can delete gRandom and recreate it with your own. For example:; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; TRandom2 is another generator, which is also very fast and uses only three words for its state.; 2.6.6 gEnv; gEnv is the global variable (of type TEnv) with all the environment settings for the current session. This variable is set by reading the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.L",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:64430,Modifiability,variab,variable,64430,"user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:64679,Modifiability,variab,variable,64679,"Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Histor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:65248,Modifiability,variab,variable,65248,"licitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first val",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:66122,Modifiability,variab,variable,66122,". This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first value corresponds to HistSize, the (optional) second one to HistSave. You can set ROOT_HIST=0 to disable the history.; 2.7.3 Tracking Memory Leaks; You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see TObjectTable). To use this facility, edit the file $ROOTSYS/etc/system.rootrc or .rootrc if you have this file and add the two following lines:; Root.ObjectStat: 1; In your code or on the command line you can type the line:; gObjectTable->Print();; This line will print the list of all active classes and the number of instances for each class. By comparing consecutive print outs, you can see objects that you forgot to delete. Note that this method cannot show leaks coming from the allocation of non-objects or classes unknown to ROOT.; 2.8 Converting from PAW to ROOT; The web page at: http://root.cern.ch/root/HowtoConvertF",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:69297,Modifiability,variab,variable,69297,"refixing the integer identifier with the letter “h” if the identifier is a positive integer and by ""h_"" if it is a negative integer identifier. In case of row-wise or column-wise ntuples, each column is converted to a branch of a tree. Note that h2root is able to convert HBOOK files containing several levels of sub-directories. Once you have converted your file, you can look at it and draw histograms or process ntuples using the ROOT command line. An example of session is shown below:; // this connects the file hbookconverted.root; root[] TFile f(""hbookconverted.root"");. // display histogram named h10 (was HBBOK id 10); root[] h10.Draw();. // display column ""var"" from ntuple h30; root[] h30.Draw(""var"");; You can also use the ROOT browser (see TBrowser) to inspect this file.; The chapter on trees explains how to read a tree. ROOT includes a function TTree::MakeClass to generate automatically the code for a skeleton analysis function. See “Example Analysis”.; In case one of the ntuple columns has a variable length (e.g. px(ntrack)), h.Draw(""px"") will histogram the px column for all tracks in the same histogram. Use the script quoted above to generate the skeleton function and create/fill the relevant histogram yourself.; 3 Histograms; This chapter covers the functionality of the histogram classes. We begin with an overview of the histogram classes, after which we provide instructions and examples on the histogram features.; We have put this chapter ahead of the graphics chapter so that you can begin working with histograms as soon as possible. Some of the examples have graphics commands that may look unfamiliar to you. These are covered in the chapter “Input/Output”.; 3.1 The Histogram Classes. ROOT supports histograms up to three dimensions. Separate concrete classes are provided for one-dimensional, two-dimensional and three-dimensional classes. The histogram classes are split into further categories, depending on the set of possible bin values:. TH1C, TH2C and TH3C ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:72099,Modifiability,Variab,Variable,72099,"togram or scatter-plot. Profile histograms, on the other hand, are used to display the mean value of Y and its RMS for each bin in X. If Y is an unknown but single-valued approximate function of X, it will have greater precision in a profile histogram than in a scatter plot. TProfile : one dimensional profiles; TProfile2D : two dimensional profiles. The class hierarchy of histogram classes. All ROOT histogram classes are derived from the base class TH1 (see figure above). This means that two-dimensional and three-dimensional histograms are seen as a type of a one-dimensional histogram, in the same way in which multidimensional C arrays are just an abstraction of a one-dimensional contiguous block of memory.; 3.2 Creating Histograms; There are several ways in which you can create a histogram object in ROOT. The straightforward method is to use one of the several constructors provided for each concrete class in the histogram hierarchy. For more details on the constructor parameters, see the subsection “Constant or Variable Bin Width” below. Histograms may also be created by:. Calling the Clone() method of an existing histogram; Making a projection from a 2-D or 3-D histogram; Reading a histogram from a file (see Input/Output chapter). // using various constructors; TH1* h1 = new TH1I(""h1"", ""h1 title"", 100, 0.0, 4.0);; TH2* h2 = new TH2F(""h2"", ""h2 title"", 40, 0.0, 2.0, 30, -1.5, 3.5);; TH3* h3 = new TH3D(""h3"", ""h3 title"", 80, 0.0, 1.0, 100, -2.0, 2.0,; 50, 0.0, 3.0);. // cloning a histogram; TH1* hc = (TH1*)h1->Clone();. // projecting histograms; // the projections always contain double values !; TH1* hx = h2->ProjectionX(); // ! TH1D, not TH1F; TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F; 3.2.1 Constant or Variable Bin Width; The histogram classes provide a variety of ways to construct a histogram, but the most common way is to provide the name and title of histogram and for each dimension: the number of bins, the minimum x (lower edge of the first bin) and the ma",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:72810,Modifiability,Variab,Variable,72810,"ctors provided for each concrete class in the histogram hierarchy. For more details on the constructor parameters, see the subsection “Constant or Variable Bin Width” below. Histograms may also be created by:. Calling the Clone() method of an existing histogram; Making a projection from a 2-D or 3-D histogram; Reading a histogram from a file (see Input/Output chapter). // using various constructors; TH1* h1 = new TH1I(""h1"", ""h1 title"", 100, 0.0, 4.0);; TH2* h2 = new TH2F(""h2"", ""h2 title"", 40, 0.0, 2.0, 30, -1.5, 3.5);; TH3* h3 = new TH3D(""h3"", ""h3 title"", 80, 0.0, 1.0, 100, -2.0, 2.0,; 50, 0.0, 3.0);. // cloning a histogram; TH1* hc = (TH1*)h1->Clone();. // projecting histograms; // the projections always contain double values !; TH1* hx = h2->ProjectionX(); // ! TH1D, not TH1F; TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F; 3.2.1 Constant or Variable Bin Width; The histogram classes provide a variety of ways to construct a histogram, but the most common way is to provide the name and title of histogram and for each dimension: the number of bins, the minimum x (lower edge of the first bin) and the maximum x (upper edge of the last bin).; TH2* h = new TH2D(; /* name */ ""h2"",; /* title */ ""Hist with constant bin width"",; /* X-dimension */ 100, 0.0, 4.0,; /* Y-dimension */ 200, -3.0, 1.5);; When employing this constructor, you will create a histogram with constant (fixed) bin width on each axis. For the example above, the interval [0.0, 4.0] is divided into 100 bins of the same width w X = 4.0 - 0.0 100 = 0.04 for the X axis (dimension). Likewise, for the Y axis (dimension), we have bins of equal width w Y = 1.5 - (-3.0) 200 = 0.0225.; If you want to create histograms with variable bin widths, ROOT provides another constructor suited for this purpose. Instead of passing the data interval and the number of bins, you have to pass an array (single or double precision) of bin edges. When the histogram has n bins, then there are n+1 distinct edges, so the array you pass m",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:73654,Modifiability,variab,variable,73654,"n double values !; TH1* hx = h2->ProjectionX(); // ! TH1D, not TH1F; TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F; 3.2.1 Constant or Variable Bin Width; The histogram classes provide a variety of ways to construct a histogram, but the most common way is to provide the name and title of histogram and for each dimension: the number of bins, the minimum x (lower edge of the first bin) and the maximum x (upper edge of the last bin).; TH2* h = new TH2D(; /* name */ ""h2"",; /* title */ ""Hist with constant bin width"",; /* X-dimension */ 100, 0.0, 4.0,; /* Y-dimension */ 200, -3.0, 1.5);; When employing this constructor, you will create a histogram with constant (fixed) bin width on each axis. For the example above, the interval [0.0, 4.0] is divided into 100 bins of the same width w X = 4.0 - 0.0 100 = 0.04 for the X axis (dimension). Likewise, for the Y axis (dimension), we have bins of equal width w Y = 1.5 - (-3.0) 200 = 0.0225.; If you want to create histograms with variable bin widths, ROOT provides another constructor suited for this purpose. Instead of passing the data interval and the number of bins, you have to pass an array (single or double precision) of bin edges. When the histogram has n bins, then there are n+1 distinct edges, so the array you pass must be of size n+1.; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; Each histogram object contains three TAxis objects: fXaxis , fYaxis, and fZaxis, but for one-dimensional histograms only the X-axis is relevant, while for two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / li",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:74210,Modifiability,variab,variable,74210,"th constant (fixed) bin width on each axis. For the example above, the interval [0.0, 4.0] is divided into 100 bins of the same width w X = 4.0 - 0.0 100 = 0.04 for the X axis (dimension). Likewise, for the Y axis (dimension), we have bins of equal width w Y = 1.5 - (-3.0) 200 = 0.0225.; If you want to create histograms with variable bin widths, ROOT provides another constructor suited for this purpose. Instead of passing the data interval and the number of bins, you have to pass an array (single or double precision) of bin edges. When the histogram has n bins, then there are n+1 distinct edges, so the array you pass must be of size n+1.; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; Each histogram object contains three TAxis objects: fXaxis , fYaxis, and fZaxis, but for one-dimensional histograms only the X-axis is relevant, while for two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:75377,Modifiability,variab,variable,75377,"nd fZaxis, but for one-dimensional histograms only the X-axis is relevant, while for two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).; The second to last bin (bin# nbins) contains the upper-edge (xup EXCLUDED).; The Last bin (bin# nbins+1) contains the overflow.; In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram h with binx, biny, binz, the function returns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:75449,Modifiability,variab,variable,75449," two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).; The second to last bin (bin# nbins) contains the upper-edge (xup EXCLUDED).; The Last bin (bin# nbins+1) contains the overflow.; In case of 2-D or 3-D histograms, a “global bin” number is defined. For example, assuming a 3-D histogram h with binx, biny, binz, the function returns a global/linear bin number.; Int_t bin = h->GetBin(binx, biny, binz);; This global bin is useful to access the bin information independently of the dimension.; 3.3.2 Re-binning. At any time, a histogram can be re-binned via the TH1::Rebin() method. It returns a new histogram with the re-binned contents. If bin errors were stored, they are recomputed during the re-binning.; 3.4 Filling Histograms; A histogram is typica",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:77441,Modifiability,extend,extend,77441,"ith statements like:; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; The Fill method computes the bin number corresponding to the given x, y or z argument and increments this bin by the given weight. The Fill() method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2() has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling TH1::AddBinContent(), replace the existing content via TH1::SetBinContent() , and access the bin content of a given bin via TH1::GetBinContent() .; Double_t binContent = h->GetBinContent(bin);; 3.4.1 Automatic Re-binning Option; By default, the number of bins is computed using the range of the axis. You can change this to re-bin automatically by setting the automatic re-binning option:; h->SetBit(TH1::kCanRebin);. Once this is set, the Fill() method will automatically extend the axis range to accommodate the new value specified in the Fill() argument. The used method is to double the bin size until the new value fits in the range, merging bins two by two. The TTree::Draw() method extensively uses this automatic binning option when drawing histograms of variables in TTree with an unknown range. The automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute the mean value and root mean square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S a check is made that the bin contents do not exceed the maximum positive capacity (127 or 65 535). Histograms of all types may have positive or/and negative bin contents.; 3.5 Random Numbers and Histograms; TH1::FillRandom() can be used to randomly fill a histogram using the contents of an existing TF1 function or another TH1 histogram (for all dimensions). For example, the following two statements create",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:77731,Modifiability,variab,variables,77731,"in by the given weight. The Fill() method returns the bin number for 1-D histograms or global bin number for 2-D and 3-D histograms. If TH1::Sumw2() has been called before filling, the sum of squares is also stored. One can increment a bin number directly by calling TH1::AddBinContent(), replace the existing content via TH1::SetBinContent() , and access the bin content of a given bin via TH1::GetBinContent() .; Double_t binContent = h->GetBinContent(bin);; 3.4.1 Automatic Re-binning Option; By default, the number of bins is computed using the range of the axis. You can change this to re-bin automatically by setting the automatic re-binning option:; h->SetBit(TH1::kCanRebin);. Once this is set, the Fill() method will automatically extend the axis range to accommodate the new value specified in the Fill() argument. The used method is to double the bin size until the new value fits in the range, merging bins two by two. The TTree::Draw() method extensively uses this automatic binning option when drawing histograms of variables in TTree with an unknown range. The automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute the mean value and root mean square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S a check is made that the bin contents do not exceed the maximum positive capacity (127 or 65 535). Histograms of all types may have positive or/and negative bin contents.; 3.5 Random Numbers and Histograms; TH1::FillRandom() can be used to randomly fill a histogram using the contents of an existing TF1 function or another TH1 histogram (for all dimensions). For example, the following two statements create and fill a histogram 10 000 times with a default Gaussian distribution of mean 0 and sigma 1 :; root[] TH1F h1(""h1"",""Histo from a Gaussian"",100,-3,3);; root[] h1.FillRandom(""gaus"",10000);; TH1::GetRandom() can be used to get a random number distr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:84804,Modifiability,inherit,inherited,84804,"se the current style gStyle, which is the global object of class TStyle. To change the current style for histograms, the TStyle class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/phi coordinates.; “LEGO”: Draw a lego plot with hidden line removal.; “LEGO1”: Draw a lego plot with hidden surface removal.; “LEGO2”: Draw a lego plot using colors to show the cell contents.; “SURF”: Draw a surface plot with hidden line ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:112438,Modifiability,inherit,inherit,112438," the number of entries; m the mean value; M the mean and mean error values; r the root mean square (RMS); R the RMS and RMS error; u the number of underflows; o the number of overflows; i the integral of bins; s the skewness; S the skewness and the skewness error; k the kurtosis; K the kurtosis and the kurtosis error. gStyle->SetOptStat(""ne""); // prints the histogram name and number; // of entries; gStyle->SetOptStat(""n""); // prints the histogram name; gStyle->SetOptStat(""nemr""); // the default value; With the option ""same"", the statistic box is not redrawn. With the option ""sames"", it is re-drawn. If it hides the previous statistics box, you can change its position with the next lines (where h is the histogram pointer):; root[] TPaveStats *s =; (TPaveStats*)h->GetListOfFunctions()->FindObject(""stats"");; root[] s->SetX1NDC (newx1); // new x start position; root[] s->SetX2NDC (newx2); // new x end position; 3.8.6 Setting Line, Fill, Marker, and Text Attributes; The histogram classes inherit from the attribute classes: TAttLine, TAttFill, TAttMarker and TAttText. See the description of these classes for the list of options.; 3.8.7 Setting Tick Marks on the Axis; The TPad::SetTicks() method specifies the type of tick marks on the axis. Let tx=gPad->GetTickx() and ty=gPad->GetTicky(). tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn; tx=ty=0 by default only the left Y axis and X bottom axis are drawn. Use TPad::SetTicks(tx,ty) to set these options. See also the methods of TAxis that set specific axis attributes. If multiple color-filled histograms are drawn on the same pad, the fill area may hide the axis tick marks. One can force the axis redrawing over all the histograms by calling:; gPad->RedrawAxis();; 3.8.8 Giving Titles to the X, Y and Z Axis; Because the axis title is an attribute of the axis, you have to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:121738,Modifiability,variab,variable,121738,"nd unbinned:; h->ResetStats();; h->GetXaxis()->SetRange();; for(int i=0; i<10000; i++) h->Fill(85);; results in GetMean and GetStdDev returning 67.5 and 17.5, respectively; you must call TH1::ResetStats again to get consistent binned statistics.; 3.14 Alphanumeric Bin Labels; By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead.; 3.14.1 Option 1: SetBinLabel; To set an alphanumeric bin label call:; TAxis::SetBinLabel(bin,label);; This can always be done before or after filling. Bin labels will be automatically drawn with the histogram. Histograms with alphanumeric bin labels. See example in $ROOTSYS/tutorials/hist/hlabels1.C , hlabels2.C; 3.14.2 Option 2: Fill; You can also call a Fill() function with one of the arguments being a string:; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; 3.14.3 Option 3: TTree::Draw; You can use a char* variable type to histogram strings with TTree::Draw().; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");. Using a *char variable type in TTree::Draw. There is an example in $ROOTSYS/tutorials/tree/cernstaff.C.; If a variable is defined as char* it is drawn as a string by default. You change that and draw the value of char[0] as an integer by adding an arithmetic operation to the expression as shown below.; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; 3.14.4 Sort Options; When using the options 2 or 3 above, the labels are automatically added to the list (THashList) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis alphabetically or by increasing or decreasing values. The reordering can be triggered via the TAxis context menu by selecting the menu item “LabelsOption” or by calling dir",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:121918,Modifiability,variab,variable,121918,"all TH1::ResetStats again to get consistent binned statistics.; 3.14 Alphanumeric Bin Labels; By default, a histogram axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead.; 3.14.1 Option 1: SetBinLabel; To set an alphanumeric bin label call:; TAxis::SetBinLabel(bin,label);; This can always be done before or after filling. Bin labels will be automatically drawn with the histogram. Histograms with alphanumeric bin labels. See example in $ROOTSYS/tutorials/hist/hlabels1.C , hlabels2.C; 3.14.2 Option 2: Fill; You can also call a Fill() function with one of the arguments being a string:; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; 3.14.3 Option 3: TTree::Draw; You can use a char* variable type to histogram strings with TTree::Draw().; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");. Using a *char variable type in TTree::Draw. There is an example in $ROOTSYS/tutorials/tree/cernstaff.C.; If a variable is defined as char* it is drawn as a string by default. You change that and draw the value of char[0] as an integer by adding an arithmetic operation to the expression as shown below.; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; 3.14.4 Sort Options; When using the options 2 or 3 above, the labels are automatically added to the list (THashList) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis alphabetically or by increasing or decreasing values. The reordering can be triggered via the TAxis context menu by selecting the menu item “LabelsOption” or by calling directly.; TH1::LabelsOption(option,axis);; Here axis may be X, Y, or Z. The parameter option may be:. “a” sort by alphabetic order; “>” sort by decreasing values; “<” sort by increasin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:122014,Modifiability,variab,variable,122014," axis is drawn with its numeric bin labels. One can specify alphanumeric labels instead.; 3.14.1 Option 1: SetBinLabel; To set an alphanumeric bin label call:; TAxis::SetBinLabel(bin,label);; This can always be done before or after filling. Bin labels will be automatically drawn with the histogram. Histograms with alphanumeric bin labels. See example in $ROOTSYS/tutorials/hist/hlabels1.C , hlabels2.C; 3.14.2 Option 2: Fill; You can also call a Fill() function with one of the arguments being a string:; hist1->Fill(somename,weigth);; hist2->Fill(x,somename,weight);; hist2->Fill(somename,y,weight);; hist2->Fill(somenamex,somenamey,weight);; 3.14.3 Option 3: TTree::Draw; You can use a char* variable type to histogram strings with TTree::Draw().; // here ""Nation"" and ""Division"" are two char* branches of a Tree; tree.Draw(""Nation::Division"", """", ""text"");. Using a *char variable type in TTree::Draw. There is an example in $ROOTSYS/tutorials/tree/cernstaff.C.; If a variable is defined as char* it is drawn as a string by default. You change that and draw the value of char[0] as an integer by adding an arithmetic operation to the expression as shown below.; // draw the integer value of MyChar[0] where ""MyChar"" is char[5]; tree.Draw(""MyChar + 0"");; 3.14.4 Sort Options; When using the options 2 or 3 above, the labels are automatically added to the list (THashList) of labels for a given axis. By default, an axis is drawn with the order of bins corresponding to the filling sequence. It is possible to reorder the axis alphabetically or by increasing or decreasing values. The reordering can be triggered via the TAxis context menu by selecting the menu item “LabelsOption” or by calling directly.; TH1::LabelsOption(option,axis);; Here axis may be X, Y, or Z. The parameter option may be:. “a” sort by alphabetic order; “>” sort by decreasing values; “<” sort by increasing values; “h” draw labels horizontal; “v” draw labels vertical; “u” draw labels up (end of label right adjusted); “d” ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:127550,Modifiability,variab,variable,127550,") :. H[j] will contain for each bin j the sum of the y values for this bin; L[j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting error depending on the selected option. See “Build Options”. E[j] = sum Y**2; L[j] = number of entries in bin J; H[j] = sum Y; h[j] = H[j] / L[j]; s[j] = sqrt[E[j] / L[j] - h[j]**2]; e[j] = s[j] / sqrt[L[j]]; In the special case where s[j] is zero, when there is only one entry per bin, e[j] is computed from the average of the s[j] for all bins. This approximation is used to keep the bin during a fit operation. The TProfile constructor takes up to eight arguments. The first five parameters are similar to TH1D constructor.; TProfile(const char *name,const char *title,Int_t nbinsx,; Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,; Option_t *option); All values of y are accepted at filling time. To fill a profile histogram, you must use TProfile::Fill function. Note that when filling the profile histogram the method TProfile::Fill checks if the variable y is between fYmin and fYmax. If a minimum or maximum value is set for the Y scale before filling, then all values below ylow or above yup will be discarded. Setting the minimum or maximum value for the Y scale before filling has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128518,Modifiability,variab,variable,128518,"m the method TProfile::Fill checks if the variable y is between fYmin and fYmax. If a minimum or maximum value is set for the Y scale before filling, then all values below ylow or above yup will be discarded. Setting the minimum or maximum value for the Y scale before filling has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y tak",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:128646,Modifiability,variab,variable,128646," ylow or above yup will be discarded. Setting the minimum or maximum value for the Y scale before filling has the same effect as calling the special TProfile constructor above where ylow and yup are specified.; 3.17.1 Build Options; The last parameter is the build option. If a bin has N data points all with the same value Y, which is the case when dealing with integers, the spread in Y for that bin is zero, and the uncertainty assigned is also zero, and the bin is ignored in making subsequent fits. If SQRT(Y) was the correct error in the case above, then SQRT(Y)/SQRT(N) would be the correct error here. In fact, any bin with non-zero number of entries N but with zero spread (spread = s[j]) should have an uncertainty SQRT(Y)/SQRT(N). Now, is SQRT(Y)/SQRT(N) really the correct uncertainty ? That it is only in the case where the Y variable is some sort of counting statistics, following a Poisson distribution. This is the default case. However, Y can be any variable from an original NTUPLE, and does not necessarily follow a Poisson distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is use",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:129693,Modifiability,variab,variables,129693,"son distribution. The computation of errors is based on Y = values of data points; N = number of data points. ' ' - the default is blank, the errors are:; spread/SQRT(N) for a non-zero spread; SQRT(Y)/SQRT(N) for a spread of zero and some data points; 0 for no data points; ‘ s ’ - errors are:; spread for a non-zero spread; SQRT(Y) for a Spread of zero and some data points; 0 for no data points; ‘ i ’ - errors are:; spread/SQRT(N) for a non-zero spread; 1/SQRT(12*N) for a Spread of zero and some data points; 0 for no data points; ‘ G ’ - errors are:; spread/SQRT(N) for a non-zero spread; sigma/SQRT(N) for a spread of zero and some data points; 0 for no data points. The option ’ i ’ is used for integer Y values with the uncertainty of \(\pm 0.5\), assuming the probability that Y takes any value between Y-0.5 and Y+0.5 is uniform (the same argument for Y uniformly distributed between Y and Y+1). An example is an ADC measurement. The ‘G’ option is useful, if all Y variables are distributed according to some known Gaussian of standard deviation Sigma. For example when all Y’s are experimental quantities measured with the same instrument with precision Sigma. The next figure shows the graphic output of this simple example of a profile histogram.; {; // Create a canvas giving the coordinates and the size; TCanvas *c1 = new TCanvas(""c1"", ""Profile example"",200,10,700,500);. // Create a profile with the name, title, the number of bins,; // the low and high limit of the x-axis and the low and high; // limit of the y-axis.; // No option is given so the default is used.; hprof = new TProfile(""hprof"",; ""Profile of pz versus px"",100,-4,4,0,20);. // Fill the profile 25000 times with random numbers; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; // Use the random number generator to get two numbers following; // a gaussian distribution with mean=0 and sigma=1; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. A profile histogram exampl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:142308,Modifiability,extend,extend,142308,"y updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming.; 4 Graphs; A graph is a graphics object made of two arrays X and Y, holding the x,y coordinates of n points. There are several graph classes; they are TGraph, TGraphErrors, TGraphAsymmErrors, and TMultiGraph.; 4.1 TGraph; The TGraph class supports the general case with non-equidistant points, and the special case with equidistant points. Graphs are created with the TGraph constructor. First, we define the arrays of coordinates and then create the graph. The coordinates can be arrays of doubles or floats.; Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0; i<n; i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; TGraph *gr1 = new TGraph (n, x, y);; An alternative constructor takes only the number of points n. It is expected that the coordinates will be set later.; TGraph *gr2 = new TGraph(n);; The default constructor can also be used. Further calls to SetPoint() will extend the internal vectors.; TGraph *gr3 = new TGraph();; 4.1.1 Graph Draw Options; The various drawing options for a graph are explained in TGraph::PaintGraph. They are:. “L” A simple poly-line between every points is drawn; “F” A fill area is drawn; “F1” Idem as “F” but fill area is no more repartee around X=0 or Y=0; “F2” draw a fill area poly line connecting the center of bins; “A” Axis are drawn around the graph; “C” A smooth curve is drawn; “*” A star is plotted at each point; “P” The current marker of the graph is plotted at each point; “B” A bar chart is drawn at each point; “[]” Only the end vertical/horizontal lines of the error bars are drawn. This option only applies to the TGraphAsymmErrors.; “1” ylow = rwymin. The options are not case sensitive and they can be concatenated in most cases. Let us look at some examples.; 4.1.1.1 Continuous Line, Axis and Stars (AC*). A graph drawn with axis, * markers and continuous line (option AC*). {; Int_t n = 20;; Double_t x[n], y[n",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:147730,Modifiability,inherit,inherits,147730,"sents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TGraphAsymmErrors is a TGraph with asymmetric error bars. It inherits the various draw format options from TGraph. Its method Paint(Option_t *option) paints the TGraphAsymmErrors with the current attributes. You can set the following additional options for drawing:. “z” or “Z”the horizontal and vertical small lines are not drawn at the end of error bars; “>”an arrow is drawn at the end of the error bars; “|>”a full arrow is drawn at the end of the error bar; its size is \(\frac{2}{3}\) of the marker size; “[]”only the end vertical/horizontal lines of the error bars are drawn; this option is interesting to superimpose systematic errors on top of a graph with statistical errors. The constructor has six arrays as parameters: X and Y as TGraph and low X-errors and high X-errors, low Y-errors and high Y-errors. The low value is the length of the error bar to the left and down, the high value is the length of the error bar to the right and up.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",; 200,10,700,500);; c1->SetGrid();. // create the arrays for the points; In",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:158510,Modifiability,extend,extended,158510,"very point in a given polygon is closer to its central point than to any other. A Voronoï diagram is sometimes also known as a Dirichlet tessellation.; The TGraph2D class has the following constructors:. With an arrays’ dimension n and three arrays x, y, and z (can be arrays of doubles, floats, or integers):. TGraph2D *g = new TGraph2D(n,x,y,z);. With an array dimension only:. TGraph2D *g = new TGraph2D(n);. Internal arrays are filled with the method SetPoint at the position “i” with the values x, y, z:. g->SetPoint(i,x,y,z);. Without parameters; the method SetPoint must be used to fill the internal arrays. TGraph2D *g = new TGraph2D();. From a file:. TGraph2D *g = new TGraph2D(""graph.dat"");; The arrays are read from the ASCII file “graph.dat” according to a specified format. The format’s default value is “%lg %lg %lg”. Note that in any of last three cases, the SetPoint method can be used to change a data point or to add a new one. If the data point index (i) is greater than the size of the internal arrays, they are automatically extended.; Specific drawing options can be used to paint a TGraph2D:. “TRI” the Delaunay triangles are drawn using filled area. A hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of the triangles are painted with the current line color;; “TRIW”the Delaunay triangles are drawn as wire frame;; “TRI1” the Delaunay triangles are painted with color levels. The edges of the triangles are painted with the current line color;; “TRI2” the Delaunay triangles are painted with color levels;; “P”draws a marker at each vertex;; “P0” draws a circle at each vertex. Each circle background is white. A TGraph2D can be also drawn with ANY options valid for 2D histogram drawing. In this case, an intermediate 2D histogram is filled using the Delaunay triangles technique to interpolate the data set. TGraph2D linearly interpolate a Z value for any (X,Y) point given some existing (X,Y,Z) points. The existi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:168295,Modifiability,adapt,adapted,168295,"used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((x-p1)/p2)^2); “expo”An Exponential with 2 parameters: f(x) = exp(p0+p1*x); “polN” A polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*x2 +...; “chebyshevN” A Chebyshev polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*(2*x2-1) +...; “landau” Landau function with mean and sigma. This function has been adapted from the CERNLIB routine G110 denlan (see TMath::Landau).; “gausn” Normalized form of the gaussian function with 3 parameters f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI)). 5.2.2 Creating User-Defined Functions (TF1); You can create a TF1 object and use it in the call the TH1::Fit. The parameter in to the Fit method is the NAME of the TF1 object. There are three ways to create a TF1. Using C++ expression using x with a fixed set of operators and functions defined in TFormula.; Same as first one, with parameters; Using a function that you have defined. This can be a free function or a functor object or a particular member function of a class. 5.2.2.1 Creating a TF1 with a Formula; Let’s look at the first case. Here we call the TF1 constructor by giving it the formula: sin(x)/x.; root[] TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10); You can also use a TF1 object in the constructor of another TF1.; root[] TF1 *f2 = new TF1(""f2"",""f1*2"",0,10); 5.2.2.2 Creating a TF1 with Parameters; The second way to cons",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:172732,Modifiability,Config,Configuring,172732,"ber function:; double operator()(double *x, double *p); The advantage of the function object is that it can have a state and reference therefore what-ever other object the user needs, without using globals. This is an example to define first the function object; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; and then use it to create the TF1:; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; If using C++11, one can create a TF1 also from a C++ lambda function:; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; 5.3 Configuring the Fit; We will show here some configuration actions that can or must be done when fitting histogram or graph using the Fit method.; 5.3.1 Fixing and Setting Parameters’ Bounds; Parameters must be initialized before invoking the Fit method. The setting of the parameter initial values is automatic for the predefined functions: poln, exp, gaus, and landau. You can fix one or more parameters by specifying the “B” option when calling the Fit method. When a function is not predefined, the fit parameters must be initialized to some value as close as possible to the expected values before calling the fit function.; To set bounds for one parameter, use TF1::SetParLimits:; func->SetParLimits(0,-1,1);; When the lower and upper limits are equal, the parameter is fixed. Next two statements fix parameter 4 at 10.; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; However, to fix a parameter to 0, one must call the FixParameter function:; func->SetParameter(4,0);; func->FixParameter(4,0);; Note that you are not forced to set the limits for all param",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:172776,Modifiability,config,configuration,172776,"ber function:; double operator()(double *x, double *p); The advantage of the function object is that it can have a state and reference therefore what-ever other object the user needs, without using globals. This is an example to define first the function object; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; and then use it to create the TF1:; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; If using C++11, one can create a TF1 also from a C++ lambda function:; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; 5.3 Configuring the Fit; We will show here some configuration actions that can or must be done when fitting histogram or graph using the Fit method.; 5.3.1 Fixing and Setting Parameters’ Bounds; Parameters must be initialized before invoking the Fit method. The setting of the parameter initial values is automatic for the predefined functions: poln, exp, gaus, and landau. You can fix one or more parameters by specifying the “B” option when calling the Fit method. When a function is not predefined, the fit parameters must be initialized to some value as close as possible to the expected values before calling the fit function.; To set bounds for one parameter, use TF1::SetParLimits:; func->SetParLimits(0,-1,1);; When the lower and upper limits are equal, the parameter is fixed. Next two statements fix parameter 4 at 10.; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; However, to fix a parameter to 0, one must call the FixParameter function:; func->SetParameter(4,0);; func->FixParameter(4,0);; Note that you are not forced to set the limits for all param",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:188552,Modifiability,config,configuring,188552,"se and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit parameters (initial values, bounds, etc..), ROOT::Fit::FitResult for storing the result of the fit.; Data classes containing the data sets used in the fitting. These classes are theROOT::Fit::BinDatafor describing bin data sets, thus data points containing both coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordinate values can be one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; Function classes defining the type of fit (the objective function used for fitting):. ROOT::Fit::Chi2FCN for chi2 (least-square fits),; ROOT::Fit::PoissonLikelihoodFCN for binned likelihood fits of histograms,; ROOT::Fit::LogLikelihoodFCN for generic un-binned likelihood fits. These classes are templated on the type of function interface t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190397,Modifiability,config,configure,190397,"-square fits),; ROOT::Fit::PoissonLikelihoodFCN for binned likelihood fits of histograms,; ROOT::Fit::LogLikelihoodFCN for generic un-binned likelihood fits. These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided. They derive from the common generic interface multi-dimensional for function evaluation, ROOT::Math::IBaseFunctionMultiDim. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, ROOT::Math::IParametricFunctionMultiDim to define the fit model function and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191018,Modifiability,extend,extended,191018,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191336,Modifiability,Config,Configure,191336,"bjects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; In this code example, we have used the utility function of the Hist library, ROOT::Fit::FillData to fill the BinData object. The ROOT::Fit::FillData is define",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:193689,Modifiability,variab,variable,193689,"The fit data options are controlled by the ROOT::Fit::DataOptions class, the range by the ROOT::Fit::DataRange class.; Here is an example how to specify the input option to use the integral of the function value in the bin instead of using the function value evaluated at the bin center, when doing the fit and to use a range beween the ‘xmin’ and ‘xmax’ values.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::DataRange range(xmin,xmax);; ROOT::Fit::BinData data(opt,range);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; The list of possible fit options available is the following:; ROOT::Fit::DataOptions opt;; opt.fIntegral = true; // use integral of bin content instead of bin center (default is false).; opt.fBinVolume = true; // normalize data by the bin volume (default is false).; // This is for fitting density functions in histograms with variable bin sizes.; opt.fUseRange =true; // use the function range when creating the fit data (default is false).; opt.fExpErrors = true; // use the expected errors estimated from the function values; // assuming Poisson statistics and not the observed errors (default is false).; opt.fUseEmpty = true; // use empty bins when fitting (default is false). If fExpErrors; // is not set an arbitrary error = 1 is assigned to those bins.; opt.fErrors1 = true; // Set all measured errors to 1 (default is false).; opt.fCoordErrors = false; // When available coordinate errors are not used in the fit; // (default is true: the errors are used when they are available,; // e.g. fitting a TGraphErrors).; opt.fAsymErrors = false; // When available asymmetric errors are considered in the fit; // (default is true, the asymmetric errors are used when they are available,; // e.g. fitting a TGraphAsymmErrors).; The ROOT::Fit::DataRange class supports defining multiple rectangular ranges ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:197055,Modifiability,variab,variables,197055,"r of a TH1 object:; double * buffer = histogram->GetBuffer();; // number of entry is first entry in the buffer; int n = buffer[0];; // when creating the data object it is important to create with the size of the data; ROOT::Fit::UnBinData data(n);; for (int i = 0; i < n; ++i); data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; Instead in this example we will create a 2-dim UnBinData object with the contents from a ROOT TTree; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; // select from the tree the data we want to use for fitting; // we use TTree::Draw for this; int nevt = ntuple->Draw(""px:py"","""",""goff"");; double * x = ntuple->GetV1();; double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; 5.7.2 Creating the Fit model; In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or an hypothetical function describing the relation between the independent variables X and the single dependent variable Y. We can have an arbitrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the indepe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:197092,Modifiability,variab,variable,197092,"r of a TH1 object:; double * buffer = histogram->GetBuffer();; // number of entry is first entry in the buffer; int n = buffer[0];; // when creating the data object it is important to create with the size of the data; ROOT::Fit::UnBinData data(n);; for (int i = 0; i < n; ++i); data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; Instead in this example we will create a 2-dim UnBinData object with the contents from a ROOT TTree; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; // select from the tree the data we want to use for fitting; // we use TTree::Draw for this; int nevt = ntuple->Draw(""px:py"","""",""goff"");; double * x = ntuple->GetV1();; double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; 5.7.2 Creating the Fit model; In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or an hypothetical function describing the relation between the independent variables X and the single dependent variable Y. We can have an arbitrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the indepe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:197153,Modifiability,variab,variables,197153,"fer[0];; // when creating the data object it is important to create with the size of the data; ROOT::Fit::UnBinData data(n);; for (int i = 0; i < n; ++i); data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; Instead in this example we will create a 2-dim UnBinData object with the contents from a ROOT TTree; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; // select from the tree the data we want to use for fitting; // we use TTree::Draw for this; int nevt = ntuple->Draw(""px:py"","""",""goff"");; double * x = ntuple->GetV1();; double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; 5.7.2 Creating the Fit model; In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or an hypothetical function describing the relation between the independent variables X and the single dependent variable Y. We can have an arbitrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the independent vector of values X and vector of parameters P. More information about the different ROOT::Math function interfaces i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:197233,Modifiability,variab,variables,197233,"T::Fit::UnBinData data(n);; for (int i = 0; i < n; ++i); data.add(buffer[2*i+1]); // the buffer of 1D histogram contains nevt,x1,w1,x2,w2,......; Instead in this example we will create a 2-dim UnBinData object with the contents from a ROOT TTree; TFile * file = TFile::Open(""hsimple.root"");; TTree *ntuple = 0; file->GetObject(""ntuple"",ntuple);; // select from the tree the data we want to use for fitting; // we use TTree::Draw for this; int nevt = ntuple->Draw(""px:py"","""",""goff"");; double * x = ntuple->GetV1();; double * y = ntuple->GetV2();; ROOT::Fit::UnBinData data(nevt, x, y );; 5.7.2 Creating the Fit model; In order to fit a data sets we need a model to describe our data, e.g. a probability density function describing our observed data or an hypothetical function describing the relation between the independent variables X and the single dependent variable Y. We can have an arbitrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the independent vector of values X and vector of parameters P. More information about the different ROOT::Math function interfaces is available in the Mathematical Library chapter.; An end-user can convert a TF1 object in a ROOT::M",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:197858,Modifiability,extend,extends,197858,"scribing our observed data or an hypothetical function describing the relation between the independent variables X and the single dependent variable Y. We can have an arbitrary number k of independent variables. For example, when fitting a k-dimensional histogram, the independent variables X are the bin center coordinates and Y is the bin weight.; The model function needs to be expressed as function of some unknown parameters. The fitting will find the best parameter value to describe the observed data.; We can use the ROOT TF1 class, the parametric function class, to describe the model function. However the ROOT::Fit::Fitter class, to be independent of the ROOT Hist library, takes as input a more general parametric function object, the interface (abstract) class ROOT::Math::IParametricFunctionMultiDim, which describe a generic one or multi-dimensional function with parameters. This interface extends the abstract class ROOT::Math::IBaseFunctionMultiDim, with methods to set/retrieve parameter values and to evaluate the function given the independent vector of values X and vector of parameters P. More information about the different ROOT::Math function interfaces is available in the Mathematical Library chapter.; An end-user can convert a TF1 object in a ROOT::Math::IParametricFunctionMultiDim, using the wrapper class ROOT::Math::WrapperMultiTF1:; TF1 * f1 = new TF1(""f1"",""gaus"");; ROOT::Math::WrappedMultiTF1 fitFunction(f1, f1->GetNdim() );; ROOT::Fit::Fitter fitter;; fitter.SetFunction( fitFunction, false);; When creating the wrapper, the parameter values stored in TF1 will be copied in the ROOT::Math::WrappedMultiTF1 object. The function object representing the model function is given to the ROOT::Fitter class using the Fitter::SetFunction method.; The user has also the possibility to provide a function object, which implements the derivatives of the function with respect to the parameters. This information might be useful for some types of fits. In this case he need",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:199744,Modifiability,Config,Configuration,199744," the derivatives of the function with respect to the parameters. This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the ROOT::Math::IParametricGradFunctionMultiDim interface. Note that the wrapper class ROOT::Math::WrappedMultiTF1 implements also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Conf",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:199763,Modifiability,config,configuration,199763," the derivatives of the function with respect to the parameters. This information might be useful for some types of fits. In this case he needs to provide the function object as a class deriving from the ROOT::Math::IParametricGradFunctionMultiDim interface. Note that the wrapper class ROOT::Math::WrappedMultiTF1 implements also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Conf",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:199920,Modifiability,config,configurations,199920,"or some types of fits. In this case he needs to provide the function object as a class deriving from the ROOT::Math::IParametricGradFunctionMultiDim interface. Note that the wrapper class ROOT::Math::WrappedMultiTF1 implements also the gradient interface, using internally TF1::GradientPar, which is based on numerical differentiation, apart for the case of linear functions (i.e. when TF1::IsLinear() is true). The parameter derivatives of the model function can be useful to some minimization algorithms, such as Fumili. However, in general is better to leave the minimization algorithm (e.g. Minuit) to compute the needed derivatives using its own customised numerical differentiation algorithm. In order to not provide to the fitter the parameter derivatives, we explicitly passed in Fitter::SetFunction a false value.; 5.7.3 Fit Configuration; The configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200756,Modifiability,Config,Config,200756,"he configuration of the fit is done via the ROOT::Fit::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:200807,Modifiability,Config,Config,200807,"it::FitConfig class and its contained ROOT::Fit::ParameterSettings class. These are the possible allowed fit configurations:. setting the initial values of the parameters;; setting the parameter step sizes;; setting eventual parameter bounds;; setting the minimizer library and the particular algorithm to use;; setting different minimization options (print level, tolerance, max iterations, etc…); setting the type of parameter errors to compute (parabolic error, Minos errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:201304,Modifiability,plug-in,plug-in,201304," errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:203935,Modifiability,config,configured,203935,"likelihood fits. It has requirements on the type of method function to be used. No specific algorithm exists; GSLMultiMin (library libMathMore). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is. BFGS2 (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; BFGS : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; ConjugateFR : Fletcher-Reeves conjugate gradient algorithm;; ConjugatePR : Polak-Ribiere conjugate gradient algorithm;; SteepestDescent: steepest descent algorithm;. GSLMultiFit (library libMathMore). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits.; GSLSimAn (library libMathMore). Minimizer based on simulated annealing.; Genetic (library libGenetic). Genetic minimizer based on an algorithm implemented in the TMVA package. Each minimizer can be configured using the ROOT::Math::MinimizerOptions class. The list of possible option that can be set are:. Minimizer type (MinimizerOptions::SetMinimizerType(const char *)) .; Minimizer algorithm (MinimizerOptions::SetMinimizerAlgorithm(const char *)).; Print Level (MinimizerOptions::SetPrintLevel(int )) to set the verbose printing level (default is 0).; Tolerance (MinimizerOptions::SetTolerance(double )) tolerance used to control the iterations.; Maximum number of function calls (MinimizerOptions::SetMaxFunctionCalls(int )).; Maximum number of iterations (MinimizerOptions::SetMaxIterations(int )). Note that this is not used by Minuit; FCN Upper value for Error Definition (MinimizerOptions::SetErrorDef(double )). Value in the minimization function used to compute the parameter errors. The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; Strategy (MinimizerOptions::SetStrategy(int )), minimization strategy u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:205010,Modifiability,config,configuration,205010,"ist of possible option that can be set are:. Minimizer type (MinimizerOptions::SetMinimizerType(const char *)) .; Minimizer algorithm (MinimizerOptions::SetMinimizerAlgorithm(const char *)).; Print Level (MinimizerOptions::SetPrintLevel(int )) to set the verbose printing level (default is 0).; Tolerance (MinimizerOptions::SetTolerance(double )) tolerance used to control the iterations.; Maximum number of function calls (MinimizerOptions::SetMaxFunctionCalls(int )).; Maximum number of iterations (MinimizerOptions::SetMaxIterations(int )). Note that this is not used by Minuit; FCN Upper value for Error Definition (MinimizerOptions::SetErrorDef(double )). Value in the minimization function used to compute the parameter errors. The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; Strategy (MinimizerOptions::SetStrategy(int )), minimization strategy used. For each minimization strategy Minuit uses different configuration parameters (e.g. different requirements in computing derivatives, computing full Hessian (strategy = 2) or an approximate version. The default is a value of 1. In this case the full Hessian matrix is computed only after the minimization.; Precision (MinimizerOptions::SetPrecision(double )). Precision value in the evaluation of the minimization function. Default is numerical double precision. Note that not all the options are implemented by all the minimizers. For example in Minuit is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The lis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:207261,Modifiability,extend,extended,207261,"Options(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default the fit is not extended (i.e. the normalization is not fitted to the data). As above the user can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood fu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:207422,Modifiability,extend,extended,207422,"ible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default the fit is not extended (i.e. the normalization is not fitted to the data). As above the user can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize. In this case, the user does not really need to build as input a ROOT::Fit dat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:207667,Modifiability,extend,extended,207667,"ing methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default the fit is not extended (i.e. the normalization is not fitted to the data). As above the user can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize. In this case, the user does not really need to build as input a ROOT::Fit data set and model function as we described before. He can implements its own version of the method function using on its own data set objects and functions.; In this case ROOT::Fit::Fitter::SetFCN is used to set the method function and ROOT::Fit::FitFCN is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:207760,Modifiability,extend,extended,207760,"quare fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default the fit is not extended (i.e. the normalization is not fitted to the data). As above the user can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize. In this case, the user does not really need to build as input a ROOT::Fit data set and model function as we described before. He can implements its own version of the method function using on its own data set objects and functions.; In this case ROOT::Fit::Fitter::SetFCN is used to set the method function and ROOT::Fit::FitFCN is used for fitting. The method function can be passed also in ROOT::Fit::FitFCN, but in this case a previously defined fitti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:207808,Modifiability,extend,extended,207808,"quare fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default the fit is not extended (i.e. the normalization is not fitted to the data). As above the user can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize. In this case, the user does not really need to build as input a ROOT::Fit data set and model function as we described before. He can implements its own version of the method function using on its own data set objects and functions.; In this case ROOT::Fit::Fitter::SetFCN is used to set the method function and ROOT::Fit::FitFCN is used for fitting. The method function can be passed also in ROOT::Fit::FitFCN, but in this case a previously defined fitti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:208786,Modifiability,config,configuration,208786,"er can select an extended likelihood fit by passing the optional extended boolean flag as true. This method is implemented using the class LogLikelihoodFCN; Linear Fit: A linear fit can be selected (no iterative minimization is needed in this case, but using linear algebra algorithms from the Matrix library), if the model function is linear in the parameters. 5.7.5.2 Customised Fit methods; Above we described the pre-defined methods used for fitting. A user can also implement its own fitting methods, thus its version of the chi-square or likelihood function he wants to minimize. In this case, the user does not really need to build as input a ROOT::Fit data set and model function as we described before. He can implements its own version of the method function using on its own data set objects and functions.; In this case ROOT::Fit::Fitter::SetFCN is used to set the method function and ROOT::Fit::FitFCN is used for fitting. The method function can be passed also in ROOT::Fit::FitFCN, but in this case a previously defined fitting configuration is used.; The possible type of method functions that are based in ROOT::Fit::Fitter::SetFCN are:. A generic functor object implementing operator()(const double * p) where p is the parameter vectors. In this case one needs to pass the number of parameters, the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit). In the last two parameters are given, the chi2/ndf can be computed after fitting the data. template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::IBaseFunctionMultiDim interface:. bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:209846,Modifiability,extend,extending,209846,"etFCN are:. A generic functor object implementing operator()(const double * p) where p is the parameter vectors. In this case one needs to pass the number of parameters, the function object and optionally a vector of initial parameter values. Other optional parameter include the size of the data sets and a flag specifying if it is a chi2 (least-square fit). In the last two parameters are given, the chi2/ndf can be computed after fitting the data. template <class Function>; bool Fitter::SetFCN(unsigned int npar, Function & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::IBaseFunctionMultiDim interface:. bool Fitter::SetFCN(const ROOT::Math::IBaseFunctionMultiDim & f,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false). A function object implementing the ROOT::Math::FitMethodFunction interface. This is an interface class extending the ROOT::Math::IBaseFunctionMultiDim with some extra functionality which can be used when fitting. This extra functionality is required by dedicated fitting algorithms like Fumili or GSLMultiFit. bool Fitter::SetFCN(const ROOT::Math::FitMethodFunction & f,; const double * initialParameters = 0, unsigned int dataSize=0). A old-Minuit like FCN interface (i.e. a free function with the signature fcn(int &npar, double *gin, double &f, double *u, int flag). typedef void(* MinuitFCN)(int &npar, double *gin, double &f, double *u, int flag); bool Fitter::SetFCN(MinuitFCN fcn, int npar,; const double * initialParameters = 0,; unsigned int dataSize=0, bool isChi2Fit = false); 5.7.6 Fit Result; The result of the fit is contained in the ROOT::Fit::Result object. A reference to the result object is obtained with the function Fitter::Result(). The ROOT::Fit::FitResult class provides an API for retrieving parameter values, errors, covariance and correlation matrix from the fit, minimum chi2/likelihood values, etc…; A FitResult::Pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:212986,Modifiability,config,configure,212986,"y the status of the fit and can be obtained by an automatic conversion of the TFitResultPtr to an integer.; If the fit option S is instead used, TFitResultPtr contains the TFitResult and behaves as a smart pointer to it. This is an example:; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; 5.8 The Minimization packages; As explained before various minimization packages can be used when fitting in ROOT. We have seen before how to configure the Fitter class to use different minimization packages and different minimization options. When using the Fit method the minimization package (and its options) can be selected using the static methods of the ROOT::Math::MinimizerOptions class. For example to select Minuit2 instead of Minuit for fitting an histogram do:; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Minimizer interface which can be use for finding the minimum of a multi-dimensional function. The interface is documented in the Mathematical Library Chapter.; In addition packages like Minuit or Minuit2 provide their own interfaces.; 5.9 MINUIT (Old TMInuit Version); This package was originally written in FORTRAN by Fred James and part of PACKLIB (patch D506). It has been converted to a C++ class by René Brun. The current ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:214137,Modifiability,variab,variables,214137,"izerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; In the following we will give some brief description of the minimization packages. The packages all implement the ROOT::Math::Minimizer interface which can be use for finding the minimum of a multi-dimensional function. The interface is documented in the Mathematical Library Chapter.; In addition packages like Minuit or Minuit2 provide their own interfaces.; 5.9 MINUIT (Old TMInuit Version); This package was originally written in FORTRAN by Fred James and part of PACKLIB (patch D506). It has been converted to a C++ class by René Brun. The current implementation in C++ is a straightforward conversion of the original FORTRAN version. The main changes are:. The variables in the various Minuit labeled common blocks have been changed to the TMinuit class data members; The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the TMinuit constructor with the maximum number of parameters; The include file Minuit.h has been commented as much as possible using existing comments in the code or the printed documentation; The original Minuit subroutines are now member functions; Constructors and destructor have been added; Instead of passing the FCN function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function SetFCN can be used to define this pointer; The ROOT static function Printf is provided to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:214927,Modifiability,flexible,flexible,214927,"part of PACKLIB (patch D506). It has been converted to a C++ class by René Brun. The current implementation in C++ is a straightforward conversion of the original FORTRAN version. The main changes are:. The variables in the various Minuit labeled common blocks have been changed to the TMinuit class data members; The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the TMinuit constructor with the maximum number of parameters; The include file Minuit.h has been commented as much as possible using existing comments in the code or the printed documentation; The original Minuit subroutines are now member functions; Constructors and destructor have been added; Instead of passing the FCN function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function SetFCN can be used to define this pointer; The ROOT static function Printf is provided to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When calling the Minuit functions such as mncont, mnscan, or any Minuit command invoking mnplot, TMinuit::mnplot() produces a TGraph object pointed by fPlot. One can retrieve this object with TMinuit::GetPlot(). For example:. h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:215285,Modifiability,variab,variables,215285,"in the various Minuit labeled common blocks have been changed to the TMinuit class data members; The internal arrays with a maximum dimension depending on the maximum number of parameters are now data members’ arrays with a dynamic dimension such that one can fit very large problems by simply initializing the TMinuit constructor with the maximum number of parameters; The include file Minuit.h has been commented as much as possible using existing comments in the code or the printed documentation; The original Minuit subroutines are now member functions; Constructors and destructor have been added; Instead of passing the FCN function in the argument list, the addresses of this function is stored as pointer in the data members of the class. This is by far more elegant and flexible in an interactive environment. The member function SetFCN can be used to define this pointer; The ROOT static function Printf is provided to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When calling the Minuit functions such as mncont, mnscan, or any Minuit command invoking mnplot, TMinuit::mnplot() produces a TGraph object pointed by fPlot. One can retrieve this object with TMinuit::GetPlot(). For example:. h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:216090,Modifiability,variab,variable,216090,"d to replace all format statements and to print on currently defined output file; The functions SetObjectFit/GetObjectFit can be used inside the FCN function to set/get a referenced object instead of using global variables; By default fGraphicsMode is true. When calling the Minuit functions such as mncont, mnscan, or any Minuit command invoking mnplot, TMinuit::mnplot() produces a TGraph object pointed by fPlot. One can retrieve this object with TMinuit::GetPlot(). For example:. h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited Parameters; For variable parameters with limits, Minuit uses the following transformation:; Pint = arcsin(2((Pext-a)/(b-a))-1); Pext = a+((b-a)/(2))(sinPint+1); so that the internal value Pint can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:216164,Modifiability,variab,variable,216164,"s; By default fGraphicsMode is true. When calling the Minuit functions such as mncont, mnscan, or any Minuit command invoking mnplot, TMinuit::mnplot() produces a TGraph object pointed by fPlot. One can retrieve this object with TMinuit::GetPlot(). For example:. h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited Parameters; For variable parameters with limits, Minuit uses the following transformation:; Pint = arcsin(2((Pext-a)/(b-a))-1); Pext = a+((b-a)/(2))(sinPint+1); so that the internal value Pint can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:217834,Modifiability,variab,variable,217834,"erical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate.; If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits:; 5.9.3.1 Getting the Right Minimum with Limits; If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented Minuit from finding the right minimum. On",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:218330,Modifiability,variab,variable-metric,218330,"ts the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate.; If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits:; 5.9.3.1 Getting the Right Minimum with Limits; If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented Minuit from finding the right minimum. On the other hand, if one or more parameters is near its limit at the minimum, this may be because the true minimum is indeed at a limit, or it may be because the minimized has become ‘’blocked’’ at a limit. This may normally happen only if the parameter is so close to a limit (internal value at an odd multiple of \(\pm \frac{\pi}{2}\) that Minuit prints a warning to this effect when it prints the parameter v",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:222511,Modifiability,parameteriz,parameterized,222511,"unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:223809,Modifiability,parameteriz,parameterization,223809,"d parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum su",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:224087,Modifiability,parameteriz,parameterization,224087," matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quick",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:225169,Modifiability,variab,variables,225169,"not do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly scaled (not all of the same order of magnitude), and correlations are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:226540,Modifiability,plug-in,plug-ins,226540,"quivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values \(F_{i}\) are fitted with theoretical functions \(f_{i}(\vec{x_{i}},\vec{\theta})\), where \(\vec{x_{i}}\) are coordinates, and \(\vec{\theta}\) - vector of parameters. For better convergence Chi-square function has to be the following form; \[; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:231539,Modifiability,layers,layers,231539,"randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:234807,Modifiability,layers,layers,234807,"direction is reset to the steepest descent (estimated by using the Polak-Ribiere formula).; 5.12.3.5 Conjugate Gradients With the Fletcher-Reeves Updating Formula; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Fletcher-Reeves formula).; 5.12.3.6 The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method; It implies the computation of a NxN matrix, but seems more powerful at least for less than 300 weights. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; 5.12.4 Using the Network; Neural network are build from a set of “samples”. A sample is a set of values defining the inputs and the corresponding output that the network should ideally provide. In ROOT this is a TTree entry. The first thing to be decided is the network layout. This layout is described in a string where the layers are separated by semicolons. The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons.; In addition, input and output layer formulas can be preceded by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayer",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:234860,Modifiability,layers,layers,234860," 5.12.3.5 Conjugate Gradients With the Fletcher-Reeves Updating Formula; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Fletcher-Reeves formula).; 5.12.3.6 The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method; It implies the computation of a NxN matrix, but seems more powerful at least for less than 300 weights. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; 5.12.4 Using the Network; Neural network are build from a set of “samples”. A sample is a set of values defining the inputs and the corresponding output that the network should ideally provide. In ROOT this is a TTree entry. The first thing to be decided is the network layout. This layout is described in a string where the layers are separated by semicolons. The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons.; In addition, input and output layer formulas can be preceded by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:234948,Modifiability,layers,layers,234948,"ts are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent (estimated by using the Fletcher-Reeves formula).; 5.12.3.6 The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method; It implies the computation of a NxN matrix, but seems more powerful at least for less than 300 weights. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; 5.12.4 Using the Network; Neural network are build from a set of “samples”. A sample is a set of values defining the inputs and the corresponding output that the network should ideally provide. In ROOT this is a TTree entry. The first thing to be decided is the network layout. This layout is described in a string where the layers are separated by semicolons. The input/output layers are defined by giving the expression for each neuron, separated by comas. Hidden layers are just described by the number of neurons.; In addition, input and output layer formulas can be preceded by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in the constructor or set later with the method SetWeight() of the class TMultiLay",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241822,Modifiability,extend,extends,241822,"ial vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; This defines a line going from the point (0.2,0.2) to the point (0.8,0.9). To draw this line, you will have to write a function, say LineDraw(Line l) and call it with your object as argument:; LineDraw(firstline);; In C++, we would not do that. W",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241942,Modifiability,variab,variables,241942,"order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; This defines a line going from the point (0.2,0.2) to the point (0.8,0.9). To draw this line, you will have to write a function, say LineDraw(Line l) and call it with your object as argument:; LineDraw(firstline);; In C++, we would not do that. We would instead define a class like this:; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241962,Modifiability,extend,extended,241962,"order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline.x1 = 0.2;; firstline.y1 = 0.2;; firstline.x2 = 0.8;; firstline.y2 = 0.9;; This defines a line going from the point (0.2,0.2) to the point (0.8,0.9). To draw this line, you will have to write a function, say LineDraw(Line l) and call it with your object as argument:; LineDraw(firstline);; In C++, we would not do that. We would instead define a class like this:; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:243596,Modifiability,variab,variables,243596,",0.2) to the point (0.8,0.9). To draw this line, you will have to write a function, say LineDraw(Line l) and call it with your object as argument:; LineDraw(firstline);; In C++, we would not do that. We would instead define a class like this:; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; Here we added two functions, that we will call methods or member functions, to the TLine class. The first method is used for initializing the line objects we would build. It is called a constructor. The second one is the Draw method itself. Therefore, to build and draw a line, we have to do:; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; The first line builds the object l by calling its constructor. The second line calls the TLine::Draw() method of this object. You don’t need to pass any parameters to this method since it applies to the object l, which knows the coordinates of the line. These are internal variables x1, y1, x2, y2 that were initialized by the constructor.; 6.2 Inheritance and Data Encapsulation; We have defined a TLine class that contains everything necessary to draw a line. If we want to draw an arrow, is it so different from drawing a line? We just have to draw a triangle at one end. It would be very inefficient to define the class TArrow from scratch. Fortunately, inheritance allows a class to be defined from an existing class. We would write something like:; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; The keyword “public” will be explained later. The class TArrow now contains everything that the class TLine does, and a couple of more things, the size of the arrowhead and a function that can change it. The Draw method of TArrow will draw the head and call the draw method of TLine. We just have to write the code for drawing the head!; 6.2.1 Method Overriding; Giving the same name to a method (remember: method = member function of a c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:243668,Modifiability,Inherit,Inheritance,243668,"nd call it with your object as argument:; LineDraw(firstline);; In C++, we would not do that. We would instead define a class like this:; class TLine {; Double_t x1;; Double_t y1;; Double_t x2;; Double_t y2;; TLine(int x1, int y1, int x2, int y2);; void Draw();; }; Here we added two functions, that we will call methods or member functions, to the TLine class. The first method is used for initializing the line objects we would build. It is called a constructor. The second one is the Draw method itself. Therefore, to build and draw a line, we have to do:; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; The first line builds the object l by calling its constructor. The second line calls the TLine::Draw() method of this object. You don’t need to pass any parameters to this method since it applies to the object l, which knows the coordinates of the line. These are internal variables x1, y1, x2, y2 that were initialized by the constructor.; 6.2 Inheritance and Data Encapsulation; We have defined a TLine class that contains everything necessary to draw a line. If we want to draw an arrow, is it so different from drawing a line? We just have to draw a triangle at one end. It would be very inefficient to define the class TArrow from scratch. Fortunately, inheritance allows a class to be defined from an existing class. We would write something like:; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; The keyword “public” will be explained later. The class TArrow now contains everything that the class TLine does, and a couple of more things, the size of the arrowhead and a function that can change it. The Draw method of TArrow will draw the head and call the draw method of TLine. We just have to write the code for drawing the head!; 6.2.1 Method Overriding; Giving the same name to a method (remember: method = member function of a class) in the child class (TArrow) as in the parent (TLine) does not give any problem. This is called overr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:243981,Modifiability,inherit,inheritance,243981,"wo functions, that we will call methods or member functions, to the TLine class. The first method is used for initializing the line objects we would build. It is called a constructor. The second one is the Draw method itself. Therefore, to build and draw a line, we have to do:; TLine l(0.2,0.2,0.8,0.9);; l.Draw();; The first line builds the object l by calling its constructor. The second line calls the TLine::Draw() method of this object. You don’t need to pass any parameters to this method since it applies to the object l, which knows the coordinates of the line. These are internal variables x1, y1, x2, y2 that were initialized by the constructor.; 6.2 Inheritance and Data Encapsulation; We have defined a TLine class that contains everything necessary to draw a line. If we want to draw an arrow, is it so different from drawing a line? We just have to draw a triangle at one end. It would be very inefficient to define the class TArrow from scratch. Fortunately, inheritance allows a class to be defined from an existing class. We would write something like:; class TArrow : public TLine {; int ArrowHeadSize;; void Draw();; void SetArrowSize(int arrowsize);; }; The keyword “public” will be explained later. The class TArrow now contains everything that the class TLine does, and a couple of more things, the size of the arrowhead and a function that can change it. The Draw method of TArrow will draw the head and call the draw method of TLine. We just have to write the code for drawing the head!; 6.2.1 Method Overriding; Giving the same name to a method (remember: method = member function of a class) in the child class (TArrow) as in the parent (TLine) does not give any problem. This is called overriding a method. Draw in TArrow overrides Draw in TLine. There is no possible ambiguity since, when one calls the Draw() method; this applies to an object whose type is known. Suppose we have an object l of type TLine and an object a of type TArrow. When you want to draw the line, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:245445,Modifiability,variab,variable,245445,"l the draw method of TLine. We just have to write the code for drawing the head!; 6.2.1 Method Overriding; Giving the same name to a method (remember: method = member function of a class) in the child class (TArrow) as in the parent (TLine) does not give any problem. This is called overriding a method. Draw in TArrow overrides Draw in TLine. There is no possible ambiguity since, when one calls the Draw() method; this applies to an object whose type is known. Suppose we have an object l of type TLine and an object a of type TArrow. When you want to draw the line, you do:; l.Draw();; Draw() from TLine is called. If you do:; a.Draw();; Draw() from TArrow is called and the arrow a is drawn.; 6.2.2 Data Encapsulation; We have seen previously the keyword “public”. This keyword means that every name declared public is seen by the outside world. This is opposed to “private” that means only the class where the name was declared private could see this name. For example, suppose we declare in TArrow the variable ArrowHeadSize private.; private:; int ArrowHeadSize;; Then, only the methods (i.e. member functions) of TArrow will be able to access this variable. Nobody else will see it. Even the classes that we could derive from TArrow will not see it. On the other hand, if we declare the method Draw() as public, everybody will be able to see it and use it. You see that the character public or private does not depend of the type of argument. It can be a data member, a member function, or even a class. For example, in the case of TArrow, the base class TLine is declared as public:; class TArrow : public TLine { ...; This means that all methods of TArrow will be able to access all methods of TLine, but this will be also true for anybody in the outside world. Of course, this is true if TLine accepts the outside world to see its methods/data members. If something is declared private in TLine, nobody will see it, not even TArrow members, even if TLine is declared as a public base class",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:245593,Modifiability,variab,variable,245593," method (remember: method = member function of a class) in the child class (TArrow) as in the parent (TLine) does not give any problem. This is called overriding a method. Draw in TArrow overrides Draw in TLine. There is no possible ambiguity since, when one calls the Draw() method; this applies to an object whose type is known. Suppose we have an object l of type TLine and an object a of type TArrow. When you want to draw the line, you do:; l.Draw();; Draw() from TLine is called. If you do:; a.Draw();; Draw() from TArrow is called and the arrow a is drawn.; 6.2.2 Data Encapsulation; We have seen previously the keyword “public”. This keyword means that every name declared public is seen by the outside world. This is opposed to “private” that means only the class where the name was declared private could see this name. For example, suppose we declare in TArrow the variable ArrowHeadSize private.; private:; int ArrowHeadSize;; Then, only the methods (i.e. member functions) of TArrow will be able to access this variable. Nobody else will see it. Even the classes that we could derive from TArrow will not see it. On the other hand, if we declare the method Draw() as public, everybody will be able to see it and use it. You see that the character public or private does not depend of the type of argument. It can be a data member, a member function, or even a class. For example, in the case of TArrow, the base class TLine is declared as public:; class TArrow : public TLine { ...; This means that all methods of TArrow will be able to access all methods of TLine, but this will be also true for anybody in the outside world. Of course, this is true if TLine accepts the outside world to see its methods/data members. If something is declared private in TLine, nobody will see it, not even TArrow members, even if TLine is declared as a public base class.; What if TLine is declared “private” instead of “public” ? Well, it will behave as any other name declared private in TArrow: only",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:249853,Modifiability,variab,variable,249853,"Evaluate(Float_t x) const;; void Solve() const;; private:; Float_t fA;; Float_t fB;; Float_t fC;; };; Quad.cxx:; #include <iostream.h>; #include <math.h>; #include ""Quad.h"". Quad::Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; Let us first look how we create an object. When we create an object by:; root[] Quad my_object(1.,2.,-3.);; We are creating an object on the stack. A FORTRAN programmer may be familiar with the idea; it is not unlike a local variable in a function or subroutine. Although there are still a few old timers who do not know it, FORTRAN is under no obligation to save local variables once the function or subroutine returns unless the SAVE statement is used. If not then it is likely that FORTRAN will place them on the stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:249998,Modifiability,variab,variables,249998," #include ""Quad.h"". Quad::Quad(Float_t a, Float_t b, Float_t c) {; fA = a;; fB = b;; fC = c;; }; Quad::~Quad() {; Cout <<""deleting object with coeffts: ""<< fA << "","" << fB << "",""; << fC << endl;; }; Float_t Quad::Evaluate(Float_t x) const {; return fA*x*x + fB*x + fC;; }; void Quad::Solve() const {; Float_t temp = fB*fB - 4.*fA*fC;; if ( temp > 0. ) {; temp = sqrt( temp );; cout << ""There are two roots: "" << ( -fB - temp ) / (2.*fA); << "" and "" << ( -fB + temp ) / (2.*fA) << endl;; } else {; if ( temp == 0. ) {; cout << ""There are two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; Let us first look how we create an object. When we create an object by:; root[] Quad my_object(1.,2.,-3.);; We are creating an object on the stack. A FORTRAN programmer may be familiar with the idea; it is not unlike a local variable in a function or subroutine. Although there are still a few old timers who do not know it, FORTRAN is under no obligation to save local variables once the function or subroutine returns unless the SAVE statement is used. If not then it is likely that FORTRAN will place them on the stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:250526,Modifiability,variab,variable,250526," two equal roots: "" << -fB / (2.*fA); << endl;; } else {; cout << ""There are no roots"" << endl;; }; }; }; Let us first look how we create an object. When we create an object by:; root[] Quad my_object(1.,2.,-3.);; We are creating an object on the stack. A FORTRAN programmer may be familiar with the idea; it is not unlike a local variable in a function or subroutine. Although there are still a few old timers who do not know it, FORTRAN is under no obligation to save local variables once the function or subroutine returns unless the SAVE statement is used. If not then it is likely that FORTRAN will place them on the stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object will live until the delete operator is applied to it.; There is no FORTRAN parallel to a heap object; variables either come or go as control passes in and out of a function or subroutine, or, like a COMMON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:250664,Modifiability,variab,variable,250664,"bject. When we create an object by:; root[] Quad my_object(1.,2.,-3.);; We are creating an object on the stack. A FORTRAN programmer may be familiar with the idea; it is not unlike a local variable in a function or subroutine. Although there are still a few old timers who do not know it, FORTRAN is under no obligation to save local variables once the function or subroutine returns unless the SAVE statement is used. If not then it is likely that FORTRAN will place them on the stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object will live until the delete operator is applied to it.; There is no FORTRAN parallel to a heap object; variables either come or go as control passes in and out of a function or subroutine, or, like a COMMON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:251088,Modifiability,variab,variables,251088,"e stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object will live until the delete operator is applied to it.; There is no FORTRAN parallel to a heap object; variables either come or go as control passes in and out of a function or subroutine, or, like a COMMON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an obje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:251198,Modifiability,variab,variables,251198,"e stack and they will “pop off” when the RETURN statement is reached. To give an object more permanence it has to be placed on the heap.; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; The second line declares a pointer to Quad called my_objptr. From the syntax point of view, this is just like all the other declarations we have seen so far, i.e. this is a stack variable. The value of the pointer is set equal to; new Quad(1.,2.,-3.);; new, despite its looks, is an operator and creates an object or variable of the type that comes next, Quad in this case, on the heap. Just as with stack objects it has to be initialized by calling its constructor. The syntax requires that the argument list follows the type. This one statement has brought two items into existence, one on the heap and one on the stack. The heap object will live until the delete operator is applied to it.; There is no FORTRAN parallel to a heap object; variables either come or go as control passes in and out of a function or subroutine, or, like a COMMON block variables, live for the lifetime of the program. However, most people in HEP who use FORTRAN will have experience of a memory manager and the act of creating a bank is a good equivalent of a heap object. For those who know systems like ZEBRA, it will come as a relief to learn that objects do not move, C++ does not garbage collect, so there is never a danger that a pointer to an object becomes invalid for that reason. However, having created an object, it is the user’s responsibility to ensure that it is deleted when no longer needed, or to pass that responsibility onto to some other object. Failing to do that will result in a memory leak, one of the most common and most hard-to-find C++ bugs.; To send a message to an object via a pointer to it, you need to use the “->” operator e.g.:; root[] my_objptr->Solve();; Although we chose to call our pointer my_objptr, to emphasize that it is a pointer, heap objects are so common in an obje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:255957,Modifiability,plug-in,plug-in,255957,"ROOT again and type in the following:; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; You will see that this deletes the first object but not the second. We have also painted ourselves into a corner, as my_objptr was also on the stack. This command will fail.; root[] my_objptr->Solve();; Cling no longer knows what my_objptr is. This is a great example of a memory leak; the heap object exists but we have lost our way to access it. In general, this is not a problem. If any object will outlive the compound statement in which it was created then a more permanent pointer will point to it, which frequently is part of another heap object. See Resetting the Interpreter Environment in the chapter “Cling the C++ Interpreter”.; 7 The C++ Interpreter Cling. ROOT has a C++ interpreter called cling built in. It is used for the prompt, both C++ and Python. It also serves as a source of information to store C++ objects, and provides the back-end for ROOT’s signal/slot and plug-in mechanisms.; This chapter focuses on the parts of cling that you will encounter while interacting with ROOT.; 7.1 The ROOT Prompt; Start up a ROOT session by typing root at the system prompt.; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0]; Now we create a TLine object:; root [1] TLine l;; root [2] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:257652,Modifiability,variab,variables,257652,"root [2] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; root [3] l.SetX1(10); root [4] l.SetY1(11); root [5] l.Print(); TLine X1=10.000000 Y1=11.000000 X2=0.000000 Y2=0.000000; root [6] .g l; .g l; ROOT_prompt_0 1 (address: NA) class TLine l, size = 72; root [7] l.GetX1();; root [8] l.GetX1(); (Double_t) 1.000000e+01; Note some of the features of the ROOT prompt: - Terminating with ‘;‘ is not required, see “C++ Extensions To Ease Scripting” below. - Emacs style command line editing. - Raw interpreter commands start with a dot; .g l for instance shows the interpreter information on the global called l. - To show the result of an expression just do not type the trailing ;.; For the further examples we will “abbreviate” root [0] etc by root [].; root [] .class TLine; ===========================================================================; class TLine; SIZE: 72 FILE: TLine.h LINE: 39; Base classes: --------------------------------------------------------; 0x20 public TAttBBox2D; List of member variables --------------------------------------------------; TLine.h 42 0x28 protected: Double_t fX1; TLine.h 43 0x30 protected: Double_t fY1; TLine.h 44 0x38 protected: Double_t fX2; TLine.h 45 0x40 protected: Double_t fY2; TLine.h 50 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kLineNDC; TLine.h 51 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kVertical; TLine.h 52 0x0 public: enum TLine::<anonymous at /home/axel/build/root/trunk/obj/include/TLine.h:49:4> kHorizontal; TLine.h 94 0x0 private: static class TClass *fgIsA; List of member functions :---------------------------------------------------; filename line:size busy function type and name; (compiled) (NA):(NA) 0 public: TLine();; (compiled) (NA):(NA) 0 public: TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2);; (compiled) (NA):(NA) 0 public: TLine(const TLine &line);; (compiled) (NA):(NA) 0 public: virt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272774,Modifiability,variab,variables,272774,"e path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC looks at $TEMP, $TEMP_DIR, $TEMPDIR, $TMP, $TMPDIR, $TMP_DIRor uses /tmp (or C:/). Also, a new interface TSystem::Get/SetBuildDir is introduced to let users select an alternative ‘root’ for building of the ACLiC libraries. For filename/full/path/name/macro.C, the library is created as fBuildDir/full/path/name/macro_C.so.; 7.4.3 Dictionary Generation; You can direct what is added to the dictionary generated by ACLiC in t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272925,Modifiability,variab,variables,272925,"stem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC looks at $TEMP, $TEMP_DIR, $TEMPDIR, $TMP, $TMPDIR, $TMP_DIRor uses /tmp (or C:/). Also, a new interface TSystem::Get/SetBuildDir is introduced to let users select an alternative ‘root’ for building of the ACLiC libraries. For filename/full/path/name/macro.C, the library is created as fBuildDir/full/path/name/macro_C.so.; 7.4.3 Dictionary Generation; You can direct what is added to the dictionary generated by ACLiC in two ways. The simplest way is to add at the end of script (i.e. after the symbols have been defined) something like:; #i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:275742,Modifiability,variab,variables,275742,"ly.; See the documentation of rootcling for details how pragma can be used.; NOTE: You should not call ACLiC with a script that has a function called main().; 7.4.4 Intermediate Steps and Files; ACLiC executes two steps and a third one if needed. These are:. Calling rootcling to create a dictionary using rootcling.; Calling the compiler to build the shared library from the script.; If there are errors, it calls the compiler to build a dummy executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the classes and functions declared in the script. It also adds the classes and functions declared in included files with the same name as the script file and any of the following extensions: .h, .hh, .hpp, .hxx, .hPP, .hXX. This means that, by default, you cannot combine scripts from different files into one library by using #include statements; you will need to compile each script separately. In a future release, we plan to add the global variables declared in the script to the dictionary also. If you are curious about the specific calls, you can raise the ROOT debug level: gDebug=3 and ACLiC will print these steps. If you need to keep the intermediate files around, for example when debugging the script using gdb, use gDebug=7.; 7.4.5 Moving between Interpreter and Compiler; The best way to develop portable scripts is to make sure you can always run them with both, the interpreter and with ACLiC. To do so, do not use the Cling extensions and program around the Cling limitations. When it is not possible or desirable to program around the Cling limitations, you can use the C preprocessor symbols defined for Cling and rootcling.; The preprocessor symbol __CLING__ is defined for both ROOT and rootcling. The symbol __ROOTCLING__ (and __MAKECINT__ for backward compatibility) is only defined in rootcling.; Use !defined(__CLING__) || defined(__ROOTCLING__) to bracket code that needs to be seen by the compiler and rootcling, but wil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:276109,Modifiability,portab,portable,276109,"ipt.; If there are errors, it calls the compiler to build a dummy executable to clearly report unresolved symbols. ACLiC makes a shared library with a dictionary containing the classes and functions declared in the script. It also adds the classes and functions declared in included files with the same name as the script file and any of the following extensions: .h, .hh, .hpp, .hxx, .hPP, .hXX. This means that, by default, you cannot combine scripts from different files into one library by using #include statements; you will need to compile each script separately. In a future release, we plan to add the global variables declared in the script to the dictionary also. If you are curious about the specific calls, you can raise the ROOT debug level: gDebug=3 and ACLiC will print these steps. If you need to keep the intermediate files around, for example when debugging the script using gdb, use gDebug=7.; 7.4.5 Moving between Interpreter and Compiler; The best way to develop portable scripts is to make sure you can always run them with both, the interpreter and with ACLiC. To do so, do not use the Cling extensions and program around the Cling limitations. When it is not possible or desirable to program around the Cling limitations, you can use the C preprocessor symbols defined for Cling and rootcling.; The preprocessor symbol __CLING__ is defined for both ROOT and rootcling. The symbol __ROOTCLING__ (and __MAKECINT__ for backward compatibility) is only defined in rootcling.; Use !defined(__CLING__) || defined(__ROOTCLING__) to bracket code that needs to be seen by the compiler and rootcling, but will be invisible to the interpreter.; Use !defined(__CLING__)to bracket code that should be seen only by the compiler and not by Cling nor rootcling.For example, the following will hide the declaration and initialization of the array gArray from both Cling and rootcling.; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; Because ACLiC calls rootcling to build a dictio",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:280279,Modifiability,variab,variable,280279,"meters; float fY; //y position in centimeters; public:; TMyClass() { fX = fY = -1; }; virtual void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }; };; void TMyClass::Print() const // parent print method; {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; class TChild : public TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; To execute script4.C do:; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; As you can see, an interpreted class behaves just like a compiled class. See “Adding a Class” for ways how to add a class with a shared library and with ACLiC.; 7.6 Inspecting Objects; An object of a class inheriting from TObject can be inspected, with the Inspect() method. The TObject::Inspect method creates a window listing the current values of the objects members. For example, the next picture is of TFile.; root[] TFile f(""staff.root""); root[] f.Inspect(); You can see the pointers are in red and can be clicked on to follow the pointer to the object. If you clicked on fList, the list of objects in memory and there were none, no new ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:280920,Modifiability,inherit,inheriting,280920,"t(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; As you can see, an interpreted class behaves just like a compiled class. See “Adding a Class” for ways how to add a class with a shared library and with ACLiC.; 7.6 Inspecting Objects; An object of a class inheriting from TObject can be inspected, with the Inspect() method. The TObject::Inspect method creates a window listing the current values of the objects members. For example, the next picture is of TFile.; root[] TFile f(""staff.root""); root[] f.Inspect(); You can see the pointers are in red and can be clicked on to follow the pointer to the object. If you clicked on fList, the list of objects in memory and there were none, no new canvas would be shown. On top of the page are the navigation buttons to see the previous and next screen. ROOT object inspector of TFile. The object inspector of fKeys, the list of keys in the memory. 8 Object Ownership; An object has ownership of another object if it has permission to delete it. Usually a collection or a parent object such as a pad holds ownership. To prevent memory leaks and multiple attempts to delete an object, you need to know which objects ROOT owns and which are owned by you.; The following rules apply to the ROOT classes. Histograms, trees, and ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:295321,Modifiability,inherit,inheritance,295321,"involves as many as seven objects. When selecting a method from the context menu and that method has options, the user will be asked for numerical values or strings to fill in the option. For example, TAxis::SetTitle will prompt you for a string to use for the axis title. Context menus of different objects in a canvas. 9.2.3.2 Structure of the Context Menus; The curious reader will have noticed that each entry in the context menu corresponds to a method of the class. Look for example to the menu named TAxis::xaxis. xaxis is the name of the object and TAxis the name of its class. If we look at the list of TAxis methods, for example in https://root.cern/doc/master/classTAxis.html, we see the methods SetTimeDisplay() andUnZoom(), which appear also in the context menu.; There are several divisions in the context menu, separated by lines. The top division is a list of the class methods; the second division is a list of the parent class methods. The subsequent divisions are the methods other parent classes in case of multiple inheritance. For example, see the TPaveText::title context menu. A TPaveText inherits from TAttLine, which has the method SetLineAttributes().; 9.2.3.3 Adding Context Menus for a Class; For a method to appear in the context menu of the object it has to be marked by // *MENU* in the header file. Below is the line from TAttLine.h that adds the SetLineAttribute method to the context menu.; virtual void SetLineAttributes(); // *MENU*; Nothing else is needed, since Cling knows the classes and their methods. It takes advantage of that to create the context menu on the fly when the object is clicking on. If you click on an axis, ROOT will ask the interpreter what are the methods of the TAxis and which ones are set for being displayed in a context menu.; Now, how does the interpreter know this? Remember, when you build a class that you want to use in the ROOT environment, you use rootcling that builds the so-called stub functions and the dictionary. These fun",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:295398,Modifiability,inherit,inherits,295398,"merical values or strings to fill in the option. For example, TAxis::SetTitle will prompt you for a string to use for the axis title. Context menus of different objects in a canvas. 9.2.3.2 Structure of the Context Menus; The curious reader will have noticed that each entry in the context menu corresponds to a method of the class. Look for example to the menu named TAxis::xaxis. xaxis is the name of the object and TAxis the name of its class. If we look at the list of TAxis methods, for example in https://root.cern/doc/master/classTAxis.html, we see the methods SetTimeDisplay() andUnZoom(), which appear also in the context menu.; There are several divisions in the context menu, separated by lines. The top division is a list of the class methods; the second division is a list of the parent class methods. The subsequent divisions are the methods other parent classes in case of multiple inheritance. For example, see the TPaveText::title context menu. A TPaveText inherits from TAttLine, which has the method SetLineAttributes().; 9.2.3.3 Adding Context Menus for a Class; For a method to appear in the context menu of the object it has to be marked by // *MENU* in the header file. Below is the line from TAttLine.h that adds the SetLineAttribute method to the context menu.; virtual void SetLineAttributes(); // *MENU*; Nothing else is needed, since Cling knows the classes and their methods. It takes advantage of that to create the context menu on the fly when the object is clicking on. If you click on an axis, ROOT will ask the interpreter what are the methods of the TAxis and which ones are set for being displayed in a context menu.; Now, how does the interpreter know this? Remember, when you build a class that you want to use in the ROOT environment, you use rootcling that builds the so-called stub functions and the dictionary. These functions and the dictionary contain the knowledge of the used classes. To do this, rootcling parses all the header files. ROOT has defined s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:297225,Modifiability,variab,variable,297225,"cling that builds the so-called stub functions and the dictionary. These functions and the dictionary contain the knowledge of the used classes. To do this, rootcling parses all the header files. ROOT has defined some special syntax to inform Cling of certain things, this is done in the comments so that the code still compiles with a C++ compiler.; For example, you have a class with a Draw() method, which will display itself. You would like a context menu to appear when on clicks on the image of an object of this class. The recipe is the following:. The class has to contain the ClassDef/ClassImp macros; For each method you want to appear in the context menu, put a comment after the declaration containing *MENU* or *TOGGLE* depending on the behavior you expect. One usually uses Set methods (setters). The *TOGGLE* comment is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of variables. We indicate to the system which argument corresponds to which data mem",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:297392,Modifiability,variab,variable,297392,"his is done in the comments so that the code still compiles with a C++ compiler.; For example, you have a class with a Draw() method, which will display itself. You would like a context menu to appear when on clicks on the image of an object of this class. The recipe is the following:. The class has to contain the ClassDef/ClassImp macros; For each method you want to appear in the context menu, put a comment after the declaration containing *MENU* or *TOGGLE* depending on the behavior you expect. One usually uses Set methods (setters). The *TOGGLE* comment is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of variables. We indicate to the system which argument corresponds to which data member of the class.; 9.2.4 Executing Events when a Cursor Passes on Top of an Object; This paragraph is for class designers. When a class is designed, it is often desirable to include drawing methods for it. We will have a more extensive discussion about this, but drawi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:297424,Modifiability,variab,variable,297424,"his is done in the comments so that the code still compiles with a C++ compiler.; For example, you have a class with a Draw() method, which will display itself. You would like a context menu to appear when on clicks on the image of an object of this class. The recipe is the following:. The class has to contain the ClassDef/ClassImp macros; For each method you want to appear in the context menu, put a comment after the declaration containing *MENU* or *TOGGLE* depending on the behavior you expect. One usually uses Set methods (setters). The *TOGGLE* comment is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of variables. We indicate to the system which argument corresponds to which data member of the class.; 9.2.4 Executing Events when a Cursor Passes on Top of an Object; This paragraph is for class designers. When a class is designed, it is often desirable to include drawing methods for it. We will have a more extensive discussion about this, but drawi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:298130,Modifiability,variab,variables,298130,"t is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of variables. We indicate to the system which argument corresponds to which data member of the class.; 9.2.4 Executing Events when a Cursor Passes on Top of an Object; This paragraph is for class designers. When a class is designed, it is often desirable to include drawing methods for it. We will have a more extensive discussion about this, but drawing an object in a canvas or a pad consists in “attaching” the object to that pad. When one uses object.Draw(), the object is NOT painted at this moment. It is only attached to the active pad or canvas.; Another method should be provided for the object to be painted, the Paint() method. This is all explained in the next paragraph. As well as Draw() and Paint(), other methods may be provided by the designer of the class. When the mouse is moved or a button pressed/released, the TCanvas function named HandleInput() scans the list of objects in all it’s pads ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:301797,Modifiability,inherit,inheritance,301797,"asic treatment. We will not go into that and let the reader refer to the sources of classes like TLine or TBox. Go and look at their ExecuteEvent method! We can nevertheless give some reference to the various actions that may be performed. For example, one often wants to change the shape of the cursor when passing on top of an object. This is done with the SetCursor method:; gPad->SetCursor(cursor); The argument cursor is the type of cursor. It may be:; kBottomLeft, kBottomRight, kTopLeft,; kTopRight, kBottomSide, kLeftSide,; kTopSide, kRightSide, kMove,; kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer,; kArrowRight, kCaret, kWatch; They are defined in TVirtualX.h and again we hope the names are self-explanatory. If not, try them by designing a small class. It may derive from something already known like TLine.; Note that the ExecuteEvent() functions may in turn; invoke such functions for other objects, in case an object is drawn using other objects. You can also exploit at best the virtues of inheritance. See for example how the class TArrow (derived from TLine) use or redefine the picking functions in its base class.; The last comment is that mouse position is always given in pixel units in all these standard functions. px=0 and py=0 corresponds to the top-left corner of the canvas. Here, we have followed the standard convention in windowing systems. Note that user coordinates in a canvas (pad) have the origin at the bottom-left corner of the canvas (pad). This is all explained in the paragraph “The Coordinate Systems of a Pad”.; 9.3 Graphical Containers: Canvas and Pad. We have talked a lot about canvases, which may be seen as windows. More generally, a graphical entity that contains graphical objects is called a Pad. A Canvas is a special kind of Pad. From now on, when we say something about pads, this also applies to canvases. A pad (class TPad) is a graphical container in the sense it contains other graphical objects like histograms and arrows. It may c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:305264,Modifiability,variab,variable,305264,"lobal Pad: gPad; When an object is drawn, it is always in the so-called active pad. For every day use, it is comfortable to be able to access the active pad, whatever it is. For that purpose, there is a global pointer, called gPad. It is always pointing to the active pad. If you want to change the fill color of the active pad to blue but you do not know its name, do this.; root[] gPad->SetFillColor(38); To get the list of colors, go to the paragraph “Color and color palettes” or if you have an opened canvas, click on the View menu, selecting the Colors item.; 9.3.1.1 Finding an Object in a Pad; Now that we have a pointer to the active pad, gPad and that we know this pad contains some objects, it is sometimes interesting to access one of those objects. The method GetPrimitive() of TPad, i.e. TPad::GetPrimitive(const char* name) does exactly this. Since most of the objects that a pad contains derive from TObject, they have a name. The following statement will return a pointer to the object myobjectname and put that pointer into the variable obj. As you can see, the type of returned pointer is TObject*.; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; Even if your object is something more complicated, like a histogram TH1F, this is normal. A function cannot return more than one type. So the one chosen was the lowest common denominator to all possible classes, the class from which everything derives, TObject. How do we get the right pointer then? Simply do a cast of the function output that will transform the output (pointer) into the right type. For example if the object is a TPaveLabel:; root[] obj = (TPaveLabel*)(gPad->GetPrimitive(""myobjectname"")); (class TPaveLabel*)0x1063cba8; This works for all objects deriving from TObject. However, a question remains. An object has a name if it derives from TNamed, not from TObject. For example, an arrow (TArrow) doesn’t have a name. In that case, the “name” is the name of the class. To know the name",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:313207,Modifiability,variab,variables,313207,"subpad"",.1,.1,.5,.5); One gives the coordinates of the lower left point (0.1, 0.1) and of the upper right one (0.5, 0.5). These coordinates are in NDC. This means that they are independent of the user coordinates system, in particular if you have already drawn for example a histogram in the mother pad. The only thing left is to draw the pad:; root[] spad1->Draw(); If you want more sub-pads, you have to repeat this procedure as many times as necessary.; 9.3.4.2 Dividing a Canvas into Sub-Pads; The manual way of dividing a pad into sub-pads is sometimes very tedious. There is a way to automatically generate horizontal and vertical sub-pads inside a given pad.; root[] pad1->Divide(3,2). Dividing a pad into 6 sub-pads. Dividing a pad into 6 sub-pads. If pad1 is a pad then, it will divide the pad into 3 columns of 2 sub-pads. The generated sub-pads get names pad1_i where the index i=1 to nxm (in our case pad1_1, pad1_2…pad1_6). The names pad1_1etc… correspond to new variables in Cling, so you may use them as soon as the executed method was pad->Divide(). However, in a compiled program, one has to access these objects. Remember that a pad contains other objects and that these objects may themselves be pads. So we can use the GetPrimitive() method:; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); One question remains. In case one does an automatic divide, how one can set the default margins between pads? This is done by adding two parameters to Divide(), which are the margins in x and y:; root[] pad1->Divide(3,2,0.1,0.1); The margins are here set to 10% of the parent pad width.; 9.3.5 Updating the Pad; For performance reasons, a pad is not updated with every change. For example, changing the coordinates of the pad does not automatically redraw it. Instead, the pad has a “bit-modified” that triggers a redraw. This bit is automatically set by:. Touching the pad with the mouse - for example resizing it with the mouse.; Finishing the execution of a script.; Adding a new p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:323941,Modifiability,inherit,inherits,323941,"ributes”; 9.4.4 Markers; A marker is a point with a fancy shape! The possible markers are shown in the next figure. Markers. The marker constructor is:; TMarker(Double_t x,Double_t y,Int_t marker); The parameters x and y are the marker coordinates and marker is the marker type, shown in the previous figure. Suppose the pointer ma is a valid marker. The marker size is set via ma->SetMarkerSize(size), where size is the desired size. Note, that the marker types 1, 6 and 7 (the dots) cannot be scaled. They are always drawn with the same number of pixels. SetMarkerSize does not apply on them. To have a “scalable dot” a circle shape should be used instead, for example, the marker type 20. The default marker type is 1, if SetMarkerStyle is not specified. It is the most common one to draw scatter plots. Different marker sizes. Different marker sizes. The user interface for changing the marker color, style and size looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttMarker.; Non-symmetric symbols should be used carefully in plotting. The next two graphs show how the misleading a careless use of symbols can be. The two plots represent the same data sets but because of a bad symbol choice, the two on the top appear further apart from the next example. The use of non-symmetric markers. A TPolyMaker is defined by an array on N points in a 2D space. At each point x[i], y[i] a marker is drawn. The list of marker types is shown in the previous paragraph. The marker attributes are managed by the class TAttMarker and are described in “Graphical Objects Attributes”. The TPolyMarker constructor is:; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); Where x and y are arrays of coordinates for the n points that form the poly-marker.; 9.4.5 Curly and Wavy Lines for Feynman Diagrams; This is a peculiarity of particle physics, but we do need sometimes to draw Feynman diagrams. Our friends working in banking can",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:325233,Modifiability,inherit,inheritance,325233,"f non-symmetric markers. A TPolyMaker is defined by an array on N points in a 2D space. At each point x[i], y[i] a marker is drawn. The list of marker types is shown in the previous paragraph. The marker attributes are managed by the class TAttMarker and are described in “Graphical Objects Attributes”. The TPolyMarker constructor is:; TPolyMarker(Int_t n,Double_t *x,Double_t *y,Option_t *option); Where x and y are arrays of coordinates for the n points that form the poly-marker.; 9.4.5 Curly and Wavy Lines for Feynman Diagrams; This is a peculiarity of particle physics, but we do need sometimes to draw Feynman diagrams. Our friends working in banking can skip this part. A set of classes implements curly or wavy poly-lines typically used to draw Feynman diagrams. Amplitudes and wavelengths may be specified in the constructors, via commands or interactively from context menus. These classes are TCurlyLine and TCurlyArc. These classes make use of TPolyLine by inheritance; ExecuteEvent methods are highly inspired from the methods used in TPolyLine and TArc. The picture generated by the tutorial macro feynman.C. The TCurlyLine constructor is:; TCurlyLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; Double_t wavelength, Double_t amplitude); The coordinates (x1, y1) define the starting point, (x2, y2) - the end-point. The wavelength and the amplitude are given in percent of the pad height.; The TCurlyArc constructor is:; TCurlyArc(Double_t x1, Double_t y1, Double_t rad,; Double_t phimin, Double_t phimax,; Double_t wavelength, Double_t amplitude); The curly arc center is (x1, y1) and the radius is rad. The wavelength and the amplitude are given in percent of the line length. The parameters phimin and phimax are the starting and ending angle of the arc (given in degrees). Refer to $ROOTSYS/tutorials/graphics/feynman.C for the script that built the figure above.; 9.4.6 Text and Latex Mathematical Expressions; Text displayed in a pad may be embedded into boxes, called ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:340534,Modifiability,inherit,inherits,340534,"t xmax, Double_t ymax,; const char* funcname, Int_t ndiv=510,; Option_t* chopt, Double_t gridlength=0); In such a way, it is possible to obtain exponential evolution of the tick marks position, or even decreasing. In fact, anything you like.; 9.5.6 Orientation of Tick Marks on Axis; Tick marks are normally drawn on the positive side of the axis, however, if xmin = xmax, then negative. chopt = '+': tick marks are drawn on Positive side. (Default); chopt = '-': tick marks are drawn on the negative side.; chopt = '+-': tick marks are drawn on both sides of the axis.; chopt = ‘U': unlabeled axis, default is labeled. 9.5.7 Labels; 9.5.7.1 Position; Labels are normally drawn on side opposite to tick marks. However, chopt = '=': on Equal side. The function TAxis::CenterLabels() sets the bit kCenterLabels and it is visible from TAxis context menu. It centers the bin labels and it makes sense only when the number of bins is equal to the number of tick marks. The class responsible for drawing the axis TGaxis inherits this property.; 9.5.7.2 Orientation; Labels are normally drawn parallel to the axis. However, if xmin = xmax, then they are drawn orthogonal, and if ymin=ymax they are drawn parallel.; 9.5.7.3 Labels for Exponents; By default, an exponent of the form 10^N is used when the label values are either all very small or very large. One can disable the exponent by calling:; TAxis::SetNoExponent(kTRUE); Note that this option is implicitly selected if the number of digits to draw a label is less than the fgMaxDigits global member. If the property SetNoExponent was set in TAxis (via TAxis::SetNoExponent), the TGaxis will inherit this property. TGaxis is the class responsible for drawing the axis. The method SetNoExponent is also available from the axis context menu. Y-axis with and without exponent labels. 9.5.7.4 Number of Digits in Labels; TGaxis::fgMaxDigits is the maximum number of digits permitted for the axis labels above which the notation with 10^N is used. It must ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:341161,Modifiability,inherit,inherit,341161,"t is labeled. 9.5.7 Labels; 9.5.7.1 Position; Labels are normally drawn on side opposite to tick marks. However, chopt = '=': on Equal side. The function TAxis::CenterLabels() sets the bit kCenterLabels and it is visible from TAxis context menu. It centers the bin labels and it makes sense only when the number of bins is equal to the number of tick marks. The class responsible for drawing the axis TGaxis inherits this property.; 9.5.7.2 Orientation; Labels are normally drawn parallel to the axis. However, if xmin = xmax, then they are drawn orthogonal, and if ymin=ymax they are drawn parallel.; 9.5.7.3 Labels for Exponents; By default, an exponent of the form 10^N is used when the label values are either all very small or very large. One can disable the exponent by calling:; TAxis::SetNoExponent(kTRUE); Note that this option is implicitly selected if the number of digits to draw a label is less than the fgMaxDigits global member. If the property SetNoExponent was set in TAxis (via TAxis::SetNoExponent), the TGaxis will inherit this property. TGaxis is the class responsible for drawing the axis. The method SetNoExponent is also available from the axis context menu. Y-axis with and without exponent labels. 9.5.7.4 Number of Digits in Labels; TGaxis::fgMaxDigits is the maximum number of digits permitted for the axis labels above which the notation with 10^N is used. It must be greater than 0. By default fgMaxDigits is 5 and to change it use the TGaxis::SetMaxDigits method. For example to set fgMaxDigits to accept 6 digits and accept numbers like 900000 on an axis call:; TGaxis::SetMaxDigits(6); 9.5.7.5 Tick Mark Positions; Labels are centered on tick marks. However, if xmin = xmax, then they are right adjusted. chopt = 'R': labels are right adjusted on tick mark (default is centered); chopt = 'L': labels are left adjusted on tick mark.; chopt = 'C': labels are centered on tick mark.; chopt = 'M': In the Middle of the divisions. 9.5.7.6 Label Formatting; Blank character",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:353024,Modifiability,inherit,inherits,353024,"33);; c1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; 9.6 Graphical Objects Attributes; 9.6.1 Text Attributes; When a class contains text or derives from a text class, it needs to be able to set text attributes like font type, size, and color. To do so, the class inherits from the TAttText class (a secondary inheritance), which defines text attributes. TLatex and TText inherit from TAttText.; 9.6.1.1 Setting Text Alignment; Text alignment may be set by a method call. What is said here applies to all objects deriving from TAttText, and there are many. We will take an example that may be transposed to other types. Suppose “la” is a TLatex object. The alignment is set with:; root[] la->SetTextAlign(align); The parameter align is a short describing the alignment:; align = 10*HorizontalAlign + VerticalAlign; For horizontal alignment, the following convention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:353070,Modifiability,inherit,inheritance,353070,"33);; c1->SetGrid();. Float_t bintime = 1;; // one bin = 1 second. change it to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; 9.6 Graphical Objects Attributes; 9.6.1 Text Attributes; When a class contains text or derives from a text class, it needs to be able to set text attributes like font type, size, and color. To do so, the class inherits from the TAttText class (a secondary inheritance), which defines text attributes. TLatex and TText inherit from TAttText.; 9.6.1.1 Setting Text Alignment; Text alignment may be set by a method call. What is said here applies to all objects deriving from TAttText, and there are many. We will take an example that may be transposed to other types. Suppose “la” is a TLatex object. The alignment is set with:; root[] la->SetTextAlign(align); The parameter align is a short describing the alignment:; align = 10*HorizontalAlign + VerticalAlign; For horizontal alignment, the following convention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:353132,Modifiability,inherit,inherit,353132," to set the time scale; TH1F *ht = new TH1F(""ht"",""The ROOT seism"",10,0,10*bintime);; Float_t signal = 1000;; ht->SetMaximum(signal);; ht->SetMinimum(-signal);; ht->SetStats(0);; ht->SetLineColor(2);; ht->GetXaxis()->SetTimeDisplay(1);; ht->GetYaxis()->SetNdivisions(520);; ht->Draw();. for (Int_t i=1;i<2300;i++) {; // Build a signal : noisy damped sine; Float_t noise = gRandom->Gaus(0,120);; if (i > 700); noise += signal*sin((i-700.)*6.28/30)*exp((700.-i)/300.);; ht->SetBinContent(i,noise);; c1->Modified();; c1->Update();; gSystem->ProcessEvents();; //canvas can be edited during the loop; }; printf(""Real Time = %8.3fs,Cpu Time = %8.3fsn"",sw.RealTime(),; sw.CpuTime());; }; 9.6 Graphical Objects Attributes; 9.6.1 Text Attributes; When a class contains text or derives from a text class, it needs to be able to set text attributes like font type, size, and color. To do so, the class inherits from the TAttText class (a secondary inheritance), which defines text attributes. TLatex and TText inherit from TAttText.; 9.6.1.1 Setting Text Alignment; Text alignment may be set by a method call. What is said here applies to all objects deriving from TAttText, and there are many. We will take an example that may be transposed to other types. Suppose “la” is a TLatex object. The alignment is set with:; root[] la->SetTextAlign(align); The parameter align is a short describing the alignment:; align = 10*HorizontalAlign + VerticalAlign; For horizontal alignment, the following convention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use TAttText::SetTextColor to set the text color. The color is the color index. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:357726,Modifiability,inherit,inherits,357726,"wn fox is not here anymore""); l->SetTextFont(i*10+2);; l->Draw();; }; }; 9.6.1.5 How to use True Type Fonts; You can activate the True Type Fonts by adding the following line in your .rootrc file.; Unix.*.Root.UseTTFonts: true; You can check that you indeed use the TTF in your Root session. When the TTF is active, you get the following message at the start of a session: “Free Type Engine v1.x used to render TrueType fonts.” You can also check with the command:; gEnv->Print(); 9.6.1.6 Setting Text Size; Use TAttText::SetTextSize to set the text size.; root[] la->SetTextSize(size); The size is the text size expressed in percentage of the current pad size.; The text size in pixels will be:. If current pad is horizontal, the size in pixels = textsize * canvas_height; If current pad is vertical, the size in pixels = textsize * canvas_width. The user interface for changing the text color, size, font and alignment looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttText.; 9.6.2 Line Attributes; All classes manipulating lines have to deal with line attributes: color, style and width. This is done by using secondary inheritance of the class TAttLine. The line color may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line color is set with:; root[] li->SetLineColor(color); The argument color is a color number. The colors are described in “Color and Color Palettes”; The line style may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line style is set with:; root[] li->SetLineStyle(style); The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:357901,Modifiability,inherit,inheritance,357901,"le.; Unix.*.Root.UseTTFonts: true; You can check that you indeed use the TTF in your Root session. When the TTF is active, you get the following message at the start of a session: “Free Type Engine v1.x used to render TrueType fonts.” You can also check with the command:; gEnv->Print(); 9.6.1.6 Setting Text Size; Use TAttText::SetTextSize to set the text size.; root[] la->SetTextSize(size); The size is the text size expressed in percentage of the current pad size.; The text size in pixels will be:. If current pad is horizontal, the size in pixels = textsize * canvas_height; If current pad is vertical, the size in pixels = textsize * canvas_width. The user interface for changing the text color, size, font and alignment looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttText.; 9.6.2 Line Attributes; All classes manipulating lines have to deal with line attributes: color, style and width. This is done by using secondary inheritance of the class TAttLine. The line color may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line color is set with:; root[] li->SetLineColor(color); The argument color is a color number. The colors are described in “Color and Color Palettes”; The line style may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line style is set with:; root[] li->SetLineStyle(style); The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.; The line width may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:359228,Modifiability,inherit,inherits,359228,"oot[] li->SetLineColor(color); The argument color is a color number. The colors are described in “Color and Color Palettes”; The line style may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line style is set with:; root[] li->SetLineStyle(style); The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.; The line width may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line width is set with:; root[] li->SetLineWidth(width); The width is the width expressed in pixel units.; The user interface for changing the line color, line width and style looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttLine.; 9.6.3 Fill Attributes; Almost all graphics classes have a fill area somewhere. These classes have to deal with fill attributes. This is done by using secondary inheritance of the class TAttFill. Fill color may be set by a method call. What is said here applies to all objects deriving from TAttFill, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “h” is a TH1F (1 dim histogram) object. The histogram fill color is set with:; root[] h->SetFillColor(color); The color is a color number. The colors are described in “Color and color palettes”; Fill style may be set by a method call. What is said here applies to all objects deriving from TAttFill, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “h” is a TH1F (1 dim histogram) object. The histogram fill style is set with:; root[] h->SetFillStyle(style); The convention for s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:359418,Modifiability,inherit,inheritance,359418,"s deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line style is set with:; root[] li->SetLineStyle(style); The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot.; The line width may be set by a method call. What is said here applies to all objects deriving from TAttLine, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “li” is a TLine object. The line width is set with:; root[] li->SetLineWidth(width); The width is the width expressed in pixel units.; The user interface for changing the line color, line width and style looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttLine.; 9.6.3 Fill Attributes; Almost all graphics classes have a fill area somewhere. These classes have to deal with fill attributes. This is done by using secondary inheritance of the class TAttFill. Fill color may be set by a method call. What is said here applies to all objects deriving from TAttFill, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “h” is a TH1F (1 dim histogram) object. The histogram fill color is set with:; root[] h->SetFillColor(color); The color is a color number. The colors are described in “Color and color palettes”; Fill style may be set by a method call. What is said here applies to all objects deriving from TAttFill, and there are many (histograms, plots). We will take an example that may be transposed to other types. Suppose “h” is a TH1F (1 dim histogram) object. The histogram fill style is set with:; root[] h->SetFillStyle(style); The convention for style is: 0:hollow, 1001:solid, 2001:hatch style, 3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully transparent, 4100: fully opaque.; Fill styles >3100 and <3999 are hatches. They are defined ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:362937,Modifiability,inherit,inherits,362937,"re not shown) are shown. The color numbers specified in the basic palette, and the picture above, can be viewed by selecting the menu entry Colors in the View canvas menu. The user may define other colors. To do this, one has to build a new TColor:; TColor(Int_t color,Float_t r,Float_t g,Float_t b,const char* name); One has to give the color number and the three Red, Green, Blue values, each being defined from 0 (min) to 1(max). An optional name may be given. When built, this color is automatically added to the existing list of colors. If the color number already exists, one has to extract it from the list and redefine the RGB values. This may be done for example with:; root[] color=(TColor*)(gROOT->GetListOfColors()->At(index_color)); root[] color->SetRGB(r,g,b); Where r, g and b go from 0 to 1 and index_color is the color number you wish to change.; The user interface for changing the fill color and style looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttFill.; 9.6.4.1 Color Palette (for Histograms); Defining one color at a time may be tedious. The histogram classes (see Draw Options) use the color palette. For example, TH1::Draw(""col"") draws a 2-D histogram with cells represented by a box filled with a color CI function of the cell content. If the cell content is N, the color CI used will be the color number in colors[N]. If the maximum cell content is >ncolors, all cell contents are scaled to ncolors. The current color palette does not have a class or global object of its own. It is defined in the current style as an array of color numbers. The current palette can be changed with:; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; By default, or if ncolors <= 0, a default palette (see above) of 50 colors is defined. The colors defined in this palette are good for coloring pads, labels, and other graphic objects. If ncolors > 0 and colors = 0, the default palette is used with a maximum of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:364307,Modifiability,adapt,adapt,364307,"umber in colors[N]. If the maximum cell content is >ncolors, all cell contents are scaled to ncolors. The current color palette does not have a class or global object of its own. It is defined in the current style as an array of color numbers. The current palette can be changed with:; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; By default, or if ncolors <= 0, a default palette (see above) of 50 colors is defined. The colors defined in this palette are good for coloring pads, labels, and other graphic objects. If ncolors > 0 and colors = 0, the default palette is used with a maximum of ncolors. If ncolors == 1 && colors == 0, then a pretty palette with a spectrum Violet->Red is created. It is recommended to use this pretty palette when drawing lego(s), surfaces or contours. For example, to set the current palette to the “pretty” one, do:; root[] gStyle->SetPalette(1); A more complete example is shown below. It illustrates the definition of a custom palette. You can adapt it to suit your needs. In case you use it for contour coloring, with the current color/contour algorithm, always define two more colors than the number of contours.; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; Since ROOT 6.26, you can also define a palette based on an ASCII text file, using TColor::CreateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The inpu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:367387,Modifiability,inherit,inherit,367387,"xis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, size, and offset of axis labels can be set similarly. In addition, there is a check box for no exponent choice, and another one for setting the same decimal part for all labels. 9.7.2 TPadEditor. It provides the following user interface:; Fixed aspect ratio - can be set for pad resizing.; Edit - sets pad or canvas as editable.; Cross-hair - sets a cross hair on the pad.; TickX - set ticks along the X axis.; TickY - set ticks along the Y axis.; GridX - set a grid along the X axis.; GridY - set a grid along the Y axis.; The pad or canvas border size can be set if a sunken or a raised border mode is; selected; no border mode can be set too. 9.8 Copy and Paste; You can make a copy of a canvas using TCanvas::DrawClonePad. This method is unique to TCanvas. It clones the entire canvas to the active pad. There is a more general method TObject::DrawClone, which all objects descendent of TObject, specifically all graphic objects inherit. Below are two examples, one to show the use of DrawClonePad and the other to show the use of DrawClone.; 9.8.1 Using the GUI; In this example we will copy an entire canvas to a new one with DrawClonePad. Run the script draw2dopt.C.; root[] .x tutorials/hist/draw2dopt.C; This creates a canvas with 2D histograms. To make a copy of the canvas follow the steps:. Right-click on it to bring up the context menu; Select DrawClonePad. This copies the entire canvas and all its sub-pads to a new canvas. The copied canvas is a deep clone, and all the objects on it are copies and independent of the original objects. For instance, change the fill on one of the original histograms, and the cloned histogram retains its attributes. DrawClonePad will copy the canvas to the active pad; the target does not have to be a canvas. It can also be a pad on a canvas. Different draw options. If you want to copy and paste a graphic object from one",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:368405,Modifiability,inherit,inherited,368405,"ct, specifically all graphic objects inherit. Below are two examples, one to show the use of DrawClonePad and the other to show the use of DrawClone.; 9.8.1 Using the GUI; In this example we will copy an entire canvas to a new one with DrawClonePad. Run the script draw2dopt.C.; root[] .x tutorials/hist/draw2dopt.C; This creates a canvas with 2D histograms. To make a copy of the canvas follow the steps:. Right-click on it to bring up the context menu; Select DrawClonePad. This copies the entire canvas and all its sub-pads to a new canvas. The copied canvas is a deep clone, and all the objects on it are copies and independent of the original objects. For instance, change the fill on one of the original histograms, and the cloned histogram retains its attributes. DrawClonePad will copy the canvas to the active pad; the target does not have to be a canvas. It can also be a pad on a canvas. Different draw options. If you want to copy and paste a graphic object from one canvas or pad to another canvas or pad, you can do so with DrawClone method inherited from TObject. All graphics objects inherit the TObject::DrawClone method. In this example, we create a new canvas with one histogram from each of the canvases from the script draw2dopt.C. Start a new ROOT session and execute the script draw2dopt.C; Select a canvas displayed by the script, and create a new canvas c1 from the File menu.; Make sure that the target canvas (c1) is the active one by middle clicking on it. If you do this step right after step 2, c1 will be active.; Select the pad with the first histogram you want to copy and paste.; Right click on it to show the context menu, and select DrawClone.; Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by the script, until you have one pad from each type. If you wanted to put the same annotation on each of the sub pads in the new canvas, you could use DrawClone to do so. Here we added the date to each pad. The ste",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:368450,Modifiability,inherit,inherit,368450,"d the other to show the use of DrawClone.; 9.8.1 Using the GUI; In this example we will copy an entire canvas to a new one with DrawClonePad. Run the script draw2dopt.C.; root[] .x tutorials/hist/draw2dopt.C; This creates a canvas with 2D histograms. To make a copy of the canvas follow the steps:. Right-click on it to bring up the context menu; Select DrawClonePad. This copies the entire canvas and all its sub-pads to a new canvas. The copied canvas is a deep clone, and all the objects on it are copies and independent of the original objects. For instance, change the fill on one of the original histograms, and the cloned histogram retains its attributes. DrawClonePad will copy the canvas to the active pad; the target does not have to be a canvas. It can also be a pad on a canvas. Different draw options. If you want to copy and paste a graphic object from one canvas or pad to another canvas or pad, you can do so with DrawClone method inherited from TObject. All graphics objects inherit the TObject::DrawClone method. In this example, we create a new canvas with one histogram from each of the canvases from the script draw2dopt.C. Start a new ROOT session and execute the script draw2dopt.C; Select a canvas displayed by the script, and create a new canvas c1 from the File menu.; Make sure that the target canvas (c1) is the active one by middle clicking on it. If you do this step right after step 2, c1 will be active.; Select the pad with the first histogram you want to copy and paste.; Right click on it to show the context menu, and select DrawClone.; Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by the script, until you have one pad from each type. If you wanted to put the same annotation on each of the sub pads in the new canvas, you could use DrawClone to do so. Here we added the date to each pad. The steps to this are:. Create the label in on of the pads with the graphics editor.; Middle-click on the target pa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:371995,Modifiability,inherit,inherits,371995,"by the constructor; TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; const char *header, Option_t *option); The legend is defined with default coordinates, border size and option. The legend coordinates (NDC) in the current pad are x1, y1, x2, y2. The default text attributes for the legend are:. Alignment = 12 left adjusted and vertically centered; Angle = 0 (degrees); Color = 1 (black); Size = calculate when number of entries is known; Font = helvetica-medium-r-normal scalable font = 42, and bold = 62 for title. The title is a regular entry and supports TLatex. The default is no title (header = 0). The options are the same as for TPave; by default, they are “brand”. Once the legend box is created, one has to add the text with the AddEntry() method:; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); The parameters are:. *objis a pointer to an object having marker, line, or fill attributes (a histogram, or a graph); label is the label to be associated to the object; option:; “L” draw line associated with line attributes of obj, if obj inherits from TAttLine.; “P” draw poly-marker associated with marker attributes of obj, if obj inherits TAttMarker.; “F” draw a box with fill associated with fill attributes of obj, if obj inherits TAttFill. One may also use the other form of the method AddEntry:; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); Here name is the name of the object in the pad. Other parameters are as in the previous case. Next example shows how to create a legend:; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; Here fun1, fun2, fu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:372090,Modifiability,inherit,inherits,372090," border size and option. The legend coordinates (NDC) in the current pad are x1, y1, x2, y2. The default text attributes for the legend are:. Alignment = 12 left adjusted and vertically centered; Angle = 0 (degrees); Color = 1 (black); Size = calculate when number of entries is known; Font = helvetica-medium-r-normal scalable font = 42, and bold = 62 for title. The title is a regular entry and supports TLatex. The default is no title (header = 0). The options are the same as for TPave; by default, they are “brand”. Once the legend box is created, one has to add the text with the AddEntry() method:; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); The parameters are:. *objis a pointer to an object having marker, line, or fill attributes (a histogram, or a graph); label is the label to be associated to the object; option:; “L” draw line associated with line attributes of obj, if obj inherits from TAttLine.; “P” draw poly-marker associated with marker attributes of obj, if obj inherits TAttMarker.; “F” draw a box with fill associated with fill attributes of obj, if obj inherits TAttFill. One may also use the other form of the method AddEntry:; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); Here name is the name of the object in the pad. Other parameters are as in the previous case. Next example shows how to create a legend:; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; Here fun1, fun2, fun3 and gr are pre-existing functions and graphs. You can edit the TLegend by right clicking on it. A legend example. 9.10 The PostScript Interface; To generate a PostS",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:372184,Modifiability,inherit,inherits,372184," The default text attributes for the legend are:. Alignment = 12 left adjusted and vertically centered; Angle = 0 (degrees); Color = 1 (black); Size = calculate when number of entries is known; Font = helvetica-medium-r-normal scalable font = 42, and bold = 62 for title. The title is a regular entry and supports TLatex. The default is no title (header = 0). The options are the same as for TPave; by default, they are “brand”. Once the legend box is created, one has to add the text with the AddEntry() method:; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); The parameters are:. *objis a pointer to an object having marker, line, or fill attributes (a histogram, or a graph); label is the label to be associated to the object; option:; “L” draw line associated with line attributes of obj, if obj inherits from TAttLine.; “P” draw poly-marker associated with marker attributes of obj, if obj inherits TAttMarker.; “F” draw a box with fill associated with fill attributes of obj, if obj inherits TAttFill. One may also use the other form of the method AddEntry:; TLegendEntry* TLegend::AddEntry(const char *name,; const char *label,; Option_t *option); Here name is the name of the object in the pad. Other parameters are as in the previous case. Next example shows how to create a legend:; leg = new TLegend(0.4,0.6,0.89,0.89);; leg->AddEntry(fun1,""One Theory"",""l"");; leg->AddEntry(fun3,""Another Theory"",""f"");; leg->AddEntry(gr,""The Data"",""p"");; leg->Draw();; // oops we forgot the blue line... add it after; leg->AddEntry(fun2,; ""#sqrt{2#pi} P_{T} (#gamma) latex formula"",""f"");; // and add a header (or ""title"") for the legend; leg->SetHeader(""The Legend Title"");; leg->Draw();; Here fun1, fun2, fun3 and gr are pre-existing functions and graphs. You can edit the TLegend by right clicking on it. A legend example. 9.10 The PostScript Interface; To generate a PostScript (or encapsulated PostScript) file for a single image in a canvas, you can:. Select to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:374382,Modifiability,Portab,Portable,374382,"rmat.; Click in the canvas area, near the edges, with the right mouse button and select the Print context menu entry. This will generate a file of canvas pointed to by c1. You can select the name of the PostScript file. If the file name is xxx.ps, you will generate a PostScript file named xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript file instead. In your program (or script), you can type:. c1->Print(""xxx.ps"") // or; c1->Print(""xxx.eps""); Next example prints the picture in the pad pointed by pad1.; pad1->Print(""xxx.ps""); The TPad::Print method has a second parameter called option. Its value can be:. 0 which is the default and is the same as “ps”; “ps” a Postscript file is produced; “Portrait” a Postscript file is produced with Portrait orientation; “Landscape” a Postscript file is produced with Landscape orientation; “eps”an Encapsulated Postscript file; “Preview”an Encapsulated Postscript file with preview is produced; “gif” a Graphics Interchange Format file; “cxx” a C++ macro file is generated; “pdf”a Portable Document Format file; “xml” a eXtensible Mark-up Language file; “jpg”a Joint Photographic Experts Group file; “png” a Portable Network Graphics Format (PNG file); “xpm” a X11 Pixel Map Format; “svg” a Scalable Vector Graphics file; “tiff” a Tagged-Image File Format; “root”a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by the filename extension what format you want to save a canvas in (i.e. canvas.ps, canvas.gif, canvas.C, etc).; The size of the PostScript picture, by default, is computed to keep the aspect ratio of the picture on the screen, where the size along x is always 20 cm. You can set the size of the PostScript picture before generating the picture with a command such as:; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; The first parameter in the TPostScript constructor is the name of the file; the second one is the format o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:374509,Modifiability,Portab,Portable,374509,"rmat.; Click in the canvas area, near the edges, with the right mouse button and select the Print context menu entry. This will generate a file of canvas pointed to by c1. You can select the name of the PostScript file. If the file name is xxx.ps, you will generate a PostScript file named xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript file instead. In your program (or script), you can type:. c1->Print(""xxx.ps"") // or; c1->Print(""xxx.eps""); Next example prints the picture in the pad pointed by pad1.; pad1->Print(""xxx.ps""); The TPad::Print method has a second parameter called option. Its value can be:. 0 which is the default and is the same as “ps”; “ps” a Postscript file is produced; “Portrait” a Postscript file is produced with Portrait orientation; “Landscape” a Postscript file is produced with Landscape orientation; “eps”an Encapsulated Postscript file; “Preview”an Encapsulated Postscript file with preview is produced; “gif” a Graphics Interchange Format file; “cxx” a C++ macro file is generated; “pdf”a Portable Document Format file; “xml” a eXtensible Mark-up Language file; “jpg”a Joint Photographic Experts Group file; “png” a Portable Network Graphics Format (PNG file); “xpm” a X11 Pixel Map Format; “svg” a Scalable Vector Graphics file; “tiff” a Tagged-Image File Format; “root”a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by the filename extension what format you want to save a canvas in (i.e. canvas.ps, canvas.gif, canvas.C, etc).; The size of the PostScript picture, by default, is computed to keep the aspect ratio of the picture on the screen, where the size along x is always 20 cm. You can set the size of the PostScript picture before generating the picture with a command such as:; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; The first parameter in the TPostScript constructor is the name of the file; the second one is the format o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:381929,Modifiability,inherit,inherit,381929,"Script.; Compare to PostScript output, the PDF files are usually smaller because some parts of them can be compressed.; PDF also allows to define table of contents. This facility can be used in ROOT. The following example shows how to proceed:; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; Each character string following the keyword “Title:” makes a new entry in the table of contents.; 9.12 Create or Modify a Style; All objects that can be drawn in a pad inherit from one or more attribute classes like TAttLine, TAttFill, TAttText, TAttMarker. When objects are created, their default attributes are taken from the current style. The current style is an object of the class TStyle and can be referenced via the global variable gStyle (in TStyle.h). See the class TStyle for a complete list of the attributes that can be set in one style.; ROOT provides several styles called:. “Default” - the default style; “Plain” - the simple style (black and white); “Bold” - bolder lines; “Video” - suitable for html output or screen viewing. The “Default” style is created by:; TStyle *default = new TStyle(""Default"",""Default Style"");; The “Plain” style can be used if you want to get a “conventional” PostScript output or if you are working on a monochrome display. The following example shows how to create it.; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; pl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:382192,Modifiability,variab,variable,382192,"shows how to proceed:; {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }; Each character string following the keyword “Title:” makes a new entry in the table of contents.; 9.12 Create or Modify a Style; All objects that can be drawn in a pad inherit from one or more attribute classes like TAttLine, TAttFill, TAttText, TAttMarker. When objects are created, their default attributes are taken from the current style. The current style is an object of the class TStyle and can be referenced via the global variable gStyle (in TStyle.h). See the class TStyle for a complete list of the attributes that can be set in one style.; ROOT provides several styles called:. “Default” - the default style; “Plain” - the simple style (black and white); “Bold” - bolder lines; “Video” - suitable for html output or screen viewing. The “Default” style is created by:; TStyle *default = new TStyle(""Default"",""Default Style"");; The “Plain” style can be used if you want to get a “conventional” PostScript output or if you are working on a monochrome display. The following example shows how to create it.; TStyle *plain = new TStyle(""Plain"",; ""Plain Style(no colors/fill areas)"");; plain->SetCanvasBorderMode(0);; plain->SetPadBorderMode(0);; plain->SetPadColor(0);; plain->SetCanvasColor(0);; plain->SetTitleColor(0);; plain->SetStatColor(0);; You can set the current style by:; gROOT->SetStyle(style_name);; You can get a pointer to an existing style by:; TStyle *style = gROOT->GetStyle(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:384539,Modifiability,extend,extended,384539," is created, its attributes are taken from the current style. For example, you may have created a histogram in a previous session and saved it in a file. Meanwhile, if you have changed the style, the histogram will be drawn with the old attributes. You can force the current style attributes to be set when you read an object from a file by calling ForceStyle before reading the objects from the file.; gROOT->ForceStyle();; When you call gROOT->ForceStyle() and read an object from a ROOT file, the object’s method UseCurrentStyle is called. The attributes saved with the object are replaced by the current style attributes. You call also call myObject->UseCurrentStyle() directly. For example if you have a canvas or pad with your histogram or any other object, you can force these objects to get the attributes of the current style by:; canvas->UseCurrentStyle();; The description of the style functions should be clear from the name of the TStyle setters or getters. Some functions have an extended description, in particular:. TStyle::SetLabelFont; TStyle::SetLineStyleString: set the format of dashed lines.; TStyle::SetOptStat; TStyle::SetPalette to change the colors palette; TStyle::SetTitleOffset; TStyle::SetOptDate(Int_t optdate) to support several date formats. If optdate is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: optdate = 10*format+mode; mode = 1 the date is printed in the bottom/left corner; mode = 2 date is printed in the bottom/right corner; mode = 3 date is printed in the top/right corner; format = 0 (default) date format is like: “Wed Sep 25 17:10:35 2002”; format = 1 date format is: “2002-09-25”; format = 2 date format is: “2002-09-25 17:10:35”. 9.13 3D Viewers; ROOT provides several viewers capable of displaying 3D content:. the Pad - simple line drawing using TPad and associated projection class TView;; GL Viewer - high quality and performance viewer(See “The GL Viewer”);; X3D viewer - si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:391962,Modifiability,Config,Configure,391962,"it’ action is disabled. Note for perspective cameras:. Dollying (moving the camera backwards/forwards) and zooming are often confused, and may appear very similar.; When you dolly the camera the lens focal length does not change, hence the distortions associated with the projections are unaffected. However the movement can result in objects coming ‘through the front’ of the camera and disappearing.; When you zoom, the camera does not move - hence clipping of near objects is unaffected. However with extremely small zooms (FOV large/focal length short) noticeable distortions, causing straight lines to become curved, can be seen with objects near the camera - the ‘fisheye’ lens effect.; Generally dollying is more ‘natural’, but you may need to use both to achieve the desired perspective and eye position - particularly when you are working inside or very close to 3D objects. Configure the camera by calling the methods SetPerspectiveCamera() or SetOrthographicCamera() of TGLViewer:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; v->SetOrthoCamera(TGLViewer::kCameraOrthoXOY,; left,right,top,bottom);; ...; v->SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);; Note - you can configure any of the six cameras in the viewer at any time, but you will not see the result until the camera is made current.; 9.13.2.3 Draw Styles; The GL Viewer supports three different rendering modes, which are applied to all the objects in your scene, but not Clip Shapes and Guides (See “Clipping” and “Manipulators”). These are shown below, along with the key used to activate the style. GL Viewer draw styles. Filled Polygons Wireframe Outline Enable with ‘r’ key Enable with ‘w’ key Enable with ‘t’ key Solid polygons, with hidden surface Object edges in color, with Combination of Filled Polygons removal, color surface materials, no surface filling/hiding. and Outline styles. Solid opacity, specular reflection etc. shapes with edges. Black background. Black background. White backgro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:392282,Modifiability,config,configure,392282,"ange, hence the distortions associated with the projections are unaffected. However the movement can result in objects coming ‘through the front’ of the camera and disappearing.; When you zoom, the camera does not move - hence clipping of near objects is unaffected. However with extremely small zooms (FOV large/focal length short) noticeable distortions, causing straight lines to become curved, can be seen with objects near the camera - the ‘fisheye’ lens effect.; Generally dollying is more ‘natural’, but you may need to use both to achieve the desired perspective and eye position - particularly when you are working inside or very close to 3D objects. Configure the camera by calling the methods SetPerspectiveCamera() or SetOrthographicCamera() of TGLViewer:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; v->SetOrthoCamera(TGLViewer::kCameraOrthoXOY,; left,right,top,bottom);; ...; v->SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);; Note - you can configure any of the six cameras in the viewer at any time, but you will not see the result until the camera is made current.; 9.13.2.3 Draw Styles; The GL Viewer supports three different rendering modes, which are applied to all the objects in your scene, but not Clip Shapes and Guides (See “Clipping” and “Manipulators”). These are shown below, along with the key used to activate the style. GL Viewer draw styles. Filled Polygons Wireframe Outline Enable with ‘r’ key Enable with ‘w’ key Enable with ‘t’ key Solid polygons, with hidden surface Object edges in color, with Combination of Filled Polygons removal, color surface materials, no surface filling/hiding. and Outline styles. Solid opacity, specular reflection etc. shapes with edges. Black background. Black background. White background.; Call method TGLViewer::SetStyle with one of TGLRnrCtx::EDrawStyleflags kFill, kOutline, kWireFrame:; v->SetStyle(TGLRnrCtx::kFill);; 9.13.2.4 Lighting / Style; The GL viewer creates five diffuse lights (left, right, to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:395545,Modifiability,Config,Configure,395545,"ition, scale and rotation. See “Manipulators” section below for details on using viewer manipulators.; The clip plane is described by the standard plane equation: ax+by+cz+d=0, where the factors a, b, c, d are entered into the edit boxes, and applied using the ‘Apply’ button.; The clip box is described by its center position, entered in the ‘Center X’, ‘Center Y’ and ‘Center Z’ edit boxes, and its lengths (extents) entered in the ‘Length X’, ‘Length Y’ and ‘Length Z’ edit boxes.; This clipping is achieved using OpenGL clip plane support; as such, there are certain limitations:. Solid shapes are not capped - they appear hollow.; Only shapes, which can be described with combination of planes, can be rendered in this fashion - e.g. a clipping tube is not possible.; Each additional clipping plane requires an additional render pass - so the more active planes the more time the render will take. Set the current clip object with TGLClipSet::SetClipType; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; Configure the clip object with TGLClipSet::SetClipState; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; As with cameras, any clip can be configured at any time, but you must set the clip current to see the effect.; 9.13.2.6 Manipulators; Manipulators are GUI ‘widgets’ or controls attached to a 3D object in the viewer, allowing a direct manipulation of the object’s geometry. There are three manipulators for the three basic geometries transformations. In each case, the manipulator consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z). GL Viewer object manipulators. Activate the manipulator by moving the mouse over one of these components (which turns yellow to indicate active state). Click with left mouse and drag this active component to perform the manipulation. Toggle between the manipulator types using the ‘x’, ‘c’, ‘v’ keys while the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:395744,Modifiability,config,configured,395744,"c, d are entered into the edit boxes, and applied using the ‘Apply’ button.; The clip box is described by its center position, entered in the ‘Center X’, ‘Center Y’ and ‘Center Z’ edit boxes, and its lengths (extents) entered in the ‘Length X’, ‘Length Y’ and ‘Length Z’ edit boxes.; This clipping is achieved using OpenGL clip plane support; as such, there are certain limitations:. Solid shapes are not capped - they appear hollow.; Only shapes, which can be described with combination of planes, can be rendered in this fashion - e.g. a clipping tube is not possible.; Each additional clipping plane requires an additional render pass - so the more active planes the more time the render will take. Set the current clip object with TGLClipSet::SetClipType; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; Configure the clip object with TGLClipSet::SetClipState; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; As with cameras, any clip can be configured at any time, but you must set the clip current to see the effect.; 9.13.2.6 Manipulators; Manipulators are GUI ‘widgets’ or controls attached to a 3D object in the viewer, allowing a direct manipulation of the object’s geometry. There are three manipulators for the three basic geometries transformations. In each case, the manipulator consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z). GL Viewer object manipulators. Activate the manipulator by moving the mouse over one of these components (which turns yellow to indicate active state). Click with left mouse and drag this active component to perform the manipulation. Toggle between the manipulator types using the ‘x’, ‘c’, ‘v’ keys while the mouse cursor is above the manipulator. Note: Manipulators cannot be controlled via the API at present.; 9.13.2.7 Guides; Guides are visual aids drawn into the viewer world. Controls for these are under ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:419645,Modifiability,coupling,coupling,419645," top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the folder.; Here is an example of a folder’s path name:; //root/Event/Hits/TCP; One does not have to specify the full path name. If the partial path name is unique, it will find it; otherwise it will return the first occurrence of the path.; The first diagram shows a system without folders. The objects have pointers to each other to access each other’s data. Pointers are an efficient way to share data between classes. However, a direct pointer creates a direct coupling between classes. This design can become a very tangled web of dependencies in a system with a large number of classes. In the second diagram, a reference to the data is in the folder and the consumers refer to the folder rather than each other to access the data. The naming and search service provided by the ROOT folders hierarchy provides an alternative. It loosely couples the classes and greatly enhances I/O operations. In this way, folders separate the data from the algorithms and greatly improve the modularity of an application by minimizing the class dependencies. In addition, the folder hierarchy creates a picture of the data organization. This is useful when discussing data design issues or when learning the data organization. The example below illustrates this point.; 10.3 How to Use Folders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by the producer, and creating a reference to the folder by the user.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:420055,Modifiability,enhance,enhances,420055,"e consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the folder.; Here is an example of a folder’s path name:; //root/Event/Hits/TCP; One does not have to specify the full path name. If the partial path name is unique, it will find it; otherwise it will return the first occurrence of the path.; The first diagram shows a system without folders. The objects have pointers to each other to access each other’s data. Pointers are an efficient way to share data between classes. However, a direct pointer creates a direct coupling between classes. This design can become a very tangled web of dependencies in a system with a large number of classes. In the second diagram, a reference to the data is in the folder and the consumers refer to the folder rather than each other to access the data. The naming and search service provided by the ROOT folders hierarchy provides an alternative. It loosely couples the classes and greatly enhances I/O operations. In this way, folders separate the data from the algorithms and greatly improve the modularity of an application by minimizing the class dependencies. In addition, the folder hierarchy creates a picture of the data organization. This is useful when discussing data design issues or when learning the data organization. The example below illustrates this point.; 10.3 How to Use Folders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by the producer, and creating a reference to the folder by the user.; 10.3.1 Creating a Folder Hierarchy; To create a folder hierarchy you add the top folder of your hierarchy to //root. Then you add a folder to an existing folder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421750,Modifiability,config,configuration,421750,"lder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421788,Modifiability,config,configuration,421788,"lder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421820,Modifiability,Config,Configuration,421820,"lder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421842,Modifiability,config,configuration,421842,"lder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:422086,Modifiability,Config,Configuration,422086,"so added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name, or the name of the folder. If only the name of the folder is given, it will return the first instance of that name. A string-based search is time consuming. If the retrieved object is used frequently or inside a loop, you should save a pointer to the object as a class",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:422119,Modifiability,config,configuration,422119,"so added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name, or the name of the folder. If only the name of the folder is given, it will return the first instance of that name. A string-based search is time consuming. If the retrieved object is used frequently or inside a loop, you should save a pointer to the object as a class",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:423293,Modifiability,Config,Configuration,423293,"s will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name, or the name of the folder. If only the name of the folder is given, it will return the first instance of that name. A string-based search is time consuming. If the retrieved object is used frequently or inside a loop, you should save a pointer to the object as a class data member. Use the naming service only in the initialization of the consumer class. When a folder is deleted, any reference to it in the parent or other folder is deleted also.; conf=(TFolder*)gROOT->FindObjectAny(""/aliroot/Run/Configuration"");; // or ...; conf=(TFolder*)gROOT->FindObjectAny(""Configuration"");; By default, a folder does not own the object it contains. You can overwrite that with TFolder::SetOwner. Once the folder is the owner of its contents, the contents are deleted when the folder is deleted. Some ROOT objects are automatically added to the folder hierarchy. For example, the following folders exist on start up:; //root/ROOT Files with the list of open Root files; //root/Classes with the list of active classes; //root/Geometries with active geometries; //root/Canvases with the list of active canvases; //root/Styles with the list of graphics styles; //root/Colors with the list of active colors; For example, if a file myFile.root is added to the list of files, one can retrieve a pointer to the corresponding TFile object with a statement like:; TFile *myFile = (TFile*)gROOT->FindObjectAny(; ""/ROOTFiles/myFile.root"");; //or...; TFile *myFile = (TFile*)gROOT->FindObjectAny(""myFile.roo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:423359,Modifiability,Config,Configuration,423359,"in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc->Add(array);; 10.3.3 Reading Data from a Folder (Consumer); One can search for a folder or an object in a folder using the TROOT::FindObjectAny method. It analyzes the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name. With FindObjectAny, you can give the full path name, or the name of the folder. If only the name of the folder is given, it will return the first instance of that name. A string-based search is time consuming. If the retrieved object is used frequently or inside a loop, you should save a pointer to the object as a class data member. Use the naming service only in the initialization of the consumer class. When a folder is deleted, any reference to it in the parent or other folder is deleted also.; conf=(TFolder*)gROOT->FindObjectAny(""/aliroot/Run/Configuration"");; // or ...; conf=(TFolder*)gROOT->FindObjectAny(""Configuration"");; By default, a folder does not own the object it contains. You can overwrite that with TFolder::SetOwner. Once the folder is the owner of its contents, the contents are deleted when the folder is deleted. Some ROOT objects are automatically added to the folder hierarchy. For example, the following folders exist on start up:; //root/ROOT Files with the list of open Root files; //root/Classes with the list of active classes; //root/Geometries with active geometries; //root/Canvases with the list of active canvases; //root/Styles with the list of graphics styles; //root/Colors with the list of active colors; For example, if a file myFile.root is added to the list of files, one can retrieve a pointer to the corresponding TFile object with a statement like:; TFile *myFile = (TFile*)gROOT->FindObjectAny(; ""/ROOTFiles/myFile.root"");; //or...; TFile *myFile = (TFile*)gROOT->FindObjectAny(""myFile.root"");; 10.4 Tasks; Tasks can be organized into a hierarchy and displayed in the browser. The TTask",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:433817,Modifiability,variab,variable,433817,"a record. 13 -> 16 [13->20]; fEND; Pointer to first free word at the EOF. 17 -> 20 [21->28]; fSeekFree; Pointer to FREE data record. 21 -> 24 [29->32]; fNbytesFree; Number of bytes in FREE data record. 25 -> 28 [33->36]; nfree; Number of free data records. 29 -> 32 [37->40]; fNbytesName; Number of bytes in TNamed at creation time. 33 -> 33 [41->41]; fUnits; Number of bytes for file pointers. 34 -> 37 [42->45]; fCompress; Zip compression level. 38 -> 41 [46->53]; fSeekInfo; Pointer to TStreamerInfo record. 42 -> 45 [54->57]; fNBytesInfo; Number of bytes in TStreamerInfo record. 46 -> 63 [58->75]; fCompress; Universal Unique ID. The first four bytes of the file header contain the string “root” which identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:434313,Modifiability,variab,variable,434313,"; Zip compression level. 38 -> 41 [46->53]; fSeekInfo; Pointer to TStreamerInfo record. 42 -> 45 [54->57]; fNBytesInfo; Number of bytes in TStreamerInfo record. 46 -> 63 [58->75]; fCompress; Universal Unique ID. The first four bytes of the file header contain the string “root” which identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 bytes instead of 4 bytes (values between the brackets):. Byte; Value Name; Description. 1 -> 4; Nbytes; Length of compressed object (in bytes). 5 -> 6; Version; TKey version identifier. 7 -> 10; ObjLen; Length of uncompressed object. 11 -> 14; Datime; Date and time when object was written to file. 15 -> 16; KeyLen; Length of the key structure (in bytes). 17 -> 18; Cyc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:436403,Modifiability,inherit,inheritance,436403,"5->35]; lname; Number of bytes in the class name. 28 -> … [36->..; .] | ClassName; | Object Class Name. … -> …; | lname; | Number of bytes in the object name. … -> …; | Name; | lName bytes with the name of the object. … -> …; | lTitle; | Number of bytes in the object title. … -> …; | Title; | Title of the object. … -> …; | DATA; | Data bytes associated to the object. You see a reference to TKey. It is explained in detail in the next section.; 11.1.4 The Class Description List (StreamerInfo List); The histogram records are followed by the StreamerInfo list of class descriptions. The list contains the description of each class that has been written to file.; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; The class description is recursive, because to fully describe a class, its ancestors and object data members have to be described also. In demo.root, the class description list contains the description for:. TH1F; all classes in the TH1F inheritance tree; all classes of the object data members; all classes in the object data members’ inheritance tree. This description is implemented by the TStreamerInfo class, and is often referred to as simply StreamerInfo. You can print a file’s StreamerInfolist with the TFile::ShowStreamerInfo method. Below is an example of the output. Only the first line of each class description is shown. The demo.root example contains only TH1F objects. Here we see the recursive nature of the class description; it contains the StreamerInfoof all the classes needed to describe TH1F.; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 num",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:436501,Modifiability,inherit,inheritance,436501,"5->35]; lname; Number of bytes in the class name. 28 -> … [36->..; .] | ClassName; | Object Class Name. … -> …; | lname; | Number of bytes in the object name. … -> …; | Name; | lName bytes with the name of the object. … -> …; | lTitle; | Number of bytes in the object title. … -> …; | Title; | Title of the object. … -> …; | DATA; | Data bytes associated to the object. You see a reference to TKey. It is explained in detail in the next section.; 11.1.4 The Class Description List (StreamerInfo List); The histogram records are followed by the StreamerInfo list of class descriptions. The list contains the description of each class that has been written to file.; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; The class description is recursive, because to fully describe a class, its ancestors and object data members have to be described also. In demo.root, the class description list contains the description for:. TH1F; all classes in the TH1F inheritance tree; all classes of the object data members; all classes in the object data members’ inheritance tree. This description is implemented by the TStreamerInfo class, and is often referred to as simply StreamerInfo. You can print a file’s StreamerInfolist with the TFile::ShowStreamerInfo method. Below is an example of the output. Only the first line of each class description is shown. The demo.root example contains only TH1F objects. Here we see the recursive nature of the class description; it contains the StreamerInfoof all the classes needed to describe TH1F.; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 num",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:445439,Modifiability,variab,variable,445439,"nts to an object of class: TH1F at 4339; key: h13 points to an object of class: TH1F at 4694; key: h14 points to an object of class: TH1F at 5038; In addition to the list of keys, TFile also keeps two other lists: TFile::fFree is a TList of free blocks used to recycle freed up space in the file. ROOT tries to find the best free block. If a free block matches the size of the new object to be stored, the object is written in the free block and this free block is deleted from the list. If not, the first free block bigger than the object is used. TFile::fListHead contains a sorted list (TSortedList) of objects in memory. The diagram below illustrates the logical view of the TFile and TKey. ROOT File/Directory/Key description. 11.2.1 Viewing the Logical File Contents; TFile is a descendent of TDirectory, which means it behaves like a TDirectory. We can list the contents, print the name, and create subdirectories. In a ROOT session, you are always in a directory and the directory you are in is called the current directory and is stored in the global variable gDirectory. Let us look at a more detailed example of a ROOT file and its role as the current directory. First, we create a ROOT file by executing a sample script.; root[] .x $ROOTSYS/tutorials/hsimple.C; Now you should have hsimple.root in your directory. The file was closed by the script so we have to open it again to work with it. We open the file with the intent to update it, and list its contents.; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; It shows the two lines starting with TFile followed by four lines starting with the word “KEY”. The four keys tell us that there are four objects on disk in this file. The syntax of the listing is:; KEY: <class> <variable>;<cycle number> <title>; For example, the first ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:446323,Modifiability,variab,variable,446323,"ry you are in is called the current directory and is stored in the global variable gDirectory. Let us look at a more detailed example of a ROOT file and its role as the current directory. First, we create a ROOT file by executing a sample script.; root[] .x $ROOTSYS/tutorials/hsimple.C; Now you should have hsimple.root in your directory. The file was closed by the script so we have to open it again to work with it. We open the file with the intent to update it, and list its contents.; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; It shows the two lines starting with TFile followed by four lines starting with the word “KEY”. The four keys tell us that there are four objects on disk in this file. The syntax of the listing is:; KEY: <class> <variable>;<cycle number> <title>; For example, the first line in the list means there is an object in the file on disk, called hpx. It is of the class TH1F (one-dimensional histogram of floating numbers). The object’s title is “This is the px distribution”. If the line starts with OBJ, the object is in memory. The <class> is the name of the ROOT class (T-something). The <variable> is the name of the object. The cycle number along with the variable name uniquely identifies the object. The <title> is the string given in the constructor of the object as title. The structure of TFile. The figure shows a TFile with five objects in the top directory (kObjA;1, kObjA;2, kObjB;1, kObjC;1 and kObjD;1). ObjA is on file twice with two different cycle numbers. It also shows four objects in memory (mObjE, mObjeF, mObjM, mObjL). It also shows several subdirectories.; 11.2.2 The Current Directory; When you create a TFile object, it becomes the current directory. Therefore, the last file to be opened is always the current directory. To check yo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:446697,Modifiability,variab,variable,446697,"e was closed by the script so we have to open it again to work with it. We open the file with the intent to update it, and list its contents.; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; It shows the two lines starting with TFile followed by four lines starting with the word “KEY”. The four keys tell us that there are four objects on disk in this file. The syntax of the listing is:; KEY: <class> <variable>;<cycle number> <title>; For example, the first line in the list means there is an object in the file on disk, called hpx. It is of the class TH1F (one-dimensional histogram of floating numbers). The object’s title is “This is the px distribution”. If the line starts with OBJ, the object is in memory. The <class> is the name of the ROOT class (T-something). The <variable> is the name of the object. The cycle number along with the variable name uniquely identifies the object. The <title> is the string given in the constructor of the object as title. The structure of TFile. The figure shows a TFile with five objects in the top directory (kObjA;1, kObjA;2, kObjB;1, kObjC;1 and kObjD;1). ObjA is on file twice with two different cycle numbers. It also shows four objects in memory (mObjE, mObjeF, mObjM, mObjL). It also shows several subdirectories.; 11.2.2 The Current Directory; When you create a TFile object, it becomes the current directory. Therefore, the last file to be opened is always the current directory. To check your current directory you can type:; root[] gDirectory->pwd(); Rint:/; This means that the current directory is the ROOT session (Rint). When you create a file, and repeat the command the file becomes the current directory.; root[] TFile f1(""AFile1.root"");; root[] gDirectory->pwd(); AFile1.root:/; If you create two files, the last becomes the cu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:446766,Modifiability,variab,variable,446766,"rk with it. We open the file with the intent to update it, and list its contents.; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; It shows the two lines starting with TFile followed by four lines starting with the word “KEY”. The four keys tell us that there are four objects on disk in this file. The syntax of the listing is:; KEY: <class> <variable>;<cycle number> <title>; For example, the first line in the list means there is an object in the file on disk, called hpx. It is of the class TH1F (one-dimensional histogram of floating numbers). The object’s title is “This is the px distribution”. If the line starts with OBJ, the object is in memory. The <class> is the name of the ROOT class (T-something). The <variable> is the name of the object. The cycle number along with the variable name uniquely identifies the object. The <title> is the string given in the constructor of the object as title. The structure of TFile. The figure shows a TFile with five objects in the top directory (kObjA;1, kObjA;2, kObjB;1, kObjC;1 and kObjD;1). ObjA is on file twice with two different cycle numbers. It also shows four objects in memory (mObjE, mObjeF, mObjM, mObjL). It also shows several subdirectories.; 11.2.2 The Current Directory; When you create a TFile object, it becomes the current directory. Therefore, the last file to be opened is always the current directory. To check your current directory you can type:; root[] gDirectory->pwd(); Rint:/; This means that the current directory is the ROOT session (Rint). When you create a file, and repeat the command the file becomes the current directory.; root[] TFile f1(""AFile1.root"");; root[] gDirectory->pwd(); AFile1.root:/; If you create two files, the last becomes the current directory.; root[] TFile f2(""AFile2.root"");; root[] gD",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:450392,Modifiability,inherit,inherits,450392,"ill read it from the file. For example drawing hprof will read it from the file and create an object in memory. Here we draw the profile histogram, and then we list the contents.; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; We now see a new line that starts with OBJ. This means that an object of class TProfile, called hprof has been added in memory to this directory. This new hprof in memory is independent from the hprof on disk. If we make changes to the hprof in memory, they are not propagated to the hprof on disk. A new version of hprof will be saved once we call Write.; You may wonder why hprof is added to the objects in the current directory. hprof is of the class TProfile that inherits from TH1D, which inherits from TH1. TH1 is the basic histogram. All histograms and trees are created in the current directory (also see “Histograms and the Current Directory”). The reference to “all histograms” includes objects of any class descending directly or indirectly from TH1. Hence, our TProfile hprof is created in the current directory f.There was another side effect when we called the TH1::Draw method. ROOT printed this statement:; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; It tells us that a TCanvas was created and it named it c1. This is where ROOT is being nice, and it creates a canvas for drawing the histogram if no canvas was named in the draw command, and if no active canvas exists. The newly created canvas, however, is NOT listed in the contents of the current directory. Why is that? The canvas is not added to the current directory, because by default ONLY histograms and trees are added to the object list of the current directory. Actually, TE",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:450418,Modifiability,inherit,inherits,450418,"ill read it from the file. For example drawing hprof will read it from the file and create an object in memory. Here we draw the profile histogram, and then we list the contents.; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; We now see a new line that starts with OBJ. This means that an object of class TProfile, called hprof has been added in memory to this directory. This new hprof in memory is independent from the hprof on disk. If we make changes to the hprof in memory, they are not propagated to the hprof on disk. A new version of hprof will be saved once we call Write.; You may wonder why hprof is added to the objects in the current directory. hprof is of the class TProfile that inherits from TH1D, which inherits from TH1. TH1 is the basic histogram. All histograms and trees are created in the current directory (also see “Histograms and the Current Directory”). The reference to “all histograms” includes objects of any class descending directly or indirectly from TH1. Hence, our TProfile hprof is created in the current directory f.There was another side effect when we called the TH1::Draw method. ROOT printed this statement:; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; It tells us that a TCanvas was created and it named it c1. This is where ROOT is being nice, and it creates a canvas for drawing the histogram if no canvas was named in the draw command, and if no active canvas exists. The newly created canvas, however, is NOT listed in the contents of the current directory. Why is that? The canvas is not added to the current directory, because by default ONLY histograms and trees are added to the object list of the current directory. Actually, TE",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:452930,Modifiability,inherit,inherit,452930,"; Canvas Name=c1 Title=c1; Option=TCanvas fXlowNDC=0 fYlowNDC=0 fWNDC=1 fHNDC=1; Name= c1 Title= c1; Option=TFrame X1= -4.000000 Y1=0.000000 X2=4.000000 Y2=19.384882; OBJ: TProfile hprof Profile of pz versus px : 0; TPaveText X1=-4.900000 Y1=20.475282 X2=-0.950000 Y2=21.686837 title; TPaveStats X1=2.800000 Y1=17.446395 X2=4.800000 Y2=21.323371 stats; Lets proceed with our example and draw one more histogram, and we see one more OBJ entry.; root[] hpx->Draw(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; TFile::ls() loops over the list of objects in memory and the list of objects on disk. In both cases, it calls the ls() method of each object. The implementation of the ls method is specific to the class of the object, all of these objects are descendants of TObject and inherit the TObject::ls() implementation. The histogram classes are descendants of TNamed that in turn is a descent of TObject. In this case, TNamed::ls() is executed, and it prints the name of the class, and the name and title of the object. Each directory keeps a list of its objects in the memory. You can get this list by TDirectory::GetList(). To see the lists in memory contents you can do:; root[]f->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; Since the file f is the current directory (gDirectory), this will yield the same result:; root[] gDirectory->GetList()->ls(); OBJ: TProfile hprof Profile of pz versus px : 0; OBJ: TH1F hpx This is the px distribution : 0; 11.2.4 Saving Histograms to Disk; At this time, the objects in memory (OBJ) are identical to the objects on disk (KEY). Let’s change that by adding a fill to the hpx we have in memory.; root[] hpx->Fill(0); Now the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:457814,Modifiability,inherit,inherit,457814,"jects in the directory. You can change the directory of a histogram with the SetDirectory method.; h->SetDirectory(newDir);; If the parameter is 0, the histogram is no longer associated with a directory.; h->SetDirectory(0);; Once a histogram is removed from the directory, it will no longer be deleted when the directory is closed. It is now your responsibility to delete this histogram object once you are finished with it. To change the default that automatically adds the histogram to the current directory, you can call the static function:; TH1::AddDirectory(kFALSE);; In this case, you will need to do all the bookkeeping for all the created histograms.; 11.2.6 Saving Objects to Disk; In addition to histograms and trees, you can save any object in a ROOT file. For example to save a canvas to the ROOT file you can use either TObject::Write() or TDirectory::WriteTObject(). The example:; root[] c1->Write(); This is equivalent to:; root[] f->WriteTObject(c1); For objects that do not inherit from TObject use:; root[] f->WriteObject(ptr,""nameofobject""); Another example:; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; 11.2.7 Saving Collections to Disk; All collection classes inherit from TCollection and hence inherit the TCollection::Write() method. When you call TCollection::Write() each object in the container is written individually into its own key in the file. To write all objects into one key you can specify the name of the key and use the optionTObject::kSingleKey. For example:; root[] TLis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:458493,Modifiability,inherit,inherit,458493," to Disk; In addition to histograms and trees, you can save any object in a ROOT file. For example to save a canvas to the ROOT file you can use either TObject::Write() or TDirectory::WriteTObject(). The example:; root[] c1->Write(); This is equivalent to:; root[] f->WriteTObject(c1); For objects that do not inherit from TObject use:; root[] f->WriteObject(ptr,""nameofobject""); Another example:; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; 11.2.7 Saving Collections to Disk; All collection classes inherit from TCollection and hence inherit the TCollection::Write() method. When you call TCollection::Write() each object in the container is written individually into its own key in the file. To write all objects into one key you can specify the name of the key and use the optionTObject::kSingleKey. For example:; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; 11.2.8 A TFile Object Going Out of Scope; There is another important point to remember about TFile::Close and TFile::Write. When a variable is declared on the stack in a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:458528,Modifiability,inherit,inherit,458528," to Disk; In addition to histograms and trees, you can save any object in a ROOT file. For example to save a canvas to the ROOT file you can use either TObject::Write() or TDirectory::WriteTObject(). The example:; root[] c1->Write(); This is equivalent to:; root[] f->WriteTObject(c1); For objects that do not inherit from TObject use:; root[] f->WriteObject(ptr,""nameofobject""); Another example:; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; 11.2.7 Saving Collections to Disk; All collection classes inherit from TCollection and hence inherit the TCollection::Write() method. When you call TCollection::Write() each object in the container is written individually into its own key in the file. To write all objects into one key you can specify the name of the key and use the optionTObject::kSingleKey. For example:; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; 11.2.8 A TFile Object Going Out of Scope; There is another important point to remember about TFile::Close and TFile::Write. When a variable is declared on the stack in a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile:",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:459195,Modifiability,variab,variable,459195,"ion; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; 11.2.7 Saving Collections to Disk; All collection classes inherit from TCollection and hence inherit the TCollection::Write() method. When you call TCollection::Write() each object in the container is written individually into its own key in the file. To write all objects into one key you can specify the name of the key and use the optionTObject::kSingleKey. For example:; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; 11.2.8 A TFile Object Going Out of Scope; There is another important point to remember about TFile::Close and TFile::Write. When a variable is declared on the stack in a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile::Close is made. This will save only the file descriptor to disk. It contains the file header, the StreamerInfolist, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The TFile::Close does not make a call to Write(), which means that the objects in memory will not be saved in the file. You need to explicitly call TFile::Write() to save the object in memory to file before the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:459424,Modifiability,variab,variable,459424,"e;1 Demo ntuple; KEY: TCanvas c1;1 c1; 11.2.7 Saving Collections to Disk; All collection classes inherit from TCollection and hence inherit the TCollection::Write() method. When you call TCollection::Write() each object in the container is written individually into its own key in the file. To write all objects into one key you can specify the name of the key and use the optionTObject::kSingleKey. For example:; root[] TList * list = new TList;; root[] TNamed * n1, * n2;; root[] n1 = new TNamed(""name1"",""title1"");; root[] n2 = new TNamed(""name2"",""title2"");; root[] list->Add(n1);; root[] list->Add(n2);; root[] gFile->WriteObject(list,""list"",TObject::kSingleKey);; 11.2.8 A TFile Object Going Out of Scope; There is another important point to remember about TFile::Close and TFile::Write. When a variable is declared on the stack in a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile::Close is made. This will save only the file descriptor to disk. It contains the file header, the StreamerInfolist, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The TFile::Close does not make a call to Write(), which means that the objects in memory will not be saved in the file. You need to explicitly call TFile::Write() to save the object in memory to file before the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from D",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:460983,Modifiability,variab,variable,460983,"e the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from Disk; If you have a ROOT session running, please quit and start fresh.; We saw that multiple versions of an object with the same name could be in a ROOT file. In our example, we saved a modified histogram hpx to the file, which resulted in two hpx's uniquely identified by the cycle number: hpx;1 and hpx;2. The question is how we can retrieve the right version of hpx. When opening the file and using hpx, Cling retrieves the one with the highest cycle number. To read the hpx;1 into memory, rather than the hpx:2 we would get by default, we have to explicitly get it and assign it to a variable.; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); 11.2.10 Subdirectories and Navigation; The TDirectory class lets you organize its contents into subdirectories, and TFile being a descendent of TDirectory inherits this ability. Here is an example of a ROOT file with multiple subdirectories as seen in the ROOT browser. To add a subdirectory to a file use TDirectory::mkdir. The example below opens the file for writing and creates a subdirectory called “Wed011003”. Listing the contents of the file shows the new directory in the file and the TDirectory object in memory.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirectory Wed011003;1 Wed011003; We can change the current directory by navigating ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:461263,Modifiability,inherit,inherits,461263," f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from Disk; If you have a ROOT session running, please quit and start fresh.; We saw that multiple versions of an object with the same name could be in a ROOT file. In our example, we saved a modified histogram hpx to the file, which resulted in two hpx's uniquely identified by the cycle number: hpx;1 and hpx;2. The question is how we can retrieve the right version of hpx. When opening the file and using hpx, Cling retrieves the one with the highest cycle number. To read the hpx;1 into memory, rather than the hpx:2 we would get by default, we have to explicitly get it and assign it to a variable.; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); 11.2.10 Subdirectories and Navigation; The TDirectory class lets you organize its contents into subdirectories, and TFile being a descendent of TDirectory inherits this ability. Here is an example of a ROOT file with multiple subdirectories as seen in the ROOT browser. To add a subdirectory to a file use TDirectory::mkdir. The example below opens the file for writing and creates a subdirectory called “Wed011003”. Listing the contents of the file shows the new directory in the file and the TDirectory object in memory.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirectory Wed011003;1 Wed011003; We can change the current directory by navigating into the subdirectory, and after changing directory; we can see that gDirectory is now “Wed011003”.; root[] f->cd(""Wed011003""); root[] gDirectory->pwd(); AFile.root:/Wed011003; In addition to gDirectory we have gFile, another global that points to the current file. In our ex",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:464456,Modifiability,variab,variable,464456,"e in the top directory.; root[] TH1 *h; f->GetObject(""Wed011003/histo;1"",h); If file is written, a copy of histo will be in the top directory. This is an effective way to copy an object from one directory to another. In contrast, in the code box below, histo will be in memory in the subdirectory because we changed the current directory.; root[] f->cd(""Wed011003""); root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); Note that there is no warning if the retrieving was not successful. You need to explicitly check the value of h, and if it is null, the object could not be found. For example, if you did not give the path name the histogram cannot be found and the pointer to h is null:; root[] TH1 *h; gDirectory->GetObject(""Wed011003/histo;1"",h); root[] h; (class TH1*)0x10767de0; root[] TH1 *h; gDirectory->GetObject(""histo;1"",h); root[] h; (class TH1*)0x0; To remove a subdirectory you need to use TDirectory::Delete. There is no TDirectory::rmdir. The Delete method takes a string containing the variable name and cycle number as a parameter.; void Delete(const char *namecycle); The namecycle string has the format name;cycle. The next are some rules to remember:. name = * means all, but don’t remove the subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465552,Modifiability,variab,variable,465552,"he next are some rules to remember:. name = * means all, but don’t remove the subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465714,Modifiability,variab,variable,465714,""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inherit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466573,Modifiability,inherit,inheritance,466573,"ot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:466730,Modifiability,inherit,inheritance,466730,"a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object data members it calls their Streamer. They in turn move up their own inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:467742,Modifiability,inherit,inherits,467742,"n inheritance tree and so forth. The simple data members are written to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; The Event class is added to the dictionary by the rootcling utility. This is the rootcling statement in the $ROOTSYS/test/Makefile:; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; The EventDict.cxx file contains the automatically generated Streamerfor Event:; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; When writing an Event object, TCl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470047,Modifiability,Variab,Variable,470047,"e file, insert a “!” as the first character after the comment marks. It tells ROOT not to save that data member in a root file when saving the class. For example, in this version of Event, the fPt and fTransient data members are not persistent.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; 11.3.3 The Pointer to Objects (//->); The string “->” in the comment field of the members *fH and *fTracks instruct the automatic Streamer to assume these will point to valid objects and the Streamerof the objects can be called rather than the more expensive R__b << fH. It is important to note that no check is done on the validity of the pointer value. In particular if the pointer points, directly or indirectly, back to the current object, this will result in an infinite recursion and the abrupt end of the process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470800,Modifiability,variab,variable,470800,"particular if the pointer points, directly or indirectly, back to the current object, this will result in an infinite recursion and the abrupt end of the process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; 11.3.5 Double32_t; Math operations very often require double precision, but on saving single usually precision is sufficient. For this purpose we support the typedef Double32_t which is stored in memory as a double and on disk as a float or integer. The actual size of disk (before compression) is determined by the parameter next to the data member declaration. For example:; Double32_t m_data; //[min,max<,nbits>]; If the comment is absent or does not contain min, max, nbits, the member is saved as a float.; If min and max are present, they are saved with 32 bits precision. min and max can be explicit values or expressions of values known to Cling (e.g. pi).; If nbits is present, the member is saved as int with nbits bits pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470962,Modifiability,variab,variable,470962," process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; 11.3.5 Double32_t; Math operations very often require double precision, but on saving single usually precision is sufficient. For this purpose we support the typedef Double32_t which is stored in memory as a double and on disk as a float or integer. The actual size of disk (before compression) is determined by the parameter next to the data member declaration. For example:; Double32_t m_data; //[min,max<,nbits>]; If the comment is absent or does not contain min, max, nbits, the member is saved as a float.; If min and max are present, they are saved with 32 bits precision. min and max can be explicit values or expressions of values known to Cling (e.g. pi).; If nbits is present, the member is saved as int with nbits bits precision. For more details see the io tutorials double32.C. Compression and precision of Double32_t. 11.3.6 Prevent Splitting (//|| ); If you want to pre",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470998,Modifiability,variab,variable,470998," process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; 11.3.5 Double32_t; Math operations very often require double precision, but on saving single usually precision is sufficient. For this purpose we support the typedef Double32_t which is stored in memory as a double and on disk as a float or integer. The actual size of disk (before compression) is determined by the parameter next to the data member declaration. For example:; Double32_t m_data; //[min,max<,nbits>]; If the comment is absent or does not contain min, max, nbits, the member is saved as a float.; If min and max are present, they are saved with 32 bits precision. min and max can be explicit values or expressions of values known to Cling (e.g. pi).; If nbits is present, the member is saved as int with nbits bits precision. For more details see the io tutorials double32.C. Compression and precision of Double32_t. 11.3.6 Prevent Splitting (//|| ); If you want to pre",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:500882,Modifiability,variab,variables,500882,""" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; The variables in the rules have the following meaning:. sourceClass. The field defines the on-disk class that is the input for the rule. source. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule. The list has to be enclosed in a square bracket and be a comma-separated list of versions or version ranges. The version is an integer number, whereas the version range is one of the following:; “a-b”: a and b are integers and the expression means all the numbers between and including a and b; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:502761,Modifiability,variab,variables,502761,"; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an integer and the expression means all the version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square brackets and is a comma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expect the following variables being predeclared:. newObj. variable representing the target in-memory object, its type is that of the target object. oldObj. in normal conversion rules, an object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API con",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:502956,Modifiability,variab,variables,502956," version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square brackets and is a comma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expect the following variables being predeclared:. newObj. variable representing the target in-memory object, its type is that of the target object. oldObj. in normal conversion rules, an object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule. Objects of the TSchemaRule class represent the rules and their fields have exactly the s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:503036,Modifiability,variab,variables,503036,"e an input for this rule. The list has to be enclosed in a square brackets and is a comma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expect the following variables being predeclared:. newObj. variable representing the target in-memory object, its type is that of the target object. oldObj. in normal conversion rules, an object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule. Objects of the TSchemaRule class represent the rules and their fields have exactly the same meaning as the ones of rules specified in the dictionaries. TSchemaRuleSet objects manage the sets of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:503074,Modifiability,variab,variable,503074,"omma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expect the following variables being predeclared:. newObj. variable representing the target in-memory object, its type is that of the target object. oldObj. in normal conversion rules, an object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule. Objects of the TSchemaRule class represent the rules and their fields have exactly the same meaning as the ones of rules specified in the dictionaries. TSchemaRuleSet objects manage the sets of rules and ensure their consistency. There can be no conflicting rules in the rule se",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:503650,Modifiability,variab,variables,503650," user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expect the following variables being predeclared:. newObj. variable representing the target in-memory object, its type is that of the target object. oldObj. in normal conversion rules, an object of TVirtualObject class representing the input data, guaranteed to hold the data members declared in the source property of the rule. buffer. in raw conversion rules, an object of TBuffer class holding the data member declared in source property of the rule. names of the data members of the target object declared in the target property of the rule declared to be the appropriate type; onfile.xxx. in normal conversion rules, names of the variables of basic types declared in the source property of the rule. 11.5.6.2 The C++ API; The schema evolution C++ API consists of two classes: ROOT::TSchemaRuleSet and ROOT::TSchemaRule. Objects of the TSchemaRule class represent the rules and their fields have exactly the same meaning as the ones of rules specified in the dictionaries. TSchemaRuleSet objects manage the sets of rules and ensure their consistency. There can be no conflicting rules in the rule sets. The rule sets are owned by the TClass objects corresponding to the target classes defined in the rules and can be accessed using TClass::{Get|Adopt}SchemaRules.; 11.5.7 Manual Schema Evolution; If you have written your own Streamer as described in the section “Streamers with Special Additions”, you will have to manually add code for each version and manage the evolution of your class. When you add or remove data members, you must modify the Streamer by hand. ROOT assumes that you have increased the class version number in the ClassDef s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:516540,Modifiability,Inherit,Inheriting,516540,"ATE, UPDATE to READ. Thus the mode argument can be either “READ” or “UPDATE”. The method returns:. 0 in case the mode was successfully modified;; 1 in case the mode did not change (it was already as requested or there were wrong input arguments);; -1 in case of failure. In the last case the file cannot be used anymore. 11.7 Remotely Access to ROOT Files; ROOT files can be accessed remotely in many ways, on the base of the protocol URL. Among the most popular are XRootD (protocols ‘root://’ and ‘xrd://’) and a Web server (protocl ‘http://’ or ‘https://’).; The rootd daemon is deprecated and has been removed in version 6.16/00.; Please refer to the XRootD documentation for starting and ensuring that such a daemon is running.; Reading and writing ROOT files over the net can be done by creating a TFile object using the static method TFile::Open() object. This will instantiate the appropriate derivation of TFile to handle the request. Inheriting from the TFile class, the returned instance will have exactly the same interface and behavior of TFile. The only difference is that it reads and writes from a remote service. In the example below the file is read via a web server through the TDavixFile plug-in.; 11.7.1 A Simple Session; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); 11.8 XML Interface; A new module xml as implemented by Sergey Linev (GSI). It is an optional package that can be used to save a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT file",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:516804,Modifiability,plug-in,plug-in,516804," change (it was already as requested or there were wrong input arguments);; -1 in case of failure. In the last case the file cannot be used anymore. 11.7 Remotely Access to ROOT Files; ROOT files can be accessed remotely in many ways, on the base of the protocol URL. Among the most popular are XRootD (protocols ‘root://’ and ‘xrd://’) and a Web server (protocl ‘http://’ or ‘https://’).; The rootd daemon is deprecated and has been removed in version 6.16/00.; Please refer to the XRootD documentation for starting and ensuring that such a daemon is running.; Reading and writing ROOT files over the net can be done by creating a TFile object using the static method TFile::Open() object. This will instantiate the appropriate derivation of TFile to handle the request. Inheriting from the TFile class, the returned instance will have exactly the same interface and behavior of TFile. The only difference is that it reads and writes from a remote service. In the example below the file is read via a web server through the TDavixFile plug-in.; 11.7.1 A Simple Session; root[] TFile *f1 = TFile::Open(""local/file.root"",""update""); root[] TFile *f2 = TFile::Open(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); 11.8 XML Interface; A new module xml as implemented by Sergey Linev (GSI). It is an optional package that can be used to save a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non R",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518546,Modifiability,plug-in,plug-in,518546," have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:519698,Modifiability,enhance,enhance,519698,"le::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifically for that purpose. The TTree class is optimized to reduce disk space and enhance access speed. A TNtuple is a TTree that is limited to only hold floating-point numbers; a TTree on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.; When using a TTree, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:523629,Modifiability,variab,variables,523629,"->Branch(""Flag"",&Flag,""Flag/i"");; tree->Branch(""Age"",&Age,""Age/I"");; tree->Branch(""Service"",&Service,""Service/I"");; tree->Branch(""Children"",&Children,""Children/I"");; tree->Branch(""Grade"",&Grade,""Grade/I"");; tree->Branch(""Step"",&Step,""Step/I"");; tree->Branch(""Hrweek"",&Hrweek,""Hrweek/I"");; tree->Branch(""Cost"",&Cost,""Cost/I"");; tree->Branch(""Division"",Division,""Division/C"");; tree->Branch(""Nation"",Nation,""Nation/C"");; char line[80];; while (fgets(line,80,fp)) {; sscanf(&line[0],""%d %d %d %d %d %d %d %d %d %s %s"",; &Category,&Flag,&Age,&Service,&Children,&Grade,&Step,&Hrweek,&Cost,Division,Nation);; tree->Fill();; }; tree->Print();; tree->Write();. fclose(fp);; delete hfile;; }; The script opens the ASCII file, creates a ROOT file and a TTree. Then it creates branches with the TTree::Branch method. The first parameter of the Branch method is the branch name. The second parameter is the address from which the first leaf is to be read. Once the branches are defined, the script reads the data from the ASCII file into C variables and fills the tree. The ASCII file is closed, and the ROOT file is written to disk saving the tree. Remember, trees (and histograms) are created in the current directory, which is the file in our example. Hence a f->Write()saves the tree.; 12.3 Show an Entry with TTree::Show; An easy way to access one entry of a tree is the use the TTree::Show method. For example to look at the 10th entry in the cernstaff.root tree:; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; 12.4 Print the Tree Structure with TTree::Print; A helpful command to see the tree structure meaning the number of entries, the branches and the leaves, is TTree::Print.; root[] T->Print(); **********************************************************************; *Tree :T : staff data from ascii file *; *Entries :3354 : Total = ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:524956,Modifiability,Variab,Variable,524956,"k at the 10th entry in the cernstaff.root tree:; root[] TFile f(""cernstaff.root""); root[] T->Show(10); ======> EVENT:10; Category = 361; Flag = 15; Age = 51; Service = 29; Children = 0; Grade = 7; Step = 13; Hrweek = 40; Cost = 7599; Division = PS; Nation = FR; 12.4 Print the Tree Structure with TTree::Print; A helpful command to see the tree structure meaning the number of entries, the branches and the leaves, is TTree::Print.; root[] T->Print(); **********************************************************************; *Tree :T : staff data from ascii file *; *Entries :3354 : Total = 245417 bytes File Size = 59945*; * Tree compression factor = 2.90 *; **********************************************************************; *Br 0 :staff :Category/I:Flag:Age:Service:Children:Grade:... *; * | Cost *; *Entries :3354 : Total Size = 154237 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; 12.5 Scan a Variable the Tree with TTree::Scan; The TTree::Scan method shows all values of the list of leaves separated by a colon.; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:526387,Modifiability,variab,variables,526387," 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewer looks like for the example file cernstaff.root. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select SetTreeName and enter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enables recording of the last issued command. To draw more than one dimension you can drag and drop any leaf to the X,Y,Z boxes"". Then push the Draw button, witch is marked with the purple icon on the bottom left.; All commands can be interrupted at any time by pressing this button.; The method TTree::Refresh is called by pressing the refresh button in TTreeViewer. It redraws the current exposed expression. Calling TTree::Refresh is useful when a tree is produced by a writer process and concurrently analyzed by one or more read",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:528981,Modifiability,variab,variables,528981,"tain a list of RECORDS. A record can be produced in the following way: dragging leaves/expression on X/Y/Z; changing drawing options; clicking the RED button on the bottom when happy with the histogram; NOTE that just double clicking a leaf will not produce a record: the histogram must be produced when clicking the DRAW button on the bottom-left. The records will appear on the list of records in the bottom right of the tree viewer. Selecting a record will draw the corresponding histogram. Records can be played using the arrow buttons near to the record button. When saving the session, the list of records is being saved as well.; Records have a default name corresponding to the Z: Y: X selection, but this can be changed using SetRecordName() method from the right panel context menu. You can create a new expression by right clicking on any of theE() boxes. The expression can be dragged and dropped into any of the boxes (X, Y, Z, Cut, or Scan). To scan one or more variables, drop them into the Scan box, then double click on the box. You can also redirect the result of the scan to a file by checking the Scan box on top. When the “Rec” box is checked, the Draw and Scan commands are recorded in the history file and echoed on the command line. The “Histogram” text box contains the name of the resulting histogram. By default it is htemp. You can type any name, if the histogram does not exist it will create one. The Option text box contains the list of Draw options. See “Draw Options”. You can select the options with the Options menu. The Command box lets you enter any command that you could also enter on the command line. The vertical slider on the far left side can be used to select the minimum and maximum of an event range. The actual start and end index are shown in on the bottom in the status window.; There is an extensive help utility accessible with the Help menu. The IList and OList are to specify an input list of entry indices and a name for the output list respecti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:535669,Modifiability,variab,variables,535669,"ched to a TTree Object; The function TTree::GetUserInfo() allows adding any object defined by a user to the tree that is not depending on the entry number. For example:; tree->GetUserInfo()->Add(myruninfo);; 12.7.7 Indexing a Tree; Use TTree::BuildIndex(), to build an index table using expressions depending on the value in the leaves.; tree->BuildIndex(majorname, minorname);; The index is built in the following way:. a pass on all entries is made like in TTree::Draw(); var1 = majorname; var2 = minorname; sel = \(2^{31} \times majorname + minorname\); for each entry in the tree the sel expression is evaluated and the results array is sorted into fIndexValues. Once the index is computed, using the TTree::GetEntryWithIndex(majornumber, minornumber) one entry can be retrieved. Example:; // to create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; Note that majorname and minorname may be expressions using original tree variables e.g.: “run-90000”, “event +3*xx”. In case an expression is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they sho",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536524,Modifiability,variab,variables,536524,"56789);; Note that majorname and minorname may be expressions using original tree variables e.g.: “run-90000”, “event +3*xx”. In case an expression is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536578,Modifiability,variab,variables,536578,"56789);; Note that majorname and minorname may be expressions using original tree variables e.g.: “run-90000”, “event +3*xx”. In case an expression is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536676,Modifiability,variab,variables,536676,"ion is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as inte",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536808,Modifiability,variab,variable,536808,"d an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch""",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537247,Modifiability,variab,variables,537247,"o be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with sam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537602,Modifiability,Variab,Variables,537602,"ther, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537709,Modifiability,variab,variables,537709,"h as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separate",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537980,Modifiability,variab,variable,537980," to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:538417,Modifiability,variab,variable,538417," in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned inte",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:538519,Modifiability,variab,variables,538519," $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:538765,Modifiability,Variab,Variable,538765,"event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a by",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:538783,Modifiability,Variab,Variable,538783,"event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a by",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:539010,Modifiability,variab,variable,539010," the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address give",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:539887,Modifiability,variab,variable,539887," can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:540158,Modifiability,variab,variable,540158," becomes a float (F). This leaf list has three floats called temp, mass, and px.; ""temp:mass:px""; The symbols used for the type are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:540366,Modifiability,variab,variable,540366," are:. C: a character string terminated by the 0 character; B: an 8 bit signed integer; b: an 8 bit unsigned integer; S: a 16 bit signed integer; s: a 16 bit unsigned integer; I: a 32 bit signed integer; i: a 32 bit unsigned integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:540588,Modifiability,variab,variables,540588,"integer; L: a 64 bit signed integer; l: a 64 bit unsigned integer; G: a long signed integer, stored as 64 bit; g: a long unsigned integer, stored as 64 bit; F: a 32 bit floating point; D: a 64 bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:540757,Modifiability,variab,variable,540757,"bit floating point; O: [the letter ‘o’, not a zero] a boolean (Bool_t). The type is used for a byte count to decide how much space to allocate. The variable written is simply the block of bytes starting at the starting address given in the second parameter. It may or may not match the leaf list depending on whether or not the programmer is being careful when choosing the leaf address, name, and type.; By default, a variable will be copied with the number of bytes specified in the type descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::B",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544337,Modifiability,config,configuration,544337,"hen the split-level is 1, an object data member is assigned a branch. If the split-level is 2, the data member objects will be split also, and a split level of 3 its data members objects, will be split. As the split-level increases so does the splitting depth. The ROOT default for the split-level is 99. This means the object will be split to the maximum.; 12.10.1.1 Memory Considerations when Splitting a Branch; Splitting a branch can quickly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544510,Modifiability,variab,variables,544510,"depth. The ROOT default for the split-level is 99. This means the object will be split to the maximum.; 12.10.1.1 Memory Considerations when Splitting a Branch; Splitting a branch can quickly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data memb",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544832,Modifiability,variab,variables,544832,"re than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class Streamer function to serialize the object into the branch buffer.; If a data member is an object, the data members of this object are split into branches according to the split-level (i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:550881,Modifiability,variab,variables,550881,"el branch is created for each element of the TObjArray.; If splitlevel = 2, one top level branch is created for each array element. If one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:551142,Modifiability,variab,variables,551142,"a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:551363,Modifiability,extend,extend,551363,"ANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Exa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:551466,Modifiability,variab,variable,551466,"he collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and re",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:551507,Modifiability,variab,variable,551507,"ctions to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variable",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:551561,Modifiability,variab,variables,551561,"ctions to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variable",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552406,Modifiability,Variab,Variables,552406,"branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552522,Modifiability,variab,variables,552522,"branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A si",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552624,Modifiability,variab,variables,552624,"OOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552712,Modifiability,variab,variables,552712,"cript contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552780,Modifiability,variab,variable,552780,"cript contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552968,Modifiability,variab,variables,552968,"o study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also call",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:553458,Modifiability,Variab,Variable,553458," Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also called px.; t1.Branch(""px"",&px,""px/F"");; 12.14.1.2 Filling the Tree; First we find some random values for the variables. We assign px and py a Gaussian with mean = 0 and sigma = 1 by calling gRandom->Rannor(px,py), and calculatepz. Then we call the TTree::Fill() method. The call t1.Fill() fills all branches in the tree because we have already organized the tree into branches and told each branch where to get the value from. After this script is executed we have a ROOT file called tree1.root with a tree called t1. There is a possibility to fill branches one by one using the method TBranc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:553541,Modifiability,variab,variables,553541," Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also called px.; t1.Branch(""px"",&px,""px/F"");; 12.14.1.2 Filling the Tree; First we find some random values for the variables. We assign px and py a Gaussian with mean = 0 and sigma = 1 by calling gRandom->Rannor(px,py), and calculatepz. Then we call the TTree::Fill() method. The call t1.Fill() fills all branches in the tree because we have already organized the tree into branches and told each branch where to get the value from. After this script is executed we have a ROOT file called tree1.root with a tree called t1. There is a possibility to fill branches one by one using the method TBranc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:554077,Modifiability,variab,variables,554077,"""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; 12.14.1.1 Creating Branches with A single Variable; This is the signature of TTree::Branch to create a branch with a list of variables:; TBranch* TTree::Branch(const char* name,void* address,; const char* leaflist,; Int_t bufsize = 32000); The first parameter is the branch name. The second parameter is the address from which to read the value. The third parameter is the leaf list with the name and type of each leaf. In this example, each branch has only one leaf. In the box below, the branch is named px and has one floating point type leaf also called px.; t1.Branch(""px"",&px,""px/F"");; 12.14.1.2 Filling the Tree; First we find some random values for the variables. We assign px and py a Gaussian with mean = 0 and sigma = 1 by calling gRandom->Rannor(px,py), and calculatepz. Then we call the TTree::Fill() method. The call t1.Fill() fills all branches in the tree because we have already organized the tree into branches and told each branch where to get the value from. After this script is executed we have a ROOT file called tree1.root with a tree called t1. There is a possibility to fill branches one by one using the method TBranch::Fill(). In this case you do not need to call TTree::Fill() method. The entries can be set by TTree::SetEntries(Double_t n). Calling this method makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histog",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555464,Modifiability,variab,variables,555464,"tree called t1. There is a possibility to fill branches one by one using the method TBranch::Fill(). In this case you do not need to call TTree::Fill() method. The entries can be set by TTree::SetEntries(Double_t n). Calling this method makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Consider the example in $ROOTSYS/test/Event.h. The top-lev",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555561,Modifiability,variab,variables,555561,"e method TBranch::Fill(). In this case you do not need to call TTree::Fill() method. The entries can be set by TTree::SetEntries(Double_t n). Calling this method makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Consider the example in $ROOTSYS/test/Event.h. The top-level branch in the tree T is declared with:; Event *event = 0;; // event must",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555723,Modifiability,variab,variable,555723,"makes sense only if the number of existing entries is null.; 12.14.2 Viewing the Tree. The tree1.root file and its tree in the browser and a leaf histogram. In the right panel of the ROOT object browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Consider the example in $ROOTSYS/test/Event.h. The top-level branch in the tree T is declared with:; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:555914,Modifiability,variab,variable,555914,"ect browse are the branches: ev, px, py, pz, and random. Note that these are shown as leaves because they are “end” branches with only one leaf. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Consider the example in $ROOTSYS/test/Event.h. The top-level branch in the tree T is declared with:; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:; Option 1:; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; This is the default and recommended way to create an object of the cl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:556066,Modifiability,variab,variables,556066,"f. To histogram a leaf, we can simply double click on it in the browser. This is how the tree t1 looks in the Tree Viewer. Here we can add a cut and add other operations for histogramming the leaves. See “The Tree Viewer”. For example, we can plot a two dimensional histogram. The tree viewer. 12.14.3 Reading the Tree; The tree1r function shows how to read the tree and access each entry and each leaf. We first define the variables to hold the read values.; Float_t px, py, pz;; Then we tell the tree to populate these variables when reading an entry. We do this with the method TTree::SetBranchAddress. The first parameter is the branch name, and the second is the address of the variable where the branch data is to be placed. In this example, the branch name is px. This name was given when the tree was written (see tree1w). The second parameter is the address of the variable px.; t1->SetBranchAddress(""px"",&px);; 12.14.3.1 GetEntry; Once the branches have been given the address, a specific entry can be read into the variables with the method TTree::GetEntry(n). It reads all the branches for entry (n) and populates the given address accordingly. By default, GetEntry() reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Consider the example in $ROOTSYS/test/Event.h. The top-level branch in the tree T is declared with:; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:; Option 1:; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; This is the default and recommended way to create an object of the class Event.It will be pointed by event.; At the following entries, event will be overwritten by the new data. All internal members that are TOb",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:560255,Modifiability,variab,variable,560255,"tBranchAddress(""ev"",&ev);; // create two histograms; TH1F *hpx = new TH1F(""hpx"",""px distribution"",100,-3,3);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",30,-3,3,30,-3,3);; //read all entries and fill the histograms; Int_t nentries = (Int_t)t1->GetEntries();; for (Int_t i=0; i<nentries; i++) {; t1->GetEntry(i);; hpx->Fill(px);; hpxpy->Fill(px,py);; }; // We do not close the file. We want to keep the generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; 12.15 Example 2: A Tree with a C Structure; The executable script for this example is $ROOTSYS/tutorials/tree/tree2.C.In this example we show:. how to build branches from a C structure; how to make a branch with a fixed length array; how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:560639,Modifiability,variab,variables,560639," the file. We want to keep the generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; 12.15 Example 2: A Tree with a C Structure; The executable script for this example is $ROOTSYS/tutorials/tree/tree2.C.In this example we show:. how to build branches from a C structure; how to make a branch with a fixed length array; how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; When using Geant3, the common block is filled by Geant3 routines at each step and only the TTree::Fill method needs to be called. In this example we emulate the Geant3 step routine with the helixStep function. We also emulate the filling of the particle values. The calls to the Branch methods are ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:562785,Modifiability,variab,variable,562785,"t field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t*vect[kPZ];. vout[kX] = vect[kX] + (f1*vect[kPX] - f2*vect[kPY]);; vout[kY] = vect[kY] + (f1*vect[kPY] + f2*vect[kPX]);; vout[kZ] = vect[kZ] + (f1*vect[kPZ] + f3);; vout[kPX] = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY]);; vout[kPY] = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX]);; vout[kPZ] = vect[kPZ] + (f4*vect[kPZ] + f6);; }; 12.15.1 Writing the Tree; void tree2w() {; // write tree2 example; //create a Tree file tree2.root; TFile f(""tree2.root"",""recreate"");. //create the file, the Tree; TTree t2(""t2"",""a Tree with data from a fake Geant3"");; // declare a variable of the C structure type; Gctrak_t gstep;. // add the branches for a subset of gstep; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; t2.Branch(""destep"",&gstep.destep,""destep/F"");; t2.Branch(""pid"",&gstep.pid,""pid/I"");. //Initialize particle parameters at first point; Float_t px,py,pz,p,charge=0;; Float_t vout[7];; Float_t mass = 0.137;; Bool_t newParticle = kTRUE;; gstep.step = 0.1;; gstep.destep = 0;; gstep.nmec = 0;; gstep.pid = 0;. //transport particles; for (Int_t i=0; i<10000; i++) {; //generate a new particle if necessary (Geant3 emulation); if (newParticle) {; px = gRandom->Gaus(0,.02);; py = gRandom->Gaus(0,.02);; pz = gRandom->Gaus(0,.02);; p = TMath::Sqrt(px*px+py*py+pz*pz);; charge = 1;; if (gRandom->Rndm() < 0.5) charge = -1;; gstep.pid += 1;; gstep.vect[0] = 0;; gstep.vect[1",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:564983,Modifiability,variab,variables,564983,"ep.getot - mass;; newParticle = kFALSE;; }; // fill the Tree with current step parameters; t2.Fill();. //transport particle in magnetic field (Geant3 emulation); helixStep(gstep.step, gstep.vect, vout);; //make one step; //apply energy loss; gstep.destep = gstep.step*gRandom->Gaus(0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Gea",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:565224,Modifiability,variab,variable,565224,"0.0002,0.00001);; gstep.gekin -= gstep.destep;; gstep.getot = gstep.gekin + mass;; gstep.vect[6]= charge*TMath::Sqrt(gstep.getot*gstep.getot; - mass*mass);; gstep.vect[0] = vout[0];; gstep.vect[1] = vout[1];; gstep.vect[2] = vout[2];; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file ds",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:565438,Modifiability,Variab,Variable,565438,"; gstep.vect[3] = vout[3];; gstep.vect[4] = vout[4];; gstep.vect[5] = vout[5];; gstep.nmec = (Int_t)(5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file dstep, and then we use the TBranch::GetEntry method. Then we fill a histogram with the dstep branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle’s path using the three values in the vector. Here we us",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:565546,Modifiability,variab,variable,565546,"5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file dstep, and then we use the TBranch::GetEntry method. Then we fill a histogram with the dstep branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle’s path using the three values in the vector. Here we use the TTree::Draw method. It automatically creates a histogram and plots the 3 expressions (see Trees",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:565593,Modifiability,variab,variable,565593,"5*gRandom->Rndm());; for (Int_t l=0; l<gstep.nmec; l++) gstep.lmec[l] = l;; if (gstep.gekin < 0.001) newParticle = kTRUE;; if (TMath::Abs(gstep.vect[2]) > 30) newParticle = kTRUE;; }; //save the Tree header. The file will be automatically; // closed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file dstep, and then we use the TBranch::GetEntry method. Then we fill a histogram with the dstep branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle’s path using the three values in the vector. Here we use the TTree::Draw method. It automatically creates a histogram and plots the 3 expressions (see Trees",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:565791,Modifiability,variab,variable,565791,"osed when going out of the function scope; t2.Write();; }; 12.15.1.1 Adding a Branch with a Fixed Length Array; At first, we create a tree and create branches for a subset of variables in the C structureGctrak_t. Then we add several types of branches. The first branch reads seven floating-point values beginning at the address of 'gstep.vect'. You do not need to specify &gstep.vect, because in C and C++ the array variable holds the address of the first element.; t2.Branch(""vect"",gstep.vect,""vect[7]/F"");; t2.Branch(""getot"",&gstep.getot,""getot/F"");; t2.Branch(""gekin"",&gstep.gekin,""gekin/F"");; 12.15.1.2 Adding a Branch with a Variable Length Array; The next two branches are dependent on each other. The first holds the length of the variable length array and the second holds the variable length array. The lmec branch reads nmec number of integers beginning at the address gstep.lmec.; t2.Branch(""nmec"",&gstep.nmec,""nmec/I"");; t2.Branch(""lmec"",gstep.lmec,""lmec[nmec]/I"");; The variable nmec is a random number and is reset for each entry.; gstep.nmec = (Int_t)(5*gRandom->Rndm());; 12.15.1.3 Filling the Tree; In this emulation of Geant3, we generate and transport particles in a magnetic field and store the particle parameters at each tracking step in a ROOT tree.; 12.15.2 Analysis; In this analysis, we do not read the entire entry we only read one branch. First, we set the address for the branch to the file dstep, and then we use the TBranch::GetEntry method. Then we fill a histogram with the dstep branch entries, draw it and fit it with a Gaussian. In addition, we draw the particle’s path using the three values in the vector. Here we use the TTree::Draw method. It automatically creates a histogram and plots the 3 expressions (see Trees in Analysis). void tree2r() {. // read the Tree generated by tree2w and fill one histogram; // we are only interested by the destep branch. // note that we use ""new"" to create the TFile and TTree objects because we; // want to keep these object",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:567904,Modifiability,extend,extend,567904,")f->Get(""t2"");; static Float_t destep;; TBranch *b_destep = t2->GetBranch(""destep"");; b_destep->SetAddress(&destep);. //create one histogram; TH1F *hdestep = new TH1F(""hdestep"",""destep in Mev"",100,1e-5,3e-5);; //read only the destep branch for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; 12.16 Example 3: Adding Friends to Trees; In this example, we will show how to extend a tree with a branch from another tree with the Friends feature.; 12.16.1 Adding a Branch to an Existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:568092,Modifiability,variab,variable,568092,"or all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; 12.16 Example 3: Adding Friends to Trees; In this example, we will show how to extend a tree with a branch from another tree with the Friends feature.; 12.16.1 Adding a Branch to an Existing Tree; You may want to add a branch to an existing tree. For example, if one variable in the tree was computed with a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree wit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569248,Modifiability,extend,extend,569248,"dd a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:570099,Modifiability,variab,variables,570099,"if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:570707,Modifiability,variab,variables,570707,"ally.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entri",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:570852,Modifiability,variab,variablename,570852,"ch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, wh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:570900,Modifiability,variab,variable,570900,"ch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, wh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:571017,Modifiability,variab,variable,571017,") below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:571057,Modifiability,variab,variable,571057,") below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely the variable, you can leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable “var” in the TTree tree versus variable v1 inTTree ft1versus variablev2in **TTree**ft2`.; tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");; The picture illustrates the access of the tree and its friends with a Draw command.; When AddFriend is called, the ROOT file is automatically opened and the friend tree (ft1) header is read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:572421,Modifiability,variab,variable,572421," read into memory. The new friend (ft1) is added to the list of friends of tree. The number of entries in the friend must be equal or greater to the number of entries of the original tree. If the friend tree has fewer entries, a warning is given and the missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree.; tree.Draw(""var:ft1.var:ft2.var"");; The example code is in $ROOTSYS/tutorials/tree/tree3.C. Here is the script:; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the se",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:572673,Modifiability,variab,variables,572673,"he missing entries are not included in the histogram.; Use TTree::GetListOfFriends to retrieve the list of friends from a tree.; When the tree is written to file (TTree::Write), the friends list is saved with it. Moreover, when the tree is retrieved, the trees on the friends list are also retrieved and the friendship restored. When a tree is deleted, the elements of the friend list are also deleted. It is possible to declare a friend tree that has the same internal structure (same branches and leaves) as the original tree, and compare the same values by specifying the tree.; tree.Draw(""var:ft1.var:ft2.var"");; The example code is in $ROOTSYS/tutorials/tree/tree3.C. Here is the script:; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second root file with a different tree; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");. /",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:575323,Modifiability,inherit,inherits,575323,"3"");; // Add the second tree to the first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It contains a character array, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:575440,Modifiability,inherit,inherits,575440,");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It contains a character array, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:575530,Modifiability,inherit,inheriting,575530,". pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It contains a character array, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvert",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:575562,Modifiability,Inherit,Inherit,575562,".x tree3.C; void tree3() {; tree3w();; tree3r();; }; 12.17 Example 4: A Tree with an Event Class; This example is a simplified version of $ROOTSYS/test/MainEvent.cxx and where Event objects are saved in a tree. The full definition of Event is in $ROOTSYS/test/Event.h. To execute this macro, you will need the library $ROOTSYS/test/libEvent.so. If it does not exist you can build the test directory applications by following the instruction in the $ROOTSYS/test/README file.; In this example we will show. the difference in splitting or not splitting a branch; how to read selected branches of the tree,; how to print a selected entry. 12.17.1 The Event Class; Event is a descendent of TObject. As such it inherits the data members of TObject and its methods such as Dump() and Inspect()andWrite(). In addition, because it inherits from TObject it can be a member of a collection. To summarize, the advantages of inheriting from a TObject are:. Inherit the Write, Inspect, and Dump methods; Enables a class to be a member of a ROOT collection; Enables RTTI. Below is the list of the Event data members. It contains a character array, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassD",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:576741,Modifiability,inherit,inherit,576741,"rray, several integers, a floating-point number, and an EventHeader object. The EventHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; 12.17.2 The EventHeader Class; The EventHeader class (also defined in Event.h) does not inherit from TObject. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from TObject. In previous releases branches were restricted to objects inheriting from the TObject. However, it has always been possible to write a class not inheriting from TObject to a tree by encapsulating it in a TObject descending class as is the case in EventHeader and Event.; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; 12.17.3 The Track Class; The Track class descends from TObject since tracks are in a TClonesArray (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its TObject inheritance enables Track to be in a collection and in Event is a TClonesArray of Tracks.; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the mo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:576848,Modifiability,inherit,inherit,576848,"entHeader class is described in the following paragraph. Event also has two pointers, one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; 12.17.2 The EventHeader Class; The EventHeader class (also defined in Event.h) does not inherit from TObject. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from TObject. In previous releases branches were restricted to objects inheriting from the TObject. However, it has always been possible to write a class not inheriting from TObject to a tree by encapsulating it in a TObject descending class as is the case in EventHeader and Event.; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; 12.17.3 The Track Class; The Track class descends from TObject since tracks are in a TClonesArray (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its TObject inheritance enables Track to be in a collection and in Event is a TClonesArray of Tracks.; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass sq",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:576927,Modifiability,inherit,inheriting,576927," one to a TClonesArray of tracks and one to a histogram. The string “->” in the comment field of the members *fTracks and *fH instructs the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; 12.17.2 The EventHeader Class; The EventHeader class (also defined in Event.h) does not inherit from TObject. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from TObject. In previous releases branches were restricted to objects inheriting from the TObject. However, it has always been possible to write a class not inheriting from TObject to a tree by encapsulating it in a TObject descending class as is the case in EventHeader and Event.; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; 12.17.3 The Track Class; The Track class descends from TObject since tracks are in a TClonesArray (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its TObject inheritance enables Track to be in a collection and in Event is a TClonesArray of Tracks.; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y int",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:577014,Modifiability,inherit,inheriting,577014,"s the automatic Streamer to assume that the objects *fTracks and *fH are never null pointers and that fTracks->Streamer can be used instead of the more time consuming form R__b << fTracks.; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; 12.17.2 The EventHeader Class; The EventHeader class (also defined in Event.h) does not inherit from TObject. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from TObject. In previous releases branches were restricted to objects inheriting from the TObject. However, it has always been possible to write a class not inheriting from TObject to a tree by encapsulating it in a TObject descending class as is the case in EventHeader and Event.; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; 12.17.3 The Track Class; The Track class descends from TObject since tracks are in a TClonesArray (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its TObject inheritance enables Track to be in a collection and in Event is a TClonesArray of Tracks.; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Fl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:577489,Modifiability,inherit,inheritance,577489,"rtex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; 12.17.2 The EventHeader Class; The EventHeader class (also defined in Event.h) does not inherit from TObject. Beginning with ROOT 3.0, an object can be placed on a branch even though it does not inherit from TObject. In previous releases branches were restricted to objects inheriting from the TObject. However, it has always been possible to write a class not inheriting from TObject to a tree by encapsulating it in a TObject descending class as is the case in EventHeader and Event.; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; 12.17.3 The Track Class; The Track class descends from TObject since tracks are in a TClonesArray (i.e. a ROOT collection class) and contains a selection of basic types and an array of vertices. Its TObject inheritance enables Track to be in a collection and in Event is a TClonesArray of Tracks.; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:579293,Modifiability,variab,variable,579293,"harge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; 12.17.4 Writing the Tree; We create a simple tree with two branches both holding Event objects. One is split and the other is not. We also create a pointer to an Event object (event).; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree conten",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:583777,Modifiability,variab,variable,583777,"le 5: Import an ASCII File into a TTree; The method TTree::ReadFile can be used to automatic define the structure of the TTree and read the data from a formatted ascii file.; Long64_t TTree::ReadFile(const char *filename,; const char *branchDescriptor); Creates or simply read branches from the file named whose name is passed in 'filename'.; {; gROOT->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; If branchDescriptor is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584113,Modifiability,variab,variable,584113,"->Reset();; TFile *f = new TFile(""basic2.root"",""RECREATE"");; TH1F *h1 = new TH1F(""h1"",""x distribution"",100,-4,4);; TTree *T = new TTree(""ntuple"",""data from ascii file"");; Long64_t nlines = T->ReadFile(""basic.dat"",""x:y:z"");; printf("" found %lld pointsn"",nlines);; T->Draw(""x"",""z>2"");; T->Write();; }; If branchDescriptor is set to an empty string (the default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like: A/D:Table[2]/F:Ntracks/I:astring/C.; Otherwise branchDescriptor must be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:584616,Modifiability,config,configuration,584616,"ust be specified with the above syntax.Lines in the input file starting with “#” are ignored. A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned.; 12.19 Trees in Analysis; The methods TTree::Draw, TTree::MakeClass and TTree::MakeSelector are available for data analysis using trees. The TTree::Draw method is a powerful yet simple way to look and draw the trees contents. It enables you to plot a variable (a leaf) with just one line of code. However, the Draw method falls short once you want to look at each entry and design more sophisticated acceptance criteria for your analysis. For these cases, you can use TTree::MakeClass. It creates a class that loops over the trees entries one by one. You can then expand it to do the logic of your analysis.; The TTree::MakeSelector is the recommended method for ROOT data analysis. It is especially important for large data set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a va",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:585644,Modifiability,variab,variable,585644,"ta set in a parallel processing configuration where the analysis is distributed over several processors and you can specify which entries to send to each processor. With MakeClass the user has control over the event loop, with MakeSelectorthe tree is in control of the event loop.; 12.20 Simple Analysis Using TTree::Draw; We will use the tree in cernstaff.root that was made by the macro in $ROOTSYS/tutorials/tree/staff.C.; First, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a variable or function).; In contrast, in compiled code, you can use:; TTree *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “G",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586048,Modifiability,variab,variable,586048,"st, open the file and lists its contents.; root[] TFile f (""cernstaff.root""); root[] f.ls(); TFile** cernstaff.root; TFile* cernstaff.root; KEY: TTree T;1 staff data from ascii file; We can see the TTree“T” in the file. We will use it to experiment with the TTree::Draw method, so let’s create a pointer to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a variable or function).; In contrast, in compiled code, you can use:; TTree *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three ex",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586292,Modifiability,inherit,inherited,586292,"r to it:; root[] TTree *MyTree = T; Cling allows us to get simply the object by using it. Here we define a pointer to a TTree object and assign it the value of “T”, the TTree in the file. Cling looks for an object named “T” in the current ROOT file and returns it (this assumes that “T” has not previously been used to declare a variable or function).; In contrast, in compiled code, you can use:; TTree *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“e1:e2:e3”). A list of examples follows this introduction.; 12.20.1 Using Selection with TTree:Draw; Change the active pad to 3, and add a selection to the list of parameters of the draw command.; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cos",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586701,Modifiability,variab,variables,586701,"ee *MyTree;f.GetObject(""T"",MyTree);; To show the different Draw options, we create a canvas with four sub-pads. We will use one sub-pad for each Draw command.; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“e1:e2:e3”). A list of examples follows this introduction.; 12.20.1 Using Selection with TTree:Draw; Change the active pad to 3, and add a selection to the list of parameters of the draw command.; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); This will draw the Costvs. Age for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:586937,Modifiability,variab,variable,586937,"nvas(); root[] myCanvas->Divide(2,2); We activate the first pad with the TCanvas::cd statement:; root[] myCanvas->cd(1); We then draw the variable Cost:; root[] MyTree->Draw(""C; As you can see, the last call TTree::Draw has only one parameter. It is a string containing the leaf name. A histogram is automatically created as a result of a TTree::Draw. The style of the histogram is inherited from the TTree attributes and the current style (gStyle) is ignored. The TTree gets its attributes from the current TStyle at the time it was created. You can call the method TTree::UseCurrentStyle to change to the current style rather than the TTree style. (See gStyle; see also “Graphics and the Graphical User Interface” ); In the next segment, we activate the second pad and draw a scatter plot variables:; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); This signature still only has one parameter, but it now has two dimensions separated by a colon (""x:y""). The item to be plotted can be an expression not just a simple variable. In general, this parameter is a string that contains up to three expressions, one for each dimension, separated by a colon (“e1:e2:e3”). A list of examples follows this introduction.; 12.20.1 Using Selection with TTree:Draw; Change the active pad to 3, and add a selection to the list of parameters of the draw command.; root[] myCanvas->cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); This will draw the Costvs. Age for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:588322,Modifiability,variab,variables,588322,"cd(3); root[] MyTree->Draw(""Cost:Age"",""Nation == ""FR""""); This will draw the Costvs. Age for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the weight is not explicitly specified it is assumed to be 1.; For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2.; ""x<y && sqrt(z)>3.2""; On the other hand, this selection will add x+y to the histogram if the square root of z is larger than 3.2.; ""(x+y)*(sqrt(z)>3.2)""; The Draw method has its own parser, and it only looks in the current tree for variables. This means that any variable used in the selection must be defined in the tree. You cannot use an arbitrary global variable in the TTree::Draw method.; 12.20.2 Using TCut Objects in TTree::Draw; The TTree::Draw method also accepts TCutG objects. A TCut is a specialized string object used for TTree selections. A TCut object has a name and a title. It does not have any data members in addition to what it inherits from TNamed. It only adds a set of operators to do logical string concatenation. For example, assume:; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; then; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; Operators =, +=, +, *, !, &&, || are overloaded, here are some examples:; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); 12.20.3 Accessing the Histogram in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:588353,Modifiability,variab,variable,588353," for the entries where the nation is equal to “FR”. You can use any C++ operator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the weight is not explicitly specified it is assumed to be 1.; For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2.; ""x<y && sqrt(z)>3.2""; On the other hand, this selection will add x+y to the histogram if the square root of z is larger than 3.2.; ""(x+y)*(sqrt(z)>3.2)""; The Draw method has its own parser, and it only looks in the current tree for variables. This means that any variable used in the selection must be defined in the tree. You cannot use an arbitrary global variable in the TTree::Draw method.; 12.20.2 Using TCut Objects in TTree::Draw; The TTree::Draw method also accepts TCutG objects. A TCut is a specialized string object used for TTree selections. A TCut object has a name and a title. It does not have any data members in addition to what it inherits from TNamed. It only adds a set of operators to do logical string concatenation. For example, assume:; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; then; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; Operators =, +=, +, *, !, &&, || are overloaded, here are some examples:; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); 12.20.3 Accessing the Histogram in Batch Mode; The TTree::Draw method creates a histogram called htemp and puts it on th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:588448,Modifiability,variab,variable,588448,"rator, and some functions defined in TFormula, in the selection parameter. The value of the selection is used as a weight when filling the histogram. If the expression includes only Boolean operations as in the example above, the result is 0 or 1. If the result is 0, the histogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the weight is not explicitly specified it is assumed to be 1.; For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2.; ""x<y && sqrt(z)>3.2""; On the other hand, this selection will add x+y to the histogram if the square root of z is larger than 3.2.; ""(x+y)*(sqrt(z)>3.2)""; The Draw method has its own parser, and it only looks in the current tree for variables. This means that any variable used in the selection must be defined in the tree. You cannot use an arbitrary global variable in the TTree::Draw method.; 12.20.2 Using TCut Objects in TTree::Draw; The TTree::Draw method also accepts TCutG objects. A TCut is a specialized string object used for TTree selections. A TCut object has a name and a title. It does not have any data members in addition to what it inherits from TNamed. It only adds a set of operators to do logical string concatenation. For example, assume:; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; then; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; Operators =, +=, +, *, !, &&, || are overloaded, here are some examples:; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); 12.20.3 Accessing the Histogram in Batch Mode; The TTree::Draw method creates a histogram called htemp and puts it on the active pad. In a batch program, the histogram htemp created by default, is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:588739,Modifiability,inherit,inherits,588739,"istogram is not filled. In general, the expression is:; Selection = ""weight *(boolean expression)""; If the Boolean expression evaluates to true, the histogram is filled with a weight. If the weight is not explicitly specified it is assumed to be 1.; For example, this selection will add 1 to the histogram if x is less than y and the square root of z is less than 3.2.; ""x<y && sqrt(z)>3.2""; On the other hand, this selection will add x+y to the histogram if the square root of z is larger than 3.2.; ""(x+y)*(sqrt(z)>3.2)""; The Draw method has its own parser, and it only looks in the current tree for variables. This means that any variable used in the selection must be defined in the tree. You cannot use an arbitrary global variable in the TTree::Draw method.; 12.20.2 Using TCut Objects in TTree::Draw; The TTree::Draw method also accepts TCutG objects. A TCut is a specialized string object used for TTree selections. A TCut object has a name and a title. It does not have any data members in addition to what it inherits from TNamed. It only adds a set of operators to do logical string concatenation. For example, assume:; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; then; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; Operators =, +=, +, *, !, &&, || are overloaded, here are some examples:; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); 12.20.3 Accessing the Histogram in Batch Mode; The TTree::Draw method creates a histogram called htemp and puts it on the active pad. In a batch program, the histogram htemp created by default, is reachable from the current pad.; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; If you pipe the result of the TTre",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:590544,Modifiability,variab,variables,590544," draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; If you pipe the result of the TTree::Draw into a histogram, the histogram is also available in the current directory. You can do:; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; 12.20.4 Using Draw Options in TTree::Draw; The next parameter is the draw option for the histogram:; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");. Using draw options in trees. The draw options are the same as for TH1::Draw. See “Draw Options” where they are listed. In addition to the draw options defined in TH1, there are three more. The 'prof' and 'profs' draw a profile histogram (TProfile) rather than a regular 2D histogram (TH2D) from an expression with two variables. If the expression has three variables, a TProfile2D is generated.; The ‘profs’ generates a TProfile with error on the spread. The ‘prof’ option generates a TProfile with error on the mean. The “goff” option suppresses generating the graphics. You can combine the draw options in a list separated by commas. After typing the lines above, you should now have a canvas that looks this.; 12.20.5 Superimposing Two Histograms; When superimposing two 2-D histograms inside a script with TTree::Draw and using the “same” option, you will need to update the pad between Draw commands.; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:590583,Modifiability,variab,variables,590583,"TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; If you pipe the result of the TTree::Draw into a histogram, the histogram is also available in the current directory. You can do:; // Draw the histogram and fill hnew with it; nt->Draw(""x>>hnew"",""cuts"");; // get hnew from the current directory; TH1F *hnew = (TH1F*)gDirectory->Get(""hnew"");; // or get hnew from the current Pad; TH1F *hnew = (TH1F*)gPad->GetPrimitive(""hnew"");; 12.20.4 Using Draw Options in TTree::Draw; The next parameter is the draw option for the histogram:; root[] MyTree->Draw(""Cost:Age"",""Nation == \""FR\"""",""surf2"");. Using draw options in trees. The draw options are the same as for TH1::Draw. See “Draw Options” where they are listed. In addition to the draw options defined in TH1, there are three more. The 'prof' and 'profs' draw a profile histogram (TProfile) rather than a regular 2D histogram (TH2D) from an expression with two variables. If the expression has three variables, a TProfile2D is generated.; The ‘profs’ generates a TProfile with error on the spread. The ‘prof’ option generates a TProfile with error on the mean. The “goff” option suppresses generating the graphics. You can combine the draw options in a list separated by commas. After typing the lines above, you should now have a canvas that looks this.; 12.20.5 Superimposing Two Histograms; When superimposing two 2-D histograms inside a script with TTree::Draw and using the “same” option, you will need to update the pad between Draw commands.; {; // superimpose two 2D scatter plots; // Create a 2D histogram and fill it with random numbers; TH2 *h2 = new TH2D (""h2"",""2D histo"",100,0,70,100,0,20000);; for (Int_t i = 0; i < 10000; i++); h2->Fill(gRandom->Gaus(40,10),gRandom->Gaus(10000,3000));; // set the color to differentiate it visually; h2->SetMarkerColor(kGreen);; h2->Draw();; // Open the example file and get the tree; TFile f(""cernstaff.root"");; TTree *myTree = (TTree*)f.Get(""T"");; // th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:593935,Modifiability,variab,variable,593935," 1 tree->Draw(""fNtrack"");; 2 tree->Draw(""event.GetNtrack()"");; 3 tree->Draw(""GetNtrack()"");; 4 tree->Draw(""fH.fXaxis.fXmax"");; 5 tree->Draw(""fH.fXaxis.GetXmax()"");; 6 tree->Draw(""fH.GetXaxis().fXmax"");; 7 tree->Draw(""GetHistogram().GetXaxis().GetXmax()"");; // Expressions in the selection parameter; 8 tree->Draw(""fTracks.fPx"",""fEvtHdr.fEvtNum%10 == 0"");; 9 tree->Draw(""fPx"",""fEvtHdr.fEvtNum%10 == 0"");; // Two dimensional arrays defined as:; // Float_t fMatrix[4][4] in Event class; 10 tree->Draw(""fMatrix"");; 11 tree->Draw(""fMatrix[ ][ ]"");; 12 tree->Draw(""fMatrix[2][2]"");; 13 tree->Draw(""fMatrix[ ][0]"");; 14 tree->Draw(""fMatrix[1][ ]"");; // using two arrays... Float_t fVertex[3]; in Track class; 15 tree->Draw(""fMatrix - fVertex"");; 16 tree->Draw(""fMatrix[2][1] - fVertex[5][1]"");; 17 tree->Draw(""fMatrix[ ][1] - fVertex[5][1]"");; 18 tree->Draw(""fMatrix[2][ ] - fVertex[5][ ]"");; 19 tree->Draw(""fMatrix[ ][2] - fVertex[ ][1]"");; 20 tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"");; 21 tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"");; // variable length arrays; 22 tree->Draw(""fClosestDistance"");; 23 tree->Draw(""fClosestDistance[fNvertex/2]"");; // mathematical expressions; 24 tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz))"");; // external function call; 25 tree->Draw(""TMath::BreitWigner(fPx,3,2)"");; // strings; 26 tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "");; 27 tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"" "");; // Where fPoints is defined in the track class:; // Int_t fNpoint;; // Int_t *fPoints; [fNpoint]; 28 tree->Draw(""fTracks.fPoints"");; 29 tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");; 30 tree->Draw(""fTracks.fPoints[2][]- fTracks.fPoints[][55]"");; 31 tree->Draw(""fTracks.fPoints[][] - fTracks.fVertex[][]"");; // selections; 32 tree->Draw(""fValid&0x1"",""(fNvertex>10) && (fNseg<=6000)"");; 33 tree->Draw(""fPx"",""(fBx>.4) || (fBy<=-.4)"");; 34 tree->Draw(""fPx"",""fBx*fBx*(fBx>.4) + fBy*fBy*(fBy<=-.4)"");; 35 tree->Draw(""fVertex"",""fVertex>10"");; 36 tree->Draw(""fPx[600]"");;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:600362,Modifiability,variab,variable,600362," from each entry:; fMatrix[0][2] - fVertex[0][1]; fMatrix[1][2] - fVertex[1][1]; fMatrix[2][2] - fVertex[2][1]; fMatrix[3][2] - fVertex[3][1]. tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]""). This is similar to case 19. Twelve values are selected (4x3) from each entry:; fMatrix[0][2] - fVertex[0][0]; fMatrix[0][2] - fVertex[0][1]; fMatrix[0][2] - fVertex[0][2]; fMatrix[1][2] - fVertex[1][0]; fMatrix[1][2] - fVertex[1][1]; fMatrix[1][2] - fVertex[1][2]; fMatrix[2][2] - fVertex[2][0]; fMatrix[2][2] - fVertex[2][1]; fMatrix[2][2] - fVertex[2][2]; fMatrix[3][2] - fVertex[3][0]; fMatrix[3][2] - fVertex[3][1]; fMatrix[3][2] - fVertex[3][2]. tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]""). This is the same as case 15. The first dimension minimum is 4 (from fMatrix), and the second dimension minimum is 3 (from fVertex). Twelve values are selected from each entry. tree->Draw(""fClosestDistance""). This event data member fClosestDistance is a variable length array:; Float_t *fClosestDistance; //[fNvertex]; This command selects all elements, but the number per entry depends on the number of vertices of that entry. tree->Draw(""fClosestDistance[fNvertex/2]""). With this command the element at fNvertex/2 of the fClosestDistancearray is selected. Only one per entry is selected. tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)""). This command shows the use of a mathematical expression. It draws the square root of the sum of the product. tree->Draw(""TMath::BreitWigner(fPx,3,2)""). The formula can contains call to a function that takes numerical arguments and returns a numerical value. The function needs to be declared to the dictionary and need to be available from the global namespace. In particular, global functions and public static member functions can be called. tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" ""). You can compare strings, using the symbols == and !=, in the first two parameters of the Draw command (TTreeFormula). In this case, the event number for ‘type1’ events is plotted. tree->",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:605506,Modifiability,variab,variable,605506,".fPoints[2] - fTracks[4].fVertex[2]; // with fTracks[4].fNpoint==3. tree->Draw(""fValid&0x1"",""(fNvertex>10) && (fNseg<=6000)""). You can use bit patterns (&,|,<<) or Boolean operation. tree->Draw(""fPx"",""(fBx>.4) || (fBy<=-.4)"");; tree->Draw(""fPx"",""fBx*fBx*(fBx>.4) + fBy*fBy*(fBy<=-.4)"");. The selection argument is used as a weight. The expression returns a multiplier and in case of a Boolean the multiplier is either 0 (for false) or 1 (for true). The first command draws fPx for the range between with conditions on fBx and fBy, the second command draws fPx for the same conditions, but adds a weight using the result of the second expression. tree->Draw(""fVertex"",""fVertex>10""). When using arrays in the selection and the expression, the selection is applied to each element of the array.; if (fVertex[0]>10) fVertex[0]; if (fVertex[1]>10) fVertex[1]; if (fVertex[2]>10) fVertex[2]. tree->Draw(""fPx[600]""); tree->Draw(""fPx[600]"",""fNtrack > 600""). When using a specific element for a variable length array the entries with fewer elements are ignored. Thus these two commands are equivalent. tree->Draw(""Nation""). Nation is a char* branch. When drawing a char* it will plot an alphanumeric histogram, of the different value of the string Nation. The axis will have the Nation values. See “Histograms”. tree->Draw(""MyChar +0""). If you want to plot a char* variable as a byte rather than a string, you can use the syntax above. tree->Draw(""fTracks.fTriggerBits""). fTriggerBits is a data member of TTrack of type TBits. Objects of class TBits can be drawn directly. This command will create a 1D histogram from 0 to nbits which is filled for each non-null bit-number. tree->Draw(""fMatrix-Alt$(fClosestDistance,0)""). Alt$(primary,alternate) returns the value of “primary” if it is available for the current iteration; otherwise return the value of “alternate”. Assuming that fClosestDistance is a smaller array than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:605876,Modifiability,variab,variable,605876,"ase of a Boolean the multiplier is either 0 (for false) or 1 (for true). The first command draws fPx for the range between with conditions on fBx and fBy, the second command draws fPx for the same conditions, but adds a weight using the result of the second expression. tree->Draw(""fVertex"",""fVertex>10""). When using arrays in the selection and the expression, the selection is applied to each element of the array.; if (fVertex[0]>10) fVertex[0]; if (fVertex[1]>10) fVertex[1]; if (fVertex[2]>10) fVertex[2]. tree->Draw(""fPx[600]""); tree->Draw(""fPx[600]"",""fNtrack > 600""). When using a specific element for a variable length array the entries with fewer elements are ignored. Thus these two commands are equivalent. tree->Draw(""Nation""). Nation is a char* branch. When drawing a char* it will plot an alphanumeric histogram, of the different value of the string Nation. The axis will have the Nation values. See “Histograms”. tree->Draw(""MyChar +0""). If you want to plot a char* variable as a byte rather than a string, you can use the syntax above. tree->Draw(""fTracks.fTriggerBits""). fTriggerBits is a data member of TTrack of type TBits. Objects of class TBits can be drawn directly. This command will create a 1D histogram from 0 to nbits which is filled for each non-null bit-number. tree->Draw(""fMatrix-Alt$(fClosestDistance,0)""). Alt$(primary,alternate) returns the value of “primary” if it is available for the current iteration; otherwise return the value of “alternate”. Assuming that fClosestDistance is a smaller array than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; E",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:606811,Modifiability,variab,variables,606811,"). fTriggerBits is a data member of TTrack of type TBits. Objects of class TBits can be drawn directly. This command will create a 1D histogram from 0 to nbits which is filled for each non-null bit-number. tree->Draw(""fMatrix-Alt$(fClosestDistance,0)""). Alt$(primary,alternate) returns the value of “primary” if it is available for the current iteration; otherwise return the value of “alternate”. Assuming that fClosestDistance is a smaller array than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; Entry$ : return the current entry number (TTree::GetReadEntry()); Entries$ : return the total number of entries (TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry; Iteration$: return the current iteration over this formula for this entry (i.e. varies from 0 to Length$). tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");. TRef and TRefArray are automatically deferenced and this shows the value of the fPx of the track referenced by fLastTrack. To access the TRef object itself use the ‘@’ notation (see next example). This auto dereferencing can be extended (via an implementation of TVirtualRefProxy) to any reference type. tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");. Will cast the return value of GetObject() (which happens to be TObject* in this case) before requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘use",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:607493,Modifiability,extend,extended,607493,"e size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; Entry$ : return the current entry number (TTree::GetReadEntry()); Entries$ : return the total number of entries (TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry; Iteration$: return the current iteration over this formula for this entry (i.e. varies from 0 to Length$). tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");. TRef and TRefArray are automatically deferenced and this shows the value of the fPx of the track referenced by fLastTrack. To access the TRef object itself use the ‘@’ notation (see next example). This auto dereferencing can be extended (via an implementation of TVirtualRefProxy) to any reference type. tree->Scan(""((Track*)(fLastTrack@.GetObject())).GetPx()"","""","""");. Will cast the return value of GetObject() (which happens to be TObject* in this case) before requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘user info’ object:; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");. tree->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:608660,Modifiability,variab,variables,608660,"ore requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘user info’ object:; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");. tree->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plot the same as:; tree->Draw(""myTimeStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:608775,Modifiability,variab,variables,608775,"ore requesting the GetPx() member functions. tree->Draw(""This->GetReadEntry()"");. You can refer to the tree (or chain) containing the data by using the string ‘This’. You can also call any TTree methods. Next example will display the name of the first ‘user info’ object:; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");. tree->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plot the same as:; tree->Draw(""myTimeStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:609019,Modifiability,Variab,Variables,609019,"ee->Draw(""mybr.mystring"");. TString and std::string object are plotted directly. The example 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plot the same as:; tree->Draw(""myTimeStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to interact with the spider plots’ output: the tab “Style” defining the spider layout and the tab “Browse” to navigate in the tree.; 12.20.8.2 Parallel Coordinates Plots. The Parallel Coordinates Plots are a common way of studying and visualizing multiple variables data sets. They were proposed by in A.Inselberg in 1981 as a new ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:609099,Modifiability,variab,variable,609099,"mple 45 draws the same results - i.e. an histogram whose labels are the string value of ‘mystring’:; tree->Draw(""mybr.mystring.c_str()"");; or; tree->Draw(""mybr.mytstring.Data()"");. tree->Draw(""myTimeStamp"");. You can plot plot objects of any class which has either AsDouble or AsString (AsDouble has priority). For such a class (for example TTimeStamp), the line 46 will plot the same as:; tree->Draw(""myTimeStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to interact with the spider plots’ output: the tab “Style” defining the spider layout and the tab “Browse” to navigate in the tree.; 12.20.8.2 Parallel Coordinates Plots. The Parallel Coordinates Plots are a common way of studying and visualizing multiple variables data sets. They were proposed by in A.Inselberg in 1981 as a new way to represent multi-dimensional information. In traditional Cartesian coordinates, ax",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:609496,Modifiability,variab,variables,609496,"meStamp.AsDouble"");; AsString can be returning either a char*, or a TString or an std::string.; 12.20.8 Multiple variables visualisation; This section presents the visualization technique available in ROOT to represent multiple variables (>4) data sets.; 12.20.8.1 Spider (Radar) Plots; Spider plots (sometimes called “web-plots” or “radar plots”) are used to compare series of data points (events). They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to interact with the spider plots’ output: the tab “Style” defining the spider layout and the tab “Browse” to navigate in the tree.; 12.20.8.2 Parallel Coordinates Plots. The Parallel Coordinates Plots are a common way of studying and visualizing multiple variables data sets. They were proposed by in A.Inselberg in 1981 as a new way to represent multi-dimensional information. In traditional Cartesian coordinates, axes are mutually perpendicular. In Parallel coordinates, all axes are parallel which allows representing data in much more than three dimensions. To show a set of points in Parallel Coordinates, a set of parallel lines is drawn, typically vertical and equally spaced. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes. The position of the vertex on the i-th axi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:609979,Modifiability,variab,variables,609979," They use the human ability to spot un-symmetry. Example of spider plot. Variables are represented on individual axes displayed along a circle. For each variable the minimum value sits on the circle’s center, and the maximum on the circle’s radius. Spider plots are not suitable for an accurate graph reading since, by their nature, it can be difficult to read out very detailed values, but they give quickly a global view of an event in order to compare it with the others. In ROOT the spider plot facility is accessed from the tree viewer GUI. The variables to be visualized are selected in the tree viewer and can be scanned using the spider plot button. The tree viewer Graphical User Interface and the Spider Plot Editor. The spider plot graphics editor provides two tabs to interact with the spider plots’ output: the tab “Style” defining the spider layout and the tab “Browse” to navigate in the tree.; 12.20.8.2 Parallel Coordinates Plots. The Parallel Coordinates Plots are a common way of studying and visualizing multiple variables data sets. They were proposed by in A.Inselberg in 1981 as a new way to represent multi-dimensional information. In traditional Cartesian coordinates, axes are mutually perpendicular. In Parallel coordinates, all axes are parallel which allows representing data in much more than three dimensions. To show a set of points in Parallel Coordinates, a set of parallel lines is drawn, typically vertical and equally spaced. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes. The position of the vertex on the i-th axis corresponds to the i-th coordinate of the point. The three following figures show some very simple examples:. The Parallel Coordinates representation of the six dimensional point (-5,3,4,2,0,1). The line y = -3x+20 and a circle in Parallel Coordinates. The Parallel Coordinates technique is good at: spotting irregular events, seeing the data trend, finding correlations and clusters. Its main wea",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:612154,Modifiability,variab,variables,612154,"ne about Parallel Coordinates is to find techniques to reduce the output’s cluttering. The Parallel Coordinates plots in ROOT have been implemented as a new plotting option “PARA” in the TTree::Draw()method. To demonstrate how the Parallel Coordinates works in ROOT we will use the tree produced by the following “pseudo C++” code:; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; The data set generated has:. 9 variables: x, y, z, u, v, w, a, b, c.; 3000*8 = 24000 events.; 3 sets of random points distributed on spheres: s1, s2, s3; Random values (noise): rnd; The variables a,b,c are almost completely random. The variables a and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");. Cluttered output produced when all the tree events are plotted. If the 24000 events are plotted as solid lines and no special techniques are used to clarify the picture, the result is the previous picture which is very cluttered and useless. To improve the readability of the Parallel Coordinates output and to explore interactively the data set, many techniques are available. We have implemented a few in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines pass",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:612309,Modifiability,variab,variables,612309,"lots in ROOT have been implemented as a new plotting option “PARA” in the TTree::Draw()method. To demonstrate how the Parallel Coordinates works in ROOT we will use the tree produced by the following “pseudo C++” code:; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; The data set generated has:. 9 variables: x, y, z, u, v, w, a, b, c.; 3000*8 = 24000 events.; 3 sets of random points distributed on spheres: s1, s2, s3; Random values (noise): rnd; The variables a,b,c are almost completely random. The variables a and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");. Cluttered output produced when all the tree events are plotted. If the 24000 events are plotted as solid lines and no special techniques are used to clarify the picture, the result is the previous picture which is very cluttered and useless. To improve the readability of the Parallel Coordinates output and to explore interactively the data set, many techniques are available. We have implemented a few in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines passing through the bins. The histogram’s axis can be represented with colors or as bar charts. These histograms can b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:612359,Modifiability,variab,variables,612359,"e Parallel Coordinates works in ROOT we will use the tree produced by the following “pseudo C++” code:; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; The data set generated has:. 9 variables: x, y, z, u, v, w, a, b, c.; 3000*8 = 24000 events.; 3 sets of random points distributed on spheres: s1, s2, s3; Random values (noise): rnd; The variables a,b,c are almost completely random. The variables a and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");. Cluttered output produced when all the tree events are plotted. If the 24000 events are plotted as solid lines and no special techniques are used to clarify the picture, the result is the previous picture which is very cluttered and useless. To improve the readability of the Parallel Coordinates output and to explore interactively the data set, many techniques are available. We have implemented a few in ROOT. First of all, in order to show better where the clusters on the various axes are, a 1D histogram is associated to each axis. These histograms (one per axis) are filled according to the number of lines passing through the bins. The histogram’s axis can be represented with colors or as bar charts. These histograms can be represented which colors (get from a palette according to the bin contents) or as bar charts. Both representations",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614464,Modifiability,variab,variables,614464,"dual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to und",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614490,Modifiability,variab,variables,614490,"dual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to und",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614548,Modifiability,variab,variables,614548,"dual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to und",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:615702,Modifiability,variab,variables,615702,"ine selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to understand. Several selections can be defined each of them having its own color. Interactive selections on Parallel Coordinates are a powerful tool because they can be defined graphically on many variables (graphical cuts in ROOT can be defined on two variables only) which allow a very accurate events filtering. Selections allow making precise events choices: a single outlying event is clearly visible when the lines are displayed as “solid” therefore it is easy to make cuts in order to eliminate one single event from a selection. Such selection (to filter one single event) on a scatter plot would be much more difficult. Selections allow to easily filter one single event. Once a selection has been defined, it is possible to use it to generate a TEntryList which is applied on the tree and used at drawing time. In our example the selection we defined allows to select exactly the two correlated “random spheres”. Output of nt->Draw(“x:y:z”) and nt->Draw(“u:v:w”) after applying the selection. Another technique has been implemented in order to show clusters when the picture is cluttered. A weight is assigned to each event. The weight value is computed as: \[; weight = \sum_{i=1}^{n} b_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:615758,Modifiability,variab,variables,615758,"ine selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to understand. Several selections can be defined each of them having its own color. Interactive selections on Parallel Coordinates are a powerful tool because they can be defined graphically on many variables (graphical cuts in ROOT can be defined on two variables only) which allow a very accurate events filtering. Selections allow making precise events choices: a single outlying event is clearly visible when the lines are displayed as “solid” therefore it is easy to make cuts in order to eliminate one single event from a selection. Such selection (to filter one single event) on a scatter plot would be much more difficult. Selections allow to easily filter one single event. Once a selection has been defined, it is possible to use it to generate a TEntryList which is applied on the tree and used at drawing time. In our example the selection we defined allows to select exactly the two correlated “random spheres”. Output of nt->Draw(“x:y:z”) and nt->Draw(“u:v:w”) after applying the selection. Another technique has been implemented in order to show clusters when the picture is cluttered. A weight is assigned to each event. The weight value is computed as: \[; weight = \sum_{i=1}^{n} b_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:618768,Modifiability,variab,variables,618768,"early the clusters. . Parallel Coordinates with transparency. 12.20.8.3 Box (Candle) Plots; ; A Box Plot (also known as a “box-and whisker” plot or “candle stick” plot) is a convenient way to describe graphically a data distribution (D) with only the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. The minimum value of the distribution D (Min).; The lower quartile (Q1): 25% of the data points in D are less than Q1.; The median (M): 50% of the data points in D are less than M.; The upper quartile (Q3): 75% of the data points in D are less than Q3.; The maximum value of the distribution D (Max). A box plot describes a distribution with only five numbers. In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; 12.20.9 Using TTree::Scan. TTree::Scan can be used to print the content of the tree’s entries optional passing a selection.; root[] MyTree->Scan();; will print the first 8 variables of the tree.; root[] MyTree->Scan(""*"");; will print all the variable of the tree.; Specific variables of the tree can be explicit selected by list them in column separated list:; root[] MyTree->Scan(""var1:var2:var3"");; will print the values of var1, var2 and var3. A selection can be applied in the second argument:; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; will print the values of var1, var2 and var3 for the entries where var1 is exactly 0.; TTree::Scan returns the number of entries passing the selection. By default 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:618838,Modifiability,variab,variable,618838,"3 Box (Candle) Plots; ; A Box Plot (also known as a “box-and whisker” plot or “candle stick” plot) is a convenient way to describe graphically a data distribution (D) with only the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. The minimum value of the distribution D (Min).; The lower quartile (Q1): 25% of the data points in D are less than Q1.; The median (M): 50% of the data points in D are less than M.; The upper quartile (Q3): 75% of the data points in D are less than Q3.; The maximum value of the distribution D (Max). A box plot describes a distribution with only five numbers. In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; 12.20.9 Using TTree::Scan. TTree::Scan can be used to print the content of the tree’s entries optional passing a selection.; root[] MyTree->Scan();; will print the first 8 variables of the tree.; root[] MyTree->Scan(""*"");; will print all the variable of the tree.; Specific variables of the tree can be explicit selected by list them in column separated list:; root[] MyTree->Scan(""var1:var2:var3"");; will print the values of var1, var2 and var3. A selection can be applied in the second argument:; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; will print the values of var1, var2 and var3 for the entries where var1 is exactly 0.; TTree::Scan returns the number of entries passing the selection. By default 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; will create a file tree.log.; Arrays (within an entr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:618870,Modifiability,variab,variables,618870,"ribe graphically a data distribution (D) with only the five numbers. It was invented in 1977 by John Tukey. The five numbers are:. The minimum value of the distribution D (Min).; The lower quartile (Q1): 25% of the data points in D are less than Q1.; The median (M): 50% of the data points in D are less than M.; The upper quartile (Q3): 75% of the data points in D are less than Q3.; The maximum value of the distribution D (Max). A box plot describes a distribution with only five numbers. In ROOT Box Plots (Candle Plots) can be produced from a TTree using the “candle” option in TTree::Draw().; tree->Draw(“px:cos(py):sin(pz)”,””,”candle”);; 12.20.9 Using TTree::Scan. TTree::Scan can be used to print the content of the tree’s entries optional passing a selection.; root[] MyTree->Scan();; will print the first 8 variables of the tree.; root[] MyTree->Scan(""*"");; will print all the variable of the tree.; Specific variables of the tree can be explicit selected by list them in column separated list:; root[] MyTree->Scan(""var1:var2:var3"");; will print the values of var1, var2 and var3. A selection can be applied in the second argument:; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; will print the values of var1, var2 and var3 for the entries where var1 is exactly 0.; TTree::Scan returns the number of entries passing the selection. By default 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; will create a file tree.log.; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:625147,Modifiability,variab,variable,625147," to use the list and hence limit all subsequent calls to Draw, Scan, Process, Query, Principal and CopyTree methods to the entries in the list. In general, it affects the GetEntryNumber method and all functions using it for looping over the tree entries. The GetEntry and GetEntries methods are not affected. Note, that in the SetEventList method, the TEventList argument is internally transformed into a TEntryList, and this operation, in case of a TChain, requires loading of all the tree headers. In this example, we create a list with all entries with more than 600 tracks and then set it so that the tree will use this list. To reset the TTree to use all events use SetEventList(0) or SetEntryList(0). Let’s look at an example. First, open the file and draw the fNtrack. root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");. Now, put the entries with over 600 tracks into a TEntryList called myList. We get the list from the current directory and assign it to a variable list. root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");. Instruct the tree T to use the new list and draw it again. Note that this is exactly the same Draw command. The list limits the entries. root[] T->SetEntryList(list);; root[] T->Draw(""fNtrack"");; You should now see a canvas similar to this one. 12.20.10.3 Operations on TEntryLists; If you have entry lists that were created using different cuts, you can combine the lists to get a new list, with entries passing at least one of the cuts. Example:; root[] T->Draw("">>list1"",""fNtrack>600"",""entrylist"");; root[] TEntryList *list1 = (TEntryList*)gDirectory->Get(""list1"");; root[] T->Draw("">>list2"",""fNtrack<590"",""entrylist"");; root[] TEntryList *list2 = (TEntryList*)gDirectory->Get(""list2"");; root[] list1->Add(list2);; list1 now contains entries with more than 600 or less than 590 tracks. Check this by calling:; root[] T->SetEntryList(lis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:628686,Modifiability,variab,variable,628686,"lows to load the entry lists in memory one by one, keeping only the list for the currently processed tree loaded.; For more details on entry lists, see TEntryList, TEntryListBlock and TEntryListFromFile class descriptions, functions TChain::SetEntryList(), TChain::SetEntryListFile(), and the macro $ROOTSYS/test/stressEntryList.C.; 12.20.11 Filling a Histogram; The TTree::Draw method can also be used to fill a specific histogram. The syntax is:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; As we can see, this created a TH1, called myHisto. If you want to append more entries to the histogram, you can use this syntax:; root[] T->Draw(""fNtrack >>+ myHisto""); If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ahead of time and use it in the Draw command. The histogram has to be in the same directory as the tree.; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; When you project a TTree into a histogram, the histogram inherits the TTree attributes and not the current style attributes. This allows you to project two Trees with different attributes into the same picture. You can call the method TTree::UseCurrentStyle to change the histogram to use the current style gStyle. See ""Graphics and the Graphical User Interface.; The binning of the newly created histogram can be specified in two ways. You can set a default in the .rootrc and/or you can add the binning information in the TTree::Draw command.; To set number of bins default for the 1-D, 2-D, 3-D histograms can be specified in the .rootrc file via the environment variables, e.g.:; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binni",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:629049,Modifiability,inherit,inherits,629049,", and the macro $ROOTSYS/test/stressEntryList.C.; 12.20.11 Filling a Histogram; The TTree::Draw method can also be used to fill a specific histogram. The syntax is:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; As we can see, this created a TH1, called myHisto. If you want to append more entries to the histogram, you can use this syntax:; root[] T->Draw(""fNtrack >>+ myHisto""); If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ahead of time and use it in the Draw command. The histogram has to be in the same directory as the tree.; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; When you project a TTree into a histogram, the histogram inherits the TTree attributes and not the current style attributes. This allows you to project two Trees with different attributes into the same picture. You can call the method TTree::UseCurrentStyle to change the histogram to use the current style gStyle. See ""Graphics and the Graphical User Interface.; The binning of the newly created histogram can be specified in two ways. You can set a default in the .rootrc and/or you can add the binning information in the TTree::Draw command.; To set number of bins default for the 1-D, 2-D, 3-D histograms can be specified in the .rootrc file via the environment variables, e.g.:; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; To set the number of bins for a specific histogram when using TTree::Draw, add up to nine numbers following the histogr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:629658,Modifiability,variab,variables,629658,"above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ahead of time and use it in the Draw command. The histogram has to be in the same directory as the tree.; root[] TH1 *h1 = new TH1(""h1"",""h1"",50,0.,150.);; root[] T->Draw(""fNtrack>> h1"");; When you project a TTree into a histogram, the histogram inherits the TTree attributes and not the current style attributes. This allows you to project two Trees with different attributes into the same picture. You can call the method TTree::UseCurrentStyle to change the histogram to use the current style gStyle. See ""Graphics and the Graphical User Interface.; The binning of the newly created histogram can be specified in two ways. You can set a default in the .rootrc and/or you can add the binning information in the TTree::Draw command.; To set number of bins default for the 1-D, 2-D, 3-D histograms can be specified in the .rootrc file via the environment variables, e.g.:; # default binnings Hist.Binning.1D.x: 100. Hist.Binning.2D.x: 40; Hist.Binning.2D.y: 40; Hist.Binning.2D.Prof: 100. Hist.Binning.3D.x: 20; Hist.Binning.3D.y: 20; Hist.Binning.3D.z: 20; Hist.Binning.3D.Profx: 100; Hist.Binning.3D.Profy: 100; To set the number of bins for a specific histogram when using TTree::Draw, add up to nine numbers following the histogram name. The numbers meaning is:; 1 bins in x-direction; 2 lower limit in x-direction; 3 upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction; When a bin number is specified, the value becomes the default. Any of the numbers can be skipped. For example:; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)"";; // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,,50,.1,.5)"";; // plot sqrt(x) against sin(y) 100 bins in x-direction;; // lower limit on x-axis is 10; no upper limit; // 50 bins in y-direction; lower limit on y-axis is .1;; // upper limit is .5; When",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:631791,Modifiability,variab,variable,631791,"inue to fill it.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0"");; This works for 1-D, 2-D and 3-D histograms.; 12.20.11.1 Projecting a Histogram; If you would like to fill a histogram, but not draw it you can use the TTree::Project() method.; root[] T->Project(""quietHisto"",""fNtrack""); 12.20.11.2 Making a Profile Histogram. In case of a two dimensional expression, you can generate a TProfile histogram instead of a two dimensional histogram by specifying the 'prof' or ’profs' option. The prof option is automatically selected when the output is redirected into a TProfile. For example y:x>>pf where pfis an existing TProfile histogram.; 12.20.11.3 Tree Information; Once we have drawn a tree, we can get information about the tree. These are the methods used to get information from a drawn tree TTree:. GetSelectedRows: Returns the number of entries accepted by the selection expression. In case where no selection was specified, it returns the number of entries processed.; GetV1: Returns a pointer to the float array of the first variable.; GetV2: Returns a pointer to the float array of second variable; GetV3: Returns a pointer to the float array of third variable.; GetW: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression. To read the drawn values of fNtrack into an array, and loop through the entries follow the lines below. First, open the file and draw the fNtrack variable:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); Then declare a pointer to a float and use the GetV1 method to retrieve the first dimension of the tree. In this example we only drew one dimension (fNtrack) if we had drawn two, we could use GetV2 to get the second one.; root[] Float_t *a; root[] a = T->GetV1(); Loop through the first 10 entries and print the values of fNtrack:; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; By default, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:631856,Modifiability,variab,variable,631856,"; 12.20.11.1 Projecting a Histogram; If you would like to fill a histogram, but not draw it you can use the TTree::Project() method.; root[] T->Project(""quietHisto"",""fNtrack""); 12.20.11.2 Making a Profile Histogram. In case of a two dimensional expression, you can generate a TProfile histogram instead of a two dimensional histogram by specifying the 'prof' or ’profs' option. The prof option is automatically selected when the output is redirected into a TProfile. For example y:x>>pf where pfis an existing TProfile histogram.; 12.20.11.3 Tree Information; Once we have drawn a tree, we can get information about the tree. These are the methods used to get information from a drawn tree TTree:. GetSelectedRows: Returns the number of entries accepted by the selection expression. In case where no selection was specified, it returns the number of entries processed.; GetV1: Returns a pointer to the float array of the first variable.; GetV2: Returns a pointer to the float array of second variable; GetV3: Returns a pointer to the float array of third variable.; GetW: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression. To read the drawn values of fNtrack into an array, and loop through the entries follow the lines below. First, open the file and draw the fNtrack variable:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); Then declare a pointer to a float and use the GetV1 method to retrieve the first dimension of the tree. In this example we only drew one dimension (fNtrack) if we had drawn two, we could use GetV2 to get the second one.; root[] Float_t *a; root[] a = T->GetV1(); Loop through the first 10 entries and print the values of fNtrack:; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; By default, TTree::Draw creates these arrays with fEstimate words where fEstimate can be set via TTree::SetEst",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:631919,Modifiability,variab,variable,631919,"; 12.20.11.1 Projecting a Histogram; If you would like to fill a histogram, but not draw it you can use the TTree::Project() method.; root[] T->Project(""quietHisto"",""fNtrack""); 12.20.11.2 Making a Profile Histogram. In case of a two dimensional expression, you can generate a TProfile histogram instead of a two dimensional histogram by specifying the 'prof' or ’profs' option. The prof option is automatically selected when the output is redirected into a TProfile. For example y:x>>pf where pfis an existing TProfile histogram.; 12.20.11.3 Tree Information; Once we have drawn a tree, we can get information about the tree. These are the methods used to get information from a drawn tree TTree:. GetSelectedRows: Returns the number of entries accepted by the selection expression. In case where no selection was specified, it returns the number of entries processed.; GetV1: Returns a pointer to the float array of the first variable.; GetV2: Returns a pointer to the float array of second variable; GetV3: Returns a pointer to the float array of third variable.; GetW: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression. To read the drawn values of fNtrack into an array, and loop through the entries follow the lines below. First, open the file and draw the fNtrack variable:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); Then declare a pointer to a float and use the GetV1 method to retrieve the first dimension of the tree. In this example we only drew one dimension (fNtrack) if we had drawn two, we could use GetV2 to get the second one.; root[] Float_t *a; root[] a = T->GetV1(); Loop through the first 10 entries and print the values of fNtrack:; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; By default, TTree::Draw creates these arrays with fEstimate words where fEstimate can be set via TTree::SetEst",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:632194,Modifiability,variab,variable,632194,"am by specifying the 'prof' or ’profs' option. The prof option is automatically selected when the output is redirected into a TProfile. For example y:x>>pf where pfis an existing TProfile histogram.; 12.20.11.3 Tree Information; Once we have drawn a tree, we can get information about the tree. These are the methods used to get information from a drawn tree TTree:. GetSelectedRows: Returns the number of entries accepted by the selection expression. In case where no selection was specified, it returns the number of entries processed.; GetV1: Returns a pointer to the float array of the first variable.; GetV2: Returns a pointer to the float array of second variable; GetV3: Returns a pointer to the float array of third variable.; GetW: Returns a pointer to the float array of Weights where the weight equals the result of the selection expression. To read the drawn values of fNtrack into an array, and loop through the entries follow the lines below. First, open the file and draw the fNtrack variable:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); Then declare a pointer to a float and use the GetV1 method to retrieve the first dimension of the tree. In this example we only drew one dimension (fNtrack) if we had drawn two, we could use GetV2 to get the second one.; root[] Float_t *a; root[] a = T->GetV1(); Loop through the first 10 entries and print the values of fNtrack:; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; By default, TTree::Draw creates these arrays with fEstimate words where fEstimate can be set via TTree::SetEstimate. If you have more entries than fEstimate only the first fEstimate selected entries will be stored in the arrays. The arrays are used as buffers. When fEstimate entries have been processed, ROOT scans the buffers to compute the minimum and maximum of each coordinate and creates the corresponding histograms. You can use these ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:633818,Modifiability,variab,variable,633818,"ult, TTree::Draw creates these arrays with fEstimate words where fEstimate can be set via TTree::SetEstimate. If you have more entries than fEstimate only the first fEstimate selected entries will be stored in the arrays. The arrays are used as buffers. When fEstimate entries have been processed, ROOT scans the buffers to compute the minimum and maximum of each coordinate and creates the corresponding histograms. You can use these lines to read all entries into these arrays:; root[] Int_t nestimate = (Int_t)T->GetEntries();; root[] T->SetEstimate(nestimate);; Obviously, this will not work if the number of entries is very large. This technique is useful in several cases, for example if you want to draw a graph connecting all the x, y(or z) points. Note that you may have a tree (or chain) with 1 billion entries, but only a few may survive the cuts and will fit without problems in these arrays.; 12.21 Using TTree::MakeClass. The TTree::Draw method is convenient and easy to use; however it falls short if you need to do some programming with the variable.; For example, for plotting the masses of all oppositely changed pairs of tracks, you would need to write a program that loops over all events, finds all pairs of tracks, and calculates the required quantities. We have shown how to retrieve the data arrays from the branches of the tree in the previous section, and you could just write that program from scratch. Since this is a very common task, ROOT provides a utility that generates a skeleton class designed to loop over the entries of the tree.; This is the TTree::MakeClass method. We will now go through the steps of using MakeClass with a simplified example. The methods used here obviously work for complex event loop calculations.; These are our assumptions: we would like to do selective plotting and loop through each entry of the tree and tracks. We chose a simple example: we want to plot fPx of the first 100 tracks of each entry. We have a ROOT tree with a branch for ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:643416,Modifiability,config,configuration,643416,"s.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to process a limited set of entries. This is especially important in a parallel processing configuration where the analysis is distributed over several processors and we can specify which entries to send to each processor. The TTree::Process method is used to specify the selector and the entries. Before we can use TTree::Process we need to make a selector. We can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the event is selected histograms can be filled. Processing stops when this function returns kFALSE. It combines the methods TSe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648250,Modifiability,config,configurations,648250,"vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56 s.(5.4 MB/s); 0.79s.(24.2 MB/s); 0.79 s.(24.2 MB/s). Comp = 1; Split = 1; 17.73 MB; 6.44 s.(3.0 MB/s)",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654165,Modifiability,variab,variables,654165," branches, use TChain::SetBranchStatus to activate a branch.; Int_t nevent = chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFriend. ATChain has a list of friends similar to a tree (see TTree::AddFriend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTS",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654383,Modifiability,variab,variable,654383,"; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFriend. ATChain has a list of friends similar to a tree (see TTree::AddFriend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing firs",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654432,Modifiability,variab,variable,654432,"; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFriend. ATChain has a list of friends similar to a tree (see TTree::AddFriend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing firs",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654540,Modifiability,variab,variable,654540,"Friend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654579,Modifiability,variab,variable,654579,"Friend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:654610,Modifiability,variab,variable,654610,"Friend). You can add a friend to a chain with the TChain::AddFriend method. With TChain::GetListOfFriends you can retrieve the list of friends. The next example has four chains each has 20 ROOT trees from 20 ROOT files.; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; Now we can add the friends to the first chain.; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; The parameter is the name of friend chain (the name of a chain is always the name of the tree from which it was created). The original chain has access to all variables in its friends. We can use the TChain::Draw method as if the values in the friends were in the original chain. To specify the chain to use in the Draw method, use:; <chainname>.<branchname>.<varname>; If the variable name is enough to identify uniquely the variable, you can leave out the chain and/or branch name. For example, this generates a 3-d scatter plot of variable “var” in the TChain ch versus variable v1 inTChain t1 versus variable v2 in TChaint2.; ch.Draw(""var:t1.v1:t2.v2"");; When a TChain::Draw is executed, an automatic call to TTree::AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:658960,Modifiability,Adapt,Adaptive,658960,"ll MathCore classes is available in the Doxygen online reference documentation.; 13.2 MathMore Library; The MathMore library provides an advanced collection of functions and C++ classes for numerical computing. This is an extension of the functionality provided by the MathCore library. The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). The current set, provided in the ROOT::Math namespace include:. Special mathematical functions (like Bessel functions, Legendre polynomials, etc.. ); Additional mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse which are not in MathCore but present in the GSL library.; Numerical algorithms for one dimensional functions based on implementation of the GNU Scientific Library (GSL):; Numerical integration classes implementing the interface ROOT::Math::Integrator which is based on the Adaptive integration algorithms of QUADPACK; Numerical differentiation via ROOT::Math::GSLDerivator; Root finder implementing the ROOT::Math::RootFinder interface, using different solver algorithms from GSL; one-dimensional Minimization implementing the interfaceROOT::Math::IMinimizer1D; Interpolation via ROOT::Math::Interpolation. All the GSL interpolation types are supported; Function approximation based on Chebyshev polynomials via the class ROOT::Math::Chebyshev; Random number generators and distributions based on GSL using the ROOT::Math::Random<Engine_type> class.; Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU Gene",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:660222,Modifiability,config,configure,660222,"ementing the interfaceROOT::Math::IMinimizer1D; Interpolation via ROOT::Math::Interpolation. All the GSL interpolation types are supported; Function approximation based on Chebyshev polynomials via the class ROOT::Math::Chebyshev; Random number generators and distributions based on GSL using the ROOT::Math::Random<Engine_type> class.; Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU General Public License.; MathMore (and its ROOT Cling dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g. functions to find min and max of arrays);; statistic functions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probabil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:660253,Modifiability,config,configure,660253,"ROOT::Math::Interpolation. All the GSL interpolation types are supported; Function approximation based on Chebyshev polynomials via the class ROOT::Math::Chebyshev; Random number generators and distributions based on GSL using the ROOT::Math::Random<Engine_type> class.; Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU General Public License.; MathMore (and its ROOT Cling dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementary mathematical functions;; functions to work with arrays and collections (e.g. functions to find min and max of arrays);; statistic functions to work on array of data (e.g. mean and RMS of arrays);; algorithms for binary search/hashing sorting;; special mathematical functions like Bessel, Erf, Gamma, etc.;; statistical functions, like common probability and cumulative (quantile) distributions; geometrical function",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:686892,Modifiability,inherit,inherit,686892," tail integral). All the inverse distributions are in the MathMore library and are defined in the header file Math/ProbFuncInv.h.; The following picture illustrates the available statistical functions (PDF, CDF and quantiles) in the case of the normal distribution. PDF, CDF and quantiles in the case of the normal distribution. 13.6 Numerical Algorithms; ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. Evaluation of function derivatives.; Evaluation of integrals.; Finding the roots of a function; Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function. ROOT provides a common way of specifying them via some interfaces; 13.7 ROOT::Math Function interfaces; To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function. In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ROOT::Math Function interface structure. 13.7.1 One-dimensional Function Interfaces; These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions. For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. ROOT::Math::IBaseFunctionOneDim: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing double operator() (const double ). The user class defined only needs to reimplement the pure abstract method double DoEval(double x), that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from IBaseFunctionOneDim:; #include ""Math/IFunction.h"". class M",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:688435,Modifiability,inherit,inherit,688435," operator() (const double ). The user class defined only needs to reimplement the pure abstract method double DoEval(double x), that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from IBaseFunctionOneDim:; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionOneDim; {; double DoEval(double x) const; {; return x*x;; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyFunction();; }; };. ROOT::Math::IGradientFunctionOneDim: Some of the numerical algorithm will need to calculate the derivatives of the function. In these cases, the user will have to provide the necessary code for this to happen. The interface defined in IGradientFunctionOneDim introduced the method double Derivative(double x) that will return the derivative of the function at the point x. The class inherit by the user will have to implement the abstract method double DoDerivative(double x), leaving the rest of the class untouched.; Example for implementing a gradient one-dimensional function:. #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionOneDim; {; public:; double DoEval(double x) const; {; return sin(x);; }. ROOT::Math::IBaseFunctionOneDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(double x) const; {; return -cos(x);; }. };; 13.7.2 Multi-dimensional Function Interfaces; The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional functions. For algorithms working on both one-dimensional and multi-dimensional functions they should inste",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:689920,Modifiability,variab,variables,689920,"}. double DoDerivative(double x) const; {; return -cos(x);; }. };; 13.7.2 Multi-dimensional Function Interfaces; The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. ROOT::Math::IBaseFunctionMultiDim: This interface provides the double operator() (const double*) that takes an array of doubles with all the values for the different dimensions. In this case, the user has to provide the functionality for two different functions: double DoEval(const double*) and unsigned int NDim(). The first ones evaluates the function given the array that represents the multiple variables. The second returns the number of dimensions of the function.; Example of implementing a basic multi-dimensional function:. #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };. ROOT::Math::IGradientFunctionMultiDim: This interface offers the same functionality as the base function plus the calculation of the derivative. It only adds the double Derivative(double* x, uint ivar) method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the second parameter. Example of implementing a multi-dimensional gradient function; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:690669,Modifiability,variab,variable,690669," all the values for the different dimensions. In this case, the user has to provide the functionality for two different functions: double DoEval(const double*) and unsigned int NDim(). The first ones evaluates the function given the array that represents the multiple variables. The second returns the number of dimensions of the function.; Example of implementing a basic multi-dimensional function:. #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };. ROOT::Math::IGradientFunctionMultiDim: This interface offers the same functionality as the base function plus the calculation of the derivative. It only adds the double Derivative(double* x, uint ivar) method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the second parameter. Example of implementing a multi-dimensional gradient function; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; 13.7.3 Parametric Function Interfaces; These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file Math/IParamFunction.h. See also the documentation of the ROOT::Fit classes in the Fitting chapter for more information. ROOT::Math::IParametricFunctionMultiDim: Describes a multi dimensional parametric function. Similarly to the one d",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:700558,Modifiability,Plug-In,Plug-In,700558,"ndl;. return 0;; }; 13.8 Numerical Integration; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. ROOT::Math::VirtualIntegrator defines the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in ROOT::Math::VirtualIntegratorOneDim and ROOT::Math::VirtualIntegratorMultiDim. These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance. These methods must be implemented in the concrete classes existing for the different integration algorithms. The user cannot create directly these virtual integrator interfaces. He needs to create the ROOT::Math::IntegratorOneDim class for integrating one-dimensional functions and ROOT::Math::IntegratorMultiDim for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize ROOT::Math::IntegratorOneDim or ROOT::Math::IntegratorMultiDim with any of the concrete integration classes without dealing with them directly. These two classes provide the same interface as in VirtualIntegratorOneDim and VirtualIntegratorMultiDim, but with the possibility to choose in the constructor, which method will be used to perform the integration.; The method to set the function to be integrated, must be of the function interface type described before. ROOT::Math::IBaseFunctionOneDimFunction is used for ROOT::Math::IBaseFunctionMultiDim and The only difference between the ROOT::Math::IntegratorOneDim and ROOT::Math::IntegratorMultiDim resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important to notice that the two grayed classes (the one w",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:705943,Modifiability,adapt,adaptive,705943,"); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; 13.8.2.2 ROOT::Math::GaussLegendreIntegrator; This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration. We can use the example above, but replacing the creation of a ROOT::Math::GaussIntegrator object with ROOT::Math::GaussLegendreIntegrator.; 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:706542,Modifiability,adapt,adaptive,706542,"le above, but replacing the creation of a ROOT::Math::GaussIntegrator object with ROOT::Math::GaussLegendreIntegrator.; 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707433,Modifiability,adapt,adaptive,707433," of the ROOT::Math::GSLIntegrator class.; // create the adaptive integrator with the 51 point rule; ROOT::Math::GSLIntegrator ig(ROOT::Math::Integration::kADAPTIVE, ROOT::Math::Integration::kGAUSS51);; ig.SetRelTolerance(1.E-6); // set relative tolerance; ig.SetAbsTolerance(1.E-6); // set absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the functi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:707688,Modifiability,adapt,adaptiva,707688,"t absoulte tolerance; The algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied \[; absErr <= max ( epsAbs, epsRel * Integral); \] Where absErr is an estimate of the absolute error (it can be retrieved with GSLIntegrator::Error()) and Integral is the estimate of the function integral (it can be obtained with GSLIntegrator::Result()); The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the GSL users documentation. * ROOT::Math::Integration::kNONADAPTIVE : based on gsl_integration_qng. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions. * ROOT::Math::Integration::kADAPTIVE: based on gsl_integration_qag. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are * Integration::kGAUSS15 : 15 points Gauss-Konrod rule (value = 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule is passed, the 31 points rule is used as default. ROOT::Math::Integration::kADAPTIVESINGULAR: based on gsl_integration_qags. It is an integration type which can be used in the case of the presence of singula",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:709360,Modifiability,Adapt,Adaptive,709360,"th functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule is passed, the 31 points rule is used as default. ROOT::Math::Integration::kADAPTIVESINGULAR: based on gsl_integration_qags. It is an integration type which can be used in the case of the presence of singularities.It uses the Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common ROOT::Math::IntegratorOneDIm class the enumeration type defining the algorithm must be defined in the namespace ROOT::Math::IntegrationOneDim (to distinguish from the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the ROOT::Math::IntegratorOneDIm.; 13.8.3 Multi-dimensional Integration; The multi-dimensional integration algorithm should be applied to functions with dimension larger than one. Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions.; 13.8.3.1 Using ROOT::Math::IntegratorMultiDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT.; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Functor wf(&f2,2);; double a[2] = {0,0};; double b[2] = {1,1};. ROOT::Math::IntegratorMultiDim ig(ROOT::Math::IntegrationMultiDim::kADAPTIVE);; ig.SetFunction(wf);; double val = ig.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFun",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711236,Modifiability,Adapt,AdaptiveIntegratorMultiDim,711236,"gral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig2(ROOT::Math::IntegrationMultiDim::kVEGAS);; ig2.SetFunction(wf);; val = ig2.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig3(wf,ROOT::Math::IntegrationMultiDim::kPLAIN);; val = ig3.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. ROOT::Math::IntegratorMultiDim ig4(wf,ROOT::Math::IntegrationMultiDim::kMISER);; val = ig4.Integral(a,b);; std::cout << ""integral result is "" << val << std::endl;; status += std::fabs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:711872,Modifiability,ADAPT,ADAPTIVE,711872,"bs(val-RESULT) > ERRORLIMIT;. return status;; }; 13.8.3.2 Multi-dimensions Integration Algorithms; Here is the types, that can be specified as enumeration and the corresponding classes. Enumeration name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712097,Modifiability,Adapt,AdaptiveIntegratorMultiDim,712097,"tion name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712150,Modifiability,adapt,adaptive,712150,"tion name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712273,Modifiability,adapt,adaptive,712273,"th:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713024,Modifiability,config,configuration,713024,"n adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least squa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:717634,Modifiability,plug-in,plug-in,717634," same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Histogram chapter.; 13.11 ROOT Finder Algorithms; The function must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object. Some of the algorithm requires the derivatives of the function. In that case a ROOT::Math::IGradientFunctionOneDim object must be provided.; 13.12 Generic Vectors for 2, 3 and 4 Dimensions (GenVector); GenVector is a package intended to represent vectors and their operations and transformations, such as rotations and Lorentz transformations, in 3 and 4 dimensions. The 3D space is used to describe the geometry vectors and points, while the 4D space-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719190,Modifiability,inherit,inherit,719190,"ons, in 3 and 4 dimensions. The 3D space is used to describe the geometry vectors and points, while the 4D space-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP and packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors an",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:720107,Modifiability,polymorphi,polymorphically,720107,"that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;; ROOT::Math::PositionVector2D and ROOT::Math::PositionVector3D template classes modeling the points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them, ROOT::Math::LorentzVector, since we have recognized a limited need for modeling the functionality of a 4D point.; 13.12.1.3 Generic Coordinate System; The vecto",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:720146,Modifiability,inherit,inheriting,720146,"that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;; ROOT::Math::PositionVector2D and ROOT::Math::PositionVector3D template classes modeling the points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them, ROOT::Math::LorentzVector, since we have recognized a limited need for modeling the functionality of a 4D point.; 13.12.1.3 Generic Coordinate System; The vecto",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:767373,Modifiability,extend,extended,767373,"within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.; TMultiDimFit implements multi-dimensional function parametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy con",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:767507,Modifiability,variab,variables,767507,"within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.; TMultiDimFit implements multi-dimensional function parametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy con",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:770220,Modifiability,inherit,inherit,770220," more straightforward this way. When stored only the upper-right part is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805621,Modifiability,inherit,inherits,805621," light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805669,Modifiability,Inherit,InheritsFrom,805669," light-weight TObject class provides the default behavior and protocol for the objects in the ROOT system. Specifically, it is the primary interface to classes providing object I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805730,Modifiability,inherit,inherits,805730,"ect I/O, error handling, inspection, introspection, and drawing. The interface to this service is via abstract classes.; 15.1.1 Introspection, Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805797,Modifiability,Inherit,InheritsFrom,805797," Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805837,Modifiability,Inherit,InheritsFrom,805837," Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805953,Modifiability,variab,variable,805953," Reflection and Run Time Type Identification; Introspection, which is also referred to as reflection, or run time type identification (RTTI) is the ability of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:805988,Modifiability,inherit,inheritance,805988," of a class to reflect upon itself or to ""look inside itself. ROOT implements reflection with the TClass class. It provides all the information about a class, a full description of data members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be executed.; 15.1.3 Input/Output; The TObject::Write method is the interface to the ROOT I/O system. It streams the object into a buffer using the Streamer m",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:806265,Modifiability,inherit,inheritance,806265,"a members and methods, including the comment field and the method parameter types. A class with the ClassDef macro has the ability to obtain a TClass with the IsA method.; TClass *cl = obj->IsA();; It returns a TClass. In addition, an object can directly get the class name and the base classes by:; const char* name = obj->ClassName();; If the class is a descendent of TObject, you can check if an object inherits from a specific class, you can use the InheritsFrom method. This method returns kTrue if the object inherits from the specified class name or TClass.; Bool_t b = obj->InheritsFrom(""TLine"");; Bool_t b = obj->InheritsFrom(TLine::Class());; ROOT and Cling rely on reflection and the class dictionary to identify the type of a variable at run time. With TObject inheritance come some methods that use Introspection to help you see the data in the object or class. For instance:; obj->Dump(); // lists all data members and their current values; obj->Inspect(); // opens a window to browse data members; obj->DrawClass(); // Draws the class inheritance tree; For an example of obj->Inspect(), see “Inspecting Objects”.; 15.1.2 Collections; To store an object in a ROOT collection, it must be a descendent of TObject. This is convenient if you want to store objects of different classes in the same collection and execute the method of the same name on all members of the collection. For example, the list of graphics primitives are in a ROOT collection called TList. When the canvas is drawn, the Paint method is executed on the entire collection. Each member may be a different class, and if the Paint method is not implemented, TObject::Paint will be executed.; 15.1.3 Input/Output; The TObject::Write method is the interface to the ROOT I/O system. It streams the object into a buffer using the Streamer method. It supports cycle numbers and automatic schema evolution. See “Input/Output”.; 15.1.4 Paint/Draw; These graphics methods are defaults; their implementation in TObject does not u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:809326,Modifiability,inherit,inheriting,809326,". The purpose of SavePrimitve is to save a primitive as a C++ statement(s). Most ROOT classes implement the SavePrimitive method. It is recommended that the SavePrimitive is implemented in user defined classes if it is to be drawn on a canvas. Such that the command TCanvas::SaveAs(Canvas.C) will preserve the user-class object in the resulting script.; 15.1.8 GetObjectInfo; This method is called when displaying the event status in a canvas. To show the event status window, select the Options menu and the EventStatus item. This method returns a string of information about the object at position (x, y). Every time the cursor moves, the object under the cursor executes the GetObjectInfo method. The string is then shown in the status bar. There is a default implementation in TObject, but it is typically overridden for classes that can report peculiarities for different cursor positions (for example the bin contents in a TH1).; 15.1.9 IsFolder; By default an object inheriting from TObject is not brows-able, because TObject::IsFolder() returns kFALSE. To make a class browse-able, the IsFolder method needs to be overridden to return kTRUE. In general, this method returns kTRUE if the object contains browse-able objects (like containers or lists of other objects).; 15.1.10 Bit Masks and Unique ID; A TObject descendent inherits two data members: fBits and fUniqueID. fBitsis 32-bit data member used with a bit mask to get object information. Bits 0 - 13 are reserved as global bits, bits 14 - 23 can be used in different class hierarchies.; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:809683,Modifiability,inherit,inherits,809683," the resulting script.; 15.1.8 GetObjectInfo; This method is called when displaying the event status in a canvas. To show the event status window, select the Options menu and the EventStatus item. This method returns a string of information about the object at position (x, y). Every time the cursor moves, the object under the cursor executes the GetObjectInfo method. The string is then shown in the status bar. There is a default implementation in TObject, but it is typically overridden for classes that can report peculiarities for different cursor positions (for example the bin contents in a TH1).; 15.1.9 IsFolder; By default an object inheriting from TObject is not brows-able, because TObject::IsFolder() returns kFALSE. To make a class browse-able, the IsFolder method needs to be overridden to return kTRUE. In general, this method returns kTRUE if the object contains browse-able objects (like containers or lists of other objects).; 15.1.10 Bit Masks and Unique ID; A TObject descendent inherits two data members: fBits and fUniqueID. fBitsis 32-bit data member used with a bit mask to get object information. Bits 0 - 13 are reserved as global bits, bits 14 - 23 can be used in different class hierarchies.; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; For example, the bits kMustCleanup and kCanDelete are used in TObject. See “The kCanDelete Bit” and “The kMustCleanup Bit”. They can be set by any object and should not be reused. Make sure not to overlap them in any given hierarchy. The bit 13 (kInvalidObject)",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:825031,Modifiability,inherit,inheriting,825031,"will not be available to you for these classes. See “Cling the C++ Interpreter”. The ShowMembers and Streamer method, as well as the >> operator overloads, are implemented only if you use ClassDef and ClassImp. See $ROOTSYS/include/Rtypes.h for the definition of ClassDef and ClassImp. To exclude a data member from the Streamer, add a ! as the first character in the comments of the field:; Int_t fTempValue; //! temporary state value; 15.5.1 The LinkDef.h File; Step 3: The LinkDef.h file tells rootcling which classes should be added to the dictionary.; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; Three options can trail the class name:. - : tells rootcling not to generate the Streamer method for this class. This is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from TObject. #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator. + : in ROOT version 1 and 2 tells rootcling to generate a Streamer with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a Streamer method is out of sync with data in the file. The + option is mutual exclusive with both the - and ! options. IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells rootcling to use the new I/O system. The byte count check is always added. The new I/O system has many advantages including support automatic schema evolution, full support for STL collections and better run-time performance. We strongly recommend using it.; #pragma link C++ class SClass+; // add byte count; For information on Streamers see “Input/Output”. To get help on rootcling type on the UNIX command line: ro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:828461,Modifiability,variab,variables,828461,"edef];; #pragma link [C|C++|off]; [class|struct|union|enum|namespace|protected][name];; #pragma link [C|C++|off] [global|typedef][name];; #pragma link [C|C++|off] [nestedclass|nestedtypedef];. #pragma link [C++|C|off|MACRO] function [name]<(argtypes)>;; #pragma link; [C++|C|off|MACRO] function [classname]::[name]<(argtypes)>;; #pragma link off all methods;; #pragma link [C|C++|off] defined_in [filename];; #pragma link; [C|C++|off] defined_in [class|struct|namespace] [name];; #pragma link [C|C++|off] all_function [classname];; #pragma link [C|C++|off] all_datamember [classname];; The [classname] and the [name] can also contain wildcards. For example:; #pragma link C++ class MyClass*;; This will request the dictionary for all the class whose name start with 'MyClass' and are already known to Cling (class templates need to have already been instantiated to be considered).; #pragma link [C|C++|off] all [class|function|global|typedef];; This pragma statement turns on or off the dictionary generation for all classes, structures, namespaces, global variables, global functions and typedefs seen so far by Cling. Example:; // some C++ header definition; #ifdef __ROOTCLING__; // turns off dictionary generation for all; #pragma link off all class;; #pragma link off all function;; #pragma link off all global;; #pragma link off all typedef;; #endif; The next pragma statement selectively turns on or off the dictionary generation for the specified classs, struct, union, enum or namespace:; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; The Dictionary of all public members of class and struct will be generated. If the ‘class+protected’ flag is used, the dictionary for protected members will also be generated. However, dictionary for protected constructor and destructor will not be generated. This ’ class+protected ’ flag will help you only for plain protected member access, but not for virtual function resolution.; If you use the ‘namespace’ fl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:829990,Modifiability,variab,variables,829990,"tively turns on or off the dictionary generation for the specified classs, struct, union, enum or namespace:; #pragma link; [C|C++|off][class|class+protected|; struct|union|enum|namespace][name];; The Dictionary of all public members of class and struct will be generated. If the ‘class+protected’ flag is used, the dictionary for protected members will also be generated. However, dictionary for protected constructor and destructor will not be generated. This ’ class+protected ’ flag will help you only for plain protected member access, but not for virtual function resolution.; If you use the ‘namespace’ flag, it is recommended to add also:; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; The behavior of ‘class’, ‘struct’ and ‘namespace’ flag are identical. Example:; // some C++ header definition; #ifdef __ROOTCLING__; #pragma link off all class;; #pragma link C++ class A;; #pragma link C++ class B;; #pragma link C++ class C<int>;; #pragma link C++ class+protected D;; #pragma link C++ namespace project1;; #pragma link C++ nestedclass;; #pragma link C++ nestedtypedef;; #endif; The next pragma statement selectively turns on or off the dictionary generation for global variables and typedef.; #pragma link [C|C++|off] [global|typedef] [name];; Example:; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; This pragma statement turns on the dictionary generation for nested classes and nested typedefs.; #pragma link [C|C++|off] [nestedclass|nestedtypedef];; Example:; // some C/C++ header definition; #ifdef __ROOTCLING__; #pragma link off all global;; #pragma link off all typedef;; #pragma link C++ global a;; #pragma link C++ typedef Int_t;; #endif; The next pragma statements turn on or off the dictionary generation for the specified function(s) or member function(s). The list of arguments’ type is optional. If you omit argument ty",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:838326,Modifiability,inherit,inherit,838326,"ucture of the selection XML files and the way in which attributes can be set, refer to the genreflex --help command.; It is important to observe that selection XML files can be used in presence of rootcling invocations instead of LinkDef files.; 15.6.1 The ROOT::Meta::Selection namespace; Not only LinkDef and selection files allow to select the classes for which the dictionaries must be created: a third method is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes which are located in this special namespace are automatically selected for dictionary generation. All the properties and annotations allowed by LinkDef and selection XML files are possible. For a detailed documentation of the features of the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instanc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:839094,Modifiability,parameteriz,parameterized,839094,"the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:839127,Modifiability,polymorphi,polymorphic,839127,"the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:840384,Modifiability,flexible,flexible,840384,"ps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines. A set of widgets for a graphical user interface can be placed in a collection. A geometrical model can be described by collections of shapes, materials and rotation matrices. Collections can themselves be placed in collections. Collections act as flexible alternatives to traditional data structures of computers science such as arrays, lists and trees.; 16.1.1 General Characteristics; The ROOT collections are polymorphic containers that hold pointers to TObjects, so:. They can only hold objects that inherit from TObject; They return pointers to TObjects, that have to be cast back to the correct subclass. Collections are dynamic; they can grow in size as required. Collections themselves are descendants of TObject so can themselves be held in collections. It is possible to nest one type of collection inside another to any level to produce structures of arbitrary complexity.; Collections do not own the objects they hold for the very good reason that the same object could be a member of more than one collection. Object ownership is important when it comes to deleting objects; if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its obje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:840549,Modifiability,polymorphi,polymorphic,840549,"d modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines. A set of widgets for a graphical user interface can be placed in a collection. A geometrical model can be described by collections of shapes, materials and rotation matrices. Collections can themselves be placed in collections. Collections act as flexible alternatives to traditional data structures of computers science such as arrays, lists and trees.; 16.1.1 General Characteristics; The ROOT collections are polymorphic containers that hold pointers to TObjects, so:. They can only hold objects that inherit from TObject; They return pointers to TObjects, that have to be cast back to the correct subclass. Collections are dynamic; they can grow in size as required. Collections themselves are descendants of TObject so can themselves be held in collections. It is possible to nest one type of collection inside another to any level to produce structures of arbitrary complexity.; Collections do not own the objects they hold for the very good reason that the same object could be a member of more than one collection. Object ownership is important when it comes to deleting objects; if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:840641,Modifiability,inherit,inherit,840641,"tions and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables. 16.1 Understanding Collections; A collection is a group of related objects. You will find it easier to manage a large number of items as a collection. For example, a diagram editor might manage a collection of points and lines. A set of widgets for a graphical user interface can be placed in a collection. A geometrical model can be described by collections of shapes, materials and rotation matrices. Collections can themselves be placed in collections. Collections act as flexible alternatives to traditional data structures of computers science such as arrays, lists and trees.; 16.1.1 General Characteristics; The ROOT collections are polymorphic containers that hold pointers to TObjects, so:. They can only hold objects that inherit from TObject; They return pointers to TObjects, that have to be cast back to the correct subclass. Collections are dynamic; they can grow in size as required. Collections themselves are descendants of TObject so can themselves be held in collections. It is possible to nest one type of collection inside another to any level to produce structures of arbitrary complexity.; Collections do not own the objects they hold for the very good reason that the same object could be a member of more than one collection. Object ownership is important when it comes to deleting objects; if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:841945,Modifiability,Inherit,InheritsFrom,841945,"held in collections. It is possible to nest one type of collection inside another to any level to produce structures of arbitrary complexity.; Collections do not own the objects they hold for the very good reason that the same object could be a member of more than one collection. Object ownership is important when it comes to deleting objects; if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842028,Modifiability,Inherit,InheritsFrom,842028,"e very good reason that the same object could be a member of more than one collection. Object ownership is important when it comes to deleting objects; if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollect",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842231,Modifiability,Inherit,InheritsFrom,842231," if nobody owns the object it could end up as wasted memory (i.e. a memory leak) when no longer needed. If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison fun",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842272,Modifiability,Inherit,InheritsFrom,842272," If a collection is deleted, its objects are not. The user can force a collection to delete its objects, but that is the user’s choice.; 16.1.2 Determining the Class of Contained Objects; Most containers may hold heterogeneous collections of objects and then it is left to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842577,Modifiability,inherit,inheritance,842577,"ft to the user to correctly cast the TObject pointer to the right class. Casting to the wrong class will give wrong results and may well crash the program! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:842719,Modifiability,inherit,inheritance,842719,"gram! Therefore, the user has to be very careful. Often a container only contains one class of objects, but if it really contains a mixture, it is possible to ask each object about its class using the InheritsFrom method.; For example if myObject is a TObject pointer:; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; As the name suggests, this test works even if the object is a subclass of TParticle. The member function IsA() can be used instead of InheritsFrom to make the test exact. The InheritsFrom and IsA methods use the extensive Run Time Type Information (RTTI) available via the ROOT meta-classes.; 16.1.3 Types of Collections; The ROOT system implements the following basic types of collections: unordered collections, ordered collections and sorted collections. Next figure shows the inheritance hierarchy for the primary collection classes. All primary collection classes derive from the abstract base class TCollection. The inheritance hierarchy of the primary collection classes. 16.1.4 Ordered Collections (Sequences); Sequences are collections that are externally ordered because they maintain internal elements according to the order in which they were added. The following sequences are available:. TList; THashList; TOrdCollection; TObjArray; TClonesArray. The TOrdCollection, TObjArray as well as the TClonesArray can be sorted using their Sort() member function (for this, the stored objects must provide a comparison function by overriding TObject::Compare() and also must enable sorting by overriding TObject::IsSortable() to return true). Ordered collections all derive from the abstract base class TSeqCollection. Sorted collections are ordered by an internal (automatic) sorting mechanism. The following sorted collections are available (the stored items must be sortable):. TSortedList; TBtree. Unordered collections don’t maintain the order in which the elements were added, i.e. when you iterate over an unordered collection, you are ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:849236,Modifiability,inherit,inherits,849236,"ublic:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as follows:. To create a TIter object its constructor must be passed an object that inherits from TCollection. The TIter constructor calls the MakeIterator() method of this collection to get the appropriate iterator object that inherits from TIterator.; The Next() and Reset() methods of TIter simply call the Next() and Reset() methods of the iterator object. Therefore, TIter simply acts as a wrapper for an object of a concrete class inheriting from TIterator.; To see this working in practice, consider the TObjArray collection. Its associated iterator is TObjArrayIter. Suppose myarray is a pointer to a TObjArray that contains MyClass objects, i.e.; TObjArray *myarray;; To create a TIter object called myiter:; TIter myiter(myarray);. As shown in the diagram, this results in several methods being called:. The TIter constructor is passed a TObjArray; TIter asks embedded TCollection to make an iterator; TCollection asks TObjArray to make an iterator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:849380,Modifiability,inherit,inherits,849380,"urn num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as follows:. To create a TIter object its constructor must be passed an object that inherits from TCollection. The TIter constructor calls the MakeIterator() method of this collection to get the appropriate iterator object that inherits from TIterator.; The Next() and Reset() methods of TIter simply call the Next() and Reset() methods of the iterator object. Therefore, TIter simply acts as a wrapper for an object of a concrete class inheriting from TIterator.; To see this working in practice, consider the TObjArray collection. Its associated iterator is TObjArrayIter. Suppose myarray is a pointer to a TObjArray that contains MyClass objects, i.e.; TObjArray *myarray;; To create a TIter object called myiter:; TIter myiter(myarray);. As shown in the diagram, this results in several methods being called:. The TIter constructor is passed a TObjArray; TIter asks embedded TCollection to make an iterator; TCollection asks TObjArray to make an iterator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member of the TObjArray:; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; The hea",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:849589,Modifiability,inherit,inheriting,849589,"onst; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; 16.5 The TIter Generic Iterator; As stated above, the TIterator class is abstract; it is not possible to create TIterator objects. However, it should be possible to write generic code to process all members of a collection so there is a need for a generic iterator object. A TIter object acts as generic iterator. It provides the same Next() and Reset() methods as TIterator although it has no idea how to support them! It works as follows:. To create a TIter object its constructor must be passed an object that inherits from TCollection. The TIter constructor calls the MakeIterator() method of this collection to get the appropriate iterator object that inherits from TIterator.; The Next() and Reset() methods of TIter simply call the Next() and Reset() methods of the iterator object. Therefore, TIter simply acts as a wrapper for an object of a concrete class inheriting from TIterator.; To see this working in practice, consider the TObjArray collection. Its associated iterator is TObjArrayIter. Suppose myarray is a pointer to a TObjArray that contains MyClass objects, i.e.; TObjArray *myarray;; To create a TIter object called myiter:; TIter myiter(myarray);. As shown in the diagram, this results in several methods being called:. The TIter constructor is passed a TObjArray; TIter asks embedded TCollection to make an iterator; TCollection asks TObjArray to make an iterator; TObjArray returns a TObjArrayIter. Now define a pointer for MyClass objects and set it to each member of the TObjArray:; MyClass *myobject;; while ((myobject = (MyClass *)myiter.Next())) {; // process myobject; }; The heart of this is the myiter.Next() expression which does the following:. The Next() method of the TIter object myiter is called; The TIter forwards the call to the TIterator embedded in the TObjArrayIter; TIterator forwards the call t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855585,Modifiability,polymorphi,polymorphic,855585," of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicate",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:856618,Modifiability,parameteriz,parameterized,856618,"like polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicates that T is a template, or parameterized class. If we need an ArrayContainer for Track objects, it can be created by:; ArrayContainer<Track> MyTrackArrayContainer;; C++ takes the parameter list and substitutes Track for T throughout the definition of the class ArrayContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:859612,Modifiability,variab,variables,859612,"rgy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensions and is not part of the CLHEP translation.; 17.2 TVector3. TVector3 is a general three-vector class, which can be used for description of different vectors in 3D. Components of three vectors:. \(x\), \(y\), \(z\) = basic components; \(\theta\) = azimuth angle; \(\phi\) = polar angle; magnitude = \(mag\) = \(\sqrt{x^2 + y^2 + z^2}\); transverse component = \(perp\) = \(\sqrt{x^2 + y^2}\). Using the TVector3 class, you should remember that it contains only common features of three vectors and lacks methods specific for some particular vector values. For example, it has no translated function because translation has no meaning for vectors.; 17.2.1 Declaration / Access to the Components; TVector3 has been implemented as a vector of three Double_t variables, representing the Cartesian coordinates. By default the values are initialized to zero, however you can change them in the constructor:; TVector3 v1; // v1 = (0,0,0); TVector3 v2(1); // v2 = (1,0,0); TVector3 v3(1,2,3); // v3 = (1,2,3); TVector3 v4(v2); // v4 = v2; It is also possible (but not recommended) to initialize a TVector3 with a Double_t or Float_t C array. You can get the components by name or by index:; xx = v1.X(); or xx = v1(0);; yy = v1.Y(); yy = v1(1);; zz = v1.Z(); zz = v1(2);; The methods SetX(), SetY(), SetZ() and SetXYZ() allow you to set the components:; v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);; v1.SetXYZ(1.,2.,3.);; 17.2.2 Other Coordinates; To get information on the TVector3 in spherical (rho, phi, theta) or cylindrical (z, r, theta) coordinates, the following methods can be used.; Double_t m = v.Mag();; // get magnitude (=rho=Sqrt(x*x+y*y+z*z))); Double_t m2 = v.Mag2(); // get magnitude squared; Double_t t = v.Theta(); // get pol",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:866489,Modifiability,variab,variable,866489,"ollows the mathematical notation of a product of the two matrices which describe the two consecutive rotations. Therefore, the second rotation should be placed first:; r = r2 * r1;; 17.3.7 Rotation of TVector3; The TRotation class provides an operator * which allows expressing a rotation of a TVector3 analog to the mathematical notation:; \[; \left|; \begin{array}{c}; x' \\; y' \\; z'; \end{array}; \right|; =; \left|; \begin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|; \times; \left|; \begin{array}{c}; x \\; y \\; z; \end{array}; \right|; \]; TRotation r;; TVector3 v(1,1,1);; v = r * v;; You can also use the Transform() method or the operator *= of the TVector3 class:; TVector3 v;; TRotation r;; v.Transform(r);; 17.4 TLorentzVector; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E).; 17.4.1 Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable. By default, all components are initialized by zero.; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; For backward compatibility there are two constructors from a Double_t and Float_t array.; 17.4.2 Access to Components; There are two sets of access functions to the components of a TLorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combination of position and time and the second set is more relevant where TLorentzVector describes momentum and energy:; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; You can use the Vect",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:869727,Modifiability,parameteriz,parameterized,869727,"rithmetic and Comparison Operators; The TLorentzVector class provides operators to add subtract or compare four-vectors:; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; if (v1 == v2) {...}; if (v1 != v3) {...}; 17.4.5 Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+)metric:; s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therefore:; mag2 = v*v = t*t-x*x-y*y-z*z; If mag2 is negative: mag = -Sqrt(-mag*mag). The methods are:; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; Since in case of momentum and energy the magnitude has the meaning of invariant mass TLorentzVector provides the more meaningful aliases M2() and M(). The methods Beta() and Gamma() returns beta and gamma = 1/Sqrt(1-beta*beta).; 17.4.6 Lorentz Boost; A boost in a general direction can be parameterized with three parameters which can be taken as the components of a three vector b=(bx,by,bz). With x=(x,y,z) and gamma=1/Sqrt(1-beta*beta) (beta being the module of vector b), an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:; x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b; t = gamma(t'+ b*x'); The Boost() method performs a boost transformation from the rod frame to the original frame. BoostVector() returns a TVector3 of the spatial components divided by the time component:; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); 17.4.7 Rotations; There are four sets of functions to rotate the TVector3 component of a TLorentzVector:; Around Axes:; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; Around an arbitrary axis:; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; Transformation from rotated frame:; v.RotateUz(direction); // direction must be a unit TVector3; Rotation by TRotation:;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:890896,Modifiability,evolve,evolve,890896,"ving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:898169,Modifiability,inherit,inheritance,898169," normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinations. You can have a look and run the tutorial: http://root.cern.ch/root/html/examples/geodemo.C.html. Primitive Shapes - the general inheritance scheme. Shapes are named objects and all primitives have constructors like:; TGeoXXX(const char *name,<type> param1,<type> param2, ...);; TGeoXXX(<type> param1,<type> param2, ...);; Naming shape primitive is mandatory only for the primitives used in Boolean composites (see “Composite Shapes”). For the sake of simplicity, we will describe only the constructors in the second form.; 18.3.1 Units; The length units used in the geometry are arbitrary. However, there are certain functionalities that work with the assumption that the used lengths are expressed in centimeters. This is the case for shape capacity or volume weight computation. The same is valid when using the ROOT geometry as navigator for an external transport MC package (e.g. GEANT) via the VMC interface.; Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in degrees. Material density is expressed in [g/cm3].; 18.3.2 Primitive Shapes; 18.3.2.1 Boxes - TGeo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:914715,Modifiability,extend,extend,914715,"by a point and the normal direction. The point lies on the plane and the normal vector points outside the half space. The half space is the only shape which is infinite and can be used only in Boolean operations that result in non-infinite composite shapes (see also “Composite Shapes” below). A half space has to be defined using the constructor:. TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; 18.3.3 Composite Shapes; Composite shapes are Boolean combinations of two or more shape components. The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base TGeoShape class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This CSG (composite solid geometry) hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.; 18.3.3.1 The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branchin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:926049,Modifiability,parameteriz,parameterizations,926049,"ven axis. Supported axes are: X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes are performed by the call TGeoShape::Divide(), but this operation can be done only via TGeoVolume::Divide() method. In other words, the algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in the paragraph ‘Dividing volumes’. One can see how all division options are interpreted and which their result inside specific shape classes is.; 18.3.7 Parametric Shapes; Shapes generally have a set of parameters that is well defined at build time. In fact, when the final geometrical hierarchy is assembled and the geometry is closed, all constituent shapes MUST**have well defined and valid parameters. In order to ease-up geometry creation, some parameterizations are however allowed.; For instance let’s suppose that we need to define several volumes having exactly the same properties but different sizes. A way to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a single volume having undefined shape parameters.; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);. name: the name of the newly created volume;; shape:the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. “tubs” will match TGeoTubeSeg, “bbox” will match TGeoBBox); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:927106,Modifiability,parameteriz,parameterizations,927106,"d to define several volumes having exactly the same properties but different sizes. A way to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a single volume having undefined shape parameters.; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);. name: the name of the newly created volume;; shape:the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. “tubs” will match TGeoTubeSeg, “bbox” will match TGeoBBox); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ‘Creating and Positioning Volumes’).; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume TGeoVolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, h",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:927807,Modifiability,parameteriz,parameterization,927807,"for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ‘Creating and Positioning Volumes’).; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume TGeoVolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.; Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.; Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: “The Drawing Package”) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:940857,Modifiability,inherit,inherit,940857,"oved or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; 18.4.2.4 Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be “invisible” at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is dire",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:972661,Modifiability,variab,variables,972661,"ed to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:973002,Modifiability,variab,variables,973002,"lize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; 18.5.3 Initializing the Direction; In order to move inside geometry starting with the current point, the modeller needs to know the current direction (nx,ny,nz). This direction is stored as Dou",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:976513,Modifiability,variab,variables,976513,"entNode();; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘Where am I?' method:; gGeoManager->FindNode();; In order to have more flexibility, there are in fact several alternative ways of initializing a modeller state:; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the ‘Where am I?' geometrical query representing the basic navigation functionality provided by the modeller.; 18.5.5 Checking the Current State; The current state and all variables related to this are essential during tracking and have to be checked several times. Besides the current point and direction, the following additional information can be retrieved from TGeoManager interface:. The current path. This represents a string containing the names and copy numbers of all positioned objects in the current branch written in the /folder/folder/…/folder/file fashion. The final node pointed by the path is the deepest object containing the current point and is representative for the current state. All intermediate folders in the path are in fact also nodes “touched” by the current point, but having some “touched” containment. The current path can be retrieved only after the state was initialized and is useful for getting an idea of the current point location. const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1. The current node,volume and material. In order to take decisions on post-step or further stepping actions, one h",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:993775,Modifiability,inherit,inheriting,993775," simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle object (may be a TParticle).; A track has a list of daughters that have to be filled using the following method:; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; The method above is pure virtual and have to create a track daughter object. Tracks are fully customizable objects when inheriting from TVirtualGeoTrack class. We will describe the structure and functionality provided by the default implementation of these, which are TGeoTrack objects.; A TGeoTrack is storing a list of control points (x,y,z) belonging to the track, having also time information (t). The painting algorithm of such tracks allows drawing them in any time interval after their creation. The track position at a given time is computed by interpolation between control points.; myTrack->AddPoint(x,y,z,t);; The creation and management of tracks is in fact fully controlled by the TGeoManager class. This holds a list of primary tracks that is also visible during browsing as Tracks folder. Primary tracks are tracks having no parent in the tracking history (for instance the output of particle generators may be considered as primaries from tracking point of view). The manager class holds inTGeoManager::fCurrentTrack a pointer to the current track. When starting tracking a particle, one can create a t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:996346,Modifiability,variab,variable,996346,"fId(user_id);; ptrTrack = gGeoManager->GetTrack(index);; Supposing a particle represented by a primary track decays or interacts, one should not create new primaries as described before, but rather add them as secondary:; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; At any step made by the current track, one is able to add control points to either primary or secondary:; track->AddPoint(x,y,z,t);; After tracks were defined and filled during tracking, one will be able to browse directly the list of tracks held by the manager class. Any track can be drawn using its Draw() and Animate() methods, but there are also global methods for drawing or animation that can be accessed from TGeoManager context menu:; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004623,Modifiability,plug-in,plug-in,1004623,"s the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1009363,Modifiability,inherit,inherit,1009363,"eed is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();; 18.7.2 Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; 18.7.2.1 Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1019982,Modifiability,variab,variables,1019982,"name="""",; Option_t *opt=""""); Example:; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to TGeoVolume objects):; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; Importing will append the volume to the current TGeoManager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVol",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1021681,Modifiability,config,configure,1021681,"nager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; 18.9.1 GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call.; 18.10 Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms.; 18.10.1 Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable’ object in the geometry hierarchy. It is represented by a path like: /TOP_1/A_1/B_3/C_1, where B_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP_1, MA_",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1032546,Modifiability,plug-in,plug-in,1032546,"s not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry ob",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1041343,Modifiability,extend,extending,1041343,"es are dynamically activated once all the required components are defined.; Create a volume from the “Volumes” category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to “General” category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046319,Modifiability,variab,variables,1046319,"s first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTH",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1047821,Modifiability,config,configuration,1047821,"te. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]; For details on <arch> see the official build pages, the Python include directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1047986,Modifiability,config,configure,1047986," cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]; For details on <arch> see the official build pages, the Python include directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Py",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1048084,Modifiability,config,configure,1048084,"xport LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]; For details on <arch> see the official build pages, the Python include directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you cont",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1048519,Modifiability,config,configuration,1048519,"<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]; For details on <arch> see the official build pages, the Python include directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you continue the build process the normal way:; $ make; $ make install; After some time, a library called libPyROOT.so (or libPyROOT.dll, on Windows) will be created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1048576,Modifiability,variab,variable,1048576,"<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]; For details on <arch> see the official build pages, the Python include directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you continue the build process the normal way:; $ make; $ make install; After some time, a library called libPyROOT.so (or libPyROOT.dll, on Windows) will be created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1049167,Modifiability,config,configured,1049167,"de directory should point to the directory that contains Python.h and the library directory should point to the directory containing libpythonx.y.so, where ‘x’ and ‘y’ are the major and minor version number, respectively. If you do not specify include and library directories explicitly, the configuration process will try the PYTHONDIR environment variable or, alternatively, the standard locations.; A recent distribution of Python is required: version 2.4.3 is preferred, but the older 2.2.x and 2.3.x versions suffice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you continue the build process the normal way:; $ make; $ make install; After some time, a library called libPyROOT.so (or libPyROOT.dll, on Windows) will be created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1049781,Modifiability,config,configuration,1049781,"fice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you continue the build process the normal way:; $ make; $ make install; After some time, a library called libPyROOT.so (or libPyROOT.dll, on Windows) will be created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1049831,Modifiability,config,configuration,1049831,"fice and are supported as well. Versions older than 2.2 are not supported and will not work. Note that one problem with 2.2 is that the shared library of the Python interpreter core is not build by default and the ‘–enable-shared’ flag should thus be used when building Python from source. If the Python interpreter that is installed on your system is too old, please obtain a new version from http://www.python.org.; Once configured, you continue the build process the normal way:; $ make; $ make install; After some time, a library called libPyROOT.so (or libPyROOT.dll, on Windows) will be created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053747,Modifiability,variab,variable,1053747,"ting the meta class with the proper parameters, you get an actual class, which can then be used to create object instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT impo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057635,Modifiability,variab,variable,1057635,"e automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057812,Modifiability,variab,variable,1057812,"ile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.g",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1066244,Modifiability,parameteriz,parameterize,1066244,"It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the __call__ member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall contain the x, y, z, and t values for the call. The second array, which is optional and its size depends on the number given to the TF1 constructor, contains the values that parameterize the function. For more details, see the TF1 documentation and the examples below.; 19.1.8.1 Plotting Python Function; This is an example of a parameter less Python function that is plotted on a default canvas:; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); Because no number of parameters is given to the TF1 constructor, ‘0’ (the default) is assumed. This way, the ‘identity' function need not handle a second argument, which would normally be used to pass the function parameters. Note that the argument’x’ is an array of size 4. The following is an example of a parameterized Python callable instance that is plotted on a default canvas:; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function with offset 5, and pitch 2; f =",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1066953,Modifiability,parameteriz,parameterized,1066953,"vide for one or two arrays. The first array, which must always be present, shall contain the x, y, z, and t values for the call. The second array, which is optional and its size depends on the number given to the TF1 constructor, contains the values that parameterize the function. For more details, see the TF1 documentation and the examples below.; 19.1.8.1 Plotting Python Function; This is an example of a parameter less Python function that is plotted on a default canvas:; from ROOT import TF1, TCanvas. def identity( x ):; return x[0]. # create an identity function; f = TF1('pyf1', identity, -1., 1.). # plot the function; c = TCanvas(); f.Draw(); Because no number of parameters is given to the TF1 constructor, ‘0’ (the default) is assumed. This way, the ‘identity' function need not handle a second argument, which would normally be used to pass the function parameters. Note that the argument’x’ is an array of size 4. The following is an example of a parameterized Python callable instance that is plotted on a default canvas:; from ROOT import TF1, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function with offset 5, and pitch 2; f = TF1('pyf2',Linear(),-1.,1.,2); f.SetParameters(5.,2.). # plot the function; c = TCanvas(); f.Draw(); Note that this time the constructor is told that there are two parameters, and note in particular how these parameters are set. It is, of course, also possible (and preferable if you only use the function for plotting) to keep the parameters as data members of the callable instance and use and set them directly from Python.; 19.1.8.2 Fitting Histograms; Fitting a histogram with a Python function is no more difficult than plotting: instantiate a TF1 with the Python callable and supply that TF1 as a parameter to the Fit() member function of the histogram. After the fit, you can retrieve the fit parameters from the TF1 instance. For example:; from ROOT import TF1, TH1F, TCanvas. class Lin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1077502,Modifiability,variab,variable,1077502,"s. gui viewer .cxx; Another ROOT GUI example program. Hello.cxx; Dancing text example. Aclock.cxx; Analog clock (a la X11 xclock). Tetris.cxx; The known Tetris game based on the ROOT graphics. stress.cxx; Important ROOT stress testing program. stress*.cxx; Stress testing of different ROOT classes. bench.cxx; STL and ROOT container test and benchmarking program. QpRandomDriver.cx x; Verification program for Quadratic programming classes in Quadp library. DrawTest.sh; Entry script to extensive TTree query test suite. dt_*; Scripts used by DrawTest.sh. The $ROOTSYS/test directory is a gold mine of root-wisdom nuggets, and we encourage you to explore and exploit it. These instructions will compile all programs in $ROOTSYS/test:; If you do not have write permission in the $ROOTSYS/test directory, copy the entire $ROOTSYS/test directory to your area. The Makefile is a useful example of how ROOT applications are linked and built. Edit the Makefile to specify your architecture by changing the ARCH variable, for example, on an SGI machine type:ARCH = sgikcc.; Now compile all programs:; % gmake; This will build several applications and shared libraries. We are especially interested in Event, stress, and guitest.; 20.2.1 Event - An Example of a ROOT Application; Event is created by compiling MainEvent.cxx, and Event.cxx. It creates a ROOT file with a tree and two histograms. When running Event we have four optional arguments with defaults:. Argument; Default. 1; Number of Events (1 … n); 400. 2; Compression level:; 0: no compression at all.; 1: If the split level is set to zero, everything is compressed according to the gzip level 1. If split level is set to 1, leaves that are not floating point numbers are compressed using the gzip level 1.; 2: If the split level is set to zero, everything is compressed according to the gzip level 2. If split level is set to 1, all non floating point leaves are compressed according to the gzip level 2 and the floating point leaves are compress",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1078857,Modifiability,variab,variable,1078857,"MainEvent.cxx, and Event.cxx. It creates a ROOT file with a tree and two histograms. When running Event we have four optional arguments with defaults:. Argument; Default. 1; Number of Events (1 … n); 400. 2; Compression level:; 0: no compression at all.; 1: If the split level is set to zero, everything is compressed according to the gzip level 1. If split level is set to 1, leaves that are not floating point numbers are compressed using the gzip level 1.; 2: If the split level is set to zero, everything is compressed according to the gzip level 2. If split level is set to 1, all non floating point leaves are compressed according to the gzip level 2 and the floating point leaves are compressed according to the gzip level 1 (gzip level -1).; Floating point numbers are compressed differently because the gain when compressing them is about 20 - 30%. For other data types it is generally better and around 100%.; 1. 3; Split or not Split; 0: only one single branch is created and the complete event is serialized in one single buffer; 1: a branch per variable is created.; 1; (Split). 4; Fill; 0: read the file; 1: write the file, but don’t fill the histograms; 2: don’t write, don’t fill the histograms; 10: fill the histograms, don’t write the file; 11: fill the histograms, write the file; 20: read the file sequentially; 25: read the file at random; 1; (Write, no fill). 20.2.1.1 Effect of Compression on File Size and Write Times; You may have noticed that a ROOT file has up to nine compression level, but here only levels 0, 1, and 2 are described. Compression levels above 2 are not competitive. They take up to much write time compared to the gain in file space. Below are three runs of Event on a Pentium III 650 MHz and the resulting file size and write and read times.; No Compression:; > Event 400 0 1 1; 400 events and 19153182 bytes processed.; RealTime=6.840000 seconds, CpuTime=3.560000 seconds; compression level=0, split=1, arg4=1; You write 2.800173 Mbytes/Realtime seconds",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101302,Modifiability,adapt,adapted,1101302,"to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102489,Modifiability,variab,variable,1102489,"rties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104028,Modifiability,config,configure,1104028,"ointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104112,Modifiability,config,configures,1104112,"Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104803,Modifiability,variab,variable,1104803,"time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the exam",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1104829,Modifiability,variab,variable,1104829,"d version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1116610,Modifiability,inherit,inherits,1116610,"of the same instance). pthreads are made for simple C functions and do not know about Thread0 being a member function of a class. Thus, you have to pass this information by hand, if you want to access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mec",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1119352,Modifiability,adapt,adapted,1119352,"ther signals have no other behavior then that to call any registered TSignalHandler::Notify().; When building in interactive application the use of the TRint object handles the kSigInterrupt signal. It causes the printing of the message: *** Break *** keyboard interruptand makes a long jump back to the ROOT command prompt. If no TRint object is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly eve",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1119722,Modifiability,variab,variables,1119722,"ect is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyon",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1120712,Modifiability,variab,variables,1120712,"les and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1121223,Modifiability,variab,variables,1121223,"res a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchronization object with two states locked and unlocked. A mutex is usually used to ensure that only one thread at a time executes some critical section of code. Before entering a critical section, a thread will attempt to lock the mutex, which guards that section. If the mutex is already locked, the thread will block until the mutex is unlocked, at which time it will lock the mutex, execute the critical section, and unlock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1122900,Modifiability,variab,variable,1122900,"ock the mutex upon leaving the critical section.; A semaphore is a synchronization mechanism that starts out initialized to some positive value. A thread may ask to wait on a semaphore in which case the thread blocks until the value of the semaphore is positive. At that time the semaphore count is decremented and the thread continues. When a thread releases semaphore, the semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simultaneous read access by many threads while restricting write access to only one thread at a time. When any thread holds the lock for reading, other threads can also acquire the lock reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a possible classification scheme to describe thread-safety of libraries:. All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data us",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125593,Modifiability,Adapt,Adaptability,1125593," neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125637,Modifiability,adapt,adapt,1125637," neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1126191,Modifiability,adapt,adapted,1126191,"puters. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Window",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1143340,Modifiability,config,config,1143340,"ponsible for holding everything together and to handle all events in the application. Its environment provides an interface to the ROOT graphics system and by calling the Run() method the event loop starts and the application program is waiting for the user action. The application exits only if the top level window is not closed. Two header files are used in addition: TApplication.h - for the class TApplication and TGClient.h that is used to make initial connection to the graphics system. The class TApplication must be instantiated only once in any given application. The original list of argument options can be retrieved via the Argc() and Argv() methods.; Note: to have signals/slots working we need to create a dictionary for the class MyMainFrame, i.e. we create the file ex2aLinkDef.h containing the line:; #pragma link C++ class MyMainFrame;; We compile the example:; rootcling -f ex2aDict.cxx -c example2a.h ex2aLinkDef.h; g++ -o example2a example2a.cxx ex2aDict.cxx `root-config --cflags --glibs`; example2a.h; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; example2a.cxx; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; The class MyMainFrame could derive from TGMainFrame. In that case the RQ_OBJECT macro is not needed anymore, since the functionality it provides is obtained ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1144361,Modifiability,inherit,inheritance,1144361,"x ex2aDict.cxx `root-config --cflags --glibs`; example2a.h; #include <TQObject.h>; #include <RQ_OBJECT.h>. class TGWindow;; class TGMainFrame;; class TRootEmbeddedCanvas;. class MyMainFrame {; RQ_OBJECT(""MyMainFrame""); private:; TGMainFrame *fMain;; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame();; void DoDraw();; };; example2a.cxx; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2a.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {...}; MyMainFrame::~MyMainFrame() { ... }; void MyMainFrame::DoDraw() { ... }; void example() { ... }. int main(int argc, char **argv) {; TApplication theApp(""App"",&argc,argv);; example();; theApp.Run();; return 0;; }; The class MyMainFrame could derive from TGMainFrame. In that case the RQ_OBJECT macro is not needed anymore, since the functionality it provides is obtained now via inheritance from TGMainFrame. This will reflect in the MyMainFrame class declaration and in the code of the MyMainFrame::MyMainFrame constructor as follows:; example2b.h; #include <TGFrame.h>; class MyMainFrame : public TGMainFrame {; private:; TRootEmbeddedCanvas *fEcanvas;; public:; MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h);; virtual ~MyMainFrame() { ... }; void DoDraw(){ ... }; ClassDef(MyMainFrame,0); };; example2b.cxx; #include <TApplication.h>; #include <TGClient.h>; #include <TCanvas.h>; #include <TF1.h>; #include <TRandom.h>; #include <TGButton.h>; #include <TRootEmbeddedCanvas.h>; #include ""example2b.h"". MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h); : TGMainFrame(p,w,h) {. // Creates widgets of the example; fEcanvas = new TRootEmbeddedCanvas (""Ecanvas"",this,200,200);; AddFrame(fEcanvas, new TGLayoutHints(kLHintsExpandX |; kLHintsExpandY, 10,10,10,1));; TGHorizontalFrame *hframe=new TGHorizontalFrame(this, 200,40",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147004,Modifiability,inherit,inheritance,1147004," GUI elements are widgets. A button is a widget, a menu item is a widget, a scrollbar is a widget, and a complete dialog box is a widget too. Some widgets may have sub widgets. For example, a dialog box can contain buttons, text fields, a combo-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has fo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147032,Modifiability,inherit,inherit,1147032,"lete dialog box is a widget too. Some widgets may have sub widgets. For example, a dialog box can contain buttons, text fields, a combo-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which ha",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147192,Modifiability,inherit,inherits,1147192,"-box, etc.; On the screen widgets look like rectangular areas with special behaviors. In terms of the object-oriented programming we can define a widget in ROOT as an object of a class deriving from TGObject.; This section presents all currently supported widgets in ROOT and their most useful methods. All of them can be considered as building blocks for an application, and most of them can be found in dialogs. Provided snippets of the code will give you practical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which handles the widget’s events, the widget status flags and the assigned command (if there is any). The general properties of TGWidget are ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1147700,Modifiability,inherit,inheritances,1147700,"ractical guidelines where and how to use certain widgets. The macro $ROOTSYS/tutorials/gui/guitest.C contains the complete source code. Widgets created by ROOT GUI classes. Any custom widget can be created by sub classing existing widgets. To achieve a better understanding of the widgets’ properties they are separated by their type and their inheritance. As all of them inherit from TGObject and most from TGWidget, these base classes are described first.; 25.5.1 TGObject; TGObject is the base class for all ROOT GUI classes. It inherits from TObject. The two data members of this class contain important information about X11/Win32 window identifier and the connection to the host’s graphics system. Every GUI element, which derives from TGObject has access to the TGClient via the data member fClient of TGObject. TGClient creates the connection with the host’s graphics system and sets up the complete graphics system for all widgets.; 25.5.2 TGWidget; The widgets base class TGWidget is typically used as a mix-in class via multiple inheritances. Its properties are available for all deriving widgets: TGButton, TGComboBox, TGTab, TGColorPalette, TGColorPick, TGDoubleSlider, TGListTree, TGNumberEntry, TGScrollBar, TGShutterItem, TGTextEntry, TGSlider, TGListBox, TGView.; This class has four data members keeping information about the widget id - important for event processing, the window which handles the widget’s events, the widget status flags and the assigned command (if there is any). The general properties of TGWidget are specified by SetFlags(Int_t flags) and ClearFlags(Int_t flags) methods. The status flags are: kWidgetWantFocus, kWidgetHasFocus, and kWidgetIsEnabled. The method Associate(const TGWindow* w) - sets the window which handles the widget events. SetCommand(const char* command) - sets the command to be executed. The command string can be gathering via GetCommand() method. For example, the third parameter in TGTextButton constructor can be omitted and set later",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1149597,Modifiability,inherit,inherits,1149597,"constructor can be omitted and set later in your program, i.e. instead of:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; You will have the following the two lines:; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; The method IsEnabled() - returns kTRUE if the widget has flag kWidgetIsEnabled and it accepts user events. This method is very important for creating a good user interface because it allows you to disable or enable a widget depending on the situation of your application. As a standard all disabled widgets are displayed “grayed out”. HasFocus() - returns kTRUE if the widget has the input focus (i.e. flag kWidgetHasFocus is set). Remember that only one item in a complex widget as a dialog can have the value of HasFocus() sets as true. WantFocus() - returns kTRUE if the flag kWidgetWantFocus is set.; 25.5.3 TGWindow; TGWindow is a ROOT GUI window base class. It inherits from TGObject and TGFrame derives from it. The application does not use it directly. It creates and registers a new window within the system. This window has common characteristics: existing parent, location, size in height and width (it has a default minimum size 1, 1 under which it cannot shrink), border with particular view, state, specific attributes. If there are no specified arguments their values will be taken from the parent. It receives events from the window system and can paint a representation of itself on the screen. 25.5.4 Frames; Most of the frame classes are mainly created for arranging widgets in a window. The class TGFrame is a subclass of TGWindow providing additional window characteristics and overriding some methods of TGWindow. It is a base class for the simple widgets as buttons, labels, etc. Its only purpose is to draw a frame around widgets that do not have a frame of their own. The main groups of TGFrame member functions are:. Window’s functions: DoRedraw(), DeleteWindow(), ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1153565,Modifiability,variab,variable,1153565,"a temporary frame shown in certain circumstances; for example, it is used for creation of tool tip widget. The method ChangeOpton(UInt_t options) allows you to change frame options. Next example shows you how to change kVerticalFrame option to kHorizontalFrame:; frame->ChangeOptions((frame->GetOptions()& ~kVerticalFrame) |; kHorizontalFrame);; The class TGCompositeFrame is the base class of all composite widgets as a menu bar, a list box, a combo box, etc. It subclasses TGFrame and has in addition a layout manager and a list of child frames/widgets. There are two steps to do the design using a composite frame widget. First you put all widgets you need within this frame and assign them desired properties using AddFrame(), then you lay them out by the Layout() method according to the assigned layout manager. The method AddFrame() creates an instance of TGFrameElement class for every child widget of a composite frame. This class has three public data members: the child pointer, its layout hints, and a status variable showing if the child is visible or hidden. If no hints are specified, the default layout hints are used. Because the layout is very important part of any design we include a special section about layout management and layout hints.; You can set a layout manager for the composite frame via:; compFrame->SetLayoutManager(TGLayoutManager *l);; The child widgets cannot be added to different composite frames.; Any child frame can be removed from the parent list by:; compFrame->RemoveFrame(TGFrame *f);; You can hide or show a child frame of a composite frame using the methods: HideFrame(TGFrame *f) or ShowFrame(TGFrame *f). You should call, for example HideFrame(TGFrame *f), only after the frames have been laid out and the sub windows of the composite frame have been mapped via method MapSubwindows(), i.e.; frame->AddFrame(hFrame1,fLayout1);; frame->AddFrame(hFrame2,fLayout2);; frame->Resize(frame->GetDefaultSize()); // lays out frames; frame->MapSubwindows(); //",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1155369,Modifiability,inherit,inherits,1155369,"rame(hFrame2,fLayout2);; frame->Resize(frame->GetDefaultSize()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; The state information about a child frame can be obtained from the methods GetState(TGframe *f), IsArranged(TGFrame *f), and IsVisible(TGFrame *f).; The method Cleanup() deletes all objects of the composite frame added via AddFrame(). All TGFrameElement objects (frames and layout hints) must be unique, i.e. cannot be shared.; We already mentioned that TGMainFrame class defines top level windows interacting with the system window manager. It handles applications with a menu bar, toolbar, text entry fields and other widgets surrounding a central area (e.g. a canvas widget). It lays out a set of related widgets and provides the typical application main window behavior. As you can see from the Figure above, it inherits from TGCompositeFrame and is inherited by TGTransientFrame and several ROOT interface classes: TViewerX3D,TRootBrowser, TRootCanvas, TRootControlBar, TTreeViewer.; To fix the size of a top level window you have to use the method TGMainFrame::SetWMSize(). This call tells the Window Manager that it should not resize the window. The option kFixedSize works only for embedded frames like TGCompositeFrame and derived classes (in combination with layout hints).; The TGVerticalFrame and TGHorizontalFrame are composite frames that lay out their child frames in vertical or horizontal way in the same order as they were added and according to their hints preferences.; The TGTransientFrame class defines transient windows that typically are used for dialogs. They extend and complete an interaction within a limited context. Always transient frames are displayed from another window or another dialog. They may appear because of a command button being activated or a menu item being selected. They may also present automatically when an additional input and th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1155407,Modifiability,inherit,inherited,1155407,"rame(hFrame2,fLayout2);; frame->Resize(frame->GetDefaultSize()); // lays out frames; frame->MapSubwindows(); // maps subwindows; frame->HideFrame(hFrame2); // hides frame hFrame2; frame->MapWindow(); // maps main frame; The state information about a child frame can be obtained from the methods GetState(TGframe *f), IsArranged(TGFrame *f), and IsVisible(TGFrame *f).; The method Cleanup() deletes all objects of the composite frame added via AddFrame(). All TGFrameElement objects (frames and layout hints) must be unique, i.e. cannot be shared.; We already mentioned that TGMainFrame class defines top level windows interacting with the system window manager. It handles applications with a menu bar, toolbar, text entry fields and other widgets surrounding a central area (e.g. a canvas widget). It lays out a set of related widgets and provides the typical application main window behavior. As you can see from the Figure above, it inherits from TGCompositeFrame and is inherited by TGTransientFrame and several ROOT interface classes: TViewerX3D,TRootBrowser, TRootCanvas, TRootControlBar, TTreeViewer.; To fix the size of a top level window you have to use the method TGMainFrame::SetWMSize(). This call tells the Window Manager that it should not resize the window. The option kFixedSize works only for embedded frames like TGCompositeFrame and derived classes (in combination with layout hints).; The TGVerticalFrame and TGHorizontalFrame are composite frames that lay out their child frames in vertical or horizontal way in the same order as they were added and according to their hints preferences.; The TGTransientFrame class defines transient windows that typically are used for dialogs. They extend and complete an interaction within a limited context. Always transient frames are displayed from another window or another dialog. They may appear because of a command button being activated or a menu item being selected. They may also present automatically when an additional input and th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1156138,Modifiability,extend,extend,1156138,"d other widgets surrounding a central area (e.g. a canvas widget). It lays out a set of related widgets and provides the typical application main window behavior. As you can see from the Figure above, it inherits from TGCompositeFrame and is inherited by TGTransientFrame and several ROOT interface classes: TViewerX3D,TRootBrowser, TRootCanvas, TRootControlBar, TTreeViewer.; To fix the size of a top level window you have to use the method TGMainFrame::SetWMSize(). This call tells the Window Manager that it should not resize the window. The option kFixedSize works only for embedded frames like TGCompositeFrame and derived classes (in combination with layout hints).; The TGVerticalFrame and TGHorizontalFrame are composite frames that lay out their child frames in vertical or horizontal way in the same order as they were added and according to their hints preferences.; The TGTransientFrame class defines transient windows that typically are used for dialogs. They extend and complete an interaction within a limited context. Always transient frames are displayed from another window or another dialog. They may appear because of a command button being activated or a menu item being selected. They may also present automatically when an additional input and the user attention are required by a certain condition.; The TGGroupFrame class presents a very convenient frame which surrounds visually a group of logically connected widgets: radio buttons, related check boxes, two or more functionally related controls. It is a composite frame with a border and a title. The title explains the purpose of the group and should be a noun or noun phrase. Here is an example taken from guitest.C:; groupFrame = new TGGroupFrame(tf,""Options"",kVerticalFrame);; groupFrame->SetTitlePos(TGGroupFrame::kLeft);; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1162281,Modifiability,adapt,adapt,1162281,"frame position centered vertically (with horizontal containers only). kLHintsBottom; specifies the frame position to the bottom of the container frame, above any laid out frames with the same hint. kLHintsExpandX; specifies the frame to be expanded up to the width of the container frame. If the container frame is a vertical frame - it will fit the whole width. If it is a horizontal frame - after the positioning of all frames the available “free” width space is shared between the frames having this hint. kLHintsExpandY; specifies the frame to be expanded up to the height of the container frame. If the container frame is a horizontal frame - it will fit the whole height. If the container frame is a vertical frame - after the arrangement of all frames the available “free” height space is shared between the frames having this hint. kLHintsNormal; = kLHintsLeft | kLHintsTop - default hints. Layout policy:; Child frames never modify their container frame. The container frame can (or cannot) adapt its size in the layout process. It can show all or a part of its frames. Every TGFrame object has a default minimum size (1, 1) assured by TGWindow.; 25.7 Event Processing: Signals and Slots; Event handling covers the interaction between different objects and between the user and the objects in an application. There are two general ways for the user to interact with an application: the keyboard and the mouse. The Graphical User Interface is as a bridge between the user and the program - it provides methods to detect the user actions and instruments that do something as a reaction of these actions. The user communicates with an application through the window system. The window system reports interaction events to the application. The application in turn forwards them to the currently active window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1165359,Modifiability,inherit,inherit,1165359," example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; Here is an abstract view of the signal/slots connections in example.C:. To benefit from this mechanism your classes must inherit from TQObject or otherwise the class definition must start with RQ_OBJECT(""ClassName"")macro. This macro allows the signals/slots communication mechanism to be applied between compiled and interpreted classes in an interactive ROOT session without having the class derive from TQObject. Every signal method declaration is followed by a comment ""*SIGNAL*"". Only instances of a class that defines a signal or instances of its subclasses can emit the signal. The ROOT implementation of a popular example presenting signals and slots is the next. Let’s have a minimal class declaration:; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; It will become the following as interpreted:; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; Both class declarations have the same data member and public m",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1166494,Modifiability,inherit,inherited,1166494,"ts communication mechanism to be applied between compiled and interpreted classes in an interactive ROOT session without having the class derive from TQObject. Every signal method declaration is followed by a comment ""*SIGNAL*"". Only instances of a class that defines a signal or instances of its subclasses can emit the signal. The ROOT implementation of a popular example presenting signals and slots is the next. Let’s have a minimal class declaration:; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; It will become the following as interpreted:; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; Both class declarations have the same data member and public methods to access the value. By placing the RQ_OBJECT(""MyClass"") macro inside the MyClass body (MyClass is not inherited from TQObject) we allow this class to use the signal/slot communication. Any instance of this class can tell the outside world that the state of its data member has changed by emitting a signal SetValue(Int_t). A possible implementation of MyClass::SetValue() can be:; void MyClass::SetValue(Int_t v) {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"",v);; }; }; The line Emit(""SetValue(Int_t)"",v) activates the signal SetValue(Int_t) with argument v. You can use any of the methods TQObject::Emit(""full_method_name"",arguments) to emit a signal. We create two instances of MyClass and connect them together:; MyClass *objA = new MyClass();; MyClass *objB = new MyClass();; objA->Connect(""SetValue(Int_t)"",""MyClass"",objB,""SetValue(Int_t)"");; objB->SetValue(11);; objA->SetValue(79);; objB->GetValue(); // the value is 79; By calling the method objA->Connect(), objA connects its signal “SetValue(Int_t)” to the “MyClass::SetValue(Int_t)” method (slot) of objB. Next, when you call ob",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175462,Modifiability,config,config,1175462,"s A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.; There are two main groups of buttons: command buttons with a text or graphics inside that indicate the action to be accomplished and option buttons well known as radio and check buttons that select or change properties. The first group is presented in ROOT by TGPictureButton and TGTextButton classes. They yield an action as soon as they are clicked. It can be opening/closing a dialog box or invoking a specific function in an application. Remember th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1193563,Modifiability,flexible,flexible,1193563,", fMBItemLayout);; fMenuBar->AddPopup(""&Test"", fMenuTest, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; Using the method TGMenuBar::AddPopup we add three TGPopupMenu objects to the menu bar fMenuBar. The first parameter is a hot string used by TGMenuTitle object. When you add a popup menu to the menu bar, a TGMenuTitle object is created by the menu bar. It is the name of the popup menu. A menu title should have a one-word name that reflects the purpose of all items within the corresponding popup menu. It should also have a defined character as its unique access key. The second parameter is the popup menu we would like to add. The third one is an object of TGLayoutHints type that defines how the menu title will be laid out in the menu bar. In our example the File and Test menus will be laid out to the left of the menu bar with 4 pixels distance in between, the Help menu - will be laid out to the right.; The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1196834,Modifiability,variab,variable,1196834,"LSE; // button behavior if clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; To have a tool bar in your application you do not need to do anything special - only to create objects: a tool bar and its picture buttons. This sample code creates the following three toolbar buttons:. First we need to complete a ToolBarData_t structure for each tool bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was val",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1197353,Modifiability,variab,variable,1197353," bar in your application you do not need to do anything special - only to create objects: a tool bar and its picture buttons. This sample code creates the following three toolbar buttons:. First we need to complete a ToolBarData_t structure for each tool bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was valid). The first parameter is the window to which the button messages will be sent. Lastly, we create an object of class TGHorizontal3DLine - a horizontal 3D line. It will separate the toolbar from the menu bar because the layout hints we define as kLHintsTop | kLHintsExpandX.; It is user friendly to allow the possibility for the tool bar to be turned on or off (via a menu). If you use a single tool bar, it should fill the complete width of its parent. When using more than one, you should also think about setting",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1197581,Modifiability,variab,variable,1197581,"ol bar button before adding it to the tool bar. This structure contains:. the icon file name “filename.xpm”; the tool tip text - a short help message explaining the button purpose; the Boolean variable defining the button behavior when is clicked; kFALSE - do not stay down; kTRUE - to stay down; the button ID; the button pointer (TGButton *) - should be NULL. We create an array *xpms[] containing the icon file names that will be used for a picture button creation. If you write only the file names here ROOT will search these files in $ROOTSYS/icons directory. If the icon files are not there, you should provide the full path name also. The array *tips[]contains the tool tip texts for buttons. The integer variable separator is used to set the distance between two groups of toolbar buttons. It defines the amount of pixels to the left for each button.; We create a tool bar object and add the buttons using the AddButton method. The variable separator helps us to define no space between the buttons in a group (0), and 5 pixels extra-space before and after. All buttons added via this method will be deleted by the toolbar. On return the TGButton field of the ToolBarData_t structure is filled in (if the icon pixmap was valid). The first parameter is the window to which the button messages will be sent. Lastly, we create an object of class TGHorizontal3DLine - a horizontal 3D line. It will separate the toolbar from the menu bar because the layout hints we define as kLHintsTop | kLHintsExpandX.; It is user friendly to allow the possibility for the tool bar to be turned on or off (via a menu). If you use a single tool bar, it should fill the complete width of its parent. When using more than one, you should also think about setting the bar size to the end of the most right button. This way other bars can be displayed in the same row below the menu bar.; Tool bar buttons should have equal size, meaningful and unique icons, and short meaningful tool tip text. The related buttons s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1201456,Modifiability,flexible,flexible,1201456,"tries:; // list box widget containing 10 entries; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; We create the list box widget passing the parent window pointer and giving an ID number. Next we add entries with specified string and ID to the list box. Before adding the list box to its parent widget, it should be resized via Resize(width, height) method. The list box width and height are in pixels. The default entry layout hints are kLHintsExpandX | kLHintsTop. If you want to add entries using different ones, call the method:; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; It adds the specified TGLBEntry and TGLayoutHints to the list box. There are several methods providing a flexible entry manipulation: you can insert, add or remove list box items dynamically. The list box entry IDs are used in these methods and also in event processing routines. In our example the integer variables fFirstEntry and fLastEntry contain the information about the first and last entry IDs. You can add or remove a list box entry using them in the following way:; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; A single-selection list box is used for selecting only one item in a list.; A multiple-selection list box permits selection of more than one item. The selected choices should be visible - you have several choices to do this:. to mark selected choices with a check mark or highlight them; to provide a summary list box to the right of the list box, cont",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1201658,Modifiability,variab,variables,1201658,"""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; We create the list box widget passing the parent window pointer and giving an ID number. Next we add entries with specified string and ID to the list box. Before adding the list box to its parent widget, it should be resized via Resize(width, height) method. The list box width and height are in pixels. The default entry layout hints are kLHintsExpandX | kLHintsTop. If you want to add entries using different ones, call the method:; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; It adds the specified TGLBEntry and TGLayoutHints to the list box. There are several methods providing a flexible entry manipulation: you can insert, add or remove list box items dynamically. The list box entry IDs are used in these methods and also in event processing routines. In our example the integer variables fFirstEntry and fLastEntry contain the information about the first and last entry IDs. You can add or remove a list box entry using them in the following way:; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; A single-selection list box is used for selecting only one item in a list.; A multiple-selection list box permits selection of more than one item. The selected choices should be visible - you have several choices to do this:. to mark selected choices with a check mark or highlight them; to provide a summary list box to the right of the list box, containing the selected choices; to provide a display-only text control indicating the number of selected choices (its position should be justified upper-right above the list box); if the actions Select All or Desele",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1204692,Modifiability,inherit,inherit,1204692,"// combo box widget; TGComboBox *fCombo = new TGComboBox(parent,100);; for (i = 0; i < 10; i++) {; sprintf(tmp, ""Entry%i"", i+1);; fCombo->AddEntry(tmp, i+1);; }; fCombo->Resize(150, 20);; // Entry3 is selected as current; fCombo->Select(2);; parent->AddFrame(fCombo, fLcombo);; You have the same flexibility to add, insert or remove entries. As with list boxes you can retrieve the information for currently selected item via GetSelected or GetSelectedEntry methods. The first one returns the entry ID, the second - the current entry pointer (TGLBEntry *).; 25.8.8 Sliders; A slider is a scale with an indicator (slider) that you can drag to choose a value from a predefined range. It may be oriented horizontally or vertically. In both cases it provides an excellent indication of where a value exists within a range of values. The class TGHSlider represents the horizontal slider; TGVSlider - the vertical one. Both inherit from the base class TGSlider that creates the main slider parameters: the range of values within a value can be selected; the indicator type; the tick mark scale. Using its methods SetRange, SetPosition and SetScale you can set these parameters. To retrieve the set slider value you can call GetPosition method.; Next sample code creates a horizontal slider hslider with a tick mark of type kSlider1. Its width is 150 pixels, and its scale is placed down (kScaleDownRight). The last parameter in the TGHSlider constructor is the slider ID. It will be used for event processing. The methods SetRange and SetPosition set the range and the current tick mark position of the slider.; hslider = new TGHSlider(parent,150,kSlider1|kScaleDownRight,sID);; hslider->SetRange(0,50);; hslider->SetPosition(39);; Slider values can be set by using the mouse to drag the slider across the scale until the desired value is reached. Another way is to click in the slider trough instead of dragging.; 25.8.8.1 Double Slider; Double slider widgets allow easy selection of a min and a max value",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1206883,Modifiability,inherit,inherit,1206883,"DoubleScaleNo, kScaleDownRight, kDoubleScaleBoth.; To change the min value you should press the left mouse button near to the left (TGDoubleHSlider) or bottom (TGDoubleHSlider) edge of the slider. Alternatively, to change the max value you need to press the mouse near to the right (TGDoubleHSlider) or top (TGDoubleHSlider) edge of the slider. To change both values simultaneously you should press the left mouse button near to the center of the slider. TGDoubleSlider is an abstract base class that creates the main slider parameters. The concrete class to use for a vertical double slider is TGDoubleVSlider and TGDoubleHSlider for a horizontal one. The double slider constructors are similar to those of the other sliders. If you set kDoubleScaleNo as a scale parameter no scale will be drawn. Here is an example:; vDslider = new TGDoubleVSlider(p,100,kDoubleScaleNo,dsliderID);; vDslider->SetRange(-10,10);; 25.8.9 Triple Slider; The new TGTripleHSlider and TGTripleVSlider classes inherit from the double slider widgets and allow easy selection of a range and a pointer value. The pointer position can be constrained into the selected range or can be relative to it. To change the slider range value press the left mouse button near to the left/right (top/bottom) edges of the slider. To change both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The fil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1213927,Modifiability,inherit,inherit,1213927," A horizontal splitter resizes the frames above and below of it; a vertical splitter resizes the frames left and right of it. This widget is represented by TGSplitter, TGHSplitter, and TGVSplitter classes. Currently there is no special graphics representation for splitter widgets; only the cursor changes when crossing a splitter.; There is nothing special to create a splitter - two lines of code only:; TGHSplitter *hsplitter = new TGHSplitter(fVf);; hsplitter->SetFrame(fH1,kTRUE);; You call a horizontal TGHSplitter or a vertical TGVSplitter splitter constructor and after you set the frame to be resized via SetFrame method. In spite of that, there are rules to be followed when you create a splitter in your application.; For a horizontal splitter they are:. the parent of a horizontal splitter must inherit from TGCompoziteFrame and must have a vertical layout; the above resized frame must have kFixedHeight option set; use layout hints kLHintsTop | kLHintsExpandX when adding the above resized frame to its parent; use layout hints kLHintsBottom | kLHintsExpandX | kLHintsExpandY when adding the bottom resized frame to its parent; set the above frame to be resized using SetFrame method; the second parameter should be kTRUE. You can see these rules in the code below:; // Create horizontal splitter; fVf = new TGVerticalFrame(fMain,10,10);; fH1 = new TGHorizontalFrame(fVf,10,10, kFixedHeight);; fH2 = new TGHorizontalFrame(fVf,10,10);; fFtop = new TGCompositeFrame(fH1,10,10, kSunkenFrame);; fFbottom = new TGCompositeFrame(fH2,10,10,kSunkenFrame);; fLtop = new TGLabel(fFtop,""Top Frame"");; fLbottom = new TGLabel(fFbottom,""Bottom Frame"");. fFtop->AddFrame(fLtop, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFbottom->AddFrame(fLbottom, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fH1->AddFrame(fFtop, new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH2->AddFrame(fFbottom,new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHint",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1215673,Modifiability,inherit,inherit,1215673,"m->AddFrame(fLbottom, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fH1->AddFrame(fFtop, new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH2->AddFrame(fFbottom,new TGLayoutHints(kLHintsTop |; kLHintsExpandY | kLHintsExpandX,0,0,1,2));; fH1->Resize(fFtop->GetDefaultWidth(),fH1->GetDefaultHeight()+20);; fH2->Resize(fFbottom->GetDefaultWidth(),fH2->GetDefaultHeight()+20);; fVf->AddFrame(fH1, new TGLayoutHints(kLHintsTop | kLHintsExpandX));. TGHSplitter *hsplitter = new TGHSplitter(fVf);; hsplitter->SetFrame(fH1,kTRUE);; fVf->AddFrame(hsplitter,new TGLayoutHints(kLHintsTop |; kLHintsExpandX));; fVf->AddFrame(fH2, new TGLayoutHints(kLHintsBottom |; kLHintsExpandX | kLHintsExpandY));; For a vertical splitter the rules are:. the parent of a vertical splitter must inherit from TGCompoziteFrame and must have a horizontal layout; the left resized frame must have kFixedWidth option set; use layout hints kLHintsLeft | kLHintsExpandY when adding the left resized frame to the parent; use layout hints kLHintsRight|kLHintsExpandX |kLHintsExpandY when adding the right resized frame to the parent; set the left frame to be resized using SetFrame method; the second parameter should be kTRUE. Next is a sample code for a vertical splitter:; // Create vertical splitter; fHf = new TGHorizontalFrame(fMain, 50, 50);; fV1 = new TGVerticalFrame(fHf, 10, 10, kFixedWidth);; fV2 = new TGVerticalFrame(fHf, 10, 10);; fFleft = new TGCompositeFrame(fV1, 10, 10, kSunkenFrame);; fFright = new TGCompositeFrame(fV2, 10, 10, kSunkenFrame);. fLleft = new TGLabel(fFleft, ""Left Frame"");; fLright = new TGLabel(fFright, ""Right Frame"");. fFleft->AddFrame(fLleft, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fFright->AddFrame(fLright, new TGLayoutHints(kLHintsLeft |; kLHintsCenterY,3,0,0,0));; fV1->AddFrame(fFleft,new TGLayoutHints(kLHintsTop |; kLHintsExpandX | kLHintsExpandY,0,0,5,5));; fV2->AddFrame(fFright,new TGLayoutHints(kLHintsTop |; kLHintsExpandX |",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1229033,Modifiability,inherit,inheriting,1229033,"es (uri comes from Unique Resource Identifier). A text/uri-list is a standard file listing format for drag and drop that specifies a list of files (each file per line). Each line ends with a carriage return and newlinern. File names have to be valid, url-encoded URI’s as shown below:; file://localhost/usr/bin/opera or file://localhost/c:/programs/myfile.txt; file://server/data/software.xml or http://root.cern.ch/root/images/ftpstats.gif; The atoms and the drag and drop manager (TGDNDManager), are created at the main application creation time (class TGMainFrame).; Setting a Drag Source - first, create and fill data:; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; Then, set a GUI widget as DND Source, and associate the data. Source widget can be any class inheriting from TGFrame.; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; Setting A Drop Target - set the widget as DND Target, and set the DND types it must be aware of: as SourceWidget, TargetWidget can be any class inheriting from TGFrame.; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; gDNDManager->GetTypeList() returns the list of types recognized by ROOT.; Note that the Widget may receive drag and drop messages with drop-data it does not understand, and thus it should only accept drops of the proper type.; 25.10.2 Handling Drag and Drop Events; Once a widget has been set as DND Target, it has to handle Drag and Drop events.; Atom_t HandleDNDenter(Atom_t *typelist) - this method is used to handle a drag operation entering the widget. The typelist parameter",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1229343,Modifiability,inherit,inheriting,1229343,"newlinern. File names have to be valid, url-encoded URI’s as shown below:; file://localhost/usr/bin/opera or file://localhost/c:/programs/myfile.txt; file://server/data/software.xml or http://root.cern.ch/root/images/ftpstats.gif; The atoms and the drag and drop manager (TGDNDManager), are created at the main application creation time (class TGMainFrame).; Setting a Drag Source - first, create and fill data:; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; Then, set a GUI widget as DND Source, and associate the data. Source widget can be any class inheriting from TGFrame.; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; Setting A Drop Target - set the widget as DND Target, and set the DND types it must be aware of: as SourceWidget, TargetWidget can be any class inheriting from TGFrame.; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; gDNDManager->GetTypeList() returns the list of types recognized by ROOT.; Note that the Widget may receive drag and drop messages with drop-data it does not understand, and thus it should only accept drops of the proper type.; 25.10.2 Handling Drag and Drop Events; Once a widget has been set as DND Target, it has to handle Drag and Drop events.; Atom_t HandleDNDenter(Atom_t *typelist) - this method is used to handle a drag operation entering the widget. The typelist parameter is the list of types the data contains. If the list contains one type the widget understands, it should return this type to notify the manager that the drop would be accepted, i.e. :; for (int i = 0; typelist[i]",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1235513,Modifiability,inherit,inheritance,1235513,"connects its ""SetValue(Int_t)"" signal to ""A::SetValue(Int_t)"" method of object b.; Calling a->SetValue(79) will make a emit a signal, which b will receive, i.e. b->SetValue(79) is invoked. It is executed immediately, just like a normal function call. b will in turn emit the same signal, which nobody receives, since no slot has been connected to it, so it disappears into hyperspace.; This example illustrates that objects can work together without knowing about each other, as long as there is someone around to set up a connection between them.; 26.4 Features of the ROOT implementation. The ROOT implementation does not require the moc preprocessor and the signal: and slot: keywords in the class declaration. Signals and slots are normal class methods.; The class which corresponds to Qt’s QObject is TQObject. It reproduces the general features of the QObject class and has the Connect(), Disconnect() and Emit() methods. The TQObject class does not derive from any class which makes it possible to have multiple inheritance from TObject derived classes and TQObject.; By placing the RQ_OBJECT() macro inside a class body you can use signals and slots with classes not inheriting from TQObject, like interpreted classes which can not derive from compiled classes. This makes it possible to apply the Object Communication Mechanism between compiled and interpreted classes in an interactive ROOT session.; The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal Pressed() from button and method/slot Draw() from object hist of class (compiled or interpreted) TH1; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; To connect to a stand-alone function (compiled or interpreted) the arguments corresponding to the name of the class and receiving object should be zero. For example; Connect(button, ""Pressed()"", 0, 0, ""printInfo()"");; It is also possible to make a single connection from all objec",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1235669,Modifiability,inherit,inheriting,1235669,"e(79) is invoked. It is executed immediately, just like a normal function call. b will in turn emit the same signal, which nobody receives, since no slot has been connected to it, so it disappears into hyperspace.; This example illustrates that objects can work together without knowing about each other, as long as there is someone around to set up a connection between them.; 26.4 Features of the ROOT implementation. The ROOT implementation does not require the moc preprocessor and the signal: and slot: keywords in the class declaration. Signals and slots are normal class methods.; The class which corresponds to Qt’s QObject is TQObject. It reproduces the general features of the QObject class and has the Connect(), Disconnect() and Emit() methods. The TQObject class does not derive from any class which makes it possible to have multiple inheritance from TObject derived classes and TQObject.; By placing the RQ_OBJECT() macro inside a class body you can use signals and slots with classes not inheriting from TQObject, like interpreted classes which can not derive from compiled classes. This makes it possible to apply the Object Communication Mechanism between compiled and interpreted classes in an interactive ROOT session.; The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal Pressed() from button and method/slot Draw() from object hist of class (compiled or interpreted) TH1; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; To connect to a stand-alone function (compiled or interpreted) the arguments corresponding to the name of the class and receiving object should be zero. For example; Connect(button, ""Pressed()"", 0, 0, ""printInfo()"");; It is also possible to make a single connection from all objects of the same class. For example:; TQObject::Connect(""Channel"", ""AlarmOn()"", ""HandlerClass"", handler, ""HandleAlarm()"");; where the class name is specified by the first ar",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1250433,Modifiability,variab,variable,1250433,"that URL for all occurrences of a given class name. One can set the URL ../mylib/ for a library name MyLib by setting Root.Html.MyLib: ../mylib/ or by calling THtml::SetLibURL(""MyLib"", ""../mylib/""). Occurrences of class MyClass of MyLib will now be referenced as ../mylib/MyClass.html.; 27.4.2 Search Engine; THtml can invoke external search engines. The ROOT reference guide sets Root.Html.Search to http://www.google.com/search?q=%s+site%3A%u. Calling THtml::SetSearchStemURL() will set the same. If this URL stem is set, THtml will create search fields in the index pages. It will send the words entered in these search fields as %s in the URL; %u will be replaced by the current document’s path, allowing a site- and directory-specific search.; 27.4.3 ViewCVS; Most code is managed in a version control system like CVS. ViewCVS is a WWW reader interface to the versioning control system that allows e.g. tracking a file’s changes. THtml will reference these pages automatically if the .rootrc variable Root.Html.ViewCVS is set to the URL stem of the ViewCVS. installation. Alternatively, one can call THtml::SetViewCVS().; 27.4.4 Wiki Pages; In some contexts it might be desirable to let users comment on classes, e.g. for suggestions of use or alternatives, details of behavior, and cross references to other relevant classes. A successful example of this is the PHP.net documentation with its user annotations. THtml can include a link to a class’s Wiki page by setting the Wiki base URL via Root.Html.WikiURL or THtml::SetWikiURL().; 27.5 Tutorial; You can run the tutorial htmlex.C to see how THtml converts a script to HTML and how it creates the corresponding class reference:; root[] .x $(ROOTSYS)/tutorials/htmlex.C+; Have a look at the HTML version of the macro in htmldoc/htmlex.C.html(which should be the same as the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1252246,Modifiability,evolve,evolves,1252246," the one at http://root.cern.ch/root/html/examples/htmlex.C.html).; It demonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1262869,Modifiability,variab,variable,1262869," Current icon style selection - can be either small, big, list, details:; Browser.IconStyle: small; Current sorting rule applied on the browser objects - can be name, type, size, date:; Browser.SortBy: name; Number of items in a group view:; Browser.GroupView: 10000; Show or not hidden items:; Browser.ShowHidden: no; Create a thumbnail view after executing the macro (default is yes).; Browser.AutoThumbnail: yes; 28.6.5 TRint Specific Settings; Rint (interactive ROOT executable) specific alias, logon and logoff macros.; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; Record ROOT session commands in a given history file (default is $(HOME)/.root_hist). If set to “-”, it turn off the command recording.; Rint.History: $(HOME)/.root_hist; Next two lines set the history file size handling. Once HistSize is reached, the last HistSave entries are removed. If HistSize is set to 0, it turns off command recording. Both values can be overridden by environment variable ROOT_HIST=size[:save], where the “:save” part is optional.; Rint.HistSize: 500; Rint.HistSave: 400; 28.6.6 ACLiC Specific Settings; ACLiC.Linkdef specifies the suffix that will be added to the script name to try to locate a custom linkdef file when generating the dictionary.; ACLiC.Linkdef: _linkdef; The top directory for storing the libraries produced by ACLiC is set by:; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; The additional include directives for ACLiC compilations are set by:; ACLiC.IncludePaths: -I/where/the/includes/are; 28.6.7 PROOF Related Variables; PROOF debug options.; Proof.DebugLevel: 0; Proof.DebugMask:-1; PROOF GDB hooks allows a debugger to be attached early in the startup phase of proofserv:0 - don’t wait; 1 - master proofserv enters wait loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.Paralle",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1263449,Modifiability,Variab,Variables,1263449,"t.Logoff: rootlogoff.C; Record ROOT session commands in a given history file (default is $(HOME)/.root_hist). If set to “-”, it turn off the command recording.; Rint.History: $(HOME)/.root_hist; Next two lines set the history file size handling. Once HistSize is reached, the last HistSave entries are removed. If HistSize is set to 0, it turns off command recording. Both values can be overridden by environment variable ROOT_HIST=size[:save], where the “:save” part is optional.; Rint.HistSize: 500; Rint.HistSave: 400; 28.6.6 ACLiC Specific Settings; ACLiC.Linkdef specifies the suffix that will be added to the script name to try to locate a custom linkdef file when generating the dictionary.; ACLiC.Linkdef: _linkdef; The top directory for storing the libraries produced by ACLiC is set by:; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; The additional include directives for ACLiC compilations are set by:; ACLiC.IncludePaths: -I/where/the/includes/are; 28.6.7 PROOF Related Variables; PROOF debug options.; Proof.DebugLevel: 0; Proof.DebugMask:-1; PROOF GDB hooks allows a debugger to be attached early in the startup phase of proofserv:0 - don’t wait; 1 - master proofserv enters wait loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the U",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1264825,Modifiability,Extend,Extend,1264825,"; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]; Example of custom setting for the Rint application (root.exe). This overrides the default specified above for a generic application. Color 5 is yellow.; Rint.Canvas.HighLightColor: 5; 28.7 Documentation to Download. The latest ROOT Users Guide; https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html; ROOT Reference Guide; http://root.cern.ch/root/Reference.html. http://root.cern.ch/twiki/bin/view/ROOT/PROOF↩. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1264985,Modifiability,Variab,Variables,1264985,"; 3 - any proofserv enters wait loop; Proof.GdbHook: 0; On the master to enable the parallel startup of workers using threads set next to “yes” (default is “no”):; Proof.ParallelStartup: no; Proof.StatsHist: no; Proof.StatsTrace: no; Proof.SlaveStatsTrace: no; Proof.CondorHome: /opt/condor; Proof.CondorConfig: /opt/condor/etc/condor_config; PEAC.GmUrl: http://somewhere:8080/clarens/; PEAC.LmUrl: http://elsewhere:8080/clarens/; 28.6.7.1 Server Authentication in TServerSocket; General setting: file with server access rules; SrvAuth.DaemonRc: /etc/root/system.daemonrc; Check of host equivalence via /etc/hosts.equiv or $HOME/.rhosts.; SrvAuth.CheckHostsEquivalence: 1; Force file opening via TNetFile (TNetXNGFile) if a hostname is specified in the Url. By default, for local files TFile::Open() invokes directly TFile.; TFile.ForceRemote: yes; Special cases for the TUrl parser, where the special cases are parsed in a protocol + file part, like rfio:host:/path/file.root, castor:/path/file.root or /alien/path/file.root. In case the file namespace descriptor ends with - the namespace is not a part of the filename. Extend in private .rootrc with a +Url.Special line.; Url.Special: file: rfio: hpss: castor: dcache:; +Url.Special: /alien/- /castor/; 28.6.7.2 PROOF XRD Client Variables; Debug level (if <=0 : none, 1 : low, 2 : medium, 3 : high); XProof.Debug: 0; Socket read timeout [in secs: default 10 secs]; XProof.ReadTimeout: 10; XNet.PrintTAG - Print a particular string the developers can choose to quickly recognize the version at run time [default - 0]; Example of custom setting for the Rint application (root.exe). This overrides the default specified above for a generic application. Color 5 is yellow.; Rint.Canvas.HighLightColor: 5; 28.7 Documentation to Download. The latest ROOT Users Guide; https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html; ROOT Reference Guide; http://root.cern.ch/root/Reference.html. http://root.cern.ch/twiki/bin/view/ROOT/PROOF↩. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:20572,Performance,load,load,20572,"tzVector, etc.); libPostscript is the PostScript interface; libProof is the parallel ROOT Facility classes; libPython provides the interface to Python; *libRFIO is the interface to CERN RFIO remote I/O system.; *libRGL is the interface to OpenGL.; libReflex is the runtime type database library used by Cling; libRint is the interactive interface to ROOT (provides command prompt); libRIO provides the functionality to write and read objects to and from ROOT files; libRooFit is the RooFit fitting framework; libRuby is the interface to Ruby; libSpectrum provides functionality for spectral analysis; *libThread is the interface to TThread classes; libTMVA contains the multivariate analysis toolkit; libTree is the TTree object container system; libTreePlayer is the TTree drawing classes; libTreeViewer is the graphical TTree query interface. 1.6.2.1 Library Dependencies. ROOT libraries dependencies. The libraries are designed and organized to minimize dependencies, such that you can load just enough code for the task at hand rather than having to load all libraries or one monolithic chunk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link aga",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:20637,Performance,load,load,20637,"tzVector, etc.); libPostscript is the PostScript interface; libProof is the parallel ROOT Facility classes; libPython provides the interface to Python; *libRFIO is the interface to CERN RFIO remote I/O system.; *libRGL is the interface to OpenGL.; libReflex is the runtime type database library used by Cling; libRint is the interactive interface to ROOT (provides command prompt); libRIO provides the functionality to write and read objects to and from ROOT files; libRooFit is the RooFit fitting framework; libRuby is the interface to Ruby; libSpectrum provides functionality for spectral analysis; *libThread is the interface to TThread classes; libTMVA contains the multivariate analysis toolkit; libTree is the TTree object container system; libTreePlayer is the TTree drawing classes; libTreeViewer is the graphical TTree query interface. 1.6.2.1 Library Dependencies. ROOT libraries dependencies. The libraries are designed and organized to minimize dependencies, such that you can load just enough code for the task at hand rather than having to load all libraries or one monolithic chunk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link aga",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21242,Performance,load,load,21242," TThread classes; libTMVA contains the multivariate analysis toolkit; libTree is the TTree object container system; libTreePlayer is the TTree drawing classes; libTreeViewer is the graphical TTree query interface. 1.6.2.1 Library Dependencies. ROOT libraries dependencies. The libraries are designed and organized to minimize dependencies, such that you can load just enough code for the task at hand rather than having to load all libraries or one monolithic chunk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22337,Performance,load,loads,22337,"ary dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22462,Performance,load,loaded,22462,"y, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22703,Performance,load,loaded,22703,"rary a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22887,Performance,load,loaded,22887,"only used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23260,Performance,load,load,23260,"e libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On star",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23292,Performance,load,loaded,23292,"e libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On star",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23490,Performance,load,loaded,23490,"yer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23565,Performance,load,loaded,23565,"pendency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:23840,Performance,load,loaded,23840,"epresented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24193,Performance,load,load,24193,"If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit an",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24551,Performance,load,load,24551,"Non-plugins will need to be linked, and are thus loaded at start-up. Plugins are defined by a base class (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24581,Performance,Load,Load,24581,"ass (e.g. TFile) that will be implemented in a plugin, a tag used to identify the plugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24692,Performance,load,load,24692,"ugin (e.g. ^rfio: as part of the protocol string), the plugin class of which an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogram",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24731,Performance,load,loading,24731,"ch an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogramming image: Image Processing io: Input/Output math: Maths and Statistics f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24791,Performance,load,loader,24791,"ch an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogramming image: Image Processing io: Input/Output math: Maths and Statistics f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:38262,Performance,load,loads,38262," a new canvas window in the current ROOT session.; Open…: popup a dialog to open a file.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:39831,Performance,response time,response time,39831,"such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas stays fixed when changing the window size. Resize Canvas: resizes and fits the canvas to the window size.; Move Opaque: if selected, graphics objects are moved in opaque mode; otherwise, only the outline of objects is drawn when moving them. The option opaque produces the best effect but it requires a reasonably fast workstation or response time.; Resize Opaque: if selected, graphics objects are resized in opaque mode; otherwise, only the outline of objects is drawn when resizing them.; Interrupt: interrupts the current drawing process.; Refresh: redraws the canvas contents.; Pad Auto Exec: executes the list of TExecs in the current pad.; Statistics: toggles the display of the histogram statistics box.; Histogram Title: toggles the display of the histogram title.; Fit Parameters: toggles the display of the histogram or graph fit parameters.; Can Edit Histogram: enables/disables the possibility to edit histogram bin contents. 2.3.1.5 Inspect Menu. ROOT: inspects the top-level gROOT object (in a new canvas).; Start Browser: starts a new object browser (in a separate window).; GUI Builder: starts the GUI builder application (in a separate window). 2.3.1.6 Help Menu. Canvas: help on canvas as a whiteboard area for drawing.; Menus: help on canvas menus.; Graphics Editor: help on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:45355,Performance,load,loads,45355,"e up or down to grow or shrink the text respectively. If you position the mouse near the bottom-end of the text, you can rotate it.; A Marker: Click with the left button where to place the marker. The marker can be modified by using the method SetMarkerStyle() of TSystem.; A Graphical Cut: Click with the left button on each point of a polygon delimiting the selected area. Close the cut by double clicking on the last point. A TCutG object is created. It can be used as a selection for a TTree::Draw. You can get a pointer to this object with:; TCutG cut = (TCutG*)gPad->GetPrimitive(""CUTG""); Once you are happy with your picture, you can select the Save as canvas.C item in the canvas File menu. This will automatically generate a script with the C++ statements corresponding to the picture. This facility also works if you have other objects not drawn with the graphics editor (histograms for example).; 2.3.2 The Editor Frame; The ROOT graphics editor loads the corresponding object editor objEditor according to the selected object obj in the canvas respecting the class inheritance. An object in the canvas is selected after the left mouse click on it. For example, if the selected object is TAxis, the TAxisEditor will shows up in the editor frame giving the possibility for changing different axis attributes. The graphics editor can be:; Embedded - connected only with the canvas in the application window that appears on the left of the canvas window after been activated via View menu / Editor. It appears on the left side if the canvas window allowing users to edit the attributes of the selected object via provided user interface. The name of the selected object is displayed on the top of the editor frame in red color. If the user interface needs more space then the height of the canvas window, a vertical scroll bar appears for easer navigation. Global - has own application window and can be connected to any created canvas in a ROOT session. It can be activated via the context me",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:53498,Performance,load,load,53498,"r choice is saved for the next time the Save As… dialog shows up.; 2.3.7 Printing the Canvas; The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name. Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; If the %p and %f are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).; 2.4 The ROOT Command Line; We have briefly touched on how to use the command line. There are different types of commands. Cling commands start with “.”. root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]. SHELL commands start with “.!” for example:. root[] .! ls. C++ commands follow C++ syntax (almost). root[] TBrowser *b = new TBrowser(); 2.4.1 Multi-line Commands; You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket {, and to end it you must type a single right curly bracket }. For example:; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; It is more convenient to edit a script than the command line, and if your multi line commands are getting unmanageable, you may want to start with a script instead.; 2.4.2 Cling Extensions; We should say that some things are not standard C++. The Cling interpreter has several extensions. See “ROOT/C",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:53538,Performance,load,load,53538,"ave As… dialog shows up.; 2.3.7 Printing the Canvas; The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name. Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; If the %p and %f are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).; 2.4 The ROOT Command Line; We have briefly touched on how to use the command line. There are different types of commands. Cling commands start with “.”. root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]. SHELL commands start with “.!” for example:. root[] .! ls. C++ commands follow C++ syntax (almost). root[] TBrowser *b = new TBrowser(); 2.4.1 Multi-line Commands; You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket {, and to end it you must type a single right curly bracket }. For example:; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; It is more convenient to edit a script than the command line, and if your multi line commands are getting unmanageable, you may want to start with a script instead.; 2.4.2 Cling Extensions; We should say that some things are not standard C++. The Cling interpreter has several extensions. See “ROOT/Cling Extensions to C++”.; 2.4.3 Helpful Hi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:63594,Performance,load,loader,63594," with your own. For example:; root[] delete gRandom;; root[] gRandom = new TRandom2(0); //seed=0; TRandom2 is another generator, which is also very fast and uses only three words for its state.; 2.6.6 gEnv; gEnv is the global variable (of type TEnv) with all the environment settings for the current session. This variable is set by reading the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:63874,Performance,Load,Load,63874,"the contents of a .rootrc file (or $ROOTSYS/etc/system.rootrc) at the beginning of the root session. See Environment Setup below for more information.; 2.7 Environment Setup; The behavior of a ROOT session can be tailored with the options in the .rootrc file. At start-up, ROOT looks for a .rootrc file in the following order:. ./.rootrc //local directory; $HOME/.rootrc //user directory; $ROOTSYS/etc/system.rootrc //global ROOT directory. If more than one .rootrc files are found in the search paths above, the options are merged, with precedence local, user, global. While in a session, to see current settings, you can do:; root[] gEnv->Print(); The rootrc file typically looks like:; # Path used by dynamic loader to find shared libraries; Unix.*.Root.DynamicPath: .:~/rootlibs:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:~/rootmacros:$(ROOTSYS)/macros. # Path where to look for TrueType fonts; Unix.*.Root.UseTTFonts: true; Unix.*.Root.TTFontPath:; ...; # Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The root",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:64828,Performance,load,loaded,64828," Activate memory statistics; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:64898,Performance,load,loaded,64898,"rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:160732,Performance,perform,perform,160732,"gles at various angles. Output can take the form of a 2D histogram or a vector. The triangles found can be drawn in 3D. This software cannot be guaranteed to work under all circumstances. It was originally written to work with a few hundred points in anXY space with similar X and Y ranges. Graph2D drawn with option “surf1” and “tri1 p0”. {; TCanvas *c = new TCanvas(""c"",""Graph2D example"",0,0,700,600);; Double_t x, y, z, P = 6.;; Int_t np = 200;; TGraph2D *dt = new TGraph2D();; TRandom *r = new TRandom();. for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(55);; dt->Draw(""surf1""); // use ""surf1"" to generate the left picture; } // use ""tri1 p0"" to generate the right one; A more complete example is $ROOTSYS/tutorials/fit/graph2dfit.C that produces the next figure. Output of macro graph2dfit.C. 4.11 TGraph2DErrors; A TGraph2DErrors is a TGraph2D with errors. It is useful to perform fits with errors on a 2D graph. An example is the macro $ROOTSYS/tutorials/graphs/graph2derrorsfit.C.; 4.12 Fitting a Graph; The graph Fit method in general works the same way as the TH1::Fit. See “Fitting Histograms”.; 4.13 Setting the Graph’s Axis Title; To give the axis of a graph a title you need to draw the graph first, only then does it actually have an axis object. Once drawn, you set the title by getting the axis and calling the TAxis::SetTitle method, and if you want to center it, you can call the TAxis::CenterTitle method.; Assuming that n, x, and y are defined. Next code sets the titles of the x and y axes.; root[] gr5 = new TGraph(n,x,y); root[] gr5->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] gr5->Draw(""ALP""); root[] gr5->GetXaxis()->SetTitle(""X-Axis""); root[] gr5->GetYaxis()->SetTitle(""Y-Axis""); root[] gr5->GetXaxis()->CenterTitle(); root[] gr5->GetYaxis()->CenterTitle(); root[] gr5->Draw(""ALP""); For more graph examples see the scripts: $RO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:165233,Performance,Perform,Perform,165233,"e the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bins; ignore error bars; “I” Use integral of function in bin instead of value at bin center; “L” Use log likelihood method (default is chi-square method). To be used when the histogram represents counts; “WL” Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1.; “P” Use Pearson chi-square method, using expected errors instead of the observed one given by TH1::GetBinError (default case). The expected error is instead estimated from the square-root of the bin function value.; “Q” Quiet mode (minimum printing); “V” Verbose mode (default is between Q and V); “S” The result of the fit is returned in the TFitResultPtr.; “E” Perform better errors estimation using the Minos technique; “M” Improve fit results, by using the IMPROVE algorithm of TMinuit.; “R” Use the range specified in the function range; “N” Do not store the graphics function, do not draw; “0” Do not plot the result of the fit. By default the fitted function is drawn unless the option “N” above is specified.; “+” Add this new fitted function to the list of fitted functions (by default, the previous function is deleted and only the last one is kept); “B”Use this option when you want to fix one or more parameters and the fitting function is a predefined one, like polN, expo, landau, gaus. Note that in case of pre-defined functions some default initial values and limits are set.; “C”In case of linear fitting, don’t calculate the chisquare (saves time).; “F”If fitting a linear function (e.g. polN), switch to use the default minimizer (e.g. Minuit). By default, polN functions are fitted by the linear fitter. *goption:The third parameter is the graphics option that is the same as in the TH1::Draw (see the ch",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:182323,Performance,perform,performing,182323,"s been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.; 5.6.1 Function Choice and Settings; ‘Predefined’ combo box - contains a list of predefined functions in ROOT. You have a choice of seve",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:183108,Performance,perform,perform,183108,"it Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.; 5.6.1 Function Choice and Settings; ‘Predefined’ combo box - contains a list of predefined functions in ROOT. You have a choice of several polynomials, a Gaussian, a Landau, and an Exponential function. The default one is Gaussian.; ‘Operation’ radio button group defines the selected operational mode between functions:; Nop - no operation (default);; Add - addition;; Conv - convolution (will be implemented in the future).; Users can enter the function expression into the text entry field below the ‘Predefined’ combo box. The entered string is checked after the Enter key was pressed and an error message shows up, if the function string is not accepted.; ‘Set Parameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The B",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:186516,Performance,perform,performed,186516,"’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one function. Setting this option to On will add the newly fitted function to the existing list of functions for the histogram. Note that the fitted functions are saved with the histogram when it is written to a ROOT file. By default, the function is drawn on the pad displaying the histogram.; 5.6.3 Draw Options; ‘SAME’ sets On/Off function drawing on the same pad. When a fit is executed, the image of the function is drawn on the current pad.; ‘No drawing’ sets On/Off the option “0”- do not draw the fit results.; ‘Do not store/draw’ sets On/Off option “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:187428,Performance,perform,performed,187428,"ion “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:187617,Performance,perform,performs,187617,"ls, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:188317,Performance,perform,performed,188317,"otted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT::Fit namespace. These classes can be classified in the following groups:. User classes driving the fit: ROOT::Fit::Fitter for executing the fit, ROOT::Fit::FitConfig for configuring the fit, ROOT::Fit::ParameterSettings to define the properties of the fit parameters (initial values, bounds, etc..), ROOT::Fit::FitResult for storing the result of the fit.; Data classes containing the data sets used in the fitting. These classes are theROOT::Fit::BinDatafor describing bin data sets, thus data points containing both coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordinate values can be one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; Function classes defining the type of fit (the objective function used for fitting)",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:189986,Performance,perform,perform,189986," coordinates and a corresponding value/weight with optionally an error on the value or the coordinate and the ROOT::Fit::UnBinData for un-binned data sets, which consists only of a vector of coordinate values. The coordinate values can be one-dimensional (i.e. one entry per event) or multi-dimensional (N entries per event).; Function classes defining the type of fit (the objective function used for fitting):. ROOT::Fit::Chi2FCN for chi2 (least-square fits),; ROOT::Fit::PoissonLikelihoodFCN for binned likelihood fits of histograms,; ROOT::Fit::LogLikelihoodFCN for generic un-binned likelihood fits. These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided. They derive from the common generic interface multi-dimensional for function evaluation, ROOT::Math::IBaseFunctionMultiDim. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, ROOT::Math::IParametricFunctionMultiDim to define the fit model function and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); *",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190508,Performance,perform,performed,190508,"ic un-binned likelihood fits. These classes are templated on the type of function interface they implement (see later). User convenient typedefs are also provided. They derive from the common generic interface multi-dimensional for function evaluation, ROOT::Math::IBaseFunctionMultiDim. In addition the fitter classes make uses of the generic interfaces for parametric function evaluations, ROOT::Math::IParametricFunctionMultiDim to define the fit model function and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190759,Performance,perform,perform,190759,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191186,Performance,perform,performing,191186,"nt a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; In t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:191358,Performance,Perform,Perform,191358,"w are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fIntegral = true;; ROOT::Fit::BinData data(opt);; // fill the bin data using the histogram; // we can do this using the following helper function from the Hist library; TH1 * h1 = (TH1*) gDirectory->Get(""myHistogram"");; ROOT::Fit::FillData(data, h1);; In this code example, we have used the utility function of the Hist library, ROOT::Fit::FillData to fill the BinData object. The ROOT::Fit::FillData is defined in the headerfile HFitI",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:201278,Performance,load,loaded,201278," errors, re-normalize errors using fitted chi2 values). The initial parameter values can be set directly in the input model function object. However, for setting parameter bounds and step sizes to values different than the automatically computed ones, one needs to use the ROOT::Fit::ParameterSetting class. This example code will set the lower/upper bounds for the first parameter and a lower bound for the second parameter; fitter.SetFunction( fitFunction, false);; fitter.Config().ParSettings(0).SetLimits(0,1.E6);; fitter.Config().ParSettings(2).SetLowerLimit(0);; Note that a ROOT::Fit::ParameterSettings objects exists for each fit parameter and it created by the ROOT::Fit::FitConfig class, after the model function has been set in the Fitter. Only when the function is set, the number of parameter is known and automatically the FitConfig creates the corresponding ParameterSetting objects.; When fitting, different minimizer can be used. The can be implemented in different libraries and loaded ar run time by the plug-in manager system of ROOT. Each different minimizer (e.g. Minuit, Minuit2, Fumili, etc.) consists of a different implementation of the ROOT::Math::Minimizer interface. Within the same minimizer, thus within the same class implementing the Minimizer interface, different algorithms can exist. For example in the case of Minuit, we have Migrad, Simplex or Minimize. The minimizer and its corresponding algorithm, when available, can be set by using the function FitConfig::SetMinimizer(""minimizerName"") or by using directly the ROOT:Math::MinimizerOptions class.; If the requested minimizer is not available in ROOT, the default one is used. The default minimizer type and algorithm can be specified by using the static function ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""minimizerName""); 5.7.4 Minimizer Libraries and Algorithms; The list of available minimizer libraries currently available in ROOT, with their corresponding available algorithms is the following o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:206447,Performance,Perform,Performing,206447,"nuit is possible to set the maximum number of function calls, but not the maximum number of iterations. The Strategy and the Precision options apply instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The list of the current option values can be inspected by using MinimizerOptions::Print.; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; In addition it is possible to provide extra options which might apply for a particular minimizer MinimizerOptions::SetExtraOptions(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit::",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:206622,Performance,perform,perform,206622," instead only for Minuit (and Minuit2).; The class supports also setting global default values for the options, by using the static functions MinimizerOptions::SetDefault... (for example MinimizerOptions::SetDefaultPrintLevel(int )). The static functions can be also used to set the minimizer options when using TH1::Fit or TGraph::Fit. The list of the current option values can be inspected by using MinimizerOptions::Print.; ROOT::Math::MinimizerOptions() opt;; // print the default minimizer option values; opt.Print();; In addition it is possible to provide extra options which might apply for a particular minimizer MinimizerOptions::SetExtraOptions(const IOptions & ). See the documentation of the particular minimizer to use for the list of possible additional options available.; 5.7.5 Performing the Fit; Here we have now all the required input ingredients for the fit, the data and the function to fit. Depending on these we have now several different way to perform the fit, using the corresponding methods of the ROOT::Fit::Fitter class and depending on the type of input data.; 5.7.5.1 Available fit methods. Least-square fit: Fitter::LeastSquare(const BinData & ) or Fitter::Fit(const Bindata &). It requires the user to pass a BinData object. It should be used when the data values follow a Gaussian distribution. This fit method is implemented using the class ROOT::Fit::Chi2FCN.; Binned Likelihood fit : Fitter::LikelihoodFit(const Bindata & ). The user needs to pass a BinData object. It should be used when the data values follow a Poisson or a multinomial distribution. The Poisson case (extended fit) is the default and in this case the function normalization is also fit to the data. The Multi-nominal case can be selected by passing the optional extended boolean flag as false. This method is implemented by the class ROOT::Fit:::PoissonLikelihoodFCN.; Un-Binned likelihood fit: Fitter::LikelihoodFit(const UnBindata &). The user needs to pass an UnBinData object. By default th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:218070,Performance,perform,perform,218070,"erical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate.; If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits:; 5.9.3.1 Getting the Right Minimum with Limits; If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented Minuit from finding the right minimum. On",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:218084,Performance,perform,perform,218084,"erical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\frac{\partial Pext}{\partial Pint} \neq 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. 5.9.3 How to Get the Right Answer from Minuit; Minuit offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimized for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-definiteness. Its main weakness is that it depends heavily on knowledge of the first derivatives, and fails miserably if they are very inaccurate.; If parameter limits are needed, in spite of the side effects, then the user should be aware of the following techniques to alleviate problems caused by limits:; 5.9.3.1 Getting the Right Minimum with Limits; If MIGRAD converges normally to a point where no parameter is near one of its limits, then the existence of limits has probably not prevented Minuit from finding the right minimum. On",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:225607,Performance,perform,performances,225607,"are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:225853,Performance,optimiz,optimized,225853," questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online referen",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:230610,Performance,optimiz,optimization,230610," feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:237493,Performance,Load,LoadWeights,237493,"n network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “graph” (evaluating graphical training curves), “update = X” (step for the text/graph output update) or “+” (will skip the randomization and start from the previous values). All combinations are available.; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containing a Higgs boson. Starting with a TFile containing two TTrees: one for the signal, the other for the background, a simple script is used:; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:238316,Performance,Load,Load,238316,"e=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containing a Higgs boson. Starting with a TFile containing two TTrees: one for the signal, the other for the background, a simple script is used:; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; Since the input is a TTree and we are starting from two different TTrees (with different names), they are first merged into one, and a “type” branch is added, that says whether there is a signal or a background event. Those irrelevant details are skipped here.; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntrain, ""text,graph,update=10"");; The neural network is instantiated and trained. “ptsumf” is used as a weight, and the standard event lists are explicit. The network that is then build has four",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:253708,Performance,load,load,253708,"a stack object. Be very careful if you take the address of stack objects. As we shall see soon, they are deleted automatically, which could leave you with an illegal pointer. Using it will corrupt and may as well crash the program!; It is time to look at the destruction of objects. A destructor is a special C++ function that releases resources for (or destroys) an object of a class. It is the opposite of a constructor that creates the object of a class when it is called. The compiler will provide a destructor that does nothing if none is provided. We will add one to our Quad class so that we can see when it is called. The class names the destructor but with a prefix ~ which is the C++ one’s complement i.e. bit wise complement, and hence has destruction overtones! We declare it in the .h file and define it in the .cxx file. It does not do much except print out that it has been called (still a useful debug technique despite today’s powerful debuggers!).; Now run root, load the Quad class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack y",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:254587,Performance,load,load,254587," class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack you have to type:; root[] gROOT->Reset();; This sends the Reset message via the global pointer to the ROOT object, which, amongst its many roles, acts as a resource manager. Start ROOT again and type in the following:; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; You will see that this deletes the first object but not the second. We have also painted ourselves into a corner, as my_objptr was also on the stack. This command will fail.; root[] my_objptr->Solve();; Cling no longer knows what my_objptr is. This is a great example of a memory leak; the heap object exists but we have lost our way to access it. In general, this is not a problem. If any object will outlive the compound statement in which it was created then a more permanent pointer will point to it, which frequently is part of another heap object. See Resetting the Interpreter Environment in the chapter “Cling the C++ Interpreter”.; 7 The C++",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:254691,Performance,load,loaded,254691," class and create a heap object:; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; To delete the object:; root[] delete my_objptr;; root[] my_objptr = 0;; You should see the print out from its destructor. Setting the pointer to zero afterwards is not strictly necessary (and Cling does it automatically), but the object is no more accessible, and any attempt to use the pointer again will, as has already been stated, cause grief. So much for heap objects, but how are stack objects deleted? In C++, a stack object is deleted as soon as control leaves the innermost compound statement that encloses it. Therefore, it is singularly futile to do something like:; root[] { Quad my_object(1.,2.,-3.); }; Cling does not follow this rule; if you type in the above line, you will not see the destructor message. As explained in the Script lesson, you can load in compound statements, which would be a bit pointless if everything disappeared as soon as it was loaded! Instead, to reset the stack you have to type:; root[] gROOT->Reset();; This sends the Reset message via the global pointer to the ROOT object, which, amongst its many roles, acts as a resource manager. Start ROOT again and type in the following:; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);; root[] Quad *my_objptr = new Quad(4.,5.,-6.);; root[] gROOT->Reset();; You will see that this deletes the first object but not the second. We have also painted ourselves into a corner, as my_objptr was also on the stack. This command will fail.; root[] my_objptr->Solve();; Cling no longer knows what my_objptr is. This is a great example of a memory leak; the heap object exists but we have lost our way to access it. In general, this is not a problem. If any object will outlive the compound statement in which it was created then a more permanent pointer will point to it, which frequently is part of another heap object. See Resetting the Interpreter Environment in the chapter “Cling the C++ Interpreter”.; 7 The C++",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263443,Performance,load,loads,263443,"t();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263599,Performance,load,load,263599,"X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:268098,Performance,load,loaded,268098," class definition and Cling will execute the requested member function. This shortcut is quite natural for an interactive system and saves much typing. In this example, ROOT searches for hpx and finds it in hsimple.root.; The next, fundamental extension is shown below. There is no need to put a semicolon at the end of a line. When you leave it off the value of the expression will be printed on the next line. For example:; root[] 23+5; (int)28; root[] 23+5;; root[] TMath::Sin; (Double_t (*)(Double_t)) Function @0x7ffff7ebb090; at include/TMath.h:418:; inline Double_t TMath::Sin(Double_t x); { return sin(x); }; Be aware that these extensions do not work when a compiler replaces the interpreter. Your code will not compile, hence when writing large scripts, it is best to stay away from these shortcuts. It will save you from having problems compiling your scripts using a real C++ compiler.; 7.4 ACLiC: Compiling Scripts Into Libraries; Instead of having Cling interpret your script there is a way to have your scripts compiled, linked and dynamically loaded using the C++ compiler and linker. The advantage of this is that your scripts will run with the speed of compiled C++ and that you can use language constructs that are not fully supported by Cling. On the other hand, you cannot use any Cling shortcuts (see “C++ Extensions To Ease Scripting” above) and for small scripts, the overhead of the compile/link cycle might be larger than just executing the script in the interpreter.; ACLiC will build a dictionary and a shared library from your C++ script, using the compiler and the compiler options that were used to compile the ROOT executable. You do not have to write a Makefile remembering the correct compiler options, and you do not have to exit ROOT.; 7.4.1 Usage; Before you can compile your interpreted script you need to add include statements for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:268979,Performance,load,load,268979," Instead of having Cling interpret your script there is a way to have your scripts compiled, linked and dynamically loaded using the C++ compiler and linker. The advantage of this is that your scripts will run with the speed of compiled C++ and that you can use language constructs that are not fully supported by Cling. On the other hand, you cannot use any Cling shortcuts (see “C++ Extensions To Ease Scripting” above) and for small scripts, the overhead of the compile/link cycle might be larger than just executing the script in the interpreter.; ACLiC will build a dictionary and a shared library from your C++ script, using the compiler and the compiler options that were used to compile the ROOT executable. You do not have to write a Makefile remembering the correct compiler options, and you do not have to exit ROOT.; 7.4.1 Usage; Before you can compile your interpreted script you need to add include statements for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use the command .L and append the file name with a +.; root[] .L MyScript.C+; The + option generates the shared library and names it by taking the name of the file “filename” but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as exe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:269028,Performance,load,load,269028,"a way to have your scripts compiled, linked and dynamically loaded using the C++ compiler and linker. The advantage of this is that your scripts will run with the speed of compiled C++ and that you can use language constructs that are not fully supported by Cling. On the other hand, you cannot use any Cling shortcuts (see “C++ Extensions To Ease Scripting” above) and for small scripts, the overhead of the compile/link cycle might be larger than just executing the script in the interpreter.; ACLiC will build a dictionary and a shared library from your C++ script, using the compiler and the compiler options that were used to compile the ROOT executable. You do not have to write a Makefile remembering the correct compiler options, and you do not have to exit ROOT.; 7.4.1 Usage; Before you can compile your interpreted script you need to add include statements for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use the command .L and append the file name with a +.; root[] .L MyScript.C+; The + option generates the shared library and names it by taking the name of the file “filename” but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:269870,Performance,load,load,269870,"nts for the classes used in the script. Once you did that, you can build and load a shared library containing your script. To load it use the command .L and append the file name with a +.; root[] .L MyScript.C+; The + option generates the shared library and names it by taking the name of the file “filename” but replacing the dot before the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270243,Performance,optimiz,optimization,270243,"the extension by an underscore and by adding the shared library extension for the current platform. For example on most platforms, hsimple.cxx will generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270408,Performance,optimiz,optimization,270408," generate hsimple_cxx.so.; The + command rebuild the library only if the script or any of the files it includes are newer than the library. When checking the timestamp, ACLiC generates a dependency file which name is the same as the library name, just replacing the ‘so’ extension by the extension ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gRO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270654,Performance,optimiz,optimizations,270654," ‘d’. For example on most platforms, hsimple.cxx will generate hsimple_cxx.d.; To ensure that the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the includ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270780,Performance,optimiz,optimization,270780,"t the shared library is rebuilt you can use the ++ syntax:; root[] .L MyScript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270857,Performance,optimiz,optimization,270857,"cript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); Y",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:271147,Performance,optimiz,optimization,271147," with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanyli",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:271234,Performance,optimiz,optimization,271234," with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanyli",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:271467,Performance,load,load,271467,"ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272307,Performance,load,load,272307,"o, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC lo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272364,Performance,Load,Load,272364,"o, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC lo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:272460,Performance,load,loading,272460,"pt.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); You can also overwrite the existing include path:; gSystem->SetIncludePath("" -I$HOME/mypackage/include ""); The $ROOTSYS/include directory is automatically appended to the include path, so you do not have to worry about including it. To add library that should be used during linking of the shared library use something like:; gSystem->AddLinkedLibs(""-L/my/path -lanylib"");; This is especially useful for static libraries. For shared ones you can also simply load them before trying to compile the script:; gSystem->Load(""mydir/mylib"");; ACLiC uses the directive fMakeSharedLibs to create the shared library. If loading the shared library fails, it tries to output a list of missing symbols by creating an executable (on some platforms like OSF, this does not HAVE to be an executable) containing the script. It uses the directive fMakeExe to do so. For both directives, before passing them to TSystem::Exec(), it expands the variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs, $ExeNameand$ObjectFiles. See SetMakeSharedLib() for more information on those variables. When the file being passed to ACLiC is on a read only file system, ACLiC warns the user and creates the library in a temporary directory:; root[] .L readonly/t.C++; Warning in <ACLiC>: /scratch/aclic/subs/./readonly is not writable!; Warning in <ACLiC>: Output will be written to /tmp; Info in <TUnixSystem::ACLiC>: creating shared library; /tmp//scratch/aclic/subs/./readonly/t_C.so; To select the temporary directory ACLiC looks at $TEMP, $TEMP_DIR, $TEMPDIR, $TMP, $TMPDIR, $TMP_DIRor uses /tmp (or C:/). Also, a new interface TSystem::Get/SetBuildDir is introduced to let users select an alternative ‘root’ for build",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:278345,Performance,load,loaded,278345,"n the ""#if !defined (__CLING__)"" and ""#endif"". If you want to use gArray in the same script as its declaration, you can do so. However, if you want use the script in the interpreter you have to bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Cling.; These types of headers can be included in interpreted and compiled mode:. The subset of standard C/C++ headers defined in $ROOTSYS/Cling/include.; Headers of classes defined in a previously loaded library (including ROOT own). The defined class must have a name known to ROOT (i.e. a class with a ClassDef). Hiding header files from rootcling that are necessary for the compiler but optional for the interpreter can lead to a subtle but fatal error. For example:; #ifndef __CLING__; #include ""TTree.h""; #else; class TTree;; #endif. class subTree : public TTree {; };; In this case, rootcling does not have enough information about the TTree class to produce the correct dictionary file. If you try this, rootcling and compiling will be error free, however, instantiating a subTree object from the Cling command line will cause a fatal error. In general, it is recommended to let rootcling see as many header files as possible.; 7.5 Classes Defined By Scripts; Lets create a small class TMyClass and a derived class TChild. The virtual method TMyClass::Print()is overridden in TChild. Save this in file called script4.C.; #include <iostream.h>. class TMyClass {; private:; float fX; //x ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:293038,Performance,perform,performance,293038," the screen changes the object in memory.; 9.2.1 Moving, Resizing and Modifying Objects; Changing the graphic objects attributes can be done with the GUI or programmatically. First, let’s see how it is done in the GUI.; 9.2.1.1 The Left Mouse Button; As was just seen moving or resizing an object is done with the left mouse button. The cursor changes its shape to indicate what may be done:; Point the object or one part of it: ; Rotate: ; Resize (exists also for the other directions): ; Enlarge (used for text): ; Move: ; Here are some examples of:; Moving: Resizing: ; Rotating: ; 9.2.1.2 With C++ Statements (Programmatically); How would one move an object in a script? Since there is a tight correspondence between what is seen on the screen and the object in memory, changing the object changes it on the screen. For example, try to do:; root[] a.SetX1(0.9); This should change one of the coordinates of our line, but nothing happens on the screen. Why is that? In short, the canvas is not updated with each change for performance reasons. See “Updating the Pad”.; 9.2.2 Selecting Objects; 9.2.2.1 The Middle Mouse Button; Objects in a canvas, as well as in a pad, are stacked on top of each other in the order they were drawn. Some objects may become “active” objects, which mean they are reordered to be on top of the others. To interactively make an object “active”, you can use the middle mouse button. In case of canvases or pads, the border becomes highlighted when it is active.; 9.2.2.2 With C++ Statements (Programmatically); Frequently we want to draw in different canvases or pads. By default, the objects are drawn in the active canvas. To activate a canvas you can use the TPad::cd() method.; root[] c1->cd(); 9.2.3 Context Menus: the Right Mouse Button; The context menus are a way to interactively call certain methods of an object. When designing a class, the programmer can add methods to the context menu of the object by making minor changes to the header file.; 9.2.3.1 Usin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:301009,Performance,perform,performed,301009," standard method to be provided is ExecuteEvent(). This method actually does the event reaction. Its prototype is where px and py are the coordinates at which the event occurred, except if the event is a key press, in which case px contains the key code.; void ExecuteEvent(Int_t event, Int_t px, Int_t py);; Where event is the event that occurs and is one of the following (defined in Buttons.h):; kNoEvent, kButton1Down, kButton2Down,; kButton3Down, kKeyDown, kButton1Up,; kButton2Up, kButton3Up, kButton1Motion,; kButton2Motion, kButton3Motion, kKeyPress,; kButton1Locate, kButton2Locate, kButton3Locate,; kKeyUp, kButton1Double, kButton2Double,; kButton3Double, kMouseMotion, kMouseEnter,; kMouseLeave; We hope the names are self-explanatory.; Designing an ExecuteEvent method is not very easy, except if one wants very basic treatment. We will not go into that and let the reader refer to the sources of classes like TLine or TBox. Go and look at their ExecuteEvent method! We can nevertheless give some reference to the various actions that may be performed. For example, one often wants to change the shape of the cursor when passing on top of an object. This is done with the SetCursor method:; gPad->SetCursor(cursor); The argument cursor is the type of cursor. It may be:; kBottomLeft, kBottomRight, kTopLeft,; kTopRight, kBottomSide, kLeftSide,; kTopSide, kRightSide, kMove,; kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer,; kArrowRight, kCaret, kWatch; They are defined in TVirtualX.h and again we hope the names are self-explanatory. If not, try them by designing a small class. It may derive from something already known like TLine.; Note that the ExecuteEvent() functions may in turn; invoke such functions for other objects, in case an object is drawn using other objects. You can also exploit at best the virtues of inheritance. See for example how the class TArrow (derived from TLine) use or redefine the picking functions in its base class.; The last comment is that mous",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:304097,Performance,perform,performed,304097,"f TH1::Draw(). It is merely ten lines of code. The last statement is AppendPad(). This statement calls method of TObject that just adds the pointer of the object, here a histogram, to the list of objects attached to the current pad. Since this is a TObject’s method, every object may be “drawn”, which means attached to a pad.; When is the painting done then ? The answer is: when needed. Every object that derives from TObject has a Paint() method. It may be empty, but for graphical objects, this routine contains all the instructions to paint effectively it in the active pad. Since a Pad has the list of objects it owns, it will call successively the Paint() method of each object, thus re-painting the whole pad on the screen. If the object is a sub-pad, its Paint() method will call the Paint() method of the objects attached, recursively calling Paint() for all the objects. Pad painting. In some cases a pad need to be painted during a macro execution. To force the pad painting gPad->Update() (see next section) should be performed.; The list of primitives stored in the pad is also used to pick objects and to interact with them.; 9.3.1 The Global Pad: gPad; When an object is drawn, it is always in the so-called active pad. For every day use, it is comfortable to be able to access the active pad, whatever it is. For that purpose, there is a global pointer, called gPad. It is always pointing to the active pad. If you want to change the fill color of the active pad to blue but you do not know its name, do this.; root[] gPad->SetFillColor(38); To get the list of colors, go to the paragraph “Color and color palettes” or if you have an opened canvas, click on the View menu, selecting the Colors item.; 9.3.1.1 Finding an Object in a Pad; Now that we have a pointer to the active pad, gPad and that we know this pad contains some objects, it is sometimes interesting to access one of those objects. The method GetPrimitive() of TPad, i.e. TPad::GetPrimitive(const char* name) does exact",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:313864,Performance,perform,performance,313864,"e a given pad.; root[] pad1->Divide(3,2). Dividing a pad into 6 sub-pads. Dividing a pad into 6 sub-pads. If pad1 is a pad then, it will divide the pad into 3 columns of 2 sub-pads. The generated sub-pads get names pad1_i where the index i=1 to nxm (in our case pad1_1, pad1_2…pad1_6). The names pad1_1etc… correspond to new variables in Cling, so you may use them as soon as the executed method was pad->Divide(). However, in a compiled program, one has to access these objects. Remember that a pad contains other objects and that these objects may themselves be pads. So we can use the GetPrimitive() method:; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); One question remains. In case one does an automatic divide, how one can set the default margins between pads? This is done by adding two parameters to Divide(), which are the margins in x and y:; root[] pad1->Divide(3,2,0.1,0.1); The margins are here set to 10% of the parent pad width.; 9.3.5 Updating the Pad; For performance reasons, a pad is not updated with every change. For example, changing the coordinates of the pad does not automatically redraw it. Instead, the pad has a “bit-modified” that triggers a redraw. This bit is automatically set by:. Touching the pad with the mouse - for example resizing it with the mouse.; Finishing the execution of a script.; Adding a new primitive or modifying some primitives for example the name and title of an object.; You can also set the “bit-modified” explicitly with the Modified method:; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); A subsequent call to TCanvas::Update() scans the list of sub-pads and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object created during the paint process. To do so, you can force the painting with a TCanvas::Update(). For example, a TGraph creates a histogram (TH1) to paint itself. In this case the internal histogram obtai",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:323530,Performance,scalab,scalable,323530,"r is:; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); It may be used as in:; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(). A rectangle with a border. A TWbox is a rectangle (TBox) with a border size and a border mode. The attributes of the outline line and of the fill area are described in “Graphical Objects Attributes”; 9.4.4 Markers; A marker is a point with a fancy shape! The possible markers are shown in the next figure. Markers. The marker constructor is:; TMarker(Double_t x,Double_t y,Int_t marker); The parameters x and y are the marker coordinates and marker is the marker type, shown in the previous figure. Suppose the pointer ma is a valid marker. The marker size is set via ma->SetMarkerSize(size), where size is the desired size. Note, that the marker types 1, 6 and 7 (the dots) cannot be scaled. They are always drawn with the same number of pixels. SetMarkerSize does not apply on them. To have a “scalable dot” a circle shape should be used instead, for example, the marker type 20. The default marker type is 1, if SetMarkerStyle is not specified. It is the most common one to draw scatter plots. Different marker sizes. Different marker sizes. The user interface for changing the marker color, style and size looks like shown in this picture. It takes place in the editor frame anytime the selected object inherits the class TAttMarker.; Non-symmetric symbols should be used carefully in plotting. The next two graphs show how the misleading a careless use of symbols can be. The two plots represent the same data sets but because of a bad symbol choice, the two on the top appear further apart from the next example. The use of non-symmetric markers. A TPolyMaker is defined by an array on N points in a 2D space. At each point x[i], y[i] a marker is drawn. The list of marker types is shown in the previous paragraph. The marker attributes are managed by the class TAttMarker and are described in “Graphical Objects Attributes”. T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:337086,Performance,optimiz,optimized,337086,"s();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around the specified value.; optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. For example:; ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions; ndiv = -10: exactly 10 primary divisions; 9.5.4 Zooming the Axis; You can use TAxis::SetRange or TAxis::SetRangeUser to zoom the axis.; TAxis::SetRange(Int_t binfirst,Int_t binlast); The SetRange method parameters are bin numbers. They are not axis. For example if a histogram plots the values from 0 to 500 and has 100 bins, SetRange(0,10) will cover the values 0 to 50. The parameters for SetRangeUser are user coordinates. If the start or end is in the middle of a bin the resulting range is approximation. It finds the low edge bin for the start and the high edge bin for the high.; TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast); Both methods, SetRange and SetRangeUser, are in the context menu of any axi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:343122,Performance,Optimiz,Optimization,343122,"and then the label is correctly aligned. The dot, if last character of the string, is also stripped. In the following, we have some parameters, like tick marks length and characters height (in percentage of the length of the axis, in user coordinates). The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%; Labels offset: 1.0 %. 9.5.7.7 Stripping Decimals; Use the TStyle::SetStripDecimals to strip decimals when drawing axis labels. By default, the option is set to true, and TGaxis::PaintAxis removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5, 1, 1.5, 2, 2.5, etc.}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); If this function is called with strip=kFALSE, TGaxis::PaintAxis() will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}; 9.5.7.8 Optional Grid; chopt = 'W': cross-Wire; 9.5.7.9 Axis Binning Optimization; By default, the axis binning is optimized. chopt = 'N': No binning optimization; chopt = 'I': Integer labeling. 9.5.8 Axis with Time Units; Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the SetTimeDisplay attribute on a given axis. If h is a histogram, it is done the following way:; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; Two parameters can be adjusted in order to define time axis: the time format and the time offset.; 9.5.8.1 Time Format; It defines the format of the labels along the time axis. It can be changed using the TAxis method SetTimeFormat. The time format is the one used by the C function strftime(). It is a string containing the following formatting characters:. For the date:; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century; %Y year with century. For the time:; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:343168,Performance,optimiz,optimized,343168,"and then the label is correctly aligned. The dot, if last character of the string, is also stripped. In the following, we have some parameters, like tick marks length and characters height (in percentage of the length of the axis, in user coordinates). The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%; Labels offset: 1.0 %. 9.5.7.7 Stripping Decimals; Use the TStyle::SetStripDecimals to strip decimals when drawing axis labels. By default, the option is set to true, and TGaxis::PaintAxis removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5, 1, 1.5, 2, 2.5, etc.}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); If this function is called with strip=kFALSE, TGaxis::PaintAxis() will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}; 9.5.7.8 Optional Grid; chopt = 'W': cross-Wire; 9.5.7.9 Axis Binning Optimization; By default, the axis binning is optimized. chopt = 'N': No binning optimization; chopt = 'I': Integer labeling. 9.5.8 Axis with Time Units; Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the SetTimeDisplay attribute on a given axis. If h is a histogram, it is done the following way:; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; Two parameters can be adjusted in order to define time axis: the time format and the time offset.; 9.5.8.1 Time Format; It defines the format of the labels along the time axis. It can be changed using the TAxis method SetTimeFormat. The time format is the one used by the C function strftime(). It is a string containing the following formatting characters:. For the date:; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century; %Y year with century. For the time:; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:343203,Performance,optimiz,optimization,343203," the string, is also stripped. In the following, we have some parameters, like tick marks length and characters height (in percentage of the length of the axis, in user coordinates). The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%; Labels offset: 1.0 %. 9.5.7.7 Stripping Decimals; Use the TStyle::SetStripDecimals to strip decimals when drawing axis labels. By default, the option is set to true, and TGaxis::PaintAxis removes trailing zeros after the dot in the axis labels, e.g. {0, 0.5, 1, 1.5, 2, 2.5, etc.}; TStyle::SetStripDecimals (Bool_t strip=kTRUE); If this function is called with strip=kFALSE, TGaxis::PaintAxis() will draw labels with the same number of digits after the dot, e.g. {0.0, 0.5, 1.0, 1.5, 2.0, 2.5, etc.}; 9.5.7.8 Optional Grid; chopt = 'W': cross-Wire; 9.5.7.9 Axis Binning Optimization; By default, the axis binning is optimized. chopt = 'N': No binning optimization; chopt = 'I': Integer labeling. 9.5.8 Axis with Time Units; Histograms’ axis can be defined as “time axis”. To do that it is enough to activate the SetTimeDisplay attribute on a given axis. If h is a histogram, it is done the following way:; h->GetXaxis()->SetTimeDisplay(1); // X axis is a time axis; Two parameters can be adjusted in order to define time axis: the time format and the time offset.; 9.5.8.1 Time Format; It defines the format of the labels along the time axis. It can be changed using the TAxis method SetTimeFormat. The time format is the one used by the C function strftime(). It is a string containing the following formatting characters:. For the date:; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century; %Y year with century. For the time:; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. The other characters are out",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:354600,Performance,scalab,scalable,354600,"vention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use TAttText::SetTextColor to set the text color. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:354667,Performance,scalab,scalable,354667,"vention applies:. 1 = left; 2 = centered; 3 = right. For vertical alignment, the following convention applies:. 1 = bottom; 2 = centered; 3 = top. For example, align: 11 = left adjusted and bottom adjusted; 32 = right adjusted and vertically centered.; 9.6.1.2 Setting Text Angle; Use TAttText::SetTextAngle to set the text angle. The angle is the degrees of the horizontal.; root[] la->SetTextAngle(angle); 9.6.1.3 Setting Text Color; Use TAttText::SetTextColor to set the text color. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and pr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:355109,Performance,scalab,scalable,355109,"lor. The color is the color index. The colors are described in “Color and Color Palettes”.; root[] la->SetTextColor(color); 9.6.1.4 Setting Text Font; Use TAttText::SetTextFont to set the font. The parameter font is the font code, combining the font and precision: font = 10 * fontID + precision; root[] la->SetTextFont(font); The table below lists the available fonts. The font IDs must be between 1 and 14. The precision can be:. Precision = 0 fast hardware fonts (steps in the size); Precision = 1 scalable and rotate-able hardware fonts (see below); Precision = 2 scalable and rotate-able hardware fonts. When precision 0 is used, only the original non-scaled system fonts are used. The fonts have a minimum (4) and maximum (37) size in pixels. These fonts are fast and are of good quality. Their size varies with large steps and they cannot be rotated. Precision 1 and 2 fonts have a different behavior depending if True Type Fonts (TTF) are used or not. If TTF are used, you always get very good quality scalable and rotate-able fonts. However, TTF are slow. Precision 1 and 2 fonts have a different behavior for PostScript in case of TLatex objects:. With precision 1, the PostScript text uses the old convention (see TPostScript) for some special characters to draw sub and superscripts or Greek text.; With precision 2, the “PostScript” special characters are drawn as such. To draw sub and superscripts it is highly recommended to use TLatex objects instead. For example: font = 62 is the font with ID 6 and precision 2. Font’s examples. The available fonts are:. Font ID; X11; True Type name; Is italic; “boldness”. 1; times-medium-i-normal; “Times New Roman”; Yes; 4. 2; times-bold-r-normal; “Times New Roman”; No; 7. 3; times-bold-i-normal; “Times New Roman”; Yes; 7. 4; helvetica-medium-r-norma l; “Arial”; No; 4. 5; helvetica-medium-o-norma l; “Arial”; Yes; 4. 6; helvetica-bold-r-normal; “Arial”; No; 7. 7; helvetica-bold-o-normal; “Arial”; Yes; 7. 8; courier-medium-r-normal; “Courie",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:366196,Performance,optimiz,optimized,366196,"ateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The input file contains one color per line in “r g b” float format. This function is useful to profit from a full set of colour-vision deficiency friendly and perceptually uniform colour maps that are available to download; 9.7 The Graphics Editor; A new graphics editor took place in ROOT v4.0. The editor can be activated by selecting the Editor menu entry in the canvas View menu or one of the context menu entries for setting line, fill, marker or text attributes. The following object editors are available for the current ROOT version.; 9.7.1 TAxisEditor. This user interface gives the possibility for changing the following axis attributes:. color of the selected axis, the axis’ title and labels;; the length of thick parameters and the possibility to set them on both axis sides (if +- is selected);; to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;; primary, secondary and tertiary axis divisions can be set via the three number fields;; the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, size, and offset of axis labels can be set similarly. In addition, there is a check box for no exponent choice, and another one for setting the same decimal part for all labels. 9.7.2 TPadEditor. It provides the following user interface:; Fixed aspect ratio - can be set for pad resizing.; Edit - sets pad or canvas as editable.; Cross-hair - sets a cross hair on the pad.; TickX - set ticks along the X axis.; TickY - set ticks along the Y axis.; GridX - set a grid along the X axis.; GridY - set a grid along the Y axis.; The pad or canvas border size can be set if a sunken or a raised border mode is; selected; no border mode can be set too. 9.8 Copy and Paste; You can make a copy of a canvas using TCanvas::DrawClonePad. This method is unique to TCanvas. It clones the ent",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:371383,Performance,scalab,scalable,371383,"ied to the new canvas in the same location as in the old canvas. For example if you were to copy the third pad of surfopt canvas to the top left corner of the target canvas you would have to reset the coordinates of the cloned pad.; 9.9 Legends; Legends for a graph are obtained with a TLegend object. This object points to markers, lines, boxes, histograms, graphs and represent their marker, line, fill attributes. Any object that has a marker or line or fill attribute may have an associated legend. A TLegend is a panel with several entries (class TLegendEntry) and is created by the constructor; TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; const char *header, Option_t *option); The legend is defined with default coordinates, border size and option. The legend coordinates (NDC) in the current pad are x1, y1, x2, y2. The default text attributes for the legend are:. Alignment = 12 left adjusted and vertically centered; Angle = 0 (degrees); Color = 1 (black); Size = calculate when number of entries is known; Font = helvetica-medium-r-normal scalable font = 42, and bold = 62 for title. The title is a regular entry and supports TLatex. The default is no title (header = 0). The options are the same as for TPave; by default, they are “brand”. Once the legend box is created, one has to add the text with the AddEntry() method:; TLegendEntry* TLegend::AddEntry(TObject *obj,; const char *label,; Option_t *option); The parameters are:. *objis a pointer to an object having marker, line, or fill attributes (a histogram, or a graph); label is the label to be associated to the object; option:; “L” draw line associated with line attributes of obj, if obj inherits from TAttLine.; “P” draw poly-marker associated with marker attributes of obj, if obj inherits TAttMarker.; “F” draw a box with fill associated with fill attributes of obj, if obj inherits TAttFill. One may also use the other form of the method AddEntry:; TLegendEntry* TLegend::AddEntry(const char *name,; const",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:374592,Performance,Scalab,Scalable,374592,"rmat.; Click in the canvas area, near the edges, with the right mouse button and select the Print context menu entry. This will generate a file of canvas pointed to by c1. You can select the name of the PostScript file. If the file name is xxx.ps, you will generate a PostScript file named xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript file instead. In your program (or script), you can type:. c1->Print(""xxx.ps"") // or; c1->Print(""xxx.eps""); Next example prints the picture in the pad pointed by pad1.; pad1->Print(""xxx.ps""); The TPad::Print method has a second parameter called option. Its value can be:. 0 which is the default and is the same as “ps”; “ps” a Postscript file is produced; “Portrait” a Postscript file is produced with Portrait orientation; “Landscape” a Postscript file is produced with Landscape orientation; “eps”an Encapsulated Postscript file; “Preview”an Encapsulated Postscript file with preview is produced; “gif” a Graphics Interchange Format file; “cxx” a C++ macro file is generated; “pdf”a Portable Document Format file; “xml” a eXtensible Mark-up Language file; “jpg”a Joint Photographic Experts Group file; “png” a Portable Network Graphics Format (PNG file); “xpm” a X11 Pixel Map Format; “svg” a Scalable Vector Graphics file; “tiff” a Tagged-Image File Format; “root”a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by the filename extension what format you want to save a canvas in (i.e. canvas.ps, canvas.gif, canvas.C, etc).; The size of the PostScript picture, by default, is computed to keep the aspect ratio of the picture on the screen, where the size along x is always 20 cm. You can set the size of the PostScript picture before generating the picture with a command such as:; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; The first parameter in the TPostScript constructor is the name of the file; the second one is the format o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:385489,Performance,perform,performance,385489,"tions have an extended description, in particular:. TStyle::SetLabelFont; TStyle::SetLineStyleString: set the format of dashed lines.; TStyle::SetOptStat; TStyle::SetPalette to change the colors palette; TStyle::SetTitleOffset; TStyle::SetOptDate(Int_t optdate) to support several date formats. If optdate is non-null, the current date/time will be printed in the canvas. The position of the date string can be controlled by: optdate = 10*format+mode; mode = 1 the date is printed in the bottom/left corner; mode = 2 date is printed in the bottom/right corner; mode = 3 date is printed in the top/right corner; format = 0 (default) date format is like: “Wed Sep 25 17:10:35 2002”; format = 1 date format is: “2002-09-25”; format = 2 date format is: “2002-09-25 17:10:35”. 9.13 3D Viewers; ROOT provides several viewers capable of displaying 3D content:. the Pad - simple line drawing using TPad and associated projection class TView;; GL Viewer - high quality and performance viewer(See “The GL Viewer”);; X3D viewer - simple legacy viewer (See “The X3D Viewer”);; GL-in-pad - combination of basic GL viewer in TPad, with no hardware acceleration. The X3D and GL viewers are created as external windows, associated with a pad, and displaying the same content as it. Only these external viewers are detailed here - for Pad (TPad, TView classes) you should refer to “Graphical Containers: Canvas and Pad” and the class definitions.; All viewers use a common architecture to publish 3D objects to the viewer - described in “Common 3D Viewer Architecture” below. In most cases, you will not need to use this, working instead with a package, such as the “The Geometry Package”, which provides comprehensive, high level functionality to create and place objects into complex 3D scenes, and uses the viewer architecture internally to show the result in your chosen viewer.; 9.13.1 Invoking a 3D viewer; A 3D viewer can be created in a script by passing the appropriate option to Draw()when attaching the dra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:387387,Performance,perform,performance,387387," viewer.; 9.13.1 Invoking a 3D viewer; A 3D viewer can be created in a script by passing the appropriate option to Draw()when attaching the drawn object(s) to a pad. For a fuller explanation of pads, attaching objects with Draw() etc. refer to “Graphical Containers: Canvas and Pad”.; root[] myShapes->Draw(""ogl"");; Valid option strings are:. “ogl” : external GL viewer; “x3d”: external X3D viewer; “pad”: pad viewer. If no option is passed to Draw() then the “pad” is used by default. If you already have content in a pad, which you would like to display in one of the external viewers you can select from the canvas View menu / View With, and pick the viewer type. Invoking external 3D viewers from canvas menus. Note: A current limitation means that when an external viewer is created the pad is no longer redrawn. When the external viewer is closed, clicking in the pad will refresh.; 9.13.2 The GL Viewer; The GL Viewer uses <OpenGL®> (or compliant libraries such as ) to generate high quality, high-performance 3D renderings, with sophisticated lighting, materials and rendering styles for 3D scenes. Many users will be able to take advantage of hardware acceleration of the underlying OpenGL commands by their computer’s video card, resulting is considerable performance gains - up to interactive manipulation of 1000’s of complex shapes in real-time.; The GL Viewer is supported on all official ROOT platforms (assuming you have suitable <OpenGL®> libraries), and is the main 3D viewer, which development effort is concentrated upon. As OpenGL® is a trademark we refer to our viewer built on this technology as the ‘GL Viewer’. The code for it can be found under $ROOTSYS/gl. The GL 3D Viewer. You can manipulate the viewer via the GUI or via the base TGLViewer object behind the interface. These are detailed below - see also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.1 Projections Modes (Cameras); The GL Viewer supports two basic types of camera, which affect how the 3D world is p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:387648,Performance,perform,performance,387648,"c. refer to “Graphical Containers: Canvas and Pad”.; root[] myShapes->Draw(""ogl"");; Valid option strings are:. “ogl” : external GL viewer; “x3d”: external X3D viewer; “pad”: pad viewer. If no option is passed to Draw() then the “pad” is used by default. If you already have content in a pad, which you would like to display in one of the external viewers you can select from the canvas View menu / View With, and pick the viewer type. Invoking external 3D viewers from canvas menus. Note: A current limitation means that when an external viewer is created the pad is no longer redrawn. When the external viewer is closed, clicking in the pad will refresh.; 9.13.2 The GL Viewer; The GL Viewer uses <OpenGL®> (or compliant libraries such as ) to generate high quality, high-performance 3D renderings, with sophisticated lighting, materials and rendering styles for 3D scenes. Many users will be able to take advantage of hardware acceleration of the underlying OpenGL commands by their computer’s video card, resulting is considerable performance gains - up to interactive manipulation of 1000’s of complex shapes in real-time.; The GL Viewer is supported on all official ROOT platforms (assuming you have suitable <OpenGL®> libraries), and is the main 3D viewer, which development effort is concentrated upon. As OpenGL® is a trademark we refer to our viewer built on this technology as the ‘GL Viewer’. The code for it can be found under $ROOTSYS/gl. The GL 3D Viewer. You can manipulate the viewer via the GUI or via the base TGLViewer object behind the interface. These are detailed below - see also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.1 Projections Modes (Cameras); The GL Viewer supports two basic types of camera, which affect how the 3D world is projected onto the 2D render area:. Perspective: Objects are drawn with characteristic ‘foreshortening’ effect, where distant objects appear smaller than near ones. This is useful for obtaining a ‘real world’ views. The degree of for",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:396427,Performance,perform,perform,396427,"he render will take. Set the current clip object with TGLClipSet::SetClipType; v->GetClipSet()->SetClipType(TGLClipSet::kClipPlane);; Configure the clip object with TGLClipSet::SetClipState; Double_t planeEq[4] = {0.5,1.0,-1.0, 2.0};; v->GetClipSet()->SetClipState(TGLClipSet::kClipPlane, planeEq);; As with cameras, any clip can be configured at any time, but you must set the clip current to see the effect.; 9.13.2.6 Manipulators; Manipulators are GUI ‘widgets’ or controls attached to a 3D object in the viewer, allowing a direct manipulation of the object’s geometry. There are three manipulators for the three basic geometries transformations. In each case, the manipulator consists of three components, one for each local axis of the object, shown in standard colors: red (X), green (Y) and blue (Z). GL Viewer object manipulators. Activate the manipulator by moving the mouse over one of these components (which turns yellow to indicate active state). Click with left mouse and drag this active component to perform the manipulation. Toggle between the manipulator types using the ‘x’, ‘c’, ‘v’ keys while the mouse cursor is above the manipulator. Note: Manipulators cannot be controlled via the API at present.; 9.13.2.7 Guides; Guides are visual aids drawn into the viewer world. Controls for these are under the “Guides” tab:; Viewer Controls Pane Guides Tab; Axes show the world (global) frame coordinatedirections: X (red), Y (green) and Z (blue). The negative portion of the axis line is shown in dark color, the positive in bright. The axis name and minimum / maximum values are labeled in the same color. There are three options for axes drawing - selected by radio buttons:. None - not drawn (default).; Edge - draw axes on the (minimum) edge of the scene extents box.; Origin - drawn axes through the origin. For edge axes, the zero value for each axis is marked on the axis line with a colored sphere. For origin axes, a single white sphere is shown at the origin.; Edge axes are ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:400804,Performance,perform,performance,400804," the red, green and blue values for the component adjusted via the sliders. You can apply this adjustment to the shape itself, or to all shapes sharing a common ‘family’. Shapes of the same family have external objects with the same TObject name string. You can also adjust the ‘Opacity’ and ‘Shine’ for the shapes materials via the sliders.; 9.13.2.11 Geometry; Viewer Controls Pane ‘Geometry’ tab.; Review and modify the shapes X/Y/Z center and scaling factors via the edit boxes. Selection and editing of shapes is not available via the API at present.; 9.13.2.12 Outputting Viewer Contents; The current viewer rendering can be output to an external EPS or PDF, using the options under the ‘File’ menu on the top menu bar. The file is named ‘viewer.eps’ or ‘viewer.pdf’ and written to the current ROOT directory.; 9.13.3 The X3D Viewer; The X3D viewer is a fairly simple and limited viewer, capable of showing basic lines and polygons. It lacks the quality, performance and more advanced features of the GL Viewer, and additionally is not supported on Windows. It is not actively developed and you are encouraged to use the GL Viewer out of preference. The below table presents the main interactions - these are repeated in the Help dialog of the viewer.; Action KeyActionKey; Wireframe Mode wRotate about xx a; Hidden Line Mode eRotate about yy b; Hidden Surface Mode rRotate about zz c; Move object down uAuto-rotate about x1 2 3; Move object up iAuto-rotate about y4 5 6; Move object left lAuto-rotate about z7 8 9; Move object right hToggle controls styleo; Move object forward jToggle stereo displays; Move object backward kToggle blue stereo viewd; Adjust focus (stereo mode) [ ] { }Toggle double bufferf; Rotate object Left mouse button down + move.; 9.13.4 Common 3D Viewer Architecture; The 3D Viewer Architecture provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects fro",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:402732,Performance,Perform,Perform,402732," provides a common mechanism for viewer clients to publish 3D objects to it. It enables:. Decoupling of producers (geometry packages etc) who model collection of 3D objects from consumers (viewers) which display them.; Producer code free of explicit drawing commands & viewer specific branching.; Support differing viewers and clients capabilities, e.g.; Mix of native (in viewer) shapes and generic client side tessellation.; Local/global frame object description; Bounding boxes; Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to add objects, test preferences etc.; TBuffer3D class hierarchy: Used to describe 3D objects (“shapes”) - filled /added by negotiation with viewer via TVirtualViewer3D. A typical interaction between viewer and client using these, taken from TGeoPainter is:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; In addition to external viewers, created in separate windows, this architecture is also used by internal TPad drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:; 1- C",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:404068,Performance,perform,perform,404068,"ns fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kNone); shape.GetBuffer3D(reqSections, localFrame);; Together these allow clients to publish objects to any one of the 3D viewers free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; In addition to external viewers, created in separate windows, this architecture is also used by internal TPad drawing when it requires 3D projections. Publishing to a viewer consists of the following steps:; 1- Create / obtain viewer handle.; 2- Begin scene on viewer.; 3- Fill mandatory parts of TBuffer3D describing object.; 4- Add to viewer.; 5- Fill optional parts of TBuffer3D as requested by viewer.; [ …. repeat 3/4/5 as required for other/child objects]; 6- End scene on viewer.; You should attach the top-level node of your external geometry (or the manager) to a TPad object using TObject::Draw(), and perform the publishing to the viewer in your object’s TObject::Paint() overloaded method. See “Scene Rebuilds”, and example scripts, for more details.; 9.13.4.1 Creating / Obtaining Viewer Handle; External viewers are bound to a TPad object (this may be removed as a requirement in the future). You can create or obtain the current viewer handle via the method:; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; Here the “type” string defines the viewer type - currently one of:. “ogl” : External GL viewer; “x3d”: External X3D viewer; “pad”: Pad viewer. If no type is passed (null string), and there is no current viewer, then the type is defaulted to “pad”. If no type is passed and there is a current viewer, then this is returned - hence once a viewer is created it can be obtained elsewhere by:; TVirtualViewer3D * v = gPad->GetViewer3D();; 9.13.4.2 Opening / Closing Scenes; Objects must be added to viewer between BeginScene() and EndScene() calls e.g.; viewer->BeginScene(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:405146,Performance,perform,perform,405146,"r in your object’s TObject::Paint() overloaded method. See “Scene Rebuilds”, and example scripts, for more details.; 9.13.4.1 Creating / Obtaining Viewer Handle; External viewers are bound to a TPad object (this may be removed as a requirement in the future). You can create or obtain the current viewer handle via the method:; TVirtualViewer3D * v = gPad->GetViewer3D(""type"");; Here the “type” string defines the viewer type - currently one of:. “ogl” : External GL viewer; “x3d”: External X3D viewer; “pad”: Pad viewer. If no type is passed (null string), and there is no current viewer, then the type is defaulted to “pad”. If no type is passed and there is a current viewer, then this is returned - hence once a viewer is created it can be obtained elsewhere by:; TVirtualViewer3D * v = gPad->GetViewer3D();; 9.13.4.2 Opening / Closing Scenes; Objects must be added to viewer between BeginScene() and EndScene() calls e.g.; viewer->BeginScene();; // Add objects; viewer ->EndScene();; These calls enable the viewer to suspend redraws, and perform internal caching/setup. If the object you attach to the pad derives from TAtt3D, then the pad will take responsibility for calling BeginScene() and EndScene() for you. You can always test if the scene is already open for object addition with:; viewer->BuildingScene();. Overview of 3D viewer architecture. Note: the x3d viewer does not support rebuilding of scenes - objects added after the first Open/Close Scene pair will be ignored.; 9.13.4.3 Describing Objects - Filling TBuffer3D; The viewers behind the TVirtualViewer3D interface differ greatly in their capabilities e.g. Some support native shape (e.g. spheres/tubes in OpenGL) and can draw these based on an abstract description. Others always require a tessellation description based on TBuffer3D’s kRaw / kRawSizes points/lines/segments sections.; Some need the 3D object positions in the master (world) frame, others can cope with local frames and a translation matrix to place the object",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:408137,Performance,perform,perform,408137,"d in TBuffer3D derived classes, allowing a more abstract shape description (“a sphere of inner radius x, outer radius y”). This enables a viewer, which knows how to draw (tessellate) the shape itself to do so, while providing a generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; Complete the mandatory kCore section.; Complete the kShapeSpecific section if applicable.; Complete the kBoundingBox if you can.; Pass this buffer to the viewer using one of the TBuffer3D::AddObject() methods. If the viewer requires more sections to be completed (kRaw/kRawSizes) TBuffer3D::AddObject() will return flags indicating which ones, otherwise it returns kNone. If requested, you must fill the buffer, mark these sections valid, and call TBuffer3D::AddObject again, to complete adding the object. For example, in out TGeo geometry package, in TGeoPainter::PaintShape, we perform the negotiation with viewer:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; if (shape.IsA() != TGeoCompositeShape::Class()) {; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and adding; // it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific, localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; // If the viewer requires additional sections fetch from the; // shape (if possible) and add again; if (reqSections != TBuffer3D::kNone) {; shape.GetBuffer3D(reqSections, localFrame);; viewer->AddObject(buffer, &addDaughters);; }; }; The buffer is supplied/filled by the appropriate TShape::GetBuffer3D() and TShape::FillBuffer3D overloads e.g. for a sphere in TGeoSphere.; const TBuffer3D &TGeoSphere::GetBuffer3D(Int_t reqSections,; Bool_t localFrame) const {; // Fills a static 3D buffer and returns",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:408374,Performance,Perform,Perform,408374,"hile providing a generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; Complete the mandatory kCore section.; Complete the kShapeSpecific section if applicable.; Complete the kBoundingBox if you can.; Pass this buffer to the viewer using one of the TBuffer3D::AddObject() methods. If the viewer requires more sections to be completed (kRaw/kRawSizes) TBuffer3D::AddObject() will return flags indicating which ones, otherwise it returns kNone. If requested, you must fill the buffer, mark these sections valid, and call TBuffer3D::AddObject again, to complete adding the object. For example, in out TGeo geometry package, in TGeoPainter::PaintShape, we perform the negotiation with viewer:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; if (shape.IsA() != TGeoCompositeShape::Class()) {; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and adding; // it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific, localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; // If the viewer requires additional sections fetch from the; // shape (if possible) and add again; if (reqSections != TBuffer3D::kNone) {; shape.GetBuffer3D(reqSections, localFrame);; viewer->AddObject(buffer, &addDaughters);; }; }; The buffer is supplied/filled by the appropriate TShape::GetBuffer3D() and TShape::FillBuffer3D overloads e.g. for a sphere in TGeoSphere.; const TBuffer3D &TGeoSphere::GetBuffer3D(Int_t reqSections,; Bool_t localFrame) const {; // Fills a static 3D buffer and returns a reference.; static TBuffer3DSphere buffer;; // Filling of kBoundingBox is defered to TGeoBBox, and; // kCore on up to TGeoShape; TGeoBBox::FillBuffer3D(buffer, reqSections, localFrame);; // Complete kShapeSpe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:414025,Performance,cache,cached,414025,"ffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; 9.13.4.7 Logical and Physical Objects; Some viewers can support two types of object placement:. Add object as a single independent entity in the world reference frame - e.g. a sphere, radius r, at x, y, z.; Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g. define a sphere S (radius r), place copy at x1, y1, z1, another copy at x2, y2, z2 etc. The second case is very typical in geometry packages, e.g. ROOT’s TGeo package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.; Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. In some cases you will not have a real object you can reasonably set TBuffer3D::fID to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set TBuffer3D::fID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster tran",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:414122,Performance,perform,perform,414122,"ctionsValid(TBuffer3D::kBoundingBox);; }; 9.13.4.7 Logical and Physical Objects; Some viewers can support two types of object placement:. Add object as a single independent entity in the world reference frame - e.g. a sphere, radius r, at x, y, z.; Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g. define a sphere S (radius r), place copy at x1, y1, z1, another copy at x2, y2, z2 etc. The second case is very typical in geometry packages, e.g. ROOT’s TGeo package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.; Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. In some cases you will not have a real object you can reasonably set TBuffer3D::fID to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set TBuffer3D::fID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster transform; fColor; fTransparency. attributes, which can be varied for each physical object.; As a minimum requirement all clients must ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:414193,Performance,perform,performance,414193,"ctionsValid(TBuffer3D::kBoundingBox);; }; 9.13.4.7 Logical and Physical Objects; Some viewers can support two types of object placement:. Add object as a single independent entity in the world reference frame - e.g. a sphere, radius r, at x, y, z.; Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g. define a sphere S (radius r), place copy at x1, y1, z1, another copy at x2, y2, z2 etc. The second case is very typical in geometry packages, e.g. ROOT’s TGeo package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.; Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. In some cases you will not have a real object you can reasonably set TBuffer3D::fID to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set TBuffer3D::fID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster transform; fColor; fTransparency. attributes, which can be varied for each physical object.; As a minimum requirement all clients must ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:415603,Performance,cache,cached,415603,"ID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster transform; fColor; fTransparency. attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. If either does not meet this requirement the object may not be displayed.; 9.13.4.8 Scene Rebuilds; TBuffer3D::AddObject is not an explicit command to the viewer - it may for various reasons decide to ignore it:. It already has the object internally cached.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddOb",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:416335,Performance,perform,perform,416335,"ays be capable of displaying the object described by this buffer. If either does not meet this requirement the object may not be displayed.; 9.13.4.8 Scene Rebuilds; TBuffer3D::AddObject is not an explicit command to the viewer - it may for various reasons decide to ignore it:. It already has the object internally cached.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:417146,Performance,cache,cache,417146,"It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:418332,Performance,perform,performed,418332,"cene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine the code under $ROOTSYS/geom - in particular TGeoShape hierarchy, and the painter object TGeoPainter (under geopainter) where the negotiation with the viewer is performed.; 10 Folders and Tasks; 10.1 Folders. A TFolder is a collection of objects visible and expandable in the ROOT object browser. Folders have a name and a title and are identified in the folder hierarchy by an “UNIX-like” naming convention. The base of all folders is //root. It is visible at the top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:427483,Performance,load,loads,427483,"(""matInit"",; ""MaterialsInitialisation"");; TTask *tracker = new MyTracker(""tracker"",""Tracker manager"");; TTask *tpc = new MyRecTPC(""tpc"",""TPC Reconstruction"");; TTask *its = new MyRecITS(""its"",""ITS Reconstruction"");; TTask *muon = new MyRecMUON(""muon"",""MUON Reconstruction"");; TTask *phos = new MyRecPHOS(""phos"",""PHOS Reconstruction"");; TTask *rich = new MyRecRICH(""rich"",""RICH Reconstruction"");; TTask *trd = new MyRecTRD(""trd"",""TRD Reconstruction"");; TTask *global = new MyRecGlobal(""global"",""Global Reconstruction"");. // Create a hierarchy by adding sub tasks; run->Add(geomInit);; run->Add(matInit);; run->Add(event);; event->Add(tracker);; event->Add(global);; tracker->Add(tpc);; tracker->Add(its);; tracker->Add(muon);; tracker->Add(phos);; tracker->Add(rich);; tracker->Add(trd);. // Add the top level task; gROOT->GetListOfTasks()->Add(run);. // Add the task to the browser; gROOT->GetListOfBrowsables()->Add(run);; new TBrowser;; }. Tasks in the ROOT browser. Note that the first line loads the class definitions in MyTasks.cxx with ACLiC. ACLiC builds a shared library and adds the classes to the Cling dictionary. See “Adding a Class with ACLiC”.; To execute a TTask, you call the ExecuteTask method. ExecuteTask will recursively call:. the TTask::Execmethod of the derived class;; the TTask::ExecuteTasks to execute for each task the list of its subtasks;. If the top level task is added to the list of ROOT browsable objects, the tree of tasks can be seen in the ROOT browser. To add it to the browser, get the list of browsable objects first and add it to the collection.; gROOT->GetListOfBrowsables()->Add(run);; The first parameter of the Add method is a pointer to a TTask, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.; After executing, the script above the browser will look like in this figure.; 10.5 Execute and Debug Tasks; The browser can be used to start a task, set break points at the beginning of a task ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:474859,Performance,load,loaded,474859,"treamer takes a TBuffer as a parameter, and first checks to see if this is a case of reading or writing the buffer.; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; fTransient = gDirectory; //save current directory; fPt= TMath::Sqrt(fPx*fPx + fPy*fPy + fPz*fPz);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; 11.3.8 Writing Objects; The Streamer decomposes the objects into data members and writes them to a buffer. It does not write the buffer to a file, it simply populates a buffer with bytes representing the object. This allows us to write the buffer to a file or do anything else we could do with the buffer. For example, we can write it to a socket to send it over the network. This is beyond the scope of this chapter, but it is worthwhile to emphasize the need and advantage of separating the creation of the buffer from its use. Let us look how a buffer is written to a file. The dictionary for a class needs to be loaded before any object of that type can be saved.; The TObject::Write method does the following:. Creates a TKey object in the current directory; Creates a TBuffer object which is part of the newly created TKey; Fills the TBuffer with a call to the class::Streamer method; Creates a second buffer for compression, if needed; Reserves space by scanning the TFree list. At this point, the size of the buffer is known.; Writes the buffer to the file; Releases the TBuffer part of the key. In other words, the TObject::Write calls the Streamer method of the class to build the buffer. The buffer is in the key and the key is written to disk. Once written to disk the memory consumed by the buffer part is released. The key part of the TKey is kept. A diagram of a streamed TH1F in the buffer. The key consumes about 60 bytes, whereas the buffer, since it contains the object data, can be very large.; 11.3.9 Ignore Object Streamers; Your class can ignore the TObject Streamerwith the MyClass->Class::IgnoreOb",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:476942,Performance,perform,performance,476942,"reTObjectStreamermethod), the automatically generated Streamerwill not call TObject::Streamer, and the TObject part of the class is not streamed to the file. This is useful in case you do not use the TObject fBits and fUniqueIDdata members. You gain space on the file, and you do not loose functionality if you do not use the fBits and fUniqueID.See “The Role of TObject” on the use of fBits and fUniqueID.; 11.3.10 Streaming a TClonesArray; When writing a TClonesArray it bypasses by default the Streamerof the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477149,Performance,optimiz,optimized,477149,"le. This is useful in case you do not use the TObject fBits and fUniqueIDdata members. You gain space on the file, and you do not loose functionality if you do not use the fBits and fUniqueID.See “The Role of TObject” on the use of fBits and fUniqueID.; 11.3.10 Streaming a TClonesArray; When writing a TClonesArray it bypasses by default the Streamerof the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer fun",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477434,Performance,optimiz,optimized,477434,"of the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477540,Performance,perform,performance,477540,"of the member class and uses a more efficient internal mechanism to write the members to the file. You can override the default and specify that the member class Streameris used by setting the TClonesArray::BypassStreamer bit to false:; TClonesArray *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477730,Performance,optimiz,optimization,477730,"y *fTracks;; fTracks->BypassStreamer(kFALSE); // use the member Streamer; When the kBypassStreamer bit is set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477779,Performance,optimiz,optimized,477779,"set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ b",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:478184,Performance,optimiz,optimized,478184,"g optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ but the advantage of a C++ pointer is that it is already C++.; 11.4.1 Streaming C++ Pointers; When ROOT encounters a pointer data member it calls the Streamer of the object and labels it with a unique object identifier. The object identifier is unique for one I/O operation. If there is another pointer to the object in the same I/O",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:487015,Performance,Load,LoadHits,487015," definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName points to something; When the special keyword ""EXEC:"" is found in the comment field of the member, the next string is assumed to be the name of a TExec object. When a file is connected, the dictionary of the classes on the file is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement object is read, a TExec object is automatically created with the name specified after the keyword ""EXEC:"" in case a TExec with a same name does not already exist.; The action to be executed via this TExec can be specified with:. A call to the TExec constructor, if the constructor is called before; Opening the file.; A call to TExec::SetAction at any time. One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; The parameter actionCommand is a string containing a Cling instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; When a TRef is de-referenced via TRef::GetObject, its TExec** is automatically executed. The TExec function/script can do one or more of the following:**. Load a file containing the referenced object. This function typically looks in the file catalog.; Compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::SetObject via:. TRef::SetObject(object); As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is in $ROOTSYS/test/Event.h:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject will automatically invoke the script GetWebHistogram.C via the interpreter. An example of a GetWebHistogram.C script is shown below:; void GetWebHistogram(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:487220,Performance,Load,Load,487220,"e name of a TExec object. When a file is connected, the dictionary of the classes on the file is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement object is read, a TExec object is automatically created with the name specified after the keyword ""EXEC:"" in case a TExec with a same name does not already exist.; The action to be executed via this TExec can be specified with:. A call to the TExec constructor, if the constructor is called before; Opening the file.; A call to TExec::SetAction at any time. One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; The parameter actionCommand is a string containing a Cling instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; When a TRef is de-referenced via TRef::GetObject, its TExec** is automatically executed. The TExec function/script can do one or more of the following:**. Load a file containing the referenced object. This function typically looks in the file catalog.; Compute a pointer to the referenced object and communicate this pointer back to the calling function TRef::SetObject via:. TRef::SetObject(object); As soon as an object is returned to GetObject, the fUniqueID of the TRef is set to the fUniqueID of the referenced object. At the next call to GetObject, the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is in $ROOTSYS/test/Event.h:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject will automatically invoke the script GetWebHistogram.C via the interpreter. An example of a GetWebHistogram.C script is shown below:; void GetWebHistogram() {; TFile *f=TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetObject(h6);; }; In the above example, a call to fWebHistog",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:496428,Performance,Optimiz,Optimized,496428,"ion offset=540 type=65 histogram options; TList* fFunctions offset=548 type=63 ->Pointer to list of functions; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:496493,Performance,optimiz,optimized,496493,"ion offset=540 type=65 histogram options; TList* fFunctions offset=548 type=63 ->Pointer to list of functions; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:496638,Performance,perform,performance,496638,"Named type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside the class definition. The syntax is:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:496650,Performance,optimiz,optimization,496650,"Named type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; i= 4, fNcells type= 3, offset= 60, len=1, method=0; i= 5, fXaxis type= 61, offset= 64, len=1, method=1081287424; i= 6, fYaxis type= 61, offset=192, len=1, method=1081287548; i= 7, fZaxis type= 61, offset=320, len=1, method=1081287676; i= 8, fBarOffset type= 22, offset=448, len=2, method=0; i= 9, fEntries type= 28, offset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside the class definition. The syntax is:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:498530,Performance,load,load,498530,"s:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particular version of the class. When a class has version 0 it is not stored in a root file but its base class(es) is(are). The reason can be that this class has no data members worth saving or all real info is in the base classes. The version number is written to the file in the Streamer by the call TBuffer::WriteVersion. You, as the designer of the class, do not need to do any manual modification in the Streamer. ROOT schema evolution mechanism is automatic and handled by the StreamerInfo.; 11.5.6 Manual Data Model Evolution Capabilities; The automatic data model schema evolution implemented in ROOT makes it possible to read back the serialized data object in the situation when the definition of the classes those objects represent changed slightly (some of the data members were removed or some new ones added). It is also possible to manually specify the rules for more sophisticated data transformations done while reading to load the serialized objects into data structures that changed quite significantly.; ROOT provides two interface enabling users to specify the conversion rules. The first way is to define a rule in the dictionary file and the second way is to insert it to the TClass object using the C++ API.; There are two types of conversion rules. The first of them, the normal rules, are the ones that should be used in the most of the cases. They provide a buffered input data and an address of the in-memory target object and allow user to specify the conversion function mapping the data being read to the output format. The second type of the rules, the raw rules, also provide the pointer to the target object but the input is a raw TBuffer object containing the input data member declared as an input to the rule. This type of a rule is provided mainly to handle the file format changes that couldn’t have been handled otherwise and in general should not be used unless there is no other op",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:501115,Performance,cache,cached,501115,"eadraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; The variables in the rules have the following meaning:. sourceClass. The field defines the on-disk class that is the input for the rule. source. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule. The list has to be enclosed in a square bracket and be a comma-separated list of versions or version ranges. The version is an integer number, whereas the version range is one of the following:; “a-b”: a and b are integers and the expression means all the numbers between and including a and b; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an integer and the expression means all the version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square br",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506344,Performance,load,loaded,506344,"sy to make and mismatches between Streamer writers and readers are frequent and increase as the number of classes increase. We recommend you use rootcling generated Streamers whenever you can, and profit from the automatic schema evolution.; 11.5.8 Building Class Definitions with the StreamerInfo; A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:506634,Performance,load,load,506634," A ROOT file’s StreamerInfolist contains the description of all versions of all classes in the file. When a file is opened the StreamerInfois read into memory and it provides enough information to make the file browsable. The TStreamerInfoenables us to recreate a header file for the class in case the compiled class is not available. This is done with the TFile::MakeProject method. It creates a directory with the header files for the named classes and a makefile to compile a shared library with the class definitions.; 11.5.9 Example: MakeProject; To explain the details, we use the example of the ATLFast project that is a fast simulation for the ATLAS experiment. The complete source for ATLFast can be down loaded at ftp://root.cern.ch/root/atlfast.tar.gz. Once we compile and run ATLFast we get a ROOT file called atlfast.root, containing the ATLFast objects. When we open the file, we get a warning that the file contains classes that are not in the dictionary. This is correct since we did not load the class definitions.; root[] TFile f(""atlfast.root""); Warning in <TClass::TClass>: no dictionary for class TMCParticle is available; Warning in <TClass::TClass>: no dictionary for class ATLFMuon available; We can see the StreamerInfofor the classes:; root[] f.ShowStreamerInfo(); ...; StreamerInfo for class: ATLFMuon, version=1; BASE TObject offset= 0 type=66 Basic ROOT object; BASE TAtt3D offset= 0 type= 0 3D attributes; Int_t m_KFcode offset= 0 type= 3 Muon KF-code; Int_t m_MCParticle offset= 0 type= 3 Muon position in MCParticles list; Int_t m_KFmother offset= 0 type= 3 Muon mother KF-code; Int_t m_UseFlag offset= 0 type= 3 Muon energy usage flag; Int_t m_Isolated offset= 0 type= 3 Muon isolation (1 for isolated); Float_t m_Eta offset= 0 type= 5 Eta coordinate; Float_t m_Phi offset= 0 type= 5 Phi coordinate; Float_t m_PT offset= 0 type= 5 Transverse energy; Int_t m_Trigger offset= 0 type= 3 Result of trigger...; However, when we try to use a specific class we get a warning ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:510398,Performance,load,loads,510398,"te” If the directory does not exist, it is creates as in “new”, in addition if the directory does exist, all existing files are deleted before creating the new files.; “update” The new classes are added to the existing directory and the existing classes are replaced with the new definition. If the directory does not exist, it creates it as in “new”.; “+”: This option can be used in combination with the other three. It will create the necessary files to easily build a shared library containing the class definitions.Specifically it will:; Generate a script called MAKE that builds the shared library containing the definition of all classes in the directory.; Generate a LinkDef.hfiles to use with rootcling in MAKE.; Run rootcling to generate a <dirname>ProjectDict.cxx file.; Compile the <dirname>ProjectDict.cxxwith the current options in compiledata.h.; Build a shared library<dirname>.so.; “++”:This option can be used instead of the single “+”. It does everything the single “+” does, and dynamically loads the shared library <dirname>.so. This example makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:510679,Performance,load,loaded,510679," the existing classes are replaced with the new definition. If the directory does not exist, it creates it as in “new”.; “+”: This option can be used in combination with the other three. It will create the necessary files to easily build a shared library containing the class definitions.Specifically it will:; Generate a script called MAKE that builds the shared library containing the definition of all classes in the directory.; Generate a LinkDef.hfiles to use with rootcling in MAKE.; Run rootcling to generate a <dirname>ProjectDict.cxx file.; Compile the <dirname>ProjectDict.cxxwith the current options in compiledata.h.; Build a shared library<dirname>.so.; “++”:This option can be used instead of the single “+”. It does everything the single “+” does, and dynamically loads the shared library <dirname>.so. This example makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; /////",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:511416,Performance,load,load,511416,"makes a directory called MyProject that will contain all class definitions from the atlfast.root file. The necessary makefile to build a shared library are also created, and since the ‘++’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:511516,Performance,Load,Load,511516,"’ is appended, the shared library is also loaded.; root[] f.MakeProject(""MyProject"",""*"", ""recreate++""); MakeProject has generated 0 classes in MyProject; MyProject/MAKE file has been generated; Shared lib MyProject/MyProject.so has been generated; Shared lib MyProject/MyProject.so has been dynamically linked; The contents of MyProject:; root[] .! ls MyProject; ATLFCluster.h ATLFJet.h ATLFMiscMaker.h ATLFTrack.h; TMCParticle.h ATLFClusterMaker.h ATLFJetMaker.h ATLFMuon.h; ATLFElectron.h ATLFMCMaker.h ATLFMuonMaker.h ATLFElectronMaker.h; ATLFMaker.h ATLFPhoton.h ATLFHistBrowser.h ATLFMisc.h; ATLFPhotonMaker.h ATLFTrackMaker.h ATLFTrigger.h ATLFTriggerMaker.h; LinkDef.h MAKE MyProject.so MyProjectProjectDict.h; MyProjectProjectDict.cxx MyProjectProjectDict.o; Now you can load the shared library in any consecutive root session to use the atlfast classes.; root[]gSystem->Load(""MyProject/MyProject""); root[]ATLFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:512519,Performance,Perform,Performance,512519,"LFMuon muon; This is an example of a generated header file:; //////////////////////////////////////////////////////////; // This class has been generated by TFile::MakeProject; // (Thu Apr 5 10:18:37 2001 by ROOT version 3.00/06); // from the TStreamerInfo in file atlfast.root; //////////////////////////////////////////////////////////; #ifndef ATLFMuon_h; #define ATLFMuon_h; #include ""TObject.h""; #include ""TAtt3D.h""; class ATLFMuon : public TObject , public TAtt3D {; public:; Int_t m_KFcode; //Muon KF-code; Int_t m_MCParticle; //Muon position in MCParticles list; Int_t m_KFmother; //Muon mother KF-code; Int_t m_UseFlag; //Muon energy usage flag; Int_t m_Isolated; //Muon isolation (1 for isolated); Float_t m_Eta; //Eta coordinate; Float_t m_Phi; //Phi coordinate; Float_t m_PT; //Transverse energy; Int_t m_Trigger; //Result of trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compression. The default for ROOT is one. The compression level can be set with the method TFile::SetCompressionLevel. The experience with this algorithm shows that a compression level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may compress the data by a factor of 10. On the other hand if the time spend on I/O is large, compression may have a large impact on the program’s performance.; The compression factor, i.e. the savings of disk space, varies with the type of data. A buffer with a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:513438,Performance,perform,performance,513438," trigger; ATLFMuon() {;}; virtual ~ATLFMuon() {;}; ClassDef(ATLFMuon,1) //; };; ClassImp(ATLFMuon); #endif; 11.6 Compression and Performance; ROOT uses a compression algorithm based on the well-known gzip algorithm. It supports nine levels of compression. The default for ROOT is one. The compression level can be set with the method TFile::SetCompressionLevel. The experience with this algorithm shows that a compression level of 1.3 for raw data files and around two on most DST files is the optimum. The choice of one for the default is a compromise between the time it takes to read and write the object vs. the disk space savings.; To specify no compression, set the level to zero.; We recommend using compression when the time spent in I/O is small compared to the total processing time. If the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may compress the data by a factor of 10. On the other hand if the time spend on I/O is large, compression may have a large impact on the program’s performance.; The compression factor, i.e. the savings of disk space, varies with the type of data. A buffer with a same value array is compressed so that the value is only written once. For example, a track has the mass of a pion that it is always the same, and the charge of the pion that is either positive or negative. For 1000 pions, the mass will be written only once, and the charge only twice (positive and negative). When the data is sparse, i.e. when there are many zeros, the compression factor is also high. Compression level; Bytes; Write Time (sec); Read Time (sec.). 0; 1,004,998; 4.77; 0.07. 1; 438,366; 6.67; 0.05. 5; 429,871; 7.03; 0.06. 9; 426,899; 8.47; 0.05. The time to uncompress an object is small compared to the compression time and is independent of the selected compression level. Note that the compression level may be changed at any time, but the new compression level will only apply to newly written objects. Consequently",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518448,Performance,load,loaded,518448,"ave a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how obje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518480,Performance,Load,Load,518480,"ave a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how obje",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518532,Performance,load,loaded,518532," have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:519663,Performance,optimiz,optimized,519663,"le::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how objects can be saved in ROOT files. In case you want to store large quantities of same-class objects, ROOT has designed the TTree and TNtuple classes specifically for that purpose. The TTree class is optimized to reduce disk space and enhance access speed. A TNtuple is a TTree that is limited to only hold floating-point numbers; a TTree on the other hand can hold all kind of data, such as objects or arrays in addition to all the simple types.; When using a TTree, we fill its branch buffers with leaf data and the buffers are written to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:520997,Performance,optimiz,optimize,520997,"itten to disk when it is full. Branches, buffers, and leafs, are explained a little later in this chapter, but for now, it is important to realize that each object is not written individually, but rather collected and written a bunch at a time.; This is where the TTree takes advantage of compression and will produce a much smaller file than if the objects were written individually. Since the unit to be compressed is a buffer, and the TTree contains many same-class objects, the header of the objects can be compressed.; The TTree reduces the header of each object, but it still contains the class name. Using compression, the class name of each same-class object has a good chance of being compressed, since the compression algorithm recognizes the bit pattern representing the class name. Using a TTree and compression the header is reduced to about 4 bytes compared to the original 60 bytes. However, if compression is turned off, you will not see these large savings.; The TTree is also used to optimize the data access. A tree uses a hierarchy of branches, and each branch can be read independently from any other branch. Now, assume that Px and Py are data members of the event, and we would like to compute Px2 + Py2 for every event and histogram the result.; If we had saved the million events without a TTree we would have to:. read each event in its entirety into memory; extract the Px and Py from the event; compute the sum of the squares; fill a histogram. We would have to do that a million times! This is very time consuming, and we really do not need to read the entire event, every time. All we need are two little data members (Px and Py). On the other hand, if we use a tree with one branch containing Px and another branch containing Py, we can read all values of Px and Py by only reading the Px and Py branches. This makes the use of the TTree very attractive.; 12.2 A Simple TTree; This script builds a TTree from an ASCII file containing statistics about the staff at CERN. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:525717,Performance,load,load,525717,"***************; *Br 0 :staff :Category/I:Flag:Age:Service:Children:Grade:... *; * | Cost *; *Entries :3354 : Total Size = 154237 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; 12.5 Scan a Variable the Tree with TTree::Scan; The TTree::Scan method shows all values of the list of leaves separated by a colon.; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewer looks like for the example file cernstaff.root. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select SetTreeName and enter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:525865,Performance,load,load,525865,"7 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; 12.5 Scan a Variable the Tree with TTree::Scan; The TTree::Scan method shows all values of the list of leaves separated by a colon.; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewer looks like for the example file cernstaff.root. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select SetTreeName and enter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enabl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:525918,Performance,Load,Load,525918,"7 bytes File Size = 32316 *; *Baskets : 3 : Basket Size = 32000 bytes Compression= 2.97 *; 12.5 Scan a Variable the Tree with TTree::Scan; The TTree::Scan method shows all values of the list of leaves separated by a colon.; root[] T->Scan(""Cost:Age:Children""); ************************************************; * Row * Cost * Age * Children *; ************************************************; * 0 * 11975 * 58 * 0 *; * 1 * 10228 * 63 * 0 *; * 2 * 10730 * 56 * 2 *; * 3 * 9311 * 61 * 0 *; * 4 * 9966 * 52 * 2 *; * 5 * 7599 * 60 * 0 *; * 6 * 9868 * 53 * 1 *; * 7 * 8012 * 60 * 1 *; ...; 12.6 The Tree Viewer. Activating the tree viewer. The tree viewer is a quick and easy way to examine a tree. To start the tree viewer, open a file and object browser. Right click on a TTree and select StartViewer. You can also start the tree viewer from the command line. First load the viewer library.; root[] TFile f(""cernstaff.root""); root[] T->StartViewer(); If you want to start a tree viewer without a tree, you need to load the tree player library first:; root[] gSystem->Load(""libTreeViewer.so""); root[] new TTreeViewer(); The figure above shows how the tree viewer looks like for the example file cernstaff.root. The left panel contains the list of trees and their branches; in this case there is only one tree. You can add more trees with the File-Open command to open the file containing the new tree, then use the context menu on the right panel, select SetTreeName and enter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enabl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:527341,Performance,concurren,concurrently,527341,"nter the name of the tree to add. On the right are the leaves or variables in the tree. You can double click on any leaf to a histogram it.; The toolbar in the upper part can be used for user commands, changing the drawing option and the histogram name. The lower part contains three picture buttons that draw a histogram, stop the current command, and refresh the tree.; The three check buttons toggle the following:; Hist- the histogram drawing mode;; Scan- enables redirecting of TTree::Scancommand in an ASCII file;; Rec - enables recording of the last issued command. To draw more than one dimension you can drag and drop any leaf to the X,Y,Z boxes"". Then push the Draw button, witch is marked with the purple icon on the bottom left.; All commands can be interrupted at any time by pressing this button.; The method TTree::Refresh is called by pressing the refresh button in TTreeViewer. It redraws the current exposed expression. Calling TTree::Refresh is useful when a tree is produced by a writer process and concurrently analyzed by one or more readers.; To add a cut/weight to the histogram, enter an expression in the “cut box”. The cut box is the one with the scissor icon. Below them there are two text widgets for specifying the input and output event lists. A Tree Viewer session is made by the list of user-defined expressions and cuts, applying to a specified tree. A session can be saved using File / SaveSource menu or the SaveSource method from the context menu of the right panel. This will create a macro having as default name treeviewer.C that can be ran at any time to reproduce the session.; Besides the list of user-defined expressions, a session may contain a list of RECORDS. A record can be produced in the following way: dragging leaves/expression on X/Y/Z; changing drawing options; clicking the RED button on the bottom when happy with the histogram; NOTE that just double clicking a leaf will not produce a record: the histogram must be produced when clicking the D",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:531926,Performance,load,load,531926,"Folders and Tasks”). You can build a folder structure and create a tree with branches for each of the sub-folders:; TTree folder_tree(""MyFolderTree"",""/MyFolder"");; The second argument ""/MyFolder""is the top folder, and the “/” signals the TTree constructor that this is a folder not just the title. You fill the tree by placing the data into the folder structure and calling TTree::Fill.; 12.7.2 Tree and TRef Objects; MyTree->BranchRef();; This call requests the construction of an optional branch supporting table of references (TRefTable). This branch (TBranchRef) will keep all the information needed to find the branches containing referenced objects at each Tree::Fill, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via TTree::Write for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow TTree::Draw to automatically load the branches needed to dereference a TRef (or TRefArray) object.; 12.7.3 Autosave; Autosave gives the option to save all branch buffers every n byte. We recommend using Autosave for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last Autosave. To set the number of bytes between Autosave you can use the TTree::SetAutosave() method. You can also call TTree::Autosave in the acquisition loop every nentry.; 12.7.4 Trees with Circular Buffers; When a TTree is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.; void TTree::SetCircular(Long64_t maxEntries);; where maxEntries is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the Tree are deleted and the buffers used again. An example of a script using a circular buffer is shown below:; void circular() {; gR",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:536432,Performance,optimiz,optimize,536432," create an index using leaves Run and Event; tree.BuildIndex(""Run"",""Event"");; // to read entry corresponding to Run=1234 and Event=56789; tree.GetEntryWithIndex(1234,56789);; Note that majorname and minorname may be expressions using original tree variables e.g.: “run-90000”, “event +3*xx”. In case an expression is specified, the equivalent expression must be computed when calling GetEntryWithIndex(). To build an index with only majorname, specify minorname=""0"" (default).; Note that once the index is built, it can be saved with the TTree object with:; tree.Write(); //if the file has been open in ""update"" mode; The most convenient place to create the index is at the end of the filling process just before saving the tree header. If a previous index was computed, it is redefined by this new call.; Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure).; 12.8 Branches; The organization of branches allows the designer to optimize the data for the anticipated use. The class for a branch is called TBranch. If two variables are independent, and the designer knows the variables will not be used together, they should be placed on separate branches. If, however, the variables are related, such as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, ch",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:541238,Performance,load,load,541238,"descriptor symbol. However, if the type consists of two characters, the number specifies the number of bytes to be used when copying the variable to the output buffer. The line below describes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::Branch method. Then we create a branch with the TTree::Branch method.; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored.; Note that it is an address of a pointer to the object, not just a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:541457,Performance,load,loaded,541457,"scribes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::Branch method. Then we create a branch with the TTree::Branch method.; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored.; Note that it is an address of a pointer to the object, not just a pointer to the object.; The fourth parameter is the buffer size and is by default 32000 bytes. It is the number of bytes of data for that branch to save to a buffer until it is saved to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544363,Performance,Perform,Performance,544363,"lit also, and a split level of 3 its data members objects, will be split. As the split-level increases so does the splitting depth. The ROOT default for the split-level is 99. This means the object will be split to the maximum.; 12.10.1.1 Memory Considerations when Splitting a Branch; Splitting a branch can quickly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544699,Performance,Perform,Performance,544699,"kly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class Streamer function to serialize the object into the branch buffer.; If a data member",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:544727,Performance,perform,performance,544727,"kly generate many branches. Each branch has its own buffer in memory. In case of many branches (say more than 100), you should adjust the buffer size accordingly. A recommended buffer size is 32000 bytes if you have less than 50 branches. Around 16000 bytes if you have less than 100 branches and 4000 bytes if you have more than 500 branches. These numbers are recommended for computers with memory size ranging from 32MB to 256MB. If you have more memory, you should specify larger buffer sizes. However, in this case, do not forget that your file might be used on another machine with a smaller memory configuration.; 12.10.1.2 Performance Considerations when Splitting a Branch; A split branch is faster to read, but slightly slower to write. The reading is quicker because variables of the same type are stored consecutively and the type does not have to be read each time. It is slower to write because of the large number of buffers as described above. See ""; Performance Benchmarks"" for performance impact of split and non-split mode.; 12.10.1.3 Rules for Splitting; When splitting a branch, variables of different types are handled differently. Here are the rules that apply when splitting a branch. If a data member is a basic type, it becomes one branch of class TBranchElement.; A data member can be an array of basic types. In this case, one single branch is created for the array.; A data member can be a pointer to an array of basic types. The length can vary, and must be specified in the comment field of the data member in the class definition. See “Input/Output”.; Pointer data member are not split, except for pointers to a TClonesArray. The TClonesArray (pointed to) is split if the split level is greater than two. When the split level is one, the TClonesArray is not split.; If a data member is a pointer to an object, a special branch is created. The branch will be filled by calling the class Streamer function to serialize the object into the branch buffer.; If a data member",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552043,Performance,load,load,552043,"called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552268,Performance,Load,Load,552268,"with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; /",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569522,Performance,perform,performance,569522,"f the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:578816,Performance,load,load,578816,"k quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; 12.17.4 Writing the Tree; We create a simple tree with two branches both holding Event objects. One is split and the other is not. We also create a pointer to an Event object (event).; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:578900,Performance,Load,Load,578900,"ex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; 12.17.4 Writing the Tree; We create a simple tree with two branches both holding Event objects. One is split and the other is not. We also create a pointer to an Event object (event).; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580411,Performance,load,loaded,580411," = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580429,Performance,load,load,580429,">Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntri",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580751,Performance,load,load,580751,");; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. //",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:580835,Performance,Load,Load,580835," 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree contents; }; 12.17.5 Reading the Tree; First, we check if the shared library with the class definitions is loaded. If not we load it. Then we read two branches, one for the number of tracks and one for the entire event. We check the number of tracks first, and if it meets our condition, we read the entire event. We show the fist entry that meets the condition.; void tree4r() {; // check if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // read the tree generated with tree4w. // note that we use ""new"" to create the TFile and TTree objects, because we; // want to keep these objects alive when we leave this function.; TFile *f = new TFile(""tree4.root"");; TTree *t4 = (TTree*)f->Get(""t4"");. // create a pointer to an event object for reading the branch values.; Event *event = new Event();; // get two branches and set the branch address; TBranch *bntrack = t4->GetBranch(""fNtrack"");; TBranch *branch = t4->GetBranch(""event_split"");; branch->SetAddress(&event);. Int_t nevent = t4->GetEntries();; Int_t nselected = 0;; Int_t nb = 0;; for (Int_t i=0; i<nevent; i++) {; //read branch ""fNtrack""only; bntrack->GetEntry(i);. // reject events with more than 587 tracks; if (event->GetNtrack() > 587)continue;. // read complete accepted event in memory; nb += t4->GetEntry(i);; nselected++;. // print the first accepted event; if (nselected == 1) t4->Show();; // clear tracks array; event->Cle",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:623178,Performance,optimiz,optimized,623178,"Ntrack>600"", ""entrylist"");; This list contains the entry number of all entries with more than 600 tracks. To see the entry numbers use the Print(""all"") command.; root[] myList->Print(""all"");; When using the “>>” whatever was in the list is overwritten. The list can be grown by using the “>>+” syntax. For example to add the entries, with exactly 600 tracks:; root[] T->Draw("">>+ myList"",""fNtrack == 600"", ""entrylist"");; If the Draw command generates duplicate entries, they are not added to the list.; root[] T->Draw("">>+ myList"","" fNtrack > 610"", ""entrylist"");; This command does not add any new entries to the list because all entries with more than 610 tracks have already been found by the previous command for entries with more than 600 tracks.; 12.20.10.1 Main Differences between TEventList and TEntryList; The functionality is essentially the same: both are used to store entry numbers. TEntryList, however, uses considerably less memory for storage, and is optimized for both very high and very low selectivity of cuts (see TEntryListBlock class description for the details of internal storage). Unlike the TEventList, TEntryList makes a distinction between indices from a TChain and from a TTree. While a TEntryList for a TTree can be seen as just a list of numbers, a TEntryList for a TChain is a collection of TEntryList(s) for the TTree(s) that constitute this TChain. Such “sub-lists” can be extracted by calling the function; TEntryList::GetEntryList(const char *treename, const char *filename); and then be used to construct a new TEntryList for a new TChain, or processed independently as normal TEntryList(s) for TTree(s). This modularity makes TEntryList much better suited for PROOF processing than the TEventList.; 12.20.10.2 Using an Event List; A TEventList or a TEntryList can be used to limit the TTree to the events in the list. The methods SetEventList and SetEntryList tell the tree to use the list and hence limit all subsequent calls to Draw, Scan, Process, Query, Prin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:624589,Performance,load,loading,624589,"ction of TEntryList(s) for the TTree(s) that constitute this TChain. Such “sub-lists” can be extracted by calling the function; TEntryList::GetEntryList(const char *treename, const char *filename); and then be used to construct a new TEntryList for a new TChain, or processed independently as normal TEntryList(s) for TTree(s). This modularity makes TEntryList much better suited for PROOF processing than the TEventList.; 12.20.10.2 Using an Event List; A TEventList or a TEntryList can be used to limit the TTree to the events in the list. The methods SetEventList and SetEntryList tell the tree to use the list and hence limit all subsequent calls to Draw, Scan, Process, Query, Principal and CopyTree methods to the entries in the list. In general, it affects the GetEntryNumber method and all functions using it for looping over the tree entries. The GetEntry and GetEntries methods are not affected. Note, that in the SetEventList method, the TEventList argument is internally transformed into a TEntryList, and this operation, in case of a TChain, requires loading of all the tree headers. In this example, we create a list with all entries with more than 600 tracks and then set it so that the tree will use this list. To reset the TTree to use all events use SetEventList(0) or SetEntryList(0). Let’s look at an example. First, open the file and draw the fNtrack. root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");. Now, put the entries with over 600 tracks into a TEntryList called myList. We get the list from the current directory and assign it to a variable list. root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");. Instruct the tree T to use the new list and draw it again. Note that this is exactly the same Draw command. The list limits the entries. root[] T->SetEntryList(list);; root[] T->Draw(""fNtrack"");; You should now see a canvas similar to this on",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:627760,Performance,load,load,627760,";; root[] TEntryList *list2 = new TEntryList(""list2"", ""list2"");; root[] list2->SetTree(""tree2"", ""file2"");; root[] list2->Enter(0);; root[] list2->Enter(3);; root[] list1->Add(list2);; root[] list1->Print(""all""); tree1 file1; 0; 2; tree2 file2; 0; 3; The result is a TEntryList for a TChain of tree1 and tree2. If the second list was for the same TTree in the same file as the first list, the result would be as follows:; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; 12.20.10.4 TEntryListFromFile; This is a special kind of TEntryList, used only when processing TChain objects (see the method TChain::SetEntryListFile()). It is used in the case, when the entry lists, corresponding to the trees of this chain, are stored in separate files. It allows to load the entry lists in memory one by one, keeping only the list for the currently processed tree loaded.; For more details on entry lists, see TEntryList, TEntryListBlock and TEntryListFromFile class descriptions, functions TChain::SetEntryList(), TChain::SetEntryListFile(), and the macro $ROOTSYS/test/stressEntryList.C.; 12.20.11 Filling a Histogram; The TTree::Draw method can also be used to fill a specific histogram. The syntax is:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; As we can see, this created a TH1, called myHisto. If you want to append more entries to the histogram, you can use this syntax:; root[] T->Draw(""fNtrack >>+ myHisto""); If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ah",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:627858,Performance,load,loaded,627858,";; root[] TEntryList *list2 = new TEntryList(""list2"", ""list2"");; root[] list2->SetTree(""tree2"", ""file2"");; root[] list2->Enter(0);; root[] list2->Enter(3);; root[] list1->Add(list2);; root[] list1->Print(""all""); tree1 file1; 0; 2; tree2 file2; 0; 3; The result is a TEntryList for a TChain of tree1 and tree2. If the second list was for the same TTree in the same file as the first list, the result would be as follows:; root[] TEntryList *list2_2 = new TEntryList(""list2_2"", ""list2_2"");; root[] list2_2->SetTree(""tree2"", ""file2"");; root[] list2_2->Enter(1);; root[] list2_2->Enter(2);; root[] list2->Add(list2_2);; root[] list2->Print(""all""); tree2 file2; 0; 1; 2; 3; 12.20.10.4 TEntryListFromFile; This is a special kind of TEntryList, used only when processing TChain objects (see the method TChain::SetEntryListFile()). It is used in the case, when the entry lists, corresponding to the trees of this chain, are stored in separate files. It allows to load the entry lists in memory one by one, keeping only the list for the currently processed tree loaded.; For more details on entry lists, see TEntryList, TEntryListBlock and TEntryListFromFile class descriptions, functions TChain::SetEntryList(), TChain::SetEntryListFile(), and the macro $ROOTSYS/test/stressEntryList.C.; 12.20.11 Filling a Histogram; The TTree::Draw method can also be used to fill a specific histogram. The syntax is:; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack >> myHisto""); root[] myHisto->Print(); TH1.Print Name= myHisto, Entries= 100, Total sum= 100; As we can see, this created a TH1, called myHisto. If you want to append more entries to the histogram, you can use this syntax:; root[] T->Draw(""fNtrack >>+ myHisto""); If you do not create a histogram ahead of time, ROOT will create one at the time of the Draw command (as is the case above). If you would like to draw the variable into a specific histogram where you, for example, set the range and bin number, you can define the histogram ah",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:635750,Performance,load,load,635750,"h a branch for each data member in the “Event” object. To build this file and tree follow the instructions on how to build the examples in $ROOTSYS/test. Execute Event and instruct it to split the object with this command (from the UNIX command line).; > $ROOTSYS/test/Event 400 1 2 1; This creates an Event.root file with 400 events, compressed, split, and filled.; See $ROOTSYS/test/MainEvent.cxx for more info.; The person who designed the tree makes a shared library available to you, which defines the classes needed. In this case, the classes are Event, EventHeader, and Track and they are defined in the shared library libEvent.so. The designer also gives you the Event.h file to see the definition of the classes. You can locate Event.h in $ROOTSYS/test, and if you have not yet built libEvent.so, please see the instructions of how to build it (typing make in $ROOTSYS/test is enough). If you have already built it, you can now use it again.; 12.21.1 Creating a Class with MakeClass; First, we load the shared library and open Event.root.; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree “T”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.; root[] T->Print();; From the output of print we can see that the tree has one branch for each data member of Event, Track, and EventHeader. Now we can use TTree::MakeClass on our tree “T”. MakeClass takes one parameter, a string containing the name of the class to be made. In the command below, the name of our class will be “MyClass”.; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; Cling informs us that it has created two files. MyClass.h contains the class definition and MyClass.C ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:636890,Performance,Load,LoadTree,636890,";; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; We can see there is a tree “T”, and just to verify that we are working with the correct one, we print the tree, which will show us the header and branches.; root[] T->Print();; From the output of print we can see that the tree has one branch for each data member of Event, Track, and EventHeader. Now we can use TTree::MakeClass on our tree “T”. MakeClass takes one parameter, a string containing the name of the class to be made. In the command below, the name of our class will be “MyClass”.; root[] T->MakeClass(""MyClass""); Files: MyClass.h and MyClass.C generated from Tree: T; Cling informs us that it has created two files. MyClass.h contains the class definition and MyClass.C contains the MyClass::Loop() method. MyClass has more methods than just Loop(). The other methods are a constructor, a destructor, GetEntry(), LoadTree(), Notify(), Cut() and Show(). The implementations of these methods are in the .h file. This division of methods was done intentionally. The .C file is kept as short as possible, and contains only code that is intended for you to customize. The .h file contains all the other methods. It is clear that you want to be as independent as possible of the header file (i.e. MyClass.h) generated by MakeClass. The solution is to implement a derived class, for example MyRealClass deriving from MyClass such that a change in your Treeor regeneration of MyClass.h does not force you to change MyRealClass.h. You can imagine deriving several classes from MyClass.h, each with a specific algorithm. To understand both files, let’s start with MyClass.h and the class declaration:; 12.21.2 MyClass.h; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:638344,Performance,Load,LoadTree,638344,"eriving from MyClass such that a change in your Treeor regeneration of MyClass.h does not force you to change MyRealClass.h. You can imagine deriving several classes from MyClass.h, each with a specific algorithm. To understand both files, let’s start with MyClass.h and the class declaration:; 12.21.2 MyClass.h; class MyClass {; public :; // Pointer to the analyzed TTree or TChain; TTree *fChain;; // Current Tree number in a TChain; Int_t fCurrent;; // Declaration of leaves types; UInt_t fUniqueID;; UInt_t fBits;; Char_t fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; Int_t fEvtHdr_fEvtNum;; // List of branches; TBranch *b_fUniqueID;; TBranch *b_fBits;; TBranch *b_fType;; TBranch *b_fNtrack;; TBranch *b_fNseg;; TBranch *b_fNvertex;; TBranch *b_fFlag;; TBranch *b_fTemperature;; TBranch *b_fEvtHdr_fEvtNum;; ...; MyClass(TTree *tree=0);; ~MyClass();; Int_t Cut(Int_t entry);; Int_t GetEntry(Int_t entry);; Int_t LoadTree(Int_t entry);; void Init(TTree *tree);; void Loop();; Bool_t Notify();; void Show(Int_t entry = -1);; };; We can see data members in the generated class. The first data member is fChain. Once this class is instantiated, fChain will point to the original tree or chain this class was made from. In our case, this is “T” in “Event.root”. If the class is instantiated with a tree as a parameter to the constructor, fChain will point to the tree named in the parameter. Next is fCurrent, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a TChain. The class definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each bra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:639500,Performance,load,loads,639500,"ss. The first data member is fChain. Once this class is instantiated, fChain will point to the original tree or chain this class was made from. In our case, this is “T” in “Event.root”. If the class is instantiated with a tree as a parameter to the constructor, fChain will point to the tree named in the parameter. Next is fCurrent, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a TChain. The class definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:639670,Performance,load,loads,639670,"is instantiated with a tree as a parameter to the constructor, fChain will point to the tree named in the parameter. Next is fCurrent, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a TChain. The class definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640038,Performance,Load,LoadTree,640038,"f MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions abo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640121,Performance,Load,LoadTree,640121,"arameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from y",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640135,Performance,load,load,640135,"arameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from y",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640223,Performance,Load,LoadTree,640223,"from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from your own file; 12.21.4 Modifying MyClass::Loop; Let us continue with the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640843,Performance,Load,LoadTree,640843,"e GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from your own file; 12.21.4 Modifying MyClass::Loop; Let us continue with the goal of going through the first 100 tracks of each entry and plot Px. To do this we change the Loop method.; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; In the for-loop, we need to add another for-loop to go over all the tracks. In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (myHisto) with all tracks and the small histogram (smallHisto) with the track if it is in the first 100.; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:642242,Performance,load,load,642242," first 100 tracks of each entry and plot Px. To do this we change the Loop method.; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; In the for-loop, we need to add another for-loop to go over all the tracks. In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (myHisto) with all tracks and the small histogram (smallHisto) with the track if it is in the first 100.; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; Outside of the for-loop, we draw both histograms on the same canvas.; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; Save these changes to MyClass.C and start a fresh root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:642297,Performance,Load,Loading,642297,"method.; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; In the for-loop, we need to add another for-loop to go over all the tracks. In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (myHisto) with all tracks and the small histogram (smallHisto) with the track if it is in the first 100.; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; Outside of the for-loop, we draw both histograms on the same canvas.; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; Save these changes to MyClass.C and start a fresh root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to proce",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:642335,Performance,load,load,642335,"method.; ...; if (fChain == 0) return;; Int_t nentries = Int_t(fChain->GetEntries());; TH1F *myHisto = new TH1F(""myHisto"",""fPx"", 100, -5,5);; TH1F *smallHisto = new TH1F(""small"",""fPx"", 100, -5,5);; ...; In the for-loop, we need to add another for-loop to go over all the tracks. In the outer for-loop, we get the entry and the number of tracks. In the inner for-loop, we fill the large histogram (myHisto) with all tracks and the small histogram (smallHisto) with the track if it is in the first 100.; ...; for (Int_t jentry=0; jentry<nentries;jentry++) {; GetEntry(jentry);; for (Int_t j = 0; j < 100; j++) {; myHisto->Fill(fTracks_fPx[j]);; if (j < 100) {; smallHisto->Fill(fTracks_fPx[j]);; }; }; }; ...; Outside of the for-loop, we draw both histograms on the same canvas.; ...; myHisto->Draw();; smallHisto->Draw(""Same"");; ...; Save these changes to MyClass.C and start a fresh root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to proce",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:643190,Performance,Load,Load,643190,"root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to process a limited set of entries. This is especially important in a parallel processing configuration where the analysis is distributed over several processors and we can specify which entries to send to each processor. The TTree::Process method is used to specify the selector and the entries. Before we can use TTree::Process we need to make a selector. We can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the correspond",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646190,Performance,load,loaded,646190,"mit reading of branches to the ones we need.; When a selector is used with a TChain in methods Process(), ProcessFill(), ProcessCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collecti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646318,Performance,load,loaded,646318,"sCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TOb",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646449,Performance,load,loads,646449,"Chain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:647006,Performance,Perform,Performance,647006," name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:647083,Performance,perform,performance,647083,",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:648171,Performance,perform,performance,648171,"ClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TObjHit) not split TClonesArray(TObjHit) split.; The next graphs show the two columns on the right which represent the split and non-split TClonesArray, are significantly lower than the vectors. The most significant difference is in reading a file without compression.; The file size with compression, write times with and without compression and the read times with and without compression all favor the TClonesArray.; 12.23 Impact of Compression on I/O; This benchmark illustrates the pros and cons of the compression option. We recommend using compression when the time spent in I/O is small compared to the total processing time. In this case, if the I/O operation is increased by a factor of 5 it is still a small percentage of the total time and it may very well save a factor of 10 on disk space. On the other hand if the time spend on I/O is large, compression may slow down the program’s performance. The standard test program $ROOTSYS/test/Event was used in various configurations with 400 events. The data file contains a TTree. The program was invoked with:; Event 400 comp split. comp = 0 means: no compression at all.; comp = 1 means: compress everything if split = 0.; comp = 1 means: compress only the tree branches with integers if split = 1.; comp = 2 means: compress everything if split=1.; split = 0 : the full event is serialized into one single buffer.; split = 1 : the event is split into branches. One branch for each data member of the Event class. The list of tracks (a TClonesArray) has the data members of the Track class also split into individual buffers. These tests were run on Pentium III CPU with 650 MHz. Event Parameters; File Size; Total Time to Write (MB/sec); Effective Time to Write (MB/sec); Total Time to Read All (MB/sec); Total Time to Read Sample (MB/sec). Comp = 0; Split = 1; 19.75 MB; 6.84 s.(2.8 MB/s); 3.56",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:650930,Performance,optimiz,optimized,650930,"reter itself. The Total time to read sample is the execution time of the script $ROOTSYS/test/eventb. This script loops on all events. For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a ha",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:651060,Performance,perform,performance,651060," For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:651098,Performance,perform,performance,651098,". In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in tree “T” by processing sequentially the three files of this chain, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:651158,Performance,perform,performance,651158," obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in tree “T” by processing sequentially the three files of this chain, we can use the TChain::Draw method.; chain.Draw(""x"");; When using a TChain, the branch address",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:652512,Performance,load,loaded,652512," with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a hash table. The class TChain is derived from the class TTree. For example, to generate a histogram corresponding to the attribute “x” in tree “T” by processing sequentially the three files of this chain, we can use the TChain::Draw method.; chain.Draw(""x"");; When using a TChain, the branch address(es) must be set with:; chain.SetBranchAdress(branchname,...) // use this for TChain; rather than:; branch->SetAddress(...); // this will not work; The second form returns the pointer to the branch of the current TTree in the chain, typically the first one. The information is lost when the next TTree is loaded. The following statements illustrate how to set the address of the object to be read and how to loop on all events of all files of the chain.; {; TChain chain(""T""); // create the chain with tree ""T""; chain.Add(""file1.root""); // add the files; chain.Add(""file2.root"");; chain.Add(""file3.root"");; TH1F *hnseg = new TH1F(""hnseg"",; ""Number of segments for selected tracks"",; 5000,0,5000);; // create an object before setting the branch address; Event *event = new Event();; // Specify the address where to read the event object; chain.SetBranchAddress(""event"", &event);. // Start main loop on all events In case you want to read only a few; // branches, use TChain::SetBranchStatus to activate a branch.; Int_t nevent = chain.GetEntries();; for (Int_t i=0;i<nevent;i++) {; // read complete accepted event in memory; chain.GetEvent(i);; // Fill histogram with number of segments; hnseg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; 12.24.1 TChain::AddFr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:655672,Performance,optimiz,optimized,655672,"AddFriendconnects the trees in the chain. When a chain is deleted, its friend elements are also deleted. The number of entries in the friend must be equal or greater to the number of entries of the original chain. If the friend has fewer entries a warning is given and the resulting histogram will have missing entries. For additional information see TTree::AddFriends(). A full example of a tree and friends is in Example #3 ($ROOTSYS/tutorials/tree/tree3.C) in the Trees section above.; 13 Math Libraries in ROOT; The aim of Math libraries in ROOT is to provide and to support a coherent set of mathematical and statistical functions. The latest developments have been concentrated in providing first versions of the MathCore and MathMore libraries, included in ROOT v5.08. Other recent developments include the new version of MINUIT, which has been re-designed and re-implemented in the C++ language. It is integrated in ROOT. In addition, an optimized package for describing small matrices and vector with fixed sizes and their operation has been developed (SMatrix). The structure is shown in the following picture. Math libraries and packages. 13.1 MathCore Library; MathCore provides a collection of functions and C++ classes for numerical computing. This library includes only the basic mathematical functions and algorithms and not all the functionality required by the physics community. A more advanced mathematical functionality is provided by the MathMore library. The current set of included classes, which are provided in the ROOT::Math namespace are:. Basic special functions like the gamma, beta and error function.; Mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf’s).; Generic function classes and interfaces for evaluating one-dimensional (ROOT::Math::IBaseFunctiononeDim) and multi-dimensional functions (ROOT::Math::IBaseFunctionMultiDim) and parametric function",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:675590,Performance,Perform,Performances,675590,"vdata is an std::vector containing the data; TUnuranEmpDist dist(vdata.begin(),vdata.end());; unr.Init(dist);; // sample N times (generate N random numbers); for (int i = 0; i<N; ++i); double x = unr.Sample();. For some predefined distributions, like Poisson and Binomial, one can use directly a function in the TUnuran class. This is more convenient in passing distribution parameters than using directly the string interface. TUnuran unr;; // Initialize unuran to generate normal random numbers from the; // Poisson distribution with parameter mu; unr.InitPoisson(mu);; ...; // Sample distributions N times (generate N random numbers); for (int i = 0; i<N; ++i); int k = unr.SampleDiscr();; Functionality is also provided via the C++ classes for using a different random number generator by passing a TRandom pointer when constructing the TUnuran class (by default the ROOT gRandom is passed to UNURAN).; 13.4.9 Performances of Random Numbers; Here are the CPU times obtained using the four random classes on an lxplus machine with an Intel 64 bit architecture and compiled using gcc 3.4:. TRandom (ns/call); TRandom1 (ns/call); TRandom2 (ns/call); TRandom3 (ns/call). Rndm(). 6; 9. Gaus(); 31; 161; 35; 42. Rannor(); 116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:700933,Performance,perform,perform,700933," the most basic functionality while the specific behaviours for one or multiple dimensions are implemented in ROOT::Math::VirtualIntegratorOneDim and ROOT::Math::VirtualIntegratorMultiDim. These interfaces define the integrator functionality with abstract methods to set the function, to compute the integral or to set the integration tolerance. These methods must be implemented in the concrete classes existing for the different integration algorithms. The user cannot create directly these virtual integrator interfaces. He needs to create the ROOT::Math::IntegratorOneDim class for integrating one-dimensional functions and ROOT::Math::IntegratorMultiDim for multi-dimensional functions. Through the ROOT Plug-In Manager, the user can initialize ROOT::Math::IntegratorOneDim or ROOT::Math::IntegratorMultiDim with any of the concrete integration classes without dealing with them directly. These two classes provide the same interface as in VirtualIntegratorOneDim and VirtualIntegratorMultiDim, but with the possibility to choose in the constructor, which method will be used to perform the integration.; The method to set the function to be integrated, must be of the function interface type described before. ROOT::Math::IBaseFunctionOneDimFunction is used for ROOT::Math::IBaseFunctionMultiDim and The only difference between the ROOT::Math::IntegratorOneDim and ROOT::Math::IntegratorMultiDim resides in the dimensionality of that function and some specific that will be seen afterwards for the one dimensional one. ROOT::Math Numerical Integrator classes. The rest of the classes shown above in the diagram are the specialized classes provided. Each one implements a different method that will be explained in detail. It is important to notice that the two grayed classes (the one which name starts by GSL) are part of the MathMore library. We will later show in more detail the differences between the implementations.; 13.8.1 Integration of One-dimensional Functions; 13.8.1.1 Using ROOT::",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:705560,Performance,perform,performing,705560,"APTIVESINGULAR; ROOT::Math:::GSLIntegrator. 13.8.2.1 ROOT::Math:::GaussIntegrator; It uses the most basic Gaussian integration algorithm, it uses the 8-point and the 16-point Gaussian quadrature approximations. It is derived from the DGAUSS routine of the CERNLIB by S. Kolbig. This class Here is an example of using directly the GaussIntegrator class; #include ""TF1.h""; #include ""Math/WrappedTF1.h""; #include ""Math/GaussIntegrator.h"". int main(); {; TF1 f(""Sin Function"", ""sin(x)"", 0, TMath::Pi());; ROOT::Math::WrappedTF1 wf1(f);. ROOT::Math::GaussIntegrator ig;. ig.SetFunction(wf1, false);; ig.SetRelTolerance(0.001);. cout << ig.Integral(0, TMath::PiOver2()) << endl;. return 0;; }; 13.8.2.2 ROOT::Math::GaussLegendreIntegrator; This class implementes the Gauss-Legendre quadrature formulas. This sort of numerical methods requieres that the user specifies the number of intermediate function points used in the calculation of the integral. It will automatically determine the coordinates and weights of such points before performing the integration. We can use the example above, but replacing the creation of a ROOT::Math::GaussIntegrator object with ROOT::Math::GaussLegendreIntegrator.; 13.8.2.3 ROOT::Math::GSLIntegrator; This is a wrapper for the QUADPACK integrator implemented in the GSL library. It supports several integration methods that can be chosen in construction time. The default type is adaptive integration with singularity applying a Gauss-Kronrod 21-point integration rule. For a detail description of the GSL methods visit the GSL user guide This class implements the best algorithms for numerical integration for one dimensional functions. We encourage the use it as the main option, bearing in mind that it uses code from the GSL library, wich is provided in the MathMore library of ROOT.; The interface to use is the same as above. We have now the possibility to specify a different integration algorithm in the constructor of the ROOT::Math::GSLIntegrator class.; // c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712606,Performance,perform,performing,712606,"s are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:713348,Performance,perform,perform,713348,"nsional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to the third derivative of a function. * GSLDerivator of MathMore based on GSL.; 13.10 Numerical Minimization; The algorithms provided by ROOT for numerical integration are implemented following the hierarchy shown in the next image. The left branch of classes are used for one dimensional minimization, while the right one is used for multidimensional minimization. In the case of multidimensional minimization we have also the classes TMinuitMinimizer implemented using TMinuit, TFumiliMinimizer implemented using TFumili for least square or likelihood minimizations. We encourage the use of the GSL algorithms for one dimensional minimization and Minuit2 (or the old versionMinuit) for multi dimensional minimization. N",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:716684,Performance,perform,perform,716684,"lls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function minimum/maximum value * TF1::GetMinimumX/TF1::GetMaximumX to find the x value corresponding at the function minimum.; The interval to search for the minimum (the default is the TF1 range), tolerance and maximum iterations can be provided as optional parameters of the TF1::GetMinimum/Maximum functions.; 13.10.2 Multi-Dimensional Minimization; All the algorithms for multi-dimensional minimization are implementing the ROOT::Math::Minimizer interface and they can be used in the same way and one can switch between minimizer at run-time. The minimizer concrete class can be in different ROOT libraries and they can be instantiate using the ROOT plug-in manager. More information on multi-dimensional minimization is provided in the Fitting Hist",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719320,Performance,optimiz,optimize,719320,"ce-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP and packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719329,Performance,perform,performances,719329,"ce-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP and packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719649,Performance,Perform,Performances,719649,"so re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719711,Performance,perform,performance,719711,"so re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723968,Performance,optimiz,optimized,723968,"(and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D transformation: we describe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:747862,Performance,perform,performance,747862,"TVectorD r1(3,data); //create a new Linear Algebra vector; //copying the data; In the case of transformations, constructor and method to set/get components exist with linear algebra matrices. The requisite is that the matrix data are stored, for example in the case of a Lorentz rotation, from (0,0) thru (3,3); TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; 13.12.6.2 Connection to Other Vector Classes; The 3D and 4D vectors of the GenVector package can be constructed and assigned from any vector which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the curr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:747950,Performance,optimiz,optimized,747950,"atrices. The requisite is that the matrix data are stored, for example in the case of a Lorentz rotation, from (0,0) thru (3,3); TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; 13.12.6.2 Connection to Other Vector Classes; The 3D and 4D vectors of the GenVector package can be constructed and assigned from any vector which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:748240,Performance,optimiz,optimization,748240,"otation r(m); //create Lorentz r; 13.12.6.2 Connection to Other Vector Classes; The 3D and 4D vectors of the GenVector package can be constructed and assigned from any vector which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like numbe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:748426,Performance,optimiz,optimized,748426," which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:748819,Performance,perform,performance,748819,"mented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that the correctness of dimension in the matrix/vector operations can be checked at compile time.; SMatrix supports, since ROOT v5.10, symmetric matrices using a storage class (ROOT::Math::MatRepSym) which contains only the N*(N+1)/2 independent element of a NxN symmetric matrix. It is not in the mandate of this package to provide complete linear algebra functionality. It provides basic ma",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:749981,Performance,optimiz,optimized,749981,"OOT::Math::SMatrix and ROOT::Math::SVector classes for describing matrices and vectors of arbitrary dimensions and of arbitrary type. The classes are templated on the scalar type and on the size, like number of rows and columns for a matrix . Therefore, the matrix/vector dimension has to be known at compile time. An advantage of using the dimension as template parameters is that the correctness of dimension in the matrix/vector operations can be checked at compile time.; SMatrix supports, since ROOT v5.10, symmetric matrices using a storage class (ROOT::Math::MatRepSym) which contains only the N*(N+1)/2 independent element of a NxN symmetric matrix. It is not in the mandate of this package to provide complete linear algebra functionality. It provides basic matrix and vector functions such as matrix-matrix, matrix-vector, vector-vector operations, plus some extra functionality for square matrices, like inversion and determinant calculation. The inversion is based on the optimized Cramer method for squared matrices of size up to 6x6.; The SMatrix package contains only header files. Normally one does not need to build any library. In the ROOT distribution a library, libSmatrix is produced with the C++ dictionary information for squared and symmetric matrices and vectors up to dimension 7 and based on Double_t, Float_t and Double32_t. The following paragraphs describe the main characteristics of the matrix and vector classes. More detailed information about the SMatrix classes API is available in the online reference documentation.; 13.13.1 Example: Vector Class (SVector); The template class ROOT::Math::SVector represents n-dimensional vectors for objects of arbitrary type. This class has 2 template parameters, which define at compile time, its properties: 1) type of the contained elements (for example float or double); 2) size of the vector. The use of this dictionary is mandatory if one want to use Smatrix in Cling and with I/O.; 13.13.1.1 Creating a Vector; The follo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:752145,Performance,perform,performed,752145,"m a vector expression, like v=p*q+w. Due to the expression template technique, no temporary objects are created in this operation.; Constructor by passing directly the elements. This is possible only for vectors up to size 10.; Constructor from an iterator copying the data referred by the iterator. It is possible to specify the begin and end of the iterator or the begin and the size. Note that for the Vector the iterator is not generic and must be of type T*, where T is the type of the contained elements. In the following example we assume that we are using the namespace ROOT::Math; //create an empty vector of size 3 ( v[0]=v[1]=v[2]=0); SVector<double,3> v;; double d[3] = {1,2,3};; SVector<double,3> v(d,3); //create a vector from a C array; 13.13.1.2 Accessing and Setting Methods; The single vector elements can be set or retrieved using the operator[i], operator(i) or the iterator interface. Notice that the index starts from zero and not from one as in FORTRAN. Also no check is performed on the passed index. The full vector elements can be set also by using the SetElements function passing a generic iterator.; double x = m(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; std::vector<double> w(3);. // set vector elements from a std::vector<double>::iterator; v.SetElements(w.begin(),w.end());; In addition there are methods to place a sub-vector in a vector. If the size of the sub-vector is larger than the vector size a static assert (a compilation error) is produced.; SVector>double,N> v;; SVector>double,M> w;; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from; // element ioff, v[ioff+i]=w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from; // v[ioff]: w[i]=v[ioff+i]; w = v.Sub < SVector>double,M> > (ioff);; For the vector functions see later in the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:760721,Performance,perform,performed,760721,"SVector2> (0,1);; // return a slice of the second column from; // (0,1): c2[0] = m(0,1); c2[1] = m(1,1); SVector2 c2 = m.SubCol<SVector2> (1,0);. // return a sub-matrix 2x2 with the upper left corner at(1,1); SMatrix22 subM = m.Sub<SMatrix22> (1,1);. // return the diagonal element in a SVector; SVector3 diag = m.Diagonal();. // return the upper(lower) block of the matrix m; SVector6 vub = m.UpperBlock(); // vub = [ 1, 2, 3, 5, 6, 9 ]; SVector6 vlb = m.LowerBlock(); // vlb = [ 1, 4, 5, 7, 8, 9 ]; 13.13.2.3 Linear Algebra Matrix Functions (Inversion, Determinant); Only limited linear algebra functionality is available for SMatrix. It is possible for squared matrices NxN, to find the inverse or to calculate the determinant. Different inversion algorithms are used if the matrix is smaller than 6x6 or if it is symmetric. In the case of a small matrix, a faster direct inversion is used. For a large (N>6)symmetric matrix the Bunch-Kaufman diagonal pivoting method is used while for a large (N>6) general matrix an LU factorization is performed using the same algorithm as in the CERNLIB routine dinv.; // Invert a NxN matrix.; // The inverted matrix replaces the existing one if the; // result is successful; bool ret = m.Invert(); // return the inverse matrix of m. // If the inversion fails ifail is different than zero ???; int ifail = 0;; ifail = m.Inverse(ifail);. // determinant of a square matrix - calculate the determinant; // modyfing the matrix content and returns it if the calculation; // was successful; double det;; bool ret = m.Det(det);. // calculate determinant by using a temporary matrix; preserves; // matrix content; bool ret = n.Det2(det);; 13.13.3 Example: Matrix and Vector Functions and Operators; 13.13.3.1 Matrix and Vector Operators; The ROOT::Math::SVector and ROOT::Math::SMatrix classes define the following operators described below. The m1, m2, m3 are vectors or matrices of the same type (and size) and a is a scalar value:; m1 == m2 // returns whether m1 is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768161,Performance,perform,perform,768161," transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:768257,Performance,perform,performed,768257,"tp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex numbers will take about a factor of 8 more computations, the alternative of introducing a set of complex classes in this non-template library would create a major maintenance challenge.; Another choice was to fill in both the upper-right corner and the bottom-left corner of a symmetric matrix. Although most algorithms use only the upper-right corner, implementation of the different matrix views was more straightforward this ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:770278,Performance,perform,performed,770278,"rt is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783119,Performance,Perform,Perform,783119,"lied.; \(A_{ij}/= \nu_j\), divide each matrix row by vector v. If the second argument is “M”, the row is multiplied. 14.4.5 Miscellaneous Operators. Format; Output; Description. A.Zero(); TMatrixX; \(A_{ij} = 0\). A.Abs(); TMatrixX; \(A_{ij} = |A_{ij}|\). A.Sqr(); TMatrixX; \(A_{ij} = A_{ij}^2\). A.Sqrt(); TMatrixX; \(A_{ij} = \sqrt{(A_{ij})}\). A.UnitMatrix(); TMatrixX; \(A_{ij} = 1\) for i ==j else 0. A.Randomize (alpha,beta,seed); TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). A.T(); TMatrixX; \(A_{ij} = A_{ji}\). A.Transpose(B); TMatrixX; \(A_{ij} = B_{ji}\). A.Invert(&det); TMatrixX; Invert matrix A. If the optional pointer to the Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the clas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783669,Performance,Perform,Perform,783669,"ibuted between \(\alpha\) and \(\beta\). A.T(); TMatrixX; \(A_{ij} = A_{ji}\). A.Transpose(B); TMatrixX; \(A_{ij} = B_{ji}\). A.Invert(&det); TMatrixX; Invert matrix A. If the optional pointer to the Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{0",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:787218,Performance,perform,perform,787218,". TMatrixDColumn(A,j) *= r; column \(j\). TMatrixDDiag(A) *= r; matrix diagonal. TMatrixDSub(A,i,l,j,k) *= r; sub matrix. Description; Format; Comment. TMatrixDRow(A,i1) += TMatrixDRow const(B,i2); add row \(i2\) to row \(i1\). add matrix slice; TMatrixDColumn(A,j1) += TMatrixDColumn const(A,j2); add column \(j2\) to column \(j1\). TMatrixDDiag(A) += TMatrixDDiag const(B); add \(B\) diagonal to \(A\) diagonal. TMatrixDRow(A,i1) *= TMatrixDRow const(B,i2); multiply row \(i2\) with row \(i1\) element wise. TMatrixDColumn(A,j1) *= TMatrixDColumn const(A,j2); multiply column \(j2\) with column \(j1\) element wise. multiply matrix slice; TMatrixDDiag(A) *= TMatrixDDiag const(B); multiply \(B\) diagonal with \(A\) diagonal element wise. TMatrixDSub(A,i1,l1,j1,k1) *= TMatrixDSub(B,i2,l2,j2,k2); multiply sub matrix of \(A\) with sub matrix of \(B\). TMatrixDSub(A,i,l,j,k) *= B; multiply sub matrix of \(A\) with matrix of \(B\). In the current implementation of the matrix views, the user could perform operations on a symmetric matrix that violate the symmetry. No checking is done. For instance, the following code violates the symmetry.; TMatrixDSym A(5);; A.UnitMatrix();; TMatrixDRow(A,1)[0] = 1;; TMatrixDRow(A,1)[2] = 1;; 14.5.2 View Examples; Inserting row i1into rowi2 of matrix \(A\) can easily accomplished through:; TMatrixDRow(A,i1) = TMatrixDRow(A,i2); Which more readable than:; const Int_t ncols = A.GetNcols();; Double_t *start = A.GetMatrixArray();; Double_t *rp1 = start+i*ncols;; const Double_t *rp2 = start+j*ncols;; while (rp1 < start+ncols) *rp1++ = *rp2++;; Check that the columns of a Haar -matrix of order order are indeed orthogonal:; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:788544,Performance,perform,performs,788544,"onst Int_t ncols = A.GetNcols();; Double_t *start = A.GetMatrixArray();; Double_t *rp1 = start+i*ncols;; const Double_t *rp2 = start+j*ncols;; while (rp1 < start+ncols) *rp1++ = *rp2++;; Check that the columns of a Haar -matrix of order order are indeed orthogonal:; const TMatrixD haar = THaarMatrixD(order);; TVectorD colj(1<<order);; TVectorD coll(1<<order);; for (Int_t j = haar.GetColLwb(); j <= haar.GetColUpb(); j++) {; colj = TMatrixDColumn_const(haar,j);; Assert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; Multiplying part of a matrix with another part of that matrix (they can overlap); TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; 14.6 Matrix Decompositions; The linear algebra package offers several classes to assist in matrix decompositions. Each of the decomposition methods performs a set of matrix transformations to facilitate solving a system of linear equations, the formation of inverses as well as the estimation of determinants and condition numbers. More specifically the classes TDecompLU, TDecompBK, TDecompChol, TDecompQRH and TDecompSVD give a simple and consistent interface to the LU, Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes are derived from the base class TDecompBase of which the important methods are listed in next table:. Method; Action. Bool_t Decompose(); perform the matrix decomposition. Double_t Condition(); calculate ||A||1 ||A-1||1, see “Condition number”. void Det(Double_t &d1,Double_t &d2); the determinant is d1 \(2^{d_{2}}\). Expressing the determinant this way makes under/over-flow very unlikely. Bool_t Solve(TVectorD &b); solve Ax=b; vectorb is supplied through the argument and replaced with solution x. TVectorD Solve(const TVectorD &b,Bool_t &ok); solve Ax=b; x is returned. Bool_t Solve(TMatrixDColumn &b); solve Ax=column(B,j);column(B,j) is supplied through the argument an",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:789080,Performance,perform,perform,789080,"ert(TMath::Abs(colj*colj-1.0) <= 1.0e-15);. for (Int_t l = j+1; l <= haar.GetColUpb(); l++) {; coll = TMatrixDColumn_const(haar,l);; Assert(TMath::Abs(colj*coll) <= 1.0e-15);; }; }; Multiplying part of a matrix with another part of that matrix (they can overlap); TMatrixDSub(m,1,3,1,3) *= m.GetSub(5,7,5,7);; 14.6 Matrix Decompositions; The linear algebra package offers several classes to assist in matrix decompositions. Each of the decomposition methods performs a set of matrix transformations to facilitate solving a system of linear equations, the formation of inverses as well as the estimation of determinants and condition numbers. More specifically the classes TDecompLU, TDecompBK, TDecompChol, TDecompQRH and TDecompSVD give a simple and consistent interface to the LU, Bunch-Kaufman, Cholesky, QR and SVD decompositions. All of these classes are derived from the base class TDecompBase of which the important methods are listed in next table:. Method; Action. Bool_t Decompose(); perform the matrix decomposition. Double_t Condition(); calculate ||A||1 ||A-1||1, see “Condition number”. void Det(Double_t &d1,Double_t &d2); the determinant is d1 \(2^{d_{2}}\). Expressing the determinant this way makes under/over-flow very unlikely. Bool_t Solve(TVectorD &b); solve Ax=b; vectorb is supplied through the argument and replaced with solution x. TVectorD Solve(const TVectorD &b,Bool_t &ok); solve Ax=b; x is returned. Bool_t Solve(TMatrixDColumn &b); solve Ax=column(B,j);column(B,j) is supplied through the argument and replaced with solution x. Bool_t TransSolve(TVectorD &b); solve \(A^Tx=b;\) vector b is supplied through the argument and replaced with solution x. TVectorD TransSolve(const TVectorD b, Bool_t &ok); solve \(A^Tx=b;\) vector x is returned. Bool_t TransSolve(TMatrixDColumn &b); solve ATx=column(B,j); column(B,j) is supplied through the argument and replaced with solution x. Bool_t MultiSolve(TMatrixD &B); solve \(A^Tx=b;\). matrix B is supplied through the argumen",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:791950,Performance,perform,performed,791950," decomposition process of matrix \(A\) in the user-definable part of TObject::fBits, see the next table. This guarantees the correct order of the operations:. kMatrixSet; kDecomposed; kDetermined; kCondition; kSingular; \(A\) assigned; \(A\) decomposed, bit kMatrixSet must have been set.; det \(A\) calculated, bit kDecomposed must have been set.; ||A||1 ||A-1||1 is calculated bit kDecomposed must have been set.; \(A\) is singular. The state is reset by assigning a new matrix through SetMatrix(TMatrixD &A) for TDecompBK and TDecompChol (actually SetMatrix(TMatrixDSym &A) and SetMatrix(TMatrixDSparse &A) for TMatrixDSparse).; As the code example below shows, the user does not have to worry about the decomposition step before calling a solve method, because the decomposition class checks before invoking Solve that the matrix has been decomposed.; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; lu.Solve(b,ok);; In the next example, we show again the same decomposition but now performed in a loop and all necessary steps are manually invoked. This example also demonstrates another very important point concerning memory management! Note that the vector, matrix and decomposition class are constructed outside the loop since the dimensions of vector/matrix are constant. If we would have replaced lu.SetMatrix(a) by TDecompLU lu(a), we would construct/deconstruct the array elements of lu on the stack.; TVectorD b(n);; TMatrixD a(n,n);; TDecompLU lu(n);; Bool_t ok;; for (....) {; b = ..;; a = ..;; lu.SetMatrix(a);; lu.Decompose();; lu.Solve(b,ok);; }; 14.6.1 Tolerances and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:793515,Performance,perform,perform,793515,"nces and Scaling; The tolerance parameter fTol (a member of the base class TDecompBase) plays a crucial role in all operations of the decomposition classes. It gives the user a tool to monitor and steer the operations its default value is \(\varepsilon\) where \(1+\varepsilon=1\).; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number. The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD that can handle singular matrices. This will be checked in a different way for any decomposition. For instance in LU, a matrix is considered singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:802178,Performance,optimiz,optimized,802178,"; const TMatrixD m = THilbertMatrixD(10,10);; TDecompSVD svd(m);; TVectorD sig = svd.GetSig(); sig.Sqr();; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; 14.8 Speed Comparisons; Speed of four matrix operations have been compared between four matrix libraries, GSL CLHEP, ROOT v3.10 and ROOT v4.0. Next figure shows the CPU time for these four operations as a function of the matrix size:. A*B The execution time is measured for the sum of A * Bsym, Bsym* A and A * B. Notice the matrix_size3 dependence of execution time. CLHEP results are hampered by a poor implementation of symmetric matrix multiplications. For instance, for general matrices of size 100x100, the time is 0.015 sec. while A * Bsym takes 0.028 sec and Bsym* A takes 0.059 sec. Both GSL and ROOT v4.0 can be setup to use the hardware-optimized multiplication routines of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:803256,Performance,multi-thread,multi-threading,803256," of the BLAS libraries. It was tested on a G4 PowerPC. The improvement becomes clearly visible around sizes of (50x50) were the execution speed improvement of the Altivec processor becomes more significant than the overhead of filling its pipe. \(A^{-1}\) Here, the time is measured for an in-place matrix inversion. Except for ROOT v3.10, the algorithms are all based on an LUfactorization followed by forward/back-substitution. ROOT v3.10 is using the slower Gaussian elimination method. The numerical accuracy of the CLHEP routine is poor:. up to 6x6 the numerical imprecise Cramer multiplication is hard-coded. For instance, calculating U=H*H-1, where H is a (5x5) Hilbert matrix, results in off-diagonal elements of \(10^{-7}\) instead of the \(10^{-13}\) using an LUaccording to Crout.; scaling protection is non-existent and limits are hard-coded, as a consequence inversion of a Hilbert matrix for sizes>(12x12) fails. In order to gain speed the CLHEP algorithm stores its permutation info of the pivots points in a static array, making multi-threading not possible. GSL uses LU decomposition without the implicit scaling of Crout. Therefore, its accuracy is not as good. For instance a (10x10) Hilbert matrix has errors 10 times larger than the LU Crout result. In ROOT v4.0, the user can choose between the Invert() and IvertFast() routines, where the latter is using the Cramer algorithm for sizes<7x7. The speed graph shows the result for InvertFast(). A*x=b the execution time is measured for solving the linear equation A*x=b. The same factorizations are used as in the matrix inversion. However, only 1 forward/back-substitution has to be used instead of msize as in the inversion of (msize x msize) matrix. As a consequence the same differences are observed but less amplified. CLHEP shows the same numerical issues as in step the matrix inversion. Since ROOT3.10 has no dedicated equation solver, the solution is calculated through x=A-1*b. This will be slower and numerically not as",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:817754,Performance,load,loaded,817754,"rtype is used, the first seen as priority. For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look for the first existing public constructor in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; 15.4 rootcling: The Cling Dictionary Generator; A way in which dictionaries can be generated is via the rootcling utility. This tool generates takes as input a set of headers and generates in output the dictionary C++ code and a pcm file. This latter file is fundamental for the correct functioning of the dictionary at runtime. It should be located in the directory where the shared library is installed in which the compiled dictionary resides.; NOTA BENE: the dictionaries that will be used within the same project must have unique names. In other words, compiled object files relative to dictionary source files cannot reside in the same library or in two libraries loaded by the same application if the original source files have the same name. This loose limitation is imposed by the registration mechanism ROOT has in place to keep track of dynamically loaded libraries.; In the following example, we walk through the steps necessary to generate a dictionary, I/O, and inspect member functions. Let’s start with a TEvent class, which contains a collection of TTracks.; The TEvent.h header is:; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple eve",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:817944,Performance,load,loaded,817944,"isting public constructor in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; 15.4 rootcling: The Cling Dictionary Generator; A way in which dictionaries can be generated is via the rootcling utility. This tool generates takes as input a set of headers and generates in output the dictionary C++ code and a pcm file. This latter file is fundamental for the correct functioning of the dictionary at runtime. It should be located in the directory where the shared library is installed in which the compiled dictionary resides.; NOTA BENE: the dictionaries that will be used within the same project must have unique names. In other words, compiled object files relative to dictionary source files cannot reside in the same library or in two libraries loaded by the same application if the original source files have the same name. This loose limitation is imposed by the registration mechanism ROOT has in place to keep track of dynamically loaded libraries.; In the following example, we walk through the steps necessary to generate a dictionary, I/O, and inspect member functions. Let’s start with a TEvent class, which contains a collection of TTracks.; The TEvent.h header is:; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple event class; };. #endif; The things to notice in these header files are:. The usage of the ClassDef macro; The default constructors of the TEvent and TTrack classes; Comme",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:825802,Performance,perform,performance,825802," is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to objects of classes not inheriting from TObject. #pragma link C++ class SClass!; // no >> operator; // or; #pragma link C++ class SClass-!; // no streamer, no >> operator. + : in ROOT version 1 and 2 tells rootcling to generate a Streamer with extra byte count information. This adds an integer to each object in the output buffer, but it allows for powerful error correction in case a Streamer method is out of sync with data in the file. The + option is mutual exclusive with both the - and ! options. IMPORTANT NOTE: In ROOT Version 3 and later, a “+” after the class name tells rootcling to use the new I/O system. The byte count check is always added. The new I/O system has many advantages including support automatic schema evolution, full support for STL collections and better run-time performance. We strongly recommend using it.; #pragma link C++ class SClass+; // add byte count; For information on Streamers see “Input/Output”. To get help on rootcling type on the UNIX command line: rootcling -h; 15.5.1.1 The Order Matters; When using template classes, the order of the pragma statements matters. For example, here is a template class Tmpl and a normal class Norm, which holds a specialized instance of a Tmpl:; class Norm {; private:; Tmpl<int>* fIntTmpl;; public:; ...; };; Then in Linkdef.h, the pragma statements must be ordered by listing all specializations before any classes that need them:; // Correct Linkdef.h ordering; ...; #pragma link C++ class Tmpl<int>;; #pragma link C++ class Norm;; ...; And not vice versa:; // Bad Linkdef.h ordering; ...; #pragma link C++ class Norm;; #pragma link C++ class Tmpl<int>;; ...; In this case, rootcling generates Norm::Streamer() that makes reference to Tmpl<int>::St",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:835722,Performance,Load,Load,835722,"cling.; #pragma link default [on|off]; By turning default ‘on’, all language constructs in given header files will be included in generated Cling dictionary (interface method source file). If default is set to ‘off’, nothing will be included in the generated dictionary. The next statement explicitly set linkage to each item:; #pragma link [C|C++|off] [class|function|global]; This pragma statement must be given before rootcling reads any C/C++ definitions from header files. Example:; #ifdef __ROOTCLING__; #pragma link default off;; #endif. class A {; int a;; double b;; };. class B {; int d;; double e;; };. #ifdef __ROOTCLING__; #pragma link C++ class A; // only class A is linked, not B; #endif; 15.5.1.2.1 Compilation; Step 4: Compile the class using the Makefile.In the Makefile call rootcling to make the dictionary for the class. Call it SClassDict.cxx. The rootcling utility generates the methods Streamer, TBuffer &operator>>() and ShowMembersfor ROOT classes.; gmake -f Makefile; Load the shared library:; root[] .L SClass.so; root[] SClass *sc = new SClass(); root[] TFile *f = new TFile(""Afile.root"",""UPDATE"");; root[] sc->Write();; For more information on rootcling see the $ROOTSYS/test directory Makefile, Event.cxx, and Event.h for an example, or follow this link: http://root.cern.ch/root/RootCintMan.html; 15.6 genreflex: A Comfortable Interface to rootcling; Version 5 supported both Cint and Reflex dictionaries. The tool to create Reflex dictionaries was a Python script called genreflex and was very successful in the user community. Even if version 6 has only one type of dictionaries, cling dictionaries, a re-implementation of genreflex is provided. More precisely, in ROOT6, genreflex is nothing but a wrapper around rootcling, which offers an identical CLI and behaviour to the old Python tool. The input to genreflex is a C++ header file, a set of switches and a selection XML file. The output, as for rootcling, is a C++ dictionary source and a pcm files. An exhaustiv",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:838691,Performance,Load,Load,838691,"les allow to select the classes for which the dictionaries must be created: a third method is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes which are located in this special namespace are automatically selected for dictionary generation. All the properties and annotations allowed by LinkDef and selection XML files are possible. For a detailed documentation of the features of the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collecti",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:838753,Performance,load,loaded,838753,"is available. This is represented by the ROOT::Meta::Selection namespace. The idea behind this technique is that all the classes which are located in this special namespace are automatically selected for dictionary generation. All the properties and annotations allowed by LinkDef and selection XML files are possible. For a detailed documentation of the features of the ROOT::Meta::Selection namespace, refer to its online documentation.; 15.7 Adding a Class with ACLiC; Step 1: Define your class; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; Step 2: Load the ABC class in the script.; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; 16 Collection Classes; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used parameterized C++ collections or polymorphic collections before, some of this material will be review. However, much of this chapter covers aspects of collections specific to the ROOT system. When you have read this chapter, you will know. How to create instances of collections; The difference between lists, arrays, hash tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection to access collection elements; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:846981,Performance,tune,tune,846981,"d to store a sub-set of the track objects. In the destructor of the class, the method Delete is called for the owning collection to delete correctly its entire track objects. To delete the objects in the container use fTrack->Delete(). To delete the container itself, do ’delete fTracks'.; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; TList *fVertex2; //subset of tracks part of vertex2; };; TEvent::~TEvent(); {; fTracks->Delete();; delete fTracks;; delete fVertex1;; delete fVertex2;; }; The TIterator class defines the minimum set of member functions that all iterators must support. These include:. Next Returns the next member of the collection or 0 if no more members.; Reset Resets the iterator so that Next returns the first object. 16.4 A Collectable Class; By default, all objects of TObject derived classes can be stored in ROOT containers. However, the TObject class provides some member functions that allow you to tune the behavior of objects in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:853124,Performance,perform,performance,853124," this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; Method 1 uses internally method 2.; Method 2 works for all collection classes. TIter overloads operator().; Methods 3 and 4 are specific for TList.; Methods 2, 3 and 4 can also easily iterate backwards using either a backward TIter (using argument kIterBackward) or by using LastLink() and lnk>Prev() or by using the Before() method.; 16.7 The TObjArray Collection; A TObjArray is a collection which supports traditional array semantics via the overloading of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-allocation and a copy of the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantics. Overhead per element: none, except possible over sizing of fCont.; 16.8 TClonesArray An Array of Identical Objects; A TClonesArray is an array of identical (clone) objects. The memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClone",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857884,Performance,load,load,857884,"yContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensio",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857919,Performance,Load,Load,857919,"same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensions and is not part of the CLHEP translation.; 17.2 TVector3. TVector3 i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:870120,Performance,perform,performs,870120," gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+)metric:; s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therefore:; mag2 = v*v = t*t-x*x-y*y-z*z; If mag2 is negative: mag = -Sqrt(-mag*mag). The methods are:; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; Since in case of momentum and energy the magnitude has the meaning of invariant mass TLorentzVector provides the more meaningful aliases M2() and M(). The methods Beta() and Gamma() returns beta and gamma = 1/Sqrt(1-beta*beta).; 17.4.6 Lorentz Boost; A boost in a general direction can be parameterized with three parameters which can be taken as the components of a three vector b=(bx,by,bz). With x=(x,y,z) and gamma=1/Sqrt(1-beta*beta) (beta being the module of vector b), an arbitrary active Lorentz boost transformation (from the rod frame to the original frame) can be written as:; x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b; t = gamma(t'+ b*x'); The Boost() method performs a boost transformation from the rod frame to the original frame. BoostVector() returns a TVector3 of the spatial components divided by the time component:; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); 17.4.7 Rotations; There are four sets of functions to rotate the TVector3 component of a TLorentzVector:; Around Axes:; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; Around an arbitrary axis:; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; Transformation from rotated frame:; v.RotateUz(direction); // direction must be a unit TVector3; Rotation by TRotation:; TRotation r;; v.Transform(r);//or v *= r; (v = r*v); 17.4.8 Miscellaneous; Angle between two vectors:; Double_t a = v1.Angle(v2);// get angle between v1 and v2; Methods Plus() and Minus() return the positive and negative light-cone components:; Double_t pcone",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874321,Performance,load,loaded,874321,")to return the inverse transformation keeping the current one unchanged. The method Invert() inverts the current TLorentzRotation:; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874372,Performance,load,load,874372,")to return the inverse transformation keeping the current one unchanged. The method Invert() inverts the current TLorentzRotation:; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874467,Performance,load,load,874467,"; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874536,Performance,Load,Load,874536,"; l1 = l2.Invert(); // invert l2, then l1=l2; The matrix for the inverse transformation of a TLorentzRotation is as follows:; \[; \left|; \begin{array}{cccc}; xx & xy & xz & -tx \\; yx & yy & yz & -ty \\; zx & zy & zz & -tz \\; -xt & -yt & -zt & tt; \end{array}; \right|; \]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:875072,Performance,optimiz,optimize,875072,".VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:875356,Performance,optimiz,optimize,875356,". The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:876800,Performance,load,load,876800,"ide another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:876900,Performance,Load,Load,876900,"cely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877035,Performance,perform,performing,877035,"is master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:878322,Performance,optimiz,optimization,878322,"[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpos",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:878350,Performance,perform,perform,878350,"[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpos",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:879621,Performance,load,load,879621,"see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: “OK, I understand the first lines that load the libGeom library and create a geometry manager object. I also recognize from the previous example the following lines creating some materials and media, but what about the geometrical transformations below?”; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on containment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformation of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:882349,Performance,perform,performing,882349," the letters R, O and T. Why one have to define so many volumes to make an R?”; A: Well, in real life some objects have much more complex shapes that an R. The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called primitive shapes). Gluing these together in the appropriate way is the user responsibility.; Q: “I am getting the global picture but not making much out of it… There are also a lot of calls to TGeoVolume::AddNode() that I do not understand.”; A: A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a node of its container and a new object of the class TGeoNode is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw()call for the top volume. These are explained in details in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:883431,Performance,perform,performing,883431,", notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw()call for the top volume. These are explained in details in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: “Checking the Geometry”). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: “Creating and Visualizing Tracks”). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:883523,Performance,perform,performed,883523,"in the section “Visualization Settings and Attributes”. At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: “Checking the Geometry”). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: “Creating and Visualizing Tracks”). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or tr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:885597,Performance,perform,performed,885597,"tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at https://root.cern.ch/doc/master/classTGeoManager.html.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly()-draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the clic",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:885754,Performance,perform,perform,885754," daughters. For a better understanding of the hierarchy, have a look at https://root.cern.ch/doc/master/classTGeoManager.html.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly()-draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the clicked volume and display only those inside visible volumes.; Right click + Weight() - estimates the weight of a volume within a given precision. Note that there are several additional methods for visibility and line attributes se",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891116,Performance,perform,performing,891116,"oid TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:891434,Performance,load,loaded,891434,"natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:896205,Performance,perform,performing,896205,"a; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ong",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:899606,Performance,optimiz,optimize,899606,"the geometry are arbitrary. However, there are certain functionalities that work with the assumption that the used lengths are expressed in centimeters. This is the case for shape capacity or volume weight computation. The same is valid when using the ROOT geometry as navigator for an external transport MC package (e.g. GEANT) via the VMC interface.; Other units in use: All angles used for defining rotation matrices or some shape parameters are expressed in degrees. Material density is expressed in [g/cm3].; 18.3.2 Primitive Shapes; 18.3.2.1 Boxes - TGeoBBox Class; Normally a box has to be built only with 3 parameters: DX,DY,DZ representing the half-lengths on X, Y and Z-axes. In this case, the origin of the box will match the one of its reference frame and the box will range from: -DX to DX on X-axis, from -DY to DY on Y and from -DZ to DZ on Z. On the other hand, any other shape needs to compute and store the parameters of their minimal bounding box. The bounding boxes are essential to optimize navigation algorithms. Therefore all other primitives derive from TGeoBBox. Since the minimal bounding box is not necessary centered in the origin, any box allows an origin translation (Ox,Oy,Oz). All primitive constructors automatically compute the bounding box parameters. Users should be aware that building a translated box that will represent a primitive shape by itself would affect any further positioning of other shapes inside. Therefore it is highly recommendable to build non-translated boxes as primitives and translate/rotate their corresponding volumes only during positioning stage.; TGeoBBox(Double_t dx,Double_t dy,Double_t dz,Double_t *origin=0);. TGeoBBox class. 18.3.2.2 Parallelepiped - TGeoPara class; A parallelepiped is a shape having 3 pairs of parallel faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. TGeoPara class. The shape has the center in ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:915077,Performance,perform,performance,915077," TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; 18.3.3 Composite Shapes; Composite shapes are Boolean combinations of two or more shape components. The supported Boolean operations are union (+), intersection (*) and subtraction(-). Composite shapes derive from the base TGeoShape class, therefore providing all shape features: computation of bounding box, finding if a given point is inside or outside the combination, as well as computing the distance to entering/exiting. They can be directly used for creating volumes or used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of basic shape primitives. They have a binary tree internal structure, therefore all shape-related geometry queries are signals propagated from top level down to the final leaves, while the provided answers are assembled and interpreted back at top. This CSG (composite solid geometry) hierarchy is effective for small number of components, while performance drops dramatically for large structures. Building a complete geometry in this style is virtually possible but highly not recommended.; 18.3.3.1 The Structure of Composite Shapes; A composite shape can always be looked as the result of a Boolean operation between only two shape components. All information identifying these two components as well as their positions with respect to the frame of the composite is represented by an object called Boolean node. A composite shape has a pointer to such a Boolean node. Since the shape components may also be composites, they will also contain binary Boolean nodes branching out other two shapes in the hierarchy. Any such branch ends-up when the final leaves are no longer composite shapes, but basic primitives. The figure shows the composite shapes structure. The composite shapes structure. Suppose that A, B, C and D represent basic shapes, we will illustrate how the internal representation of few combinations look",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:919775,Performance,Load,Load,919775,"e(""CS2"",; ""(A:m1+B):m2-(C:m3*D:m4):m5"");; Building composite shapes as in the first example is not always quite useful since we were using un-positioned shapes. When supplying just shape names as identifiers, the created Boolean nodes will assume that the shapes are positioned with an identity transformation with respect to the frame of the created composite. In order to provide some positioning of the combination components, we have to attach after each shape identifier the name of an existing transformation, separated by a colon. Obviously all transformations created for this purpose have to be objects with unique names in order to be properly substituted during parsing.; 18.3.3.2 Composite Shape Example; One should have in mind that the same shape or matrix identifiers can be used many times in the same expression, as in the following example:; const Double_t sq2 = TMath::Sqrt(2.);; gSystem->Load(""libGeom"");; TGeoManager *mgr =; new TGeoManager(""Geom"",""composite shape example"");; TGeoMedium *medium = 0;; TGeoVolume *top = mgr->MakeBox(""TOP"",medium,100,250,250);; mgr->SetTopVolume(top);. // make shape components; TGeoBBox *sbox = new TGeoBBox(""B"",100,125*sq2,125*sq2);; TGeoTube *stub = new TGeoTube(""T"",0,100,250);; TGeoPgon *spgon = new TGeoPgon(""P"",0.,360.,6,2);; spgon->DefineSection(0,-250,0,80);; spgon->DefineSection(1,250,0,80);. // define some rotations; TGeoRotation *r1 = new TGeoRotation(""r1"",90,0,0,180,90,90);; r1->RegisterYourself();; TGeoRotation *r2 = new TGeoRotation(""r2"",90,0,45,90,45,270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();. A composite shape example. Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:920988,Performance,Perform,Performed,920988,"B"",100,125*sq2,125*sq2);; TGeoTube *stub = new TGeoTube(""T"",0,100,250);; TGeoPgon *spgon = new TGeoPgon(""P"",0.,360.,6,2);; spgon->DefineSection(0,-250,0,80);; spgon->DefineSection(1,250,0,80);. // define some rotations; TGeoRotation *r1 = new TGeoRotation(""r1"",90,0,0,180,90,90);; r1->RegisterYourself();; TGeoRotation *r2 = new TGeoRotation(""r2"",90,0,45,90,45,270);; r2->RegisterYourself();; // create a composite; TGeoCompositeShape *cs = new TGeoCompositeShape(""cs"",; ""((T+T:r1)-(P+P:r1))*B:r2"");; TGeoVolume *comp = new TGeoVolume(""COMP"",cs);; comp->SetLineColor(5);. // put it in the top volume; top->AddNode(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();. A composite shape example. Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.; 18.3.4 Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:921615,Performance,perform,performed,921615,"e(comp,1);; mgr->CloseGeometry();; // visualize it with ray tracing; top->Raytrace();. A composite shape example. Composite shapes can be subsequently used for defining volumes. Moreover, these volumes contain other volumes, following the general criteria. Volumes created based on composite shapes cannot be divided.; 18.3.4 Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:925294,Performance,perform,performed,925294,"rn are the main components of the geometrical tree. A specific shape can be created stand-alone:; TGeoBBox *box = new TGeoBBox(""s_box"",halfX,halfY,halfZ); // named; TGeoTube *tub = new TGeoTube(rmin,rmax,halfZ); // no name; //... (See all specific shape constructors); Sometimes it is much easier to create a volume having a given shape in one step, since shapes are not directly linked in the geometrical tree but volumes are:; TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"",pmed,halfX,; halfY,halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"",pmed,rmin,; rmax,halfZ);; // ...(See MakeXXX() utilities in TGeoManager class); 18.3.6 Dividing Shapes; Shapes can generally be divided along a given axis. Supported axes are: X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes are performed by the call TGeoShape::Divide(), but this operation can be done only via TGeoVolume::Divide() method. In other words, the algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in the paragraph ‘Dividing volumes’. One can see how all division options are interpreted and which their result inside specific shape classes is.; 18.3.7 Parametric Shapes; Shapes generally have a set of parameters that is well defined at build time. In fact, when the final geometrical hierarchy is assembled and the geometry is closed, all constituent shapes MUST**have well defined and valid parameters. In order to ease-up geometry creation, some parameterizations are however allowed.; For instance let’s suppose that we need to define several volumes having exactly the same properties but different sizes. A way to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a sin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:928713,Performance,load,loaded,928713,"VolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.; Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.; Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: “The Drawing Package”) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method TGeoManager::CloseGeometry()). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the TGeoManager class will register itself to ROOT and the logical/physical structures will become immediately browsable.; 18.4.1 The Volume Hierarchy; The basic",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:933952,Performance,perform,perform,933952,"r keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID’s that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry can be saved as a starting state for later use.; Nodes can be declared as overlapping in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geometry’). Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; The creation of overlapping nodes can be done with a similar prototype:; TGeoVolume::AddNodeOverlap(/*same arguments*/);; When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbors. These are stored and checked all the time during navigation; therefore, navigation is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes.; 18.4.2 Creating and Positioning Volumes; 18.4.2.1 Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. E",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:936863,Performance,perform,performances,936863," // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); 18.4.2.3 Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat’ CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:939453,Performance,optimiz,optimization,939453,"r,; TGeoMatrix *matrix=gGeoIdentity); The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeller. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes. These build additional optimization structures upon geometry closure. In order to have navigation features properly working one has to follow some rules for building a valid geometry. The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.; The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:940764,Performance,optimiz,optimizes,940764,"er must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; 18.4.2.4 Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be “invisible” at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:940783,Performance,perform,performance,940783,"er must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; 18.4.2.4 Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be “invisible” at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:941941,Performance,optimiz,optimize,941941,"e volume they are placed into in order to be “invisible” at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ‘invisible’ (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D,E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these v",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:950926,Performance,optimiz,optimization,950926,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let’s think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let’s say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; 18.4.2.8 Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:951111,Performance,perform,performance,951111,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let’s think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let’s say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; 18.4.2.8 Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:955355,Performance,perform,performed,955355,"box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.; In the exa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959052,Performance,perform,performance,959052," grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959233,Performance,optimiz,optimizations,959233,"of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:959428,Performance,perform,perform,959428,"n the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960569,Performance,optimiz,optimizing,960569,"lates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960584,Performance,perform,performance,960584,"lates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis u",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960645,Performance,perform,performance,960645,"Assembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a give",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:960714,Performance,perform,performing,960714,"Assembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: http://root.cern.ch/root/html/examples/assembly.C.html.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a give",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:961071,Performance,optimiz,optimize,961071,"on of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transform",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:961080,Performance,perform,performance,961080,"on of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; Note that components cannot be declared as “overlapping” and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transform",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:961536,Performance,perform,perform,961536,"lies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. 18.4.3 Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in TGeo has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: \(\left|\begin{array}{cccc} r_{11} & r_{12} & r_{13} & 0 \\ r_{21} & r_{22} & r_{23} & 0 \\ r_{31} & r_{32} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Translati",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:962297,Performance,perform,performed,962297,"for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: \(\left|\begin{array}{cccc} r_{11} & r_{12} & r_{13} & 0 \\ r_{21} & r_{22} & r_{23} & 0 \\ r_{31} & r_{32} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ t_x & t_y & t_z & 1 \end{array} \right|\) Scale: \(\left|\begin{array}{cccc} s_x & 0 & 0 & 0 \\ 0 & s_y & 0 & 0 \\ 0 & 0 & s_z & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\); Inverse rotation: \(\left|\begin{array}{cccc} r_{11} & r_{21} & r_{31} & 0 \\ r_{12} & r_{22} & r_{32} & 0 \\ r_{13} & r_{23} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Inverse translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ -t_x & -t_y & -t_z & 1 \end{array} \right|\) Inverse scale: \(\left|\begin{array}{cccc} \frac{1}{s_x} & 0 & 0 & 0 \\ 0 & \frac{1}{s_y} & 0 & 0 \\ 0 & 0 & \frac{1}{s_z} & 0 \\ 0 & 0 & 0 & 1 \end{array} ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:967995,Performance,perform,performed,967995,"The only data member is: Double_t fTranslation[3]. Translations can be added or subtracted. TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psiabout the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3],TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. 18.4.4 Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970125,Performance,cache,cache,970125,"l geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a de",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970295,Performance,load,loaded,970295,"f geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:980735,Performance,perform,perform,980735,"nd ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the TGeoManager corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; 18.5.6 Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:981558,Performance,perform,performed,981558," the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the TGeoManager corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; 18.5.6 Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stac",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:983896,Performance,perform,perform,983896,"Node() or TGeoManager::InitTrack()) and the current node or path has not been changed by the user.; 18.5.7.1 Finding If Current State Is Changed For a New Point; One can find fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘Where am I?'search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; 18.5.7.2 Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:984049,Performance,perform,performing,984049,"nd fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘Where am I?'search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; 18.5.7.2 Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; In the prototype above, besides the current point and direc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:992406,Performance,scalab,scalability,992406,"Vector to the Next Crossed Surface at Crossing Point; Supposing we have found out that a particle will cross a boundary during the next step, it is sometimes useful to compute the normal to the crossed surface. The modeller uses the following convention: we define as normal (\(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:992422,Performance,perform,performance,992422,"Vector to the Next Crossed Surface at Crossing Point; Supposing we have found out that a particle will cross a boundary during the next step, it is sometimes useful to compute the normal to the crossed surface. The modeller uses the following convention: we define as normal (\(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC.; 18.5.8 Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:997249,Performance,perform,perform,997249,"_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to “catch” the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames.; 18.6 Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs.; 18.6.1 The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:999848,Performance,perform,performed,999848,"ter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precis",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:999941,Performance,perform,perform,999941,"ed its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default valu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000089,Performance,optimiz,optimize,1000089,"r words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000205,Performance,perform,performance,1000205,"r words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000466,Performance,load,loaded,1000466,"ack is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001122,Performance,perform,performed,1001122,"eature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (h",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001414,Performance,perform,perform,1001414,"inter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001509,Performance,perform,perform,1001509,"inter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is f",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002285,Performance,perform,performed,1002285,"rks for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002348,Performance,optimiz,optimized,1002348,"iability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation che",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002417,Performance,perform,performing,1002417,"iability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation che",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004609,Performance,load,loaded,1004609,"s the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1005078,Performance,load,loads,1005078,"s. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1006246,Performance,perform,perform,1006246,"tes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1008244,Performance,perform,performed,1008244,").; Q: “I do not see all volumes in my tree but just something inside.”; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can change this by using: gGeoManager::SetVisLevel(n);; Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves’ on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves’ global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();; 18.7.2 Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1009028,Performance,tune,tune,1009028,"king the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?”; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();; 18.7.2 Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; 18.7.2.1 Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; A",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1010316,Performance,tune,tune,1010316,"e line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; 18.7.2.2 Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: Visible daughters. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.; 18.7.3 Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we ar",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1012780,Performance,Perform,Perform,1012780,"ures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad. myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013501,Performance,perform,performing,1013501," TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); The knowledge of the path to the objects that need to be misaligned is essential since there is no",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1017995,Performance,load,loading,1017995,"er->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; The call to pn1->Align() will invalidate the pointer to the node B_1 in pn2 object.. The way out is to either call pn1->Align() before the creation of pn2, either to use a global method that will correct all existing physical nodes:; void RefreshPhysicalNodes(Bool_t lock = kTRUE); The method above will optionally lock the possibility of doing any further misalignment.; 18.9 Geometry I/O; Once geometry is successfully built, it can be saved in a root file, as C++ macro or as GDML file by calling:; TGeoManager::Export(const char *filename,const char*keyname="""",; Option_t *opt=""vg""). Filenameis the name of the file to be written (mandatory). Depending on the extension of the file, the geometry is exported either as ,root file or .C(.cxx) macro or GDML file in case extension is .gdml.; keynameis the name of the key in the file (default """"); opt = ""v"" is an export voxelization (default), otherwise voxelization is recomputed after loading the geometry, ""g"" this option (default) is taken into account only for exporting to gdml file and it ensures compatibility with Geant4 (e.g. it adds extra plane to incorrectly set polycone, it checks whether offset of Phi division is in (-360;0> range, …), for this gdml export there are two more option, that are not set by default: ""f"" and ""n"". If none of this two options are set, then names of solids and volumes in resulting gdml file will have incremental suffix (e.g. TGeoBBox_0x1, TGeoBBox_0x2, …). If ""f"" option is set then then suffix will contain pointer of object (e.g. TGeoBBox_0xAAAAA01, …). Finally if option ""n"" is set then no suffix will be added, though in this case uniqueness of the names is not ensured and it can cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided:; TGeoManager::Import(const char *filename,const char *keyname="""",; Option_t *opt=""""); Example",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1018771,Performance,Load,Loading,1018771,"ise voxelization is recomputed after loading the geometry, ""g"" this option (default) is taken into account only for exporting to gdml file and it ensures compatibility with Geant4 (e.g. it adds extra plane to incorrectly set polycone, it checks whether offset of Phi division is in (-360;0> range, …), for this gdml export there are two more option, that are not set by default: ""f"" and ""n"". If none of this two options are set, then names of solids and volumes in resulting gdml file will have incremental suffix (e.g. TGeoBBox_0x1, TGeoBBox_0x2, …). If ""f"" option is set then then suffix will contain pointer of object (e.g. TGeoBBox_0xAAAAA01, …). Finally if option ""n"" is set then no suffix will be added, though in this case uniqueness of the names is not ensured and it can cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided:; TGeoManager::Import(const char *filename,const char *keyname="""",; Option_t *opt=""""); Example:; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1019474,Performance,Load,Load,1019474,"ave incremental suffix (e.g. TGeoBBox_0x1, TGeoBBox_0x2, …). If ""f"" option is set then then suffix will contain pointer of object (e.g. TGeoBBox_0xAAAAA01, …). Finally if option ""n"" is set then no suffix will be added, though in this case uniqueness of the names is not ensured and it can cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided:; TGeoManager::Import(const char *filename,const char *keyname="""",; Option_t *opt=""""); Example:; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightf",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1021952,Performance,optimiz,optimization,1021952,"mport(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; 18.9.1 GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call.; 18.10 Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms.; 18.10.1 Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable’ object in the geometry hierarchy. It is represented by a path like: /TOP_1/A_1/B_3/C_1, where B_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP_1, MA_1, MB_3, …). Navigation in the geometry hierarchy. The elementary operations for changing the state are:; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); The current state accounting and global matrix handling a",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024136,Performance,optimiz,optimizes,1024136,"terial properties. This task is done by:; TGeoNode *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the deepest node that geometrically contains P (in our case let us suppose it is B_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. Deepest means that B_3 still contains point P (as well as A_1 and TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024213,Performance,perform,performed,1024213,"e *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the deepest node that geometrically contains P (in our case let us suppose it is B_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. Deepest means that B_3 still contains point P (as well as A_1 and TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway se",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1024755,Performance,optimiz,optimization,1024755,"TOP_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. 18.10.2 Finding the Distance to Next Crossed Boundary; The most important feature provided by the modeller related to track propagation is the computation of the distance to the next boundary along a straight line.; The relevant state parameters used for this task are:. Current particle position and direction (x,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1026845,Performance,perform,perform,1026845,"eforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning “step approved”. The default value for stepmax is TGeoShape::Bigwith the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary. According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big() ; The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; 18.10.2.1 Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::Is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1029198,Performance,perform,performed,1029198,"se, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1029556,Performance,perform,performed,1029556,"roposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overl",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1029693,Performance,optimiz,optimization,1029693,"ts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1030270,Performance,perform,performed,1030270," the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; Note: The method TGeoManager::FindNextB",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1031707,Performance,perform,performs,1031707,"puted in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1032529,Performance,load,loaded,1032529,"s not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry ob",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1033400,Performance,load,loaded,1033400,"editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037429,Performance,perform,performed,1037429,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “Undo” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edite",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1042016,Performance,perform,performance,1042016," shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefits of PyROOT is through a few examples.; 19.1.1 Glue-ing Applications; The PyQt library, see http://www.riverbankcomputing.co.uk/pyqt, provides Python bindings for the Qt cross-p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1042678,Performance,load,loaded,1042678,"the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefits of PyROOT is through a few examples.; 19.1.1 Glue-ing Applications; The PyQt library, see http://www.riverbankcomputing.co.uk/pyqt, provides Python bindings for the Qt cross-platform GUI framework ( http://www.trolltech.com). With PyROOT and PyQt, adding ROOT application layer code to a Qt GUI, becomes children play. The following example shows how a Python class can be used to have ROOT code respond to a click on a Qt widget.; # Glue-ing Qt and ROOT through Python; import sys, ROOT; from qt import *. theApp = QApplication( sys.argv); box = QVBox(); box.resize(QSize(40,10).expandedTo(box.minimumSizeHint())). class myButton(QPushButton):; def __init__( self,label,master):; QPushButton.__init__(self,label,master); self.setFont( QFont('Times',18,QFont.Bold)). def browse(self):; self.b = ROOT.TBrowser(). bb = myButton('browser',box); QObject.connect( bb,SIGNAL('clicked()'),bb.browse). theA",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045561,Performance,load,loaded,1045561,"imensional histogram showing a Gaussian distribution. More examples like the one above are distributed with ROOT under the $ROOTSYS/tutorials directory.; # Example: displaying a ROOT histogram from Python; from ROOT import gRandom,TCanvas,TH1F. c1 = TCanvas('c1','Example',200,10,700,500); hpx = TH1F('hpx','px',100,-4,4). for i in xrange(25000):; px = gRandom.Gaus(); hpx.Fill(px). hpx.Draw(); c1.Update(); 19.1.3 Access to Python from ROOT; Access to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045639,Performance,load,loaded,1045639," the one above are distributed with ROOT under the $ROOTSYS/tutorials directory.; # Example: displaying a ROOT histogram from Python; from ROOT import gRandom,TCanvas,TH1F. c1 = TCanvas('c1','Example',200,10,700,500); hpx = TH1F('hpx','px',100,-4,4). for i in xrange(25000):; px = gRandom.Gaus(); hpx.Fill(px). hpx.Draw(); c1.Update(); 19.1.3 Access to Python from ROOT; Access to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to buil",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045991,Performance,load,load,1045991,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046030,Performance,load,loading,1046030,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046055,Performance,Load,Load,1046055,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050370,Performance,load,loaded,1050370,"created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050512,Performance,load,loading,1050512,"the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. N",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050791,Performance,load,load,1050791," script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1051465,Performance,load,loaded,1051465,"tomatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will not actually result in copying all ROOT classes into the current namespace. Instead, classes will still be bound (and possibly loaded) on an as-needed basis. Note carefully how this is different from other Python (extension) modules, and what to expect if you use the normal inspection tools (such as e.g. ‘dir()’). This feature prevents the inspection tools from being swamped by an enormous amount of classes, but they can no longer be used to explore unknown parts of the system (e.g. to find out which classes are available). Furthermore, because of this approach, <tab>-completion will usually not be available until after the first use (and hence creation) of a class.; Access to class static functions, public data members, enums, etc. is as expected. Many more example uses of ROOT classes from Python can be found in the tutorials directory in the ROOT distribution. The recipes section contains a description on working with your own classes (see “Using Your Own Classes”).; 19.1.5.2 Access to STL Classes; The STL classes live in the ROOT.std namespace (or, if you prefer to get them from there, in the RO",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053875,Performance,load,loaded,1053875,"bject instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053911,Performance,load,loading,1053911," std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintu",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054094,Performance,load,loaded,1054094,"ype or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1054272,Performance,load,loading,1054272,"ype or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT globals is the same as python globals, which is sometimes counterintuitive: since they are references, they can be changed only if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1055932,Performance,load,load,1055932,"ly if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a strin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1055988,Performance,Load,LoadMacro,1055988,"ly if done so directly through their containing module. The following session shows that in detail:; >>> from ROOT import *; >>> print(gDebug); 0; >>> gROOT.ProcessLine( 'gDebug = 7;' ); >>> print(gDebug); 0 # local gDebug is unchanged; >>> gDebug = 5 # changes _local_ reference only; >>> print(gDebug); 5 # locally correct, but ...; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 7 # ... ROOT global unchanged; >>> import ROOT; >>> print(ROOT.gDebug); 7 # still the old value (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a strin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1056400,Performance,Load,LoadMacro,1056400,"lue (not '5'); >>> ROOT.gDebug = 3 # changes ROOT module reference; >>> gROOT.ProcessLine( 'cout << gDebug << endl;' ); 3 # ROOT global properly changed; >>>; The above is another good reason to prefer ‘import ROOT’ over ‘from ROOT import *’.; 19.1.5.4 Access to Python; The access to Python from Cling goes through the TPython class, or directly if a Python object or class has crossed the border. The TPython class, which looks approximately like this:; class TPython {. public:; // load a Python script as if it were a macro; static void LoadMacro(const char* name);. // execute a Python statement (e.g. ""import ROOT""); static void Exec(const char* cmd);. // evaluate a Python expression (e.g. ""1+1""); static const TPyReturn& Eval(const char* expr);. // bind a ROOT object with, at the Python side, the name ""label""; static bool Bind(TObject* obj,const char* label);. // enter an interactive Python session (exit with ^D); static void Prompt();; };; LoadMacro(const char* name) - the argument is a name of a Python file that is to be executed ('execfile'), after which any new classes are automatically made available to Cling. Since it is non-selective, use with care.; ExecScript(const char* name,int argc=0,const char** argv=0) - the argument is a name of a python file that is to be executed (‘execfile’) in a private namespace to minimize side-effects. Optionally, you can add CLI-style arguments which are handed to the script through ‘sys.argv’ in the normal way.; Exec(const char* cmd)- the argument is a string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit ca",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1057953,Performance,load,loaded,1057953,"string of Python code that is executed as a statement. There is no return value, but an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058031,Performance,load,loaded,1058031,"t an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058058,Performance,Load,Load,1058058,"t an error message will be printed if there are problems such as syntax errors.; Eval(const char* expr)- the argument is a string of Python code that is evaluated as an expression. The result of the expression is returned, if it is either a builtin type (int, long, float, double, and const char* are supported), a Python type that can cross, or a ROOT type. If a ROOT type is returned, an explicit cast to void* is needed to assign the return value to a local pointer (which may have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058470,Performance,load,loaded,1058470,"ay have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058632,Performance,Load,LoadMacro,1058632,"ay have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058816,Performance,Load,LoadMacro,1058816,"abel”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call TPython::Exec(), which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘r’ in front of the second argument string), in order to remove the need of escaping the backslashes.; 19.1.5.6 Cling Commands; In interactive mode, the Python exception hook is used to mim",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062747,Performance,Perform,Performance,1062747,"olicy:; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masse",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062764,Performance,perform,performance,1062764,"olicy:; ROOT.SetMemoryPolicy( ROOT.kMemoryHeuristics ); Care must be taken in the case of graphic objects: when drawn on the current pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masse",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1062996,Performance,optimiz,optimize,1062996,"nt pad, a reference to the graphics is kept that PyROOT isn’t currently aware of, and it is up to the developer to keep at lease one Python reference alive. See $ROOTSYS/tutorials/pyroot/zdemo.py (available in the latest release) for an example. Alternatively, one can tell python to give up ownership for individual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063178,Performance,perform,performance,1063178,"ndividual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT cal",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063284,Performance,perform,performance,1063284,"ndividual instances:; o = ROOT.TObject(); ROOT.SetOwnership( o, False ) # True to own, False to release; 19.1.6.2 Memory Management by Hand; If needed, you can explicitly destroy a ROOT object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT cal",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063397,Performance,optimiz,optimization,1063397,"T object that you own through its associated TClass:; myobject.IsA().Destructor(myobject); which will send out the deletion notification to the system (thus you do not need to care anymore at this point about Python reference counting, the object will go, even if it’s reference count it non-zero), and free the memory.; 19.1.7 Performance; The performance of PyROOT when programming with ROOT in Python is similar to that of Cling. Differences occur mainly because of differences in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063866,Performance,optimiz,optimizing,1063866,"ces in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bou",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063939,Performance,bottleneck,bottlenecks,1063939,"ces in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bou",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063961,Performance,perform,performance,1063961,"y, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064204,Performance,optimiz,optimizes,1064204,"t good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064270,Performance,perform,performance,1064270,"t good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1064888,Performance,cache,cache,1064888,"ler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1065028,Performance,cache,cached,1065028,"tp://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the __call__ member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1065352,Performance,perform,perform,1065352,"tical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bound method; for i in xrange(25000):; px = gRandom.Gaus(); hpxFill(px) # use bound method: no lookup needed; del hpxFill # done with cached method; Note that if you do not discard the bound method, a reference to the histogram will remain outstanding, and it will not be deleted when it should be. It is therefore important to delete the method when you’re done with it.; 19.1.8 Use of Python Functions; It is possible to mix Python functions with ROOT and perform such operations as plotting and fitting of histograms with them. In all cases, the procedure consists of instantiating a ROOT TF1, TF2, or TF3 with the Python function and working with that ROOT object. There are some memory issues, so it is for example not yet possible to delete a TF1 instance and then create another one with the same name. In addition, the Python function, once used for instantiating the TF1, is never deleted.; Instead of a Python function, you can also use callable instances (e.g., an instance of a class that has implemented the __call__ member function). The signature of the Python callable should provide for one or two arrays. The first array, which must always be present, shall contain the x, y, z, and t values for the call. The second array, which is optional and its size depends on the number given to the TF1 constructor, contains the values that parameterize the function. For more details, see the TF1 documentation and the examples below.; 19.1.8.1",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1069562,Performance,Load,LoadTree,1069562,"nd dedicated buffers to reduce the memory usage and to speed up access. Consequently, mapping TTree functionality to Python is not straightforward, and most of the following features are implemented in ROOT release 4.01/04 and later only, whereas you will need 5.02 if you require all of them.; 19.1.9.1 Accessing an Existing Tree; Let us assume that you have a file containing TTrees, TChains, or TNtuples and want to read the contents for use in your analysis code. This is commonly the case when you work with the result of the reconstruction software of your experiment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the tree1.C macro):; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); Access to arrays works the same way as access to single value tree elements, where the size of the array is determined by the number of values actually read from the file. For example:; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; 19.1.9.2 Writing a Tree; Writing a ROOT TTree in a Python session is a little convoluted, if only because you will need a C++ class to make sure that data members can be mapped, unless you are working with built-in types. Here is an example for working with the latter only:; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','rec",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1072634,Performance,load,loading,1072634,"ct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is defined through the gROOT.ProcessLine() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073176,Performance,load,load,1073176,"() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutori",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073222,Performance,Load,Load,1073222,"f() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073358,Performance,load,load,1073358," you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; ---------",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073556,Performance,load,load,1073556,"ses; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for m",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073619,Performance,Load,LoadMacro,1073619,"after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1084108,Performance,perform,performance,1084108,"e files; Cling test (3 nested loops) with LHCb trigger. The program stress takes one argument, the number of events to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.......",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1084302,Performance,perform,performance,1084302,"s to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1091510,Performance,perform,perform,1091510,"elector::Terminate method. To see the list of selected events, you can do elist->Print(""all""). The selection function has selected 7525 events out of the 283813 events in the chain of files. (2.65 per cent); root[] chain.Process(""h1analysis.C"",""fillList""); Step D: Process only entries in the event list. The event list is read from the file in elist.root generated by step C.; root[] chain.Process(""h1analysis.C"",""useList""); Step E: The above steps have been executed with the interpreter. You can repeat the steps B, C, and D using ACLiC by replacing “h1analysis.C” by “h1analysis.C+” or “h1analysis.C++”.; Step F: If you want to see the differences between the interpreter speed and ACLiC speed start a new session, create the chain as in step 1, then execute; root[] chain.Process(""h1analysis.C+"",""useList""); The commands executed with the four different methods B, C, D and E produce two canvases shown below:; ; 21.2 Script; This is the h1analsysis.C file that was generated by TTree::MakeSelector and then modified to perform the analysis.; #include ""h1analysis.h""; #include ""TH2.h""; #include ""TF1.h""; #include ""TStyle.h""; #include ""TCanvas.h""; #include ""TLine.h""; #include ""TEventList.h"". const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; TEventList *elist = 0;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;. //_________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1]); + par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }. //_________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25); + par[1]/2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1092662,Performance,perform,performs,1092662,".h""; #include ""TLine.h""; #include ""TEventList.h"". const Double_t dxbin = (0.17-0.13)/40; // Bin-width; const Double_t sigma = 0.0012;; TEventList *elist = 0;; Bool_t useList, fillList;; TH1F *hdmd;; TH2F *h2;. //_________________________________________________________; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-par[3])*(x-par[3]);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,par[1]); + par[2]/2.5066/par[4]*TMath::Exp(-xp3/2/par[4]/par[4]));; return res;; }. //_________________________________________________________; Double_t fdm2(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957) return 0;; Double_t xp3 = (x-0.1454)*(x-0.1454);; Double_t res = dxbin*(par[0]*TMath::Power(x-0.13957,0.25); + par[1]/2.5066/sigma*TMath::Exp(-xp3/2/sigma/sigma));; return res;; }. //_________________________________________________________; void h1analysis::Begin(TTree *tree); {; // function called before starting the event loop; // -it performs some cleanup; // -it creates histograms; // -it sets some initialization for the event list. //initialize the Tree branch addresses; Init(tree);. //print the option specified in the Process function; TString option = GetOption();; printf(""Starting h1analysis with process option: %sn"",option.Data());. //Some cleanup in case this function had already been executed; //Delete any previously generated histograms or functions; gDirectory->Delete(""hdmd"");; gDirectory->Delete(""h2*"");; delete gROOT->GetFunction(""f5"");; delete gROOT->GetFunction(""f2"");. //create histograms; hdmd = new TH1F(""hdmd"",""dm_d"",40,0.13,0.17);; h2 = new TH2F(""h2"",""ptD0 vs dm_d"",30,0.135,0.165,30,-3,6);. //process cases with event list; fillList = kFALSE;; useList = kFALSE;; fChain->SetEventList(0);; delete gDirectory->GetList()->FindObject(""elist"");. // case when one creates/fills the event list; if (option.Contains(""fillList"")) {; fillList = kTRUE;; elist = new TEventList(""elist"",""s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101463,Performance,multi-thread,multi-threaded,1101463,">Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101590,Performance,multi-thread,multi-threaded,1101590,"server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102001,Performance,queue,queues,1102001,"ead is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102437,Performance,multi-thread,multi-threaded,1102437,"rties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main r",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1103509,Performance,multi-thread,multi-threaded,1103509,"e, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform independent interface to threads for ROOT.; 23.2.1 Installation; For the time being, it is still necessary to compile a threaded version of ROOT to enable some very special treatments of the canvas operations. We hope that this will become the default later.; To compile ROOT, just do (for example on a debian Linux):; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; This configures and builds ROOT using /usr/lib/libpthread.so as the Pthread library, and defines R__THREAD.; This enables the thread specific treatment of gPad, and creates $ROOTSYS/lib/libThread.so.; Note: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementati",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105330,Performance,Load,Load,1105330,"te: The parameter linuxdeb2 has to be replaced with the appropriate ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled co",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105372,Performance,Load,Load,1105372,"ROOT keyword for your platform.; 23.2.2 Classes; TThread class implements threads . The platform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105421,Performance,load,loads,1105421,"atform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, Use",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105857,Performance,Load,Loading,1105857," platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105901,Performance,Load,Load,1105901,"ixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, yo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105943,Performance,Load,Load,1105943,"ixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, yo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105983,Performance,Load,Load,1105983,"a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, UserArgs);; You can pass arguments to the thread function using the UserArgs-pointer. When you want to start a method of a class as a thread, you have to give the pointer to the class instance as UserArgs. Running. root[] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107713,Performance,perform,performed,1107713,"] th->Run();; root[] TThread::Ps(); // like UNIX ps c.ommand;; With the mhs3 example, you should be able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1107759,Performance,perform,perform,1107759," able to see a canvas with two pads on it. Both pads keep histograms updated and filled by three different threads. With the CalcPi example, you should be able to see two threads calculating Pi with the given number of intervals as precision.; 23.2.4 TThread in More Details; Cling is not thread safe yet, and it will block the execution of the threads until it has finished executing.; 23.2.4.1 Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can n",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1116814,Performance,load,loaded,1116814," access all members of the Myclass instance from the Thread0 function.; Note: Method Thread0 cannot be a virtual member function, since the cast of Thread0 to void(*) in the TThread constructor may raise problems with C++ virtual function table. However, Thread0 may call another virtual member function virtual void Myclass::Func0() which then can be overridden in a derived class of Myclass. (See example TMhs3).; Class Myclass may also provide a method to stop the running thread:; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; Example TMhs3: Class TThreadframe (TThreadframe.h, TThreadframe.cxx) is a simple example of a framework class managing up to four threaded methods. Class TMhs3 (TMhs3.h, TMhs3.cxx) inherits from this base class, showing the mhs3 example 8.1 (mhs3.h, mhs3.cxx)within a class. The Makefile of this example builds the shared libraries libTThreadframe.so and libTMhs3.so. These are either loaded or executed by the ROOT script TMhs3demo.C, or are linked against an executable: TMhs3run.cxx.; 23.3.1 Known Problems; Parts of the ROOT framework, like the interpreter, are not yet thread-safe. Therefore, you should use this package with caution. If you restrict your threads to distinct and `simple’ duties, you will able to benefit from their use. The TThread class is available on all platforms, which provide a POSIX compliant thread implementation. On Linux, Xavier Leroy’s Linux Threads implementation is widely used, but the TThread implementation should be usable on all platforms that provide pthread.; Linux Xlib on SMP machines is not yet thread-safe. This may cause crashes during threaded graphics operations; this problem is independent of ROOT.; Object instantiation: there is no implicit locking mechanism for memory allocation and global ROOT lists. The user has to explicitly protect their code when using them.; 23.4 The Signals of ROOT; The list of default signals handled by ROOT is:; k",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1119452,Performance,load,loaded,1119452,"en building in interactive application the use of the TRint object handles the kSigInterrupt signal. It causes the printing of the message: *** Break *** keyboard interruptand makes a long jump back to the ROOT command prompt. If no TRint object is created, there will be no kSigInterrupt handling. All signals can be reset to their default UNIX behavior via the call of TSytem::ResetSignal(). All signals can be ignored via TSytem::IgnoreSignal(). The TSytem::IgnoreInterrupt() is a method to toggle the handling of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing wit",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1119930,Performance,Concurren,Concurrency,1119930,"ing of the interrupt signal. Typically it is called to prevent a SIGINT to interrupt some important call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1120059,Performance,concurren,concurrency,1120059," call (like writing to a ROOT file).; If TRint is used and the default ROOT interrupt handler is not desired, you should use GetSignalHandler() of TApplication to get the interrupt handler and to remove it by RemoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done whe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1120272,Performance,concurren,concurrency,1120272,"emoveSignalHandler()of TSystem .; 23.5 Glossary; The following glossary is adapted from the description of the Rogue Wave Threads.h++ package.; A process is a program that is loaded into memory and prepared for execution. Each process has a private address space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1120572,Performance,concurren,concurrency,1120572,"ess space. Processes begin with a single thread.; A thread is a sequence of instructions being executed in a program. A thread has a program counter and a private stack to keep track of local variables and return addresses. A multithreaded process is associated with one or more threads. Threads execute independently. All threads in a given process share the private address space of that process.; Concurrency exists when at least two threads are in progress at the same time. A system with only a single processor can support concurrency by switching execution contexts among multiple threads.; Parallelism arises when at least two threads are executing simultaneously. This requires a system with multiple processors. Parallelism implies concurrency, but not vice-versa.; A function is reentrant if it will behave correctly even if a thread of execution enters the function while one or more threads are already executing within the function. These could be the same thread, in the case of recursion, or different threads, in the case of concurrency.; Thread-specific data (TSD) is also known as thread-local storage (TLS). Normally, any data that has lifetime beyond the local variables on the thread’s private stack are shared among all threads within the process. Thread-specific data is a form of static or global data that is maintained on a per-thread basis. That is, each thread gets its own private copy of the data.; Left to their own devices, threads execute independently. Synchronization is the work that must be done when there are, in fact, interdependencies that require some form of communication among threads. Synchronization tools include mutexes, semaphores, condition variables, and other variations on locking.; A critical section is a section of code that accesses a non-sharable resource. To ensure correct code, only one thread at a time may execute in a critical section. In other words, the section is not reentrant.; A mutex, or mutual exclusion lock, is a synchroniza",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1124197,Performance,perform,perform,1124197," library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library from the burden of locking. A thread suffers from deadlock if it is blocked waiting for a condition that will never occur. Typically, this occurs when one thread needs to access a resource that is already locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remot",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125458,Performance,Scalab,Scalability,1125458,"y locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1125700,Performance,load,load,1125700," neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1126376,Performance,perform,performing,1126376,"and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number of computers that can be used in parallel.; Adaptability : the system should be able to adapt itself to variations in the remote environment (changing load on the cluster nodes, network interruptions, etc.).; Being an extension of the ROOT system, PROOF is designed to work on objects in ROOT data stores, though, for the time being, it mainly addresses the case of TTree based object collections.; PROOF is primarily meant as an interactive alternative to batch systems for Central Analysis Facilities and departmental workgroups (Tier-2’s). However, thanks to a multi-tier architecture allowing multiple levels of masters, it can be easily adapted to wide range virtual clusters distributed over geographically separated domains and heterogeneous machines (GRIDs).; While pure interactivity might not always be possible when performing a complicated analysis on a very large data set, PROOF still tries to give the user the interactive experience with something we call “interactive batch”. With “interactive batch” the user can start very long running queries, disconnect the client and at any time, any location and from any computer reconnect to the query to monitor its progress or retrieve the results. This feature gives it a distinct advantage over purely batch based solutions, that only provide an answer once all sub-jobs have been finished. The Multi-tier structure of a PROOF cluster. Details about the PROOF system and the way to use it can be found at 1; The PROOF development is a joint effort between CERN and MIT.; 25 Writing a Graphical User Interface. The ROOT GUI classes support an extensive and rich set of widgets with the Windows 95 look and feel. The widget classes interface to the underlying graphics system via a single abstract class. Concrete versions of this abstract class have been implemented for X11 and Win32, thereby making the ROOT GUI ful",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1137643,Performance,perform,performs,1137643,"the vertical layout manager which arranges its widgets vertically in a column.; The next widget we create as a child of the main frame is the horizontal frame hframe:; TGHorizontalFrame *hframe=new TGHorizontalFrame(fMain,200,40);; The first parameter of its constructor is again the address of its parent, fMain. The next ones define the frame width and height in pixels. The name of the class TGHorizontalFrame gives a hint that a horizontal layout will apply on its children widgets. The Draw and Exit buttons will be laid out horizontally. Here are their constructors:; TGTextButton *draw = new TGTextButton(hframe,""&Draw"");; hframe ->AddFrame(draw, new TGLayoutHints(kLHintsCenterX,5,5,3,4));; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate(0)"");; hframe ->AddFrame(exit,new TGLayoutHints(kLHintsCenterX,5,5,3,4));; They are created as objects of the TGTextButton class that represent the command buttons with a text label. When you click on a command button it performs the action shown on its label. These buttons are well known as “push buttons” or just “buttons”. The parent address hframe is passed as first parameter. The second one defines the button label and normally indicates the action to be taken when the button is clicked. It is possible to define a hot key for the button at that point using the hot string for its label. A hot string is a string with a “hot” character underlined. This character we call the button hot key. It shows the assigned keyboard mnemonic for the button choice. Following our example, this means that you can use Alt+D to click on Draw button and Alt+E to click on Exit. There is a possibility to specify a command string as third parameter of the button constructor. We use it to assign the command gApplication->Terminate(0). The application will be terminated when you click on the Exit button.; We call again AddFrame() to add the buttons to their parent widget giving layout hints for each of them. This time we wou",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1157956,Performance,perform,performs,1157956,";; The second line sets the title position on the left. You can change it to be centered or right aligned if you use TGGroupFrame::kCenter or TGGroupFrame::kRight as a parameter. Be conservative in the use of borders because of the potential for clutter. Do not place them around single entry fields, single combo boxes, list boxes and groups of command buttons. The design of these widgets provides them with a border. The picture above provides kind of borders to avoid.; 25.6 Layout Management; The layout process is an integral part of any GUI. When you create a simple message window, laying out its few buttons and text widgets is quite simple. However, this process becomes increasingly difficult if you have to implement large GUI’s with many widgets that should behave properly when the GUI is resized or uses a different font type or size. Layout management is the process of determining the size and position of every widget in a container.; A layout manager is an object that performs layout management for the widgets within a container. You already know that when adding a component (child widget) to a container (parent widget) you can provide alignment hints (or rely on the default ones). These hints are used by the layout manager to correctly position the widgets in the container. The TGLayoutManager is an abstract class providing the basic layout functionality. The layout classes hierarchy. The base “container” class is TGCmpositeFrame. You can easily change the layout manager using the SetLayoutManager(TGLayoutManager *l) method. Setting the proper layout manager for each container is the first step you have to do. The container uses that layout manager to position and size the components before they are painted. ROOT currently provides the layout managers shown on the picture above.; The next important step is to provide hints about every widget in the container, i.e. to provide positions and right amount of space between the components. The TGLayoutHints objects s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175549,Performance,load,loaded,1175549,"alue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton is an abstract class defining the general button behavior: width, height, state, its group, tool tip text, etc.; There are two main groups of buttons: command buttons with a text or graphics inside that indicate the action to be accomplished and option buttons well known as radio and check buttons that select or change properties. The first group is presented in ROOT by TGPictureButton and TGTextButton classes. They yield an action as soon as they are clicked. It can be opening/closing a dialog box or invoking a specific function in an application. Remember the Draw button from the example. The radio and check buttons from the second group are used to sel",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1178206,Performance,perform,performed,1178206,"assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any changed information is accepted and again displayed in the window that remains open;; Close - closes the window;; Help - opens online Help.; Below are examples of text buttons. Note the two placement methods. The first example should be used when there are one to three command buttons; the second one when there are more than three buttons. Picture buttons are usually rectangular in shape with an icon or graphics label. Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1189471,Performance,perform,perform,1189471,"EAAnyNumber, //input value filter; TGNumberFormat::kNELLimitMinMax, //specify limits; -1.,1.); //limit values; TGNumberEntryField is a number entry input widget.; Nent = new TGNumberEntryField(hgrunf2, kNENT_ID, 0.6,; TGNumberFormat::kNESRealThree,; TGNumberFormat::kNEAAnyNumber);; TGNumberEntryField is a plain vanilla entry field, whereas TGNumberEntry adds two small buttons to increase and decrease the numerical value in the field. The number entry widgets also support using the up and down cursor keys to change the numerical values. The step size can be selected with control and shift keys:. –small step (1 unit/factor of 3); Shift medium step (10 units/factor of 10); Controllarge step (100 units/factor of 30); Shift+Controlhuge step (1000 units/factor of 100). The steps are either linear or logarithmic. The default behavior is set when the entry field is created, but it can be changed by pressing the alt key at the same time.; 25.8.4 Menus; Menus provide a list of commands or options helping the user to select and to perform a task. The menu system classes are TGMenuBar, TGMenuTitle, TGPopupMenu, and TGMenuEntry.; The TGMenuBar class implements a menu bar widget. It is used to specify and provide access to common and frequently used application actions described in menu titles, implemented by TGMenuTitle class. The menu bar is the highest-level of the menu system and it is a starting point for all interactions. Also, it is always visible and allows using the keyboard equivalents. The geometry of the menu bar is automatically set to the parent widget, i.e. the menu bar automatically resizes itself so that it has the same width as its parent (typically TGMainFrame).; The menu bar is as a container for its menus - objects of the type TGPopupMenu. Popup menus can appear in a menu bar. They can be a sub-menu of another popup menu (cascading menus) or can be standalone (as a context menu). They are made of one or more menu items choices. When displayed, the menu items ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1202729,Performance,perform,performed,1202729,"entry IDs are used in these methods and also in event processing routines. In our example the integer variables fFirstEntry and fLastEntry contain the information about the first and last entry IDs. You can add or remove a list box entry using them in the following way:; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; A single-selection list box is used for selecting only one item in a list.; A multiple-selection list box permits selection of more than one item. The selected choices should be visible - you have several choices to do this:. to mark selected choices with a check mark or highlight them; to provide a summary list box to the right of the list box, containing the selected choices; to provide a display-only text control indicating the number of selected choices (its position should be justified upper-right above the list box); if the actions Select All or Deselect All must be quickly or frequently performed, use command buttons. 25.8.7 Combo Boxes; A combo box is as single-selection list box that shows only the currently selected entry and a prompt button displayed as a downward arrow. The prompt button provides a visual cue that a list box is hidden. Its main advantage is consuming of quite a bit of screen space. When the user clicks on it, a list pops up, from which a new choice can be made. After a new item is chosen the combo box folds again showing the new selection. The combo box widget is represented by the user callable class TGComboBox. The class TGComboBoxPopup is a service class. The combo box constructor is very similar to the list box one. The first parameter is a parent widget pointer again, the second - an integer value that will be used as combo box ID. The method used for adding entries is ver",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1207878,Performance,perform,performed,1207878,"ew TGTripleHSlider and TGTripleVSlider classes inherit from the double slider widgets and allow easy selection of a range and a pointer value. The pointer position can be constrained into the selected range or can be relative to it. To change the slider range value press the left mouse button near to the left/right (top/bottom) edges of the slider. To change both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10)",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1210741,Performance,cache,cached,1210741,"cify the parent widget and a string object holding the desired text.; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; Next sample creates an icon object. First we create an object of type TGPicture. The TGPicture objects are never created directly by the application code. We call TGClient telling it the pixmap’s file name to create a TGPicture object and, in turn, it will return a pointer to the created object. If the pixmap file cannot be found the returned pointer will be NULL. As usual, the first parameter of a TGIcon constructor is the parent frame. The second one is the TGPicture object holding the pixmap we want to show. Last two parameters define the width and height of pixmap in pixels. In the end we add the created icon object to its parent.; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; The TGPicture objects are cached by TGClient in order to keep the resource usage low and to improve the efficiency of the client-server windowing systems. TGClient will check whether a pixmap with the same name was already loaded before to register a new picture object. If it finds it, it will return a pointer to the existing object. Also, it will increase the usage counter for the object.; All TGPicture objects are managed by the class TGPicturePool. TGClient creates an object of this type upon initialization. Normally your application program does not deal directly with this class because all manipulations go through TGClient class.; Once you have finished with using of the TGPicture object, you should call the method TGClient::FreePicture(const TGPicture *pic) to free it. The usage counter of the picture object will be decreased and when it reaches zero - the TGPicture object will be deleted.; 25.8.12 Status Bar; The status bar widget is used to display some information about the current ap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1210938,Performance,load,loaded,1210938,"Picture. The TGPicture objects are never created directly by the application code. We call TGClient telling it the pixmap’s file name to create a TGPicture object and, in turn, it will return a pointer to the created object. If the pixmap file cannot be found the returned pointer will be NULL. As usual, the first parameter of a TGIcon constructor is the parent frame. The second one is the TGPicture object holding the pixmap we want to show. Last two parameters define the width and height of pixmap in pixels. In the end we add the created icon object to its parent.; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; The TGPicture objects are cached by TGClient in order to keep the resource usage low and to improve the efficiency of the client-server windowing systems. TGClient will check whether a pixmap with the same name was already loaded before to register a new picture object. If it finds it, it will return a pointer to the existing object. Also, it will increase the usage counter for the object.; All TGPicture objects are managed by the class TGPicturePool. TGClient creates an object of this type upon initialization. Normally your application program does not deal directly with this class because all manipulations go through TGClient class.; Once you have finished with using of the TGPicture object, you should call the method TGClient::FreePicture(const TGPicture *pic) to free it. The usage counter of the picture object will be decreased and when it reaches zero - the TGPicture object will be deleted.; 25.8.12 Status Bar; The status bar widget is used to display some information about the current application state: what is being viewed in the window, a descriptive message about selected objects, or other no interactive information. It may also be used to explain highlighted menu and tool bar items. ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1221979,Performance,load,loads,1221979," and the Cling the C++ Interpreter to connect signals to slots methods.; Therefore, all necessary elements for an object-oriented editor design are in place. The editor complexity can be reduced by splitting it into discrete units of so-called object editors. Any object editor provides an object specific GUI. The main purpose of the ROOT graphics editor is the organization of the object editors’ appearance and the task sequence between them.; 25.9.1 Object Editors; Every object editor follows a simple naming convention: to have as a name the object class name concatenated with ‘Editor’ (e.g. for TGraph objects the object editor is TGraphEditor). Thanks to the signals/slots communication mechanism and to the method DistancetoPrimitive() that computes a ‘‘distance’’ to an object from the mouse position, it was possible to implement a signal method of the canvas that says which is the selected object and to which pad it belongs. Having this information the graphics editor loads the corresponding object editor and the user interface is ready for use. This way after a click on ‘axis’—the axis editor is active; a click on a ‘pad’ activates the pad editor, etc.; The algorithm in use is simple and is based on the object-oriented relationship and communication. When the user activates the editor, according to the selected object <obj> in the canvas it looks for a class name <obj>Editor. For that reason, the correct naming is very important. If a class with this name is found, the editor verifies that this class derives from the base editor class TGedFrame. If all checks are satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The gr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1223632,Performance,load,loaded,1223632,"e satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The graphics editor gives an intuitive way to edit objects in a canvas with immediate feedback. Complexity of some object editors is reduced by hiding GUI elements and revealing them only on users’ requests.; An object in the canvas is selected by clicking on it with the left mouse button. Its name is displayed on the top of the editor frame in red color. If the editor frame needs more space than the canvas window, a vertical scroll bar appears for easy navigation. Histogram, pad and axis editors. 25.9.2 Editor Design Elements; The next rules describe the path to follow when creating your own object editor that will be recognized and loaded by the graphics editor in ROOT, i.e. it will be included as a part of it. Derive the code of your object editor from the base editor class TGedFrame.; Keep the correct naming convention: the name of the object editor should be the object class name concatenated with the word ‘Editor'.; Provide a default constructor.; Use the signals/slots communication mechanism for event processing.; Implement the virtual method SetModel(TObject *obj) where all widgets are set with the current object’s attributes. This method is called when the editor receives a signal from the canvas saying that an object is the selected.; Implement all necessary slots and connect them to appropriate signals that GUI widgets send out. The GUI classes in ROOT are developed to emit signals whenever they change a state that others might be interested. As we noted already, the signals/slots communication mechanism allows total independence of the interacting classes. 2",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1224832,Performance,cache,cached,1224832,"ing convention: the name of the object editor should be the object class name concatenated with the word ‘Editor'.; Provide a default constructor.; Use the signals/slots communication mechanism for event processing.; Implement the virtual method SetModel(TObject *obj) where all widgets are set with the current object’s attributes. This method is called when the editor receives a signal from the canvas saying that an object is the selected.; Implement all necessary slots and connect them to appropriate signals that GUI widgets send out. The GUI classes in ROOT are developed to emit signals whenever they change a state that others might be interested. As we noted already, the signals/slots communication mechanism allows total independence of the interacting classes. 25.9.2.1 Creation and Destruction; GED-frames are constructed during traversal of class hierarchy of the selected object, executed from method TGedEditor::SetModel(). When a new object of a different class is selected, the unneeded GED-frames are cached in memory for potential reuse. The frames are deleted automatically when the editor is closed.; Note: A deep cleanup is assumed for all frames put into the editor. This implies:. do not share the layout-hints among GUI components;; do not delete child widgets in the destructor as this is done automatically. 25.9.2.2 Using Several Tabs; Sometimes you might need to use several tabs to organize properly your class-editor. Each editor tab is a resource shared among all the class-editors. Tabs must be created from the constructor of your editor-class by using the method:; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; It returns a pointer to a new tab container frame ready for use in your class. If you need to hide/show this frame depending on the object’s status, you should store it in a data member. See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1231666,Performance,perform,performed,1231666,"r which the cursor is; TPad *pad = fCanvas->Pick(x, y, 0);; if (pad) {; pad->cd();; gROOT->SetSelectedPad(pad);; }; return action;; Bool_t HandleDNDdrop(TDNDdata *data) - this is the place where the widget actually receives the data. First, check the data format (see description of TDNDData - Drag and Drop data class) and then use it accordingly. In the case of ROOT object, here is an example of how to retrieve it:; if (data->fDataType == gVirtualX->InternAtom(""application/root"")) {; TBufferFile buf(TBuffer::kRead, data->fDataLength,; (void *)data->fData);; buf.SetReadMode();; TObject *obj = (TObject *)buf.ReadObjectAny(TObject::Class());; if (obj->IsA()->GetMethodAllAny(""Draw"")); obj->Draw();; }; In the case of URI/list, the use is:; if (data->fDataType == gVirtualX->InternAtom(""text/uri-list"")) {; TString sfname((char *)data->fData);; TUrl uri(sfname.Data());; if (sfname.EndsWith("".jpg""); TImage *img = TImage::Open(uri.GetFile());; }; Bool_t HandleDNDleave() is used if a specific action has to be performed when the drag operation leaves the widget.; 26 The Signal/Slot Communication Mechanism. 26.1 Introduction; ROOT supports its own version of the signal/slot communication mechanism originally featured in Qt, a C++ GUI application framework by the Qt Company. The ROOT implementation uses the ROOT type system. In addition to all features provided by Qt the ROOT version supports connecting slots to a class (as opposed to connecting to a specific object). These slots will be called whenever the specified signal is emitted by any object of the class. Also a slot can have default arguments and be either a class method or a stand-alone function (compiled or interpreted).; 26.2 Basic Concepts; Signals and slots are used for communication between objects.; Signals are emitted by objects when they change their state in a way that may be interesting to the outside world. This is all the object does to communicate. It does not know if anything is receiving the signal at the o",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1239068,Performance,concurren,concurrent,1239068," not enforced at run-time).; The third requirement, only necessary if you want to have class signals (i.e. for all objects of a class), is that you have to replace the standard ClassImp macro by ClassImpQ.; Signals are currently implemented for all ROOT GUI classes and the TTimer and TCanvas classes (to find quickly all defined signals do for example: grep '*SIGNAL*' $ROOTSYS/include/*.h).; 26.6 Examples; 26.6.1 A First Time Example (rqfirst.C); This example shows:. How to create interpreted class with signals with different types/number of arguments.; How to connect signals to slots.; How to activate signals. 26.6.2 Histogram Filling with Dynamic State Reported via Signals (rqsimple.C); Based on hsimple this example demonstrates:. All features of the hsimple example.; How to create an interpreted class with signals which will report about dynamic state of the histogram processing.; How to use the TTimer class for emulation of “multithreading”.; How to use signals for the concurrent update of pad, file, benchmark facility, etc. 26.6.3 An Example on How to Use Canvas Event Signals (rqfiller.C); This example shows:. How the object communication mechanism can be used for handling the TCanvas’s mouse/key events in an interpreted class. With this demo you can fill histograms by hand:. Click the left button or move mouse with button pressed to fill histograms.; Use the right button of the mouse to reset the histograms. 26.6.4 Complex GUI Using Signals and Slots (guitest.C); Based on $ROOTSYS/test/guitest.cxx this example demonstrates:. All features of the original compiled guitest.cxx program.; Sophisticated use of signals and slots to build a complete user interface that can be executed either in the interpreter or as a compiled program. 27 Automatic HTML Documentation. THtml is ROOT’s documentation engine. It can be used to document your classes in a reference guide, and to convert your text or source files to HTML.; 27.1 Reference Guide; The Reference Guide for the ROOT",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1254706,Performance,load,loader,1254706,"om the sources are the following:. Clone the repository:. $ git clone https://github.com/root-project/root.git. Make a directory for building. $ mkdir build; $ cd build. Run cmake and make. $ cmake ../root; $ make -j8. Setup and run ROOT. $ source bin/thisroot.sh; $ root; 28.5.0.1 Staying up-to-date; To keep your local ROOT source up-to-date with the GitHub repository you should regularly run the command:; % git pull; 28.6 File system.rootrc; ROOT Environment settings are handled via the class TEnv. gEnv->Print()shows which values are active. Any settings can be obtained by TEnv::GetValue methods that return an integer, double or character value for a named resource. If the resource is not found, the default value (given as the second parameter) is returned.; fShowEventStatus = gEnv->GetValue(""Canvas.ShowEventStatus"",kFALSE);; Via the method TEnv::SetValue allows you can set the value of a resource or create a new resource:; gEnv->SetValue(""Root.ObjectStat"",1);; Path used by dynamic loader to find shared libraries and macros. Paths are different for Unix and Windows. The example shows the defaults for all ROOT applications for either Unix or Windows:; Unix.*.Root.DynamicPath: .:$(ROOTSYS)/lib; Unix.*.Root.MacroPath: .:$(ROOTSYS)/macros; WinNT.*.Root.DynamicPath: .;$(ROOTSYS)/bin;$(PATH); WinNT.*.Root.MacroPath: .;$(ROOTSYS)/macros; Path where to look for TrueType fonts:; Unix.*.Root.UseTTFonts: true; *.*.Root.TTFontPath: $(ROOTSYS)/fonts; Use Net* API functions:; WinNT.UseNetAPI: true; Use thread library (if exists).; Unix.*.Root.UseThreads: false; Select the compression algorithm (0=old zlib, 1=new zlib). Setting this to `0’ may be a security vulnerability.; Root.ZipMode: 1; Show where item is found in the specified path:; Root.ShowPath: false; Activate memory statistics.; Root.ObjectStat: 0; Global debug mode. When >0 turns on progressively more details debugging.; Root.Debug: 0; Root.Stacktrace: yes; Settings for X11 behaviour.; X11.Sync: no; X11.FindBestVisual: y",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1262409,Performance,Load,Load,1262409,"or: white; Gui.DocumentForegroundColor: black; Tooltip background and foreground colors in use:; Gui.TooltipBackgroundColor: LightYellow; Gui.TooltipForegroundColor: black; Path where all GUI icons in use can be found:; Gui.IconPath: $(HOME)/icons:$(ROOTSYS)/icons:.; Mime type file setting:; Gui.MimeTypeFile: $(HOME)/.root.mimes; If $(HOME)/.root.mimes does not exists, defaults to this:; #Gui.MimeTypeFile: $(ROOTSYS)/etc/root.mimes; 28.6.4 TBrowser Settings; Current icon style selection - can be either small, big, list, details:; Browser.IconStyle: small; Current sorting rule applied on the browser objects - can be name, type, size, date:; Browser.SortBy: name; Number of items in a group view:; Browser.GroupView: 10000; Show or not hidden items:; Browser.ShowHidden: no; Create a thumbnail view after executing the macro (default is yes).; Browser.AutoThumbnail: yes; 28.6.5 TRint Specific Settings; Rint (interactive ROOT executable) specific alias, logon and logoff macros.; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; Record ROOT session commands in a given history file (default is $(HOME)/.root_hist). If set to “-”, it turn off the command recording.; Rint.History: $(HOME)/.root_hist; Next two lines set the history file size handling. Once HistSize is reached, the last HistSave entries are removed. If HistSize is set to 0, it turns off command recording. Both values can be overridden by environment variable ROOT_HIST=size[:save], where the “:save” part is optional.; Rint.HistSize: 500; Rint.HistSave: 400; 28.6.6 ACLiC Specific Settings; ACLiC.Linkdef specifies the suffix that will be added to the script name to try to locate a custom linkdef file when generating the dictionary.; ACLiC.Linkdef: _linkdef; The top directory for storing the libraries produced by ACLiC is set by:; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; The additional include directives for ACLiC compilations are set by:; ACLiC.IncludePaths: -I/where/the/inc",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:66403,Safety,detect,detect,66403,"line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; The first value defines the maximum of lines kept; once it is reached all, the last HistSave lines will be removed. One can set HistSize to 0 to disable history line management. There is also implemented an environment variable called ROOT_HIST. By setting ROOT_HIST=300:200 the above values can be overriden - the first value corresponds to HistSize, the (optional) second one to HistSave. You can set ROOT_HIST=0 to disable the history.; 2.7.3 Tracking Memory Leaks; You can track memory usage and detect leaks by monitoring the number of objects that are created and deleted (see TObjectTable). To use this facility, edit the file $ROOTSYS/etc/system.rootrc or .rootrc if you have this file and add the two following lines:; Root.ObjectStat: 1; In your code or on the command line you can type the line:; gObjectTable->Print();; This line will print the list of all active classes and the number of instances for each class. By comparing consecutive print outs, you can see objects that you forgot to delete. Note that this method cannot show leaks coming from the allocation of non-objects or classes unknown to ROOT.; 2.8 Converting from PAW to ROOT; The web page at: http://root.cern.ch/root/HowtoConvertFromPAW.html#TABLE gives the “translation” table of some commonly used PAW commands into ROOT. If you move the mouse cursor over the picture at: http://root.cern.ch/root/HowtoConvertFromPAW.html#SET, you will get the corresponding ROOT commands as tooltips.; 2.8.1 Converting HBOOK/PAW Files; ROOT has a utility",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:216634,Safety,avoid,avoided,216634,"gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");. To set Minuit in no graphics mode, call. gMinuit->SetGraphicsMode(kFALSE);; 5.9.1 Basic Concepts of Minuit; The Minuit package acts on a multi parameter FORTRAN function to which one must give the generic name FCN. In the ROOT implementation, the function FCN is defined via the Minuit SetFCN member function when an histogram fitting is invoked. The value of FCN will in general depend on one or more variable parameters.; 5.9.2 The Transformation of Limited Parameters; For variable parameters with limits, Minuit uses the following transformation:; Pint = arcsin(2((Pext-a)/(b-a))-1); Pext = a+((b-a)/(2))(sinPint+1); so that the internal value Pint can take on any value, while the external value Pext can take on values only between the lower limit a and the ext upper limit b. Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical round off both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if they put limits of (0, 1010) on a parameter, then the values 0.0 and 1. 0 will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the ‘’parabolic’’ parameter errors) when there are parameter limits. Users should",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:223543,Safety,recover,recovers,223543,"roblem, and one which has been badly parameterized so that individual errors are not very meaningful because they are so highly correlated; Parameter at limit. This condition, signaled by a Minuit warning message, may make both the function minimum and parameter errors unreliable. See the discussion above ‘Getting the right parameter errors with limits’. The best way to be absolutely sure of the errors is to use ‘’independent’’ calculations and compare them, or compare the calculated errors with a picture of the function. Theoretically, the covariance matrix for a ‘’physical’’ function must be positive-definite at the minimum, although it may not be so for all points far away from the minimum, even for a well-determined physical problem. Therefore, if MIGRAD reports that it has found a non-positive-definite covariance matrix, this may be a sign of one or more of the following:; 5.9.4.1 A Non-physical Region; On its way to the minimum, MIGRAD may have traversed a region that has unphysical behavior, which is of course not a serious problem as long as it recovers and leaves such a region.; 5.9.4.2 An Underdetermined Problem; If the matrix is not positive-definite even at the minimum, this may mean that the solution is not well defined, for example that there are more unknowns than there are data points, or that the parameterization of the fit contains a linear dependence. If this is the case, then Minuit (or any other program) cannot solve your problem uniquely. The error matrix will necessarily be largely meaningless, so the user must remove the under determinedness by reformulating the parameterization. Minuit cannot do this itself.; 5.9.4.3 Numerical Inaccuracies; It is possible that the apparent lack of positive-definiteness is due to excessive round off errors in numerical calculations (in the user function), or not enough precision. This is unlikely in general, but becomes more likely if the number of free parameters is very large, or if the parameters are badly",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:230545,Safety,predict,predictions,230545," feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the following structure showed on the left. It is made of neurons characterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:236130,Safety,avoid,avoid,236130,"by ‘@’ (e.g. “@out”) if one wants to normalize the corresponding value. Also, if the string ends with ‘!’, output neurons are set up for classification, i.e. with a sigmoid (1 neuron) or softmax (more neurons) activation function.; Many questions on the good usage of neural network, including rules of dumb to determine the best network topology are addressed at ftp://ftp.sas.com/pub/neural/FAQ.html; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; Expressions are evaluated as for TTree::Draw(). Input and outputs are taken from the TTree associated with the network. This TTree can be given as argument of the constructor or defined later with TMultiLayerPerceptron::SetData(). Events can also be weighted. The weight expression can be given in the constructor or set later with the method SetWeight() of the class TMultiLayerPerceptron. Two datasets must be defined before learning the network: a training dataset that is used when minimizing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “grap",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241472,Safety,recover,recovered,241472,"he neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to define a structure and initialize the points (you can try this):; Line firstline;; firstline",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:262240,Safety,abort,abort,262240,"piled) (NA):(NA) 0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; Here we see:. Use .class as quick help and reference; Unix like I/O redirection using .> out.txt and unredirection with .>; Use ? to get help on all ‘‘raw’’ interpreter commands; Use @ to abort a multi-line command. Now let us execute a multi-line command:; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of stateme",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:264013,Safety,avoid,avoid,264013,"xit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of objects in the current directory, you can always retrieve them to delete them if needed.; root[] TH1F *h = (TH1F*)gDirectory->Get(""myHist""); // or; root[] TH1F *h = (TH1F*)gDirectory->GetList()->FindObject(""myHist"");; In addition, histograms and trees are automatically deleted when the current directory is closed. This will automatically take care of the clean up. See “Input/Output”.; 7.2.1 Executing a Script From a Script; You may want to execute a script conditionally inside another script. To do it you need to call the interpreter and you can do that with TROOT::ProcessLine(). The example $ROOTSYS/tutorials/tree/cernstaff.C calls a script to build the root file if it does not exist:; void cernstaff() {; if (gSystem->AccessPathName(""cernstaff.root"")) {; gROOT->ProcessLine("".x cernbuild.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:297102,Safety,safe,safe,297102,"you build a class that you want to use in the ROOT environment, you use rootcling that builds the so-called stub functions and the dictionary. These functions and the dictionary contain the knowledge of the used classes. To do this, rootcling parses all the header files. ROOT has defined some special syntax to inform Cling of certain things, this is done in the comments so that the code still compiles with a C++ compiler.; For example, you have a class with a Draw() method, which will display itself. You would like a context menu to appear when on clicks on the image of an object of this class. The recipe is the following:. The class has to contain the ClassDef/ClassImp macros; For each method you want to appear in the context menu, put a comment after the declaration containing *MENU* or *TOGGLE* depending on the behavior you expect. One usually uses Set methods (setters). The *TOGGLE* comment is used to toggle a boolean data field. In that case, it is safe to call the data field fMyBool where MyBool is the name of the setter SetMyBool. Replace MyBool with your own boolean variable.; You can specify arguments and the data members in which to store the arguments. For example:; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; To specify arguments:; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; This statement is in the comment field, after the *MENU*. If there is more than one argument, these arguments are separated by commas, where fX1 and fY2 are data fields in the same class.; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; If the arguments statement is present, the option dialog displayed when selecting SetXXX field will show the values of vari",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:318406,Safety,avoid,avoid,318406,"ere. As you see, TPad defines log scale for the two directions x and y plus z if you want to draw a 3D representation of some function or histogram.; The way to set log scale in the x direction for the active pad is:; root[] gPad->SetLogx(1); To reset log in the z direction:; root[] gPad->SetLogz(0); If you have a divided pad, you need to set the scale on each of the sub-pads. Setting it on the containing pad does not automatically propagate to the sub-pads. Here is an example of how to set the log scale for the x-axis on a canvas with four sub-pads:; root[] TCanvas MyCanvas(""MyCanvas"",""My Canvas""); root[] MyCanvas->Divide(2,2); root[] MyCanvas->cd(1); root[] gPad->SetLogx(); root[] MyCanvas->cd(2); root[] gPad->SetLogx(); root[] MyCanvas->cd(3); root[] gPad->SetLogx(); 9.3.8 WaitPrimitive method; When the TPad::WaitPrimitive() method is called with no arguments, it will wait until a double click or any key pressed is executed in the canvas. A call to gSystem->Sleep(10) has been added in the loop to avoid consuming at all the CPU. This new option is convenient when executing a macro. By adding statements like:; canvas->WaitPrimitive();; You can monitor the progress of a running macro, stop it at convenient places with the possibility to interact with the canvas and resume the execution with a double click or a key press.; 9.3.9 Locking the Pad; You can make the TPad non-editable. Then no new objects can be added, and the existing objects and the pad can not be changed with the mouse or programmatically. By default the TPad is editable.; TPad::SetEditable(kFALSE); 9.4 Graphical Objects; In this paragraph, we describe the various simple 2D graphical objects defined in ROOT. Usually, one defines these objects with their constructor and draws them with their Draw() method. Therefore, the examples will be very brief. Most graphical objects have line and fill attributes (color, width) that will be described in “Graphical objects attributes”. If the user wants more informat",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:321961,Safety,avoid,avoided,321961,"sed in degrees.; A poly-line is a set of joint segments. It is defined by a set of N points in a 2D space. Its constructor is:; TPolyLine(Int_t n,Double_t* x,Double_t* y,Option_t* option); Where n is the number of points, and x and y are arrays of n elements with the coordinates of the points. TPolyLine can be used by it self, but is also a base class for other objects, such as curly arcs.; 9.4.2 Circles and Ellipses; An ellipse can be truncated and rotated. It is defined by its center (x1,y1) and two radii r1 and r2. A minimum and maximum angle may be specified (phimin,phimax). The ellipse may be rotated with an angle theta. All these angles are in degrees. The attributes of the outline line are set via TAttLine, of the fill area - via TAttFill class. They are described in “Graphical Objects Attributes”. Different types of ellipses. When an ellipse sector is drawn only, the lines between the center and the end points of the sector are drawn by default. By specifying the drawn option “only”, these lines can be avoided. Alternatively, the method SetNoEdges() can be called. To remove completely the ellipse outline, specify zero (0) as a line style.; The TEllipse constructor is:; TEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2,; Double_t phimin, Double_t phimax, Double_t theta); An ellipse may be created with:; root[] e = new TEllipse(0.2,0.2,0.8,0.3); root[] e->Draw(); 9.4.3 Rectangles; The class TBox defines a rectangle. It is a base class for many different higher-level graphical primitives. Its bottom left coordinates x1, y1 and its top right coordinates x2, y2, defines a box. The constructor is:; TBox(Double_t x1,Double_t y1,Double_t x2,Double_t y2); It may be used as in:; root[] b = new TBox(0.2,0.2,0.8,0.3); root[] b->SetFillColor(5); root[] b->Draw(). A rectangle with a border. A TWbox is a rectangle (TBox) with a border size and a border mode. The attributes of the outline line and of the fill area are described in “Graphical Objects Attributes”; 9.",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:377252,Safety,detect,detect,377252,"cter “@”. The use of these special characters is illustrated in several scripts referenced by the TPostScript constructor.; 9.10.2 Writing Several Canvases to the Same PostScript File; The following sequence writes the canvas to “c1.ps” and closes the postscript file:; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps"");; If the Postscript file name finishes with “(”, the file remains opened (it is not closed). If the Postscript file name finishes with “)” and the file has been opened with “(”, the file is closed.; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps""; // and ps file is closed; }; The TCanvas::Print(""file.ps("") mechanism is very useful, but it can be a little inconvenient to have the action of opening/closing a file being atomic with printing a page. Particularly if pages are being generated in some loop, one needs to detect the special cases of first and last page. The “[” and “]” can be used instead of “(” and “)” as shown in the next example.; c1.Print(""file.ps[""); // no actual print; just open file.ps; for (i=0; i<10; ++i) {; // fill canvas for context i; ...; c1.Print(""file.ps""); // actually print canvas to file.ps; } // end loop; c1.Print(""file.ps]""); // no actual print; just close file.ps; The following script illustrates how to open a postscript file and draw several pictures. The generation of a new postscript page is automatic when TCanvas::Clear is called by object->Draw().; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);. //select PostScript output type; Int_t type = 111; //portrait ps; // Int_t type = 112; //landscape ps; // Int_t type = 113; //eps. //create a PostScript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page. //draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:410585,Safety,avoid,avoids,410585,"D::kRawSizes) {; ...; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; }; // Complete kRaw tesselation section; if ((reqSections & TBuffer3D::kRaw) &&; buffer.SectionsValid(TBuffer3D::kRawSizes)) {; SetPoints(buffer.fPnts);; // Transform points to master frame if viewer requires it; // The fLocalFrame flag and translation matrix will have; // already been set in TGeoShape::FillBuffer3D() as required; if (!buffer.fLocalFrame); TransformPoints(buffer.fPnts, buffer.NbPnts());; SetSegsAndPols(buffer);; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; return buffer;; }; Note:. we use a static TBuffer3D derived object for efficiency - once the object is added the buffer can be reused.; kRawSize (the calculation of tessellation sizing required in buffer) and kRaw (the actual filling of tessellation) is split, as the X3D viewer requires two publication passes - one to establish the full tessellation capacity for all shapes, and another to actually add them. Splitting avoids having to do the expensive tessellation on the first pass. 9.13.4.4 Shape Specific TBuffer3D Derived Classes; Currently we provide the following shape specific classes, which the GL Viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres (GL Viewer only supports solid spheres at present - cut / hollow ones will be requested as tessellated objects by client.); TBuffer3DTube - basic tube with inner/outer radius and length.; TBuffer3DTubeSeg - angle tube segment.; TBuffer3DCutTube - angle tube segment with plane cut ends. See the above example from TGeoSphere::GetBuffer3D and also equivalent functions in TGeoTube, TGeoTubeSeg and TGeoCtub. Anyone is free to add new TBuffer3D classes, but it should be clear that one or more viewers will require updating to be able to take advantage of them. Hence we only provide classes which existing viewers can benefit from. The number of native shapes in GL Viewer will be expanded in the future.; 9.13.4.5 Master ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:417139,Safety,safe,safely,417139,"It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:421495,Safety,Detect,Detector,421495,"lders; Using folders means to build a hierarchy of folders, posting the reference to the data in the folder by the producer, and creating a reference to the folder by the user.; 10.3.1 Creating a Folder Hierarchy; To create a folder hierarchy you add the top folder of your hierarchy to //root. Then you add a folder to an existing folder with the TFolder::AddFolder method. This method takes two parameters: the name and title of the folder to be added. It returns a pointer of the newly created folder.; The code below creates the folder hierarchy shown in the browser. In this macro, the folder is also added to the list of browsable. This way, it is visible in the browser on the top level.; {; // Add the top folder of my hierary to //root; TFolder *aliroot=gROOT->GetRootFolder()->AddFolder(""aliroot"",; ""aliroot top level folders"");; // Add the hierarchy to the list of browsables; gROOT->GetListOfBrowsables()->Add(aliroot,""aliroot"");. // Create and add the constants folder; TFolder *constants=aliroot->AddFolder(""Constants"",; ""Detector constants"");. // Create and add the pdg folder to pdg; TFolder *pdg = constants->AddFolder(""DatabasePDG"",""PDG database"");. // Create and add the run folder; TFolder *run = aliroot->AddFolder(""Run"",""Run dependent folders"");. // Create and add the configuration folder to run; TFolder *configuration = run->AddFolder(""Configuration"",; ""Run configuration"");. // Create and add the run_mc folder; TFolder *run_mc = aliroot->AddFolder(""RunMC"",; ""MonteCarlo run dependent folders"");. // Create and add the configuration_mc folder to run_mc; TFolder *configuration_mc = run_mc->AddFolder(""Configuration"",; ""MonteCarlo run configuration"");; }; 10.3.2 Posting Data to a Folder (Producer). A TFolder can contain other folders as shown above or any TObject descendents. In general, users will not post a single object to a folder; they will store a collection or multiple collections in a folder. For example, to add an array to a folder:; TObjArray *array;; run_mc-",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:429126,Safety,recover,recovery,429126,">Add(run);; The first parameter of the Add method is a pointer to a TTask, the second parameter is the string to show in the browser. If the string is left out, the name of the task is used.; After executing, the script above the browser will look like in this figure.; 10.5 Execute and Debug Tasks; The browser can be used to start a task, set break points at the beginning of a task or when the task has completed. At a breakpoint, data structures generated by the execution up this point may be inspected asynchronously and then the execution can be resumed by selecting the “Continue” function of a task.; A task may be active or inactive (controlled by TTask::SetActive). When a task is inactive, its sub tasks are not executed. A task tree may be made persistent, saving the status of all the tasks.; 11 Input/Output. This chapter covers the saving and reading of objects to and from ROOT files. It begins with an explanation of the physical layout of a ROOT file. It includes a discussion on compression, and file recovery. Then we explain the logical file, the class TFile and its methods. We show how to navigate in a file, how to save objects and read them back. We also include a discussion on Streamers. Streamers are the methods responsible to capture an objects current state to save it to disk or send it over the network. At the end of the chapter is a discussion on the two specialized ROOT files: TNetFile and TWebFile.; 11.1 The Physical Layout of ROOT Files; A ROOT file is like a UNIX file directory. It can contain directories and objects organized in unlimited number of levels. It also is stored in machine independent format (ASCII, IEEE floating point, Big Endian byte ordering). To look at the physical layout of a ROOT file, we first create one. This example creates a ROOT file and 15 histograms, fills each histogram with 1000 entries from a Gaussian distribution, and writes them to the file.; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of His",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440126,Safety,Recover,Recovery,440126,"le can have multiple versions of the same class, for example objects of old and new versions of a class can be in the same file. The StreamerInfois described in detail in the section on Streamers.; 11.1.5 The List of Keys and the List of Free Blocks; The last three entries on the output of TFile::Map() are the list of keys, the list of free segments, and the address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Re",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440420,Safety,recover,recover,440420,"e last three entries on the output of TFile::Map() are the list of keys, the list of free segments, and the address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440518,Safety,recover,recovery,440518,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440547,Safety,redund,redundant,440547,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440744,Safety,recover,recovery,440744,":8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints informa",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440947,Safety,recover,recovery,440947,"nly 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441132,Safety,recover,recovery,441132,"may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441173,Safety,Recover,Recover,441173,"may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects i",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441199,Safety,recover,recover,441199,"le if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441261,Safety,recover,recovered,441261,"le if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441337,Safety,abort,aborted,441337,"imit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print()",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441510,Safety,recover,recovery,441510,"ible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441631,Safety,recover,recover,441631,"erly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TK",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:441652,Safety,recover,recovered,441652,"erly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] TFile f(""demo.root""); Warning in <TFile::TFile>: file demo.root probably not closed, trying to recover successfully recovered 15 keys; 11.2 The Logical ROOT File: TFile and TKey; We saw that the TFile::Map() method reads the file sequentially and prints information about each record while scanning the file. It is not feasible to support only sequential access and hence ROOT provides random or direct access, i.e. reading a specified object at a time. To do so, TFile keeps a list of TKeys, which is essentially an index to the objects in the file. The TKey class describes the record headers of objects in the file. For example, we can get the list of keys and print them. To find a specific object on the file we can use the TFile::Get() method.; root[] TFile f(""demo.root""); root[] f.GetListOfKeys()->Print(); TKey Name = h0, Title = histo nr:0, Cycle = 1; TKey Name = h1, Title = histo nr:1, Cycle = 1; TKey Name = h2, Title = histo nr:2, Cycle = 1; TKey Name = h3, Title = histo nr:3, Cycle = 1; TKey Name = h4, Title = histo nr:4, Cycle = 1; TKey Name = h5, Title = histo nr:5, Cycle = 1; TK",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:479631,Safety,avoid,avoid,479631,"ass. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ but the advantage of a C++ pointer is that it is already C++.; 11.4.1 Streaming C++ Pointers; When ROOT encounters a pointer data member it calls the Streamer of the object and labels it with a unique object identifier. The object identifier is unique for one I/O operation. If there is another pointer to the object in the same I/O operation, the first object is referenced i.e. it is not saved again. When reading the file, the object is rebuilt and the references recalculated. Streaming object pointers. In this way, the network of pointers and their objects is rebuilt and ready to use the same way it was used before it was persistent. If the pointer hold the address of an object which in embedded in another object (as opposed to being pointed to by a pointer), the object will be duplicate at read time. To avoid this, make the pointer a transient data member.; 11.4.2 Motivation for the TRef Class; If the object is split into several files or into several branches of one or more TTrees, standard C++ pointers cannot be used because each I/O operation will write the referenced objects, and multiple copies will exist. In addition, if the pointer is read before the referenced object, it is null and may cause a run time system error. To address these limitations, ROOT offers the TRef class.; TRef allows referencing an object in a different branch and/or in a different file. TRef also supports the complex situation where a TFile is updated multiple times on the same machine or a different machine. When a TRef is read before its referenced object, it is null. As soon as the referenced object is read, the TRef points to it. In addition, one can specify an action to be taken by TRef in the case it is read before its reference object (see“Action on Demand” below).; 11.4.3 Using TRef; A TRef is a lightweight object pointing",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:485035,Safety,avoid,avoid,485035," TObject destructor. Each TProcessID has a table (TObjArray *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID, a pointer to this unique object may be found using fObjects->At(fUniqueID). In the same way, when a TRef::GetObject is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See TProcessID::GetObjectWithID and PutObjectWithID.; 11.4.4.2 Object Number; When an object is referenced, a unique identifier is computed and stored in both the fUniqueID of the referenced and referencing object. This uniqueID is computed by incrementing by one the static global in TProcessID::fgNumber. The fUniqueID is the serial object number in the current session. One can retrieve the current fgNumber value by calling the static function TProcessID::GetObjectCount at any time or can set this number by TProcessID::SetObjectCount. To avoid a growing table of fObjects in TProcessID, in case, for example, one processes many events in a loop, it might be necessary to reset the object number at the end of processing of one event. See an example in $ROOTSYS/test/Event.cxx (look at function Build). The value of ObjectNumbermay be saved at the beginning of one event and reset to this original value at the end of the event. These actions may be nested.; saveNumber = TProcessID::GetObjectCount();; ...; TProcessID::SetObjectCount(savedNumber);; 11.4.5 Action on Demand; The normal behavior of a TRef has been described above. In addition, TRef supports “Actions on Demand”. It may happen that the referenced object is not yet in the memory, on a separate file or not yet computed. In this case, TRef is able to execute automatically an action:. Call to a compiled function (static function of member function); Call to an interpreted function; Execution of a Cling script. 11.4.5.1 How to Select This Option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName points to something; Wh",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:532179,Safety,recover,recover,532179,"t this is a folder not just the title. You fill the tree by placing the data into the folder structure and calling TTree::Fill.; 12.7.2 Tree and TRef Objects; MyTree->BranchRef();; This call requests the construction of an optional branch supporting table of references (TRefTable). This branch (TBranchRef) will keep all the information needed to find the branches containing referenced objects at each Tree::Fill, the branch numbers containing the referenced objects are saved in the table of references. When the Tree header is saved (via TTree::Write for example), the branch is saved, keeping the information with the pointers to the branches having referenced objects. Enabling this optional table, allow TTree::Draw to automatically load the branches needed to dereference a TRef (or TRefArray) object.; 12.7.3 Autosave; Autosave gives the option to save all branch buffers every n byte. We recommend using Autosave for large acquisitions. If the acquisition fails to complete, you can recover the file and all the contents since the last Autosave. To set the number of bytes between Autosave you can use the TTree::SetAutosave() method. You can also call TTree::Autosave in the acquisition loop every nentry.; 12.7.4 Trees with Circular Buffers; When a TTree is memory resident, you set it up so that it retains retain only the last few entries. For example, this can be very useful for monitoring purpose.; void TTree::SetCircular(Long64_t maxEntries);; where maxEntries is the maximum number of entries to be kept in the buffers. When the number of entries exceeds this value, the first entries in the Tree are deleted and the buffers used again. An example of a script using a circular buffer is shown below:; void circular() {; gROOT->cd(); //make sure that the Tree is memory resident; TTree *T = new TTree(""T"",""test circular buffers"");; TRandom r;; Float_t px,py,pz;; Double_t random;; UShort_t i;; T->Branch(""px"",&px,""px/F"");; T->Branch(""py"",&py,""py/F"");; T->Branch(""pz"",&pz,""pz/F"");; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:538198,Safety,avoid,avoid,538198,"t of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separated by a “/” and it is separated from the next leaf by a “:”.; <Variable>/<type>:<Variable>/<type>; The example on the next line has two leafs: a floating-point number called temp and an integer named ntrack.; ""temp/F:ntrack/I:""; The type can be omitted and if no type is given, the same type as the previous variable is assumed. This leaf list has three integers called ntrack, nseg, and nvtex.; ""ntrack/I:nseg:nvtex""; There is one more rule: when no type is given for the very first leaf, it becomes a float (F). This leaf list has ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:550540,Safety,avoid,avoid,550540,"el branch if the corresponding class is not a collection. If it is a collection, the entry in the collection becomes in turn top level branches, etc. The split level is decreased by 1 every time a new collection is found. For example if list is a TObjArray*. If splitlevel = 1, one top level branch is created for each element of the TObjArray.; If splitlevel = 2, one top level branch is created for each array element. If one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:560932,Safety,SAFE,SAFETY,560932,"tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; 12.15 Example 2: A Tree with a C Structure; The executable script for this example is $ROOTSYS/tutorials/tree/tree2.C.In this example we show:. how to build branches from a C structure; how to make a branch with a fixed length array; how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; When using Geant3, the common block is filled by Geant3 routines at each step and only the TTree::Fill method needs to be called. In this example we emulate the Geant3 step routine with the helixStep function. We also emulate the filling of the particle values. The calls to the Branch methods are the same as if Geant3 were used.; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:561200,Safety,safe,safety,561200," how to make a branch with a variable length array; how to read selective branches; how to fill a histogram from a branch; how to use TTree::Draw to show a 3D plot. A C structure (struct) is used to build a ROOT tree. In general we discourage the use of C structures, we recommend using a class instead. However, we do support them for legacy applications written in C or FORTRAN. The example struct holds simple variables and arrays. It maps to a Geant3 common block /gctrak/.This is the definition of the common block/structure:; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; When using Geant3, the common block is filled by Geant3 routines at each step and only the TTree::Fill method needs to be called. In this example we emulate the Geant3 step routine with the helixStep function. We also emulate the filling of the particle values. The calls to the Branch methods are the same as if Geant3 were used.; void helixStep(Float_t step, Float_t *vect, Float_t *vout); {; // extrapolate track in constant field; Float_t field = 20; // field in kilogauss; enum Evect {kX,kY,kZ,kPX,kPY,kPZ,kPP};; vout[kPP] = vect[kPP];. Float_t h4 = field*2.99792e-4;; Float_t rho = -h4/vect[kPP];; Float_t tet = rho*step;; Float_t tsint = tet*tet/6;; Float_t sintt = 1 - tsint;; Float_t sint = tet*sintt;; Float_t cos1t = tet/2;; Float_t f1 = step*sintt;; Float_t f2 = step*cos1t;; Float_t f3 = step*tsint*vect[kPZ];; Float_t f4 = -tet*cos1t;; Float_t f5 = sint;; Float_t f6 = tet*cos1t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569109,Safety,risk,risk,569109,"a certain algorithm, you may want to try another algorithm and compare the results. One solution is to add a new branch, fill it, and save the tree. The code below adds a simple branch to an existing tree. Note that the kOverwrite option in the Write method overwrites the existing tree. If it is not specified, two copies of the tree headers are saved.; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:569929,Safety,risk,risk,569929,"/ the tree; }; Adding a branch is often not possible because the tree is in a read-only file and you do not have permission to save the modified tree with the new branch. Even if you do have the permission, you risk loosing the original tree with an unsuccessful attempt to save the modification. Since trees are usually large, adding a branch could extend it over the 2GB limit. In this case, the attempt to write the tree fails, and the original data is may also be corrupted. In addition, adding a branch to a tree enlarges the tree and increases the amount of memory needed to read an entry, and therefore decreases the performance. For these reasons, ROOT offers the concept of friends for trees (and chains). We encourage you to use TTree::AddFriend rather than adding a branch manually.; 12.16.2 TTree::AddFriend; A tree keeps a list of friends. In the context of a tree (or a chain), friendship means unrestricted access to the friends data. In this way it is much like adding another branch to the tree without taking the risk of damaging it. To add a friend to the list, you can use the TTree::AddFriend method. The TTree (tree) below has two friends (ft1 and ft2) and now has access to the variables a,b,c,i,j,k,l and m. The AddFriend method has two parameters, the first is the tree name and the second is the name of the ROOT file where the friend tree is saved. AddFriend automatically opens the friend file. If no file name is given, the tree called ft1 is assumed to be in the same file as the original tree.; tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it an alias in the context of the friendship:; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend’s variables were in the original tree. To specify which tree to use in the Draw method, use the syntax:; <treeName>.<branchname>.<varname>; If the variablename is enough to identify uniquely th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:644512,Safety,avoid,avoiding,644512,"s to send to each processor. The TTree::Process method is used to specify the selector and the entries. Before we can use TTree::Process we need to make a selector. We can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the event is selected histograms can be filled. Processing stops when this function returns kFALSE. It combines the methods TSelector::ProcessCut() and TSelector::ProcessFill() in one, avoiding the necessity to maintain the state in the class to communicate between these two functions. It reduces the information that needs to be shared between them and promotes a more granular data access by reading branches as they are needed.; TSelector::Terminate() - it is called at the end of a loop on a TTree. This is a convenient place to draw and fit your histograms.; TSelector::Version() - this function provides backward compatibility for old versions and support for the future upgrades.; The TSelector, unlike the resulting class from MakeClass, separates the processing into a ProcessCut() and ProcessFill(), so we can limit reading of branches to the ones we need.; When a selector is used with a TChain in methods Process(), ProcessFill(), ProcessCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain-",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:666505,Safety,detect,detected,666505,"rated using a linear congruential random generator. The multipliers used are the same of the BSD rand() random generator. Its sequence is:; \(x_{n+1} = (ax_n + c) mod m\) with \(a =1103515245\), \(c = 12345\) and \(m =2^{31}\).; This type of generator uses a state of only a 32 bit integer and it has a very short period, 231,about 109, which can be exhausted in just few seconds. The quality of this generator is therefore BAD and it is strongly recommended to NOT use for any statistical study.; 13.4.2 TRandom1; This random number generator is based on the Ranlux engine, developed by M. Lüsher and implemented in Fortran by F. James. This engine has mathematically proven random proprieties and a long period of about 10171. Various luxury levels are provided (1,2,3,4) and can be specified by the user in the constructor. Higher the level, better random properties are obtained at a price of longer CPU time for generating a random number. The level 3 is the default, where any theoretical possible correlation has very small chance of being detected. This generator uses a state of 24 32-bits words. Its main disadvantage is that is much slower than the others (see timing table). For more information on the generator see the following article:. F. James, “RANLUX: A Fortran implementation of the high quality pseudo-random number generator of Lüscher”, Computer Physics Communication, 79 (1994) 111. 13.4.3 TRandom2; This generator is based on the maximally equi-distributed combined Tausworthe generator by L’Ecuyer. It uses only 3 32-bits words for the state and it has a period of about 1026. It is fast and given its small states, it is recommended for applications, which require a very small random number size. For more information on the generator see the following article:. P. L’Ecuyer, “Maximally Equi-distributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203-213. 13.4.4 TRandom3; This is based on the Mersenne and Twister pseudo-random number g",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:693895,Safety,avoid,avoid,693895,"ametricGradFunction:; public ROOT::Math::IParametricGradFunctionMultiDim; {; private:; const double* pars;. public:; double DoEvalPar(const double* x, const double* p) const; {; return p[0] * x[0] + sin(x[1]) + p[1];; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; 13.7.4 Wrapper Functions; To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the ROOT::Math function interfaces are provided. this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs.; There is one possible wrapper for every interface explained in the previous section. The following table indicates the wrapper for the most basic ones:. Interface; Function Wrapper. ROOT::Math::IBaseFunctionOneDim; ROOT::Math::Functor1D. ROOT::Math::IGradientFunctionOneDim; ROOT::Math::GradFunctor1D. ROOT::Math::IBaseFunctionMultiDim; ROOT::Math::Functor. ROOT::Math::IGradientFunctionMultiDim; ROOT::Math::GradFunctor. Thee functor wrapper are defined in the header file Math/Functor.h.; 13.7.4.1 Wrapping One Dimensional Functions; The ROOT::Math::Functor1D is used to wrap one-dimensional functions It can wrap all the following types: * A free C function of type double ()(double ). * Any C++ callable object implementation double operator()( double ). * A class member function with the correct signature like double Foo::Eval(double ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719745,Safety,avoid,avoided,719745,"physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;; ROOT::Math::Positio",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:720073,Safety,avoid,avoid,720073,"that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 component direction and magnitude vectors, not rooted at any particular point;; ROOT::Math::PositionVector2D and ROOT::Math::PositionVector3D template classes modeling the points in 2 and 3 dimensions. For the 4D space-time vectors, we use the same class to model them, ROOT::Math::LorentzVector, since we have recognized a limited need for modeling the functionality of a 4D point.; 13.12.1.3 Generic Coordinate System; The vecto",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:722274,Safety,avoid,avoid,722274,"rtesian2D, based on (x,y);; ROOT::Math::Polar2D, based on (r,phi);. 3D coordinate system classes:. ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r,theta,phi);; ROOT::Math::Cylindrical3D, based on (rho,z,phi); ROOT::Math::CylindricalEta3D, based on (rho,eta,phi), where eta is the pseudo-rapidity;. 4D coordinate system classes:. ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. Users can define the vectors according to the coordinate type, which is the most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are tra",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:723163,Safety,avoid,avoid,723163," or the assignment (=) operator. For maximum flexibility and minimize memory allocation, the coordinate system classes are templated on the scalar type. To avoid exposing templated parameter to the users, typedefs are defined for all types of vectors based on doubles. See in the examples for all the possible types of vector classes, which can be constructed by users with the available coordinate system types.; 13.12.1.4 Coordinate System Tag; The 2D and 3D points and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D and ROOT::Math::PositionVector3D (and also for 2D classes). A default tag exists for users who do not need this functionality, ROOT::Math::DefaultCoordinateSystemTag.; 13.12.1.5 Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in rotations (in 3 dimensions), Lorentz transformations and Poincare transformations, which are translation/rotation combinations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors by using the operator ()or the operator * and the transformations can be combined via the operator *. The available transformations are:. 3D rotation classes; rotation described by a 3x3 matrix (ROOT::Math::Rotation3D); rotation described by Euler angles (ROOT::Math::EulerAngles); rotation described by a direction axis and an angle (ROOT::Math::AxisAngle); rotation described by a quaternion (ROOT::Math::Quaternion); optimized rotation around x (ROOT::Math::RotationX), y (ROOT::Math::RotationY) and z (ROOT::Math::RotationZ) and described by just one angle.; 3D tran",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725088,Safety,Avoid,Avoiding,725088,"ribe the transformations defined as a composition between a rotation and a translation using the class ROOT::Math::Transform3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the R",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:725230,Safety,avoid,avoiding,725230,"form3D. It is important to note that transformations act differently on vectors and points. The vectors only rotate, therefore when applying a transformation (rotation + translation) on a vector, only the rotation operates while the translation has no effect. The Transform3D class interface is similar to the one used in the CLHEP Geometry package (class ).; Lorentz rotation:; generic Lorentz rotation described by a 4x4 matrix containing a 3D rotation part and a boost part (class ROOT::Math::LorentzRotation); a pure boost in an arbitrary direction and described by a 4x4 symmetric matrix or 10 numbers (class ROOT::Math::Boost); boost along the axis:x(ROOT::Math::BoostX), y(ROOT::Math::BoostY) and z(ROOT::Math::BoostZ). 13.12.1.6 Minimal Vector Classes Interface; We have tried to keep the interface to a minimal level by:. Avoiding methods that provide the same functionality but use different names (like getX() and x()).; Minimizing the number of setter methods, avoiding methods, which can be ambiguous and can set the vector classes in an inconsistent state. We provide only methods which set all the coordinates at the same time or set only the coordinates on which the vector is based, for example SetX() for a Cartesian vector. We then enforce the use of transformations as rotations or translations (additions) for modifying the vector contents.; The majority of the functionality, which is present in the CLHEP package, involving operations on two vectors, is moved in separated helper functions (see ROOT::Math::VectorUtil). This has the advantage that the basic interface will remain more stable with time while additional functions can be added easily. 13.12.1.7 Naming Convention; As part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section ab",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:726938,Safety,avoid,avoid,726938,"s part of ROOT, the GenVector package adheres to the prescribed ROOT naming convention, with some (approved) exceptions, as described here:. Every class and function is in the ROOT::Math namespace.; Member function names start with upper-case letter, apart some exceptions (see the next section about CLHEP compatibility). 13.12.1.8 Compatibility with CLHEP Vector Classes. For backward compatibility with CLHEP the vector classes can be constructed from a CLHEP HepVector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessorsx(), y(), and z() (and t() for the 4D).; We provide vector member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). 13.12.1.9 Connection to Linear Algebra Package; In some use cases, like in track reconstruction, it is needed to use the content of the vector and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must in",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:727810,Safety,avoid,avoid,727810," and rotation classes in conjunction with linear algebra operations. We prefer to avoid any direct dependency to any linear algebra package. However, we provide some hooks to convert to and from linear algebra classes. The vector and the transformation classes have methods which allow to get and set their data members (like SetCoordinates and GetCoordinates) passing either a generic iterator or a pointer to a contiguous set of data, like a C array. This allows an easy connection with the linear algebra package, which in turn, allows creation of matrices using C arrays (like the ROOT TMatrix classes) or iterators (SMatrix classes). Multiplication between linear algebra matrices and GenVector vectors is possible by using the template free functions ROOT::Math::VectorUtil::Mult. This function works for any linear algebra matrix, which implements the operator (i,j) and with first matrix element at i=j=0.; 13.12.2 Example: 3D Vector Classes; To avoid exposing template parameter to the users, typedef’s are defined for all types of vectors based on double’s and float’s. To use them, one must include the header file Math/Vector3D.h. The following typedef’s, defined in the header file Math/Vector3Dfwd.h, are available for the different instantiations of the template class ROOT::Math::DisplacementVector3D:. ROOT::Math::XYZVector vector based on x,y,z coordinates (Cartesian) in double precision; ROOT::Math::XYZVectorF vector based on x,y,z coordinates (Cartesian) in float precision; ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar) in double precision; ROOT::Math::Polar3DVectorF vector based on r,theta,phi coordinates (polar) in float precision; ROOT::Math::RhoZPhiVector vector based on rho,z,phi coordinates (cylindrical) in double precision; ROOT::Math::RhoZPhiVectorF vector based on rho,z,phi coordinates (cylindrical) in float precision; ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z) in double ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:755923,Safety,avoid,avoid,755923,"y constructor (and assignment) for a matrix with the same representation, or from a different one when possible, for example from a symmetric to a general matrix.; Constructor (and assignment) from a matrix expression, like D=A*B+C. Due to the expression template technique, no temporary objects are created in this operation. In the case of an operation like A=A*B+C, a temporary object is needed and it is created automatically to store the intermediary result in order to preserve the validity of this operation.; Constructor from a generic STL-like iterator copying the data referred by the iterator, following its order. It is both possible to specify the begin and end of the iterator or the begin and the size. In case of a symmetric matrix, it is required only the triangular block and the user can specify whether giving a block representing the lower (default case) or the upper diagonal part. Here are some examples on how to create a matrix. We use typedef’s in the following examples to avoid the full C++ names for the matrix classes. Notice that for a general matrix the representation has the default value, ROOT::Math::MatRepStd, and it is not needed to be specified. Furthermore, for a general square matrix, the number of column may be as well omitted.; // typedef definitions used in the following declarations; typedef ROOT::Math::SMatrix<double,3> SMatrix33;; typedef ROOT::Math::SMatrix<double,2> SMatrix22;; typedef ROOT::Math::SMatrix<double,3,3,; ROOT::Math::MatRepSym<double,3>> SMatrixSym3;; typedef ROOT::Math::SVector>double,2> SVector2;; typedef ROOT::Math::SVector>double,3> SVector3;; typedef ROOT::Math::SVector>double,6> SVector6;; SMatrix33 m0; // create a zero 3x3 matrix; // create an 3x3 identity matrix; SMatrix33 i = ROOT::Math::SMatrixIdentity();; double a[9] = {1,2,3,4,5,6,7,8,9}; // input matrix data; // create a matrix using the a[] data; SMatrix33 m(a,9); // this will produce the 3x3 matrix; // ( 1 2 3 ); // ( 4 5 6 ); // ( 7 8 9 ); Example to fill a ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:766388,Safety,predict,predictions,766388,"s in the efficiency and background estimate. The signal is always assumed to be Poisson; background may be Poisson, Gaussian, or user-supplied; efficiency may be Binomial, Gaussian, or user-supplied. See publication at Nucl. Instrum. Meth. A551:493-503,2005.; TLimit class computes 95% C.L. limits using the Likelihood ratio semi-Bayesian method ( method; see e.g. T. Junk, NIM A434, p. 435-443, 1999). It takes signal background and data histograms wrapped in a TLimitDataSource as input, and runs a set of Monte Carlo experiments in order to compute the limits. If needed, inputs are fluctuated according to systematic.; 13.14.2 Specialized Classes for Fitting; TFractionFitter fits Monte Carlo (MC) fractions to data histogram (a la HMCMLL, R. Barlow and C. Beeston, Comp. Phys. Comm. 77 (1993) 219-228). It takes into account both data and Monte Carlo statistical uncertainties through a likelihood fit using Poisson statistics. However, the template (MC) predictions are also varied within statistics, leading to additional contributions to the overall likelihood. This leads to many more fit parameters (one per bin per template), but the minimization with respect to these additional parameters is done analytically rather than introducing them as formal fit parameters. Some special care needs to be taken in the case of bins with zero content.; TMultiDimFit implements multi-dimensional function parametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to acces",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:794338,Safety,detect,detect,794338,"red singular in the solving stage when a diagonal element of the decomposed matrix is smaller than fTol. Here an important point is raised. The Decompose() method is successful as long no zero diagonal element is encountered. Therefore, the user could perform decomposition and only after this step worry about the tolerance number.; If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices or vectors that are invalid. If one would like to monitor the tolerance parameter but not have the code stop in case of a number smaller than fTol, one could proceed as follows:; TVectorD b = ..;; TMatrixD a = ..;; .; TDecompLU lu(a);; Bool_t ok;; TVectorD x = lu.Solve(b,ok);; Int_t nr = 0;; while (!ok) {; lu.SetMatrix(a);; lu.SetTol(0.1*lu.GetTol());; if (nr++ > 10) break;; x = lu.Solve(b,ok);; }; if (x.IsValid()); cout << ""solved with tol ="" << lu.GetTol() << endl;; else; cout << ""solving failed "" << endl;; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix. In this case, the user will have to reduce the tolerance number by this factor. (For CPU time saving we decided not to make this an automatic procedure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix tha",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:795486,Safety,predict,predicts,795486,"ure).; 14.6.2 Condition number; The numerical accuracy of the solution x in Ax = b can be accurately estimated by calculating the condition number k of matrix \(A\), which is defined as:; \(k = ||A||_{1}||A^{-1}||_{1}\) where \(||A||_{1} = \underset{j}{max}(\sum_{i}|A_{ij}|)\); A good rule of thumb is that if the matrix condition number is 10n, the accuracy in x is 15 - n digits for double precision.; Hager devised an iterative method (W.W. Hager, Condition estimators, SIAM J. Sci. Stat. Comp., 5 (1984), pp. 311-316) to determine \(||A^{-1}||_{1}\) without actually having to calculate \(A^{-1}\). It is used when calling Condition().; A code example below shows the usage of the condition number. The matrix \(A\) is a (10x10) Hilbert matrix that is badly conditioned as its determinant shows. We construct a vector b by summing the matrix rows. Therefore, the components of the solution vector x should be exactly 1. Our rule of thumb to the 2.1012 condition number predicts that the solution accuracy should be around; 15 - 12 = 3; digits. Indeed, the largest deviation is 0.00055 in component 6.; TMatrixDSym H = THilbertMatrixDSym(10);; TVectorD rowsum(10);; for (Int_t irow = 0; irow < 10; irow++); for (Int_t icol = 0; icol < 10; icol++); rowsum(irow) += H(irow,icol);; TDecompLU lu(H);; Bool_t ok;; TVectorD x = lu.Solve(rowsum,ok);; Double_t d1,d2;; lu.Det(d1,d2);; cout << ""cond:"" << lu.Condition() << endl;; cout << ""det :"" << d1*TMath:Power(2.,d2) << endl;; cout << ""tol :"" << lu.GetTol() << endl;; x.Print();; cond:3.9569e+12; det :2.16439e-53; tol :2.22045e-16; Vector 10 is as follows; | 1 |; ------------------; 0 |1; 1 |1; 2 |0.999997; 3 |1.00003; 4 |0.999878; 5 |1.00033; 6 |0.999452; 7 |1.00053; 8 |0.999723; 9 |1.00006; 14.6.3 LU; Decompose an nxn matrix \(A\).; PA = LU; P permutation matrix stored in the index array fIndex: j=fIndex[i] indicates that row j and rowishould be swapped. Sign of the permutation, \(-1^n\), where n is the number of interchanges in the permuta",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855641,Safety,safe,safe,855641," of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicate",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857014,Safety,safe,safe,857014,"a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed because it is static and hard-coded, it should be dynamic. However, the important point is that the template statement indicates that T is a template, or parameterized class. If we need an ArrayContainer for Track objects, it can be created by:; ArrayContainer<Track> MyTrackArrayContainer;; C++ takes the parameter list and substitutes Track for T throughout the definition of the class ArrayContainer, then compiles the code so generated, effectively doing the same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:874836,Safety,detect,detector,874836,"]; 17.5.4 Transformation of a TLorentzVector; To apply TLorentzRotation to TLorentzVector you can use either the VectorMultiplication() method or the * operator. You can also use the Transform() function and the *=operator of the class TLorentzVector.; TLorentzVector v;; TLorentzRotation l;; ...; v = l.VectorMultiplication(v);; v = l * v;; v.Transform(l);; v *= l; // v = l*v; 17.5.5 Physics Vector Example; The test file $ROOTSYS/test/TestVectors.cxx is an example of using physics vectors. The vector classes are not loaded by default, and to run it, you will need to load libPhysics.so first:; root[] .L $ROOTSYS/lib/libPhysics.so; root[] .x TestVectors.cxx; To load the physics vector library in a ROOT application use:; gSystem->Load(""libPhysics"");; The example $ROOTSYS/test/TestVectors.cxx does not return much, especially if all went well, but when you look at the code you will find examples for many calls.; 18 The Geometry Package. The new ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA.; 18.1 Quick Start: Creating the “world”; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called volumes.These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:877466,Safety,safe,safely,877466,"mporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();;",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:897117,Safety,safe,safe,897117,"on. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement additional specific abstract methods:. Computation of the minimal box bounding the shape, given that this box have to be aligned with the local coordinates;; Algorithms for dividing the shape along a given axis. The modeller currently provides a set of 20 basic shapes, which we will call primitives. It also provides a special class allowing the creation of shapes as a result of Boolean operations between primitives. These are called composite shapes and the composition operation can be recursive (combined composites). This allows the creation of a quite large number of different shape topologies and combinati",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:901361,Safety,detect,detector,901361," faces out of which one is parallel with the XY plane (Z faces). All faces are parallelograms in the general case. The Z faces have 2 edges parallel with the X-axis. TGeoPara class. The shape has the center in the origin and it is defined by:. dX, dY, dZ: half-lengths of the projections of the edges on X, Y and Z. The lower Z face is positioned at -dZ, while the upper at +dZ.; alpha: angle between the segment defined by the centers of the X-parallel edges and Y axis [-90,90] in degrees; theta: theta angle of the segment defined by the centers of the Z faces;; phi: phi angle of the same segment. TGeoPara(dX,dY,dZ,alpha,theta,phi);; A box is a particular parallelepiped having the parameters: (dX,dY,dZ,0.,0.,0.).; 18.3.2.3 Trapezoids; In general, we will call trapezoidal shapes having 8 vertices and up to 6 trapezoid faces. Besides that, two of the opposite faces are parallel to XY plane and are positioned at dZ. Since general trapezoids are seldom used in detector geometry descriptions, there are several primitives implemented in the modeller for particular cases.; Trd1 is a trapezoid with only X varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y:; TGeoTrd1(Double_t dx1,Double_t dx2,Double_t dy,Double_t dz);. TGeoTrd1 class. Trd2 is a trapezoid with both X and Y varying with Z. It is defined by the half-length in Z, the half-length in X at the lowest and highest Z planes and the half-length in Y at these planes:; TGeoTrd2(Double_t dx1,Double_t dx2,Double_t dy1,Double_t dy2, Double_t dz);. TGeoTrd2 class. 18.3.2.4 General Trapezoid - TGeoTrap Class; A general trapezoid is one for which the faces perpendicular to z are trapezes but their centers are not necessary at the same x, y coordinates. TGeoTrap Class. It has eleven parameters: the half length in z, the polar angles from the center of the face at low z to that at high z, H1 the half length in y at low z, LB1 the half length in x at",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:907214,Safety,avoid,avoid,907214,");. TGeoEltu Class. 18.3.2.11 Hyperboloids - TGeoHype Class; A hyperboloid is represented as a solid limited by two planes perpendicular to the Z axis (top and bottom planes) and two hyperbolic surfaces of revolution about Z axis (inner and outer surfaces). The class describing hyperboloids is TGeoHype has 5 input parameters:; TGeoHype(Double_t rin,Double_t stin,Double_t rout,; Double_t stout,Double_t dz);. TGeoHype Class. The hyperbolic surface equation is taken in the form:; r2 - z2tan2() = r2min. r,z: cylindrical coordinates for a point on the surface; : stereo angle between the hyperbola asymptotic lines and Z axis; r2min: minimum distance between hyperbola and Z axis (at z=0). The input parameters represent:. rin, stin: minimum radius and tangent of stereo angle for inner surface; rout, stout: minimum radius and tangent of stereo angle for outer surface; dz: half length in Z (bounding planes positions at +/-dz). The following conditions are mandatory in order to avoid intersections between the inner and outer hyperbolic surfaces in the range +/-dz:. rin<rout; rout>0; rin2 + dz2*stin2 > rout2 + dz2*stout2. Particular cases:. rin=0, stin0: the inner surface is conical; stin=0 / stout=0: cylindrical surface(s). 18.3.2.12 Cones - TGeoCone Class; The cones are defined by 5 parameters:; TGeoCone(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2);. rmin1: internal radius at Z is -dz; rmax1: external radius at Z is -dz; rmin2: internal radius at Z is +dz; rmax2: external radius at Z is +dz; dz: half length in Z (a cone ranges from -dz to +dz). A cone has Z-axis as its symmetry axis. TGeoCone Class. 18.3.2.13 Cone Segments - TGeoConeSeg Class; A cone segment is a cone having a range in phi. The cone segment class derives from TGeoCone, having two extra parameters: phi1 and phi2.; TGeoConeSeg(Double_t dz,Double_t rmin1,Double_t rmax1,; Double_t rmin2,Double_t rmax2,Double_t phi1,Double_t phi2);; Parametersphi1 and phi2 have the same meaning and co",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922338,Safety,safe,safe,922338," useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t s",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922661,Safety,safe,safe,922661,"all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922712,Safety,SAFE,SAFE,922712,"all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNor",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:922760,Safety,safe,safe,922760," handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method abo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923023,Safety,safe,safe,923023,"cal shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 1",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923271,Safety,safe,safe,923271,"ide(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; The method computes the distance to exiting a shape from a given point inside, along a given direction. This direction is given by its director cosines with respect to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 18.3.5 Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:923430,Safety,Safe,Safety,923430," to the local shape coordinate system. This method provides additional information according the value of iact input parameter:. iact = 0computes only safe distance and fill it at the location given by SAFE;; iact = 1a proposed STEP is supplied. The safe distance is computed first. If this is bigger than STEP than the proposed step is approved and returned by the method since it does not cross the shape boundaries. Otherwise, the distance to exiting the shape is computed and returned;; iact = 2computes both safe distance and distance to exiting, ignoring the proposed step;; iact > 2computes only the distance to exiting, ignoring anything else. Double_t TGeoShape::DistFromOutside(Double_t *point[3],; Double_t *dir[3],Int_t iact,Double_t step,Double_t *safe);; This method computes the distance to entering a shape from a given point outside. It acts in the same way as the previous method.; Double_t TGeoShape::Safety(Double_t *point[3],Bool_t inside);; This computes the maximum shift of a point in any direction that does not change its inside/outsidestate (does not cross shape boundaries). The state of the point has to be properly supplied.; Double_t *TGeoShape::ComputeNormal(Double_t *point[3],; Double_t *dir[3],Double_t *norm[3]);; The method above computes the director cosines of normal to the crossed shape surface from a given point towards direction. This is filled into the norm array, supplied by the user. The normal vector is always chosen such that its dot product with the direction is positive defined.; 18.3.5 Creating Shapes; Shape objects embeds only the minimum set of parameters that are fully describing a valid physical shape. For instance, the half-length, the minimum and maximum radius represent a tube. Shapes are used together with media in order to create volumes, which in their turn are the main components of the geometrical tree. A specific shape can be created stand-alone:; TGeoBBox *box = new TGeoBBox(""s_box"",halfX,halfY,halfZ); // named; TGeoTube *",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:927220,Safety,detect,detector,927220,"y to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a single volume having undefined shape parameters.; TGeoManager::Volume(const char *name,const char *shape,Int_t nmed);. name: the name of the newly created volume;; shape:the type of the associated shape. This has to contain the case-insensitive first 4 letters of the corresponding class name (e.g. “tubs” will match TGeoTubeSeg, “bbox” will match TGeoBBox); nmed: the medium number. This will create a special volume that will not be directly used in the geometry, but whenever positioned will require a list of actual parameters for the current shape that will be created in this process. Such volumes having shape parameters known only when used have to be positioned only with TGeoManager::Node() method (see ‘Creating and Positioning Volumes’).; Other case when shape parameterizations are quite useful is scaling geometry structures. Imagine that we would like to enlarge/shrink a detector structure on one or more axes. This happens quite often in real life and is handled by “fitting mother” parameters. This is accomplished by defining shapes with one or more invalid (negative) parameters. For instance, defining a box having dx=10., dy=10., and dz=-1 will not generate an error but will be interpreted in a different way: A special volume TGeoVolumeMulti will be created. Whenever positioned inside a mother volume, this will create a normal TGeoVolume object having as shape a box with dz fitting the corresponding dzof the mother shape. Generally, this type of parameterization is used when positioning volumes in containers having a matching shape, but it works also for most reasonable combinations.; 18.4 Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both c",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:935137,Safety,avoid,avoid,935137," embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes.; 18.4.2 Creating and Positioning Volumes; 18.4.2.1 Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user’s task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; 18.4.2.2 Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);. // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);. // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; T",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:936748,Safety,detect,detector,936748," // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);. // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeoVolume *vol = gGeoManager->Volume(""VNAME"",""XXXX"",nmed,upar,; npar);. // Where XXXX stands for the first 4 letters of the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); 18.4.2.3 Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat’ CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:942355,Safety,avoid,avoid,942355," (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D,E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:947046,Safety,avoid,avoid,947046,"n will naturally belong to all overlapping partners. The answer provided by the modeller to “Where am I?” is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:949650,Safety,detect,detector,949650,"onsider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:. The part of a MANY node B extruding its container A will never be “seen” during navigation, as if B was in fact the result of the intersection of A and B.; If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.; If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.; The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - might be in some cases a better way out.; 18.4.2.7 Replicating Volumes; What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let’s guess what it has to do. The most simple algorithm will just loop over all ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:970996,Safety,safe,safety,970996," Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting p",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:971099,Safety,detect,detector,971099,"chanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions.; 18.5 Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manage",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:972791,Safety,safe,safety,972791,"ed to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by t",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:985611,Safety,safe,safety,985611,"ng the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; In the prototype above, besides the current point and direction that are supposed already initialized, the only input parameter is step. This represents the maximum step allowed by the tracking algorithm or the physical step. The modeller will search for a boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the curr",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:986301,Safety,safe,safety,986301," boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; According the step value, two use cases are possible:. step = TGeoShape::kBig(default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBo",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987617,Safety,safe,safety,987617,"itional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the comp",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987737,Safety,Safe,Safe,987737,"o the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current ste",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:987822,Safety,safe,safe,987822,"o the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current ste",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988253,Safety,safe,safety,988253," crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988317,Safety,safe,safe,988317,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988490,Safety,safe,safety,988490,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988562,Safety,safe,safety,988562,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988601,Safety,safe,safety,988601,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:988623,Safety,Safe,Safety,988623,"r::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; 18.5.7.3 Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; 18.5.7.4 Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this cas",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1000016,Safety,detect,detected,1000016,"r words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; We will call overlaps only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from. When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker.**. Overlap checking. This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). Th",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1001903,Safety,safe,safety,1001903,"overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate nod",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002171,Safety,safe,safety,1002171," against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002361,Safety,avoid,avoid,1002361,"iability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation che",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002706,Safety,detect,detected,1002706,"1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node ",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1003375,Safety,Safe,Safety,1003375,"hat are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawi",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1013079,Safety,detect,detector,1013079,"ger highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):; 1. TGeoShape *clip1, *clip2, ...; One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; 2. gGeoManager->SetClippingShape(clip1);; One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);. Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom example looks clipped with a tube. Ray-tracing example with box-clipping. 18.8 Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information.; 18.8.1 Physical Nodes; Physical nodes are the actual “touchable” objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and spe",MatchSource.WIKI,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html
