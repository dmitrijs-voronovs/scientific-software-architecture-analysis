id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:1213,Modifiability,inherit,inheritance,1213,"his class implements a layout algorithm for globals referenced by bit sets; /// that tries to keep members of small bit sets together. This can; /// significantly reduce bit set sizes in many cases.; ///; /// It works by assembling fragments of layout from sets of referenced globals.; /// Each set of referenced globals causes the algorithm to create a new; /// fragment, which is assembled by appending each referenced global in the set; /// into the fragment. If a referenced global has already been referenced by an; /// fragment created earlier, we instead delete that fragment and append its; /// contents into the fragment we are assembling.; ///; /// By starting with the smallest fragments, we minimize the size of the; /// fragments that are copied into larger fragments. This is most intuitively; /// thought about when considering the case where the globals are virtual tables; /// and the bit sets represent their derived classes: in a single inheritance; /// hierarchy, the optimum layout would involve a depth-first search of the; /// class hierarchy (and in fact the computed layout ends up looking a lot like; /// a DFS), but a naive DFS would not work well in the presence of multiple; /// inheritance. This aspect of the algorithm ends up fitting smaller; /// hierarchies inside larger ones where that would be beneficial.; ///; /// For example, consider this class hierarchy:; ///; /// A B; /// \ / | \; /// C D E; ///; /// We have five bit sets: bsA (A, C), bsB (B, C, D, E), bsC (C), bsD (D) and; /// bsE (E). If we laid out our objects by DFS traversing B followed by A, our; /// layout would be {B, C, D, E, A}. This is optimal for bsB as it needs to; /// cover the only 4 objects in its hierarchy, but not for bsA as it needs to; /// cover 5 objects, i.e. the entire layout. Our algorithm proceeds as follows:; ///; /// Add bsC, fragments {{C}}; /// Add bsD, fragments {{C}, {D}}; /// Add bsE, fragments {{C}, {D}, {E}}; /// Add bsA, fragments {{A, C}, {D}, {E}}; /// Add bsB,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:800,Usability,intuit,intuitively,800,"his class implements a layout algorithm for globals referenced by bit sets; /// that tries to keep members of small bit sets together. This can; /// significantly reduce bit set sizes in many cases.; ///; /// It works by assembling fragments of layout from sets of referenced globals.; /// Each set of referenced globals causes the algorithm to create a new; /// fragment, which is assembled by appending each referenced global in the set; /// into the fragment. If a referenced global has already been referenced by an; /// fragment created earlier, we instead delete that fragment and append its; /// contents into the fragment we are assembling.; ///; /// By starting with the smallest fragments, we minimize the size of the; /// fragments that are copied into larger fragments. This is most intuitively; /// thought about when considering the case where the globals are virtual tables; /// and the bit sets represent their derived classes: in a single inheritance; /// hierarchy, the optimum layout would involve a depth-first search of the; /// class hierarchy (and in fact the computed layout ends up looking a lot like; /// a DFS), but a naive DFS would not work well in the presence of multiple; /// inheritance. This aspect of the algorithm ends up fitting smaller; /// hierarchies inside larger ones where that would be beneficial.; ///; /// For example, consider this class hierarchy:; ///; /// A B; /// \ / | \; /// C D E; ///; /// We have five bit sets: bsA (A, C), bsB (B, C, D, E), bsC (C), bsD (D) and; /// bsE (E). If we laid out our objects by DFS traversing B followed by A, our; /// layout would be {B, C, D, E, A}. This is optimal for bsB as it needs to; /// cover the only 4 objects in its hierarchy, but not for bsA as it needs to; /// cover 5 objects, i.e. the entire layout. Our algorithm proceeds as follows:; ///; /// Add bsC, fragments {{C}}; /// Add bsD, fragments {{C}, {D}}; /// Add bsE, fragments {{C}, {D}, {E}}; /// Add bsA, fragments {{A, C}, {D}, {E}}; /// Add bsB,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:150,Availability,mask,mask,150,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:86,Performance,load,loading,86,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:175,Testability,test,test,175,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:849,Testability,test,test,849,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:911,Testability,test,test,911,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:24,Energy Efficiency,allocate,allocated,24,/// The number of bytes allocated so far for each of the bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate BitSize bits in the byte array where Bits contains the bits to; /// set. AllocByteOffset is set to the offset within the byte array and; /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest; /// Processing Time) multiprocessor scheduling algorithm to lay out the bits; /// efficiently; the pass allocates bit sets in decreasing size order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:266,Energy Efficiency,schedul,scheduling,266,/// Allocate BitSize bits in the byte array where Bits contains the bits to; /// set. AllocByteOffset is set to the offset within the byte array and; /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest; /// Processing Time) multiprocessor scheduling algorithm to lay out the bits; /// efficiently; the pass allocates bit sets in decreasing size order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:312,Energy Efficiency,efficient,efficiently,312,/// Allocate BitSize bits in the byte array where Bits contains the bits to; /// set. AllocByteOffset is set to the offset within the byte array and; /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest; /// Processing Time) multiprocessor scheduling algorithm to lay out the bits; /// efficiently; the pass allocates bit sets in decreasing size order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:334,Energy Efficiency,allocate,allocates,334,/// Allocate BitSize bits in the byte array where Bits contains the bits to; /// set. AllocByteOffset is set to the offset within the byte array and; /// AllocMask is set to the bitmask for those bits. This uses the LPT (Longest; /// Processing Time) multiprocessor scheduling algorithm to lay out the bits; /// efficiently; the pass allocates bit sets in decreasing size order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h:477,Performance,optimiz,optimization,477,"//==- MemProfContextDisambiguation.h - Context Disambiguation ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements support for context disambiguation of allocation calls for profile; // guided heap optimization using memprof metadata. See implementation file for; // details.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h:465,Usability,guid,guided,465,"//==- MemProfContextDisambiguation.h - Context Disambiguation ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements support for context disambiguation of allocation calls for profile; // guided heap optimization using memprof metadata. See implementation file for; // details.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h:61,Testability,test,testing,61,// Owns the import summary specified by internal options for testing the; // ThinLTO backend via opt (to simulate distributed ThinLTO).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h:418,Modifiability,variab,variables,418,"//===- MergeFunctions.h - Merge Identical Functions -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h:541,Modifiability,variab,variables,541,"//===- MergeFunctions.h - Merge Identical Functions -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h:404,Usability,simpl,simple,404,"//===- MergeFunctions.h - Merge Identical Functions -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MergeFunctions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h:447,Performance,tune,tuned,447,"/// The module inliner pass for the new pass manager.; ///; /// This pass wires together the inlining utilities and the inline cost; /// analysis into a module pass. Different from SCC inliner, it considers every; /// call in every function in the whole module and tries to inline if; /// profitable. With this module level inliner, it is possible to evaluate more; /// heuristics in the module level such like PriorityInlineOrder. It can be; /// tuned with a number of parameters to control what cost model is used and; /// what tradeoffs are made when making the decision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h:46,Performance,optimiz,optimizations,46,"//===- IPO/OpenMPOpt.h - Collection of OpenMP optimizations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h:29,Performance,optimiz,optimizations,29,// namespace omp; /// OpenMP optimizations pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h:393,Performance,perform,performs,393,"//===- PartialInlining.h - Inline parts of functions ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs partial inlining, typically by inlining an if statement; // that surrounds the body of the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:418,Integrability,interface,interface,418,"//===- Transforms/IPO/SampleContextTracker.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for context-sensitive profile tracker used; /// by CSSPGO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:85,Integrability,interface,interfaces,85,"// Profile tracker that manages profiles and its associated context. It; // provides interfaces used by sample profile loader to query context profile or; // base profile for given function or location; it also manages context tree; // manipulation that is needed to accommodate inline decisions so we have; // accurate post-inline profile for functions. Internally context profiles; // are organized in a trie, with each node representing profile for specific; // calling context and the context is identified by path from root to the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:119,Performance,load,loader,119,"// Profile tracker that manages profiles and its associated context. It; // provides interfaces used by sample profile loader to query context profile or; // base profile for given function or location; it also manages context tree; // manipulation that is needed to accommodate inline decisions so we have; // accurate post-inline profile for functions. Internally context profiles; // are organized in a trie, with each node representing profile for specific; // calling context and the context is identified by path from root to the node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h:21,Usability,guid,guid,21,// Map from function guid to real function names. Only used in md5 mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleContextTracker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h:418,Integrability,interface,interface,418,"//===- SampleProfile.h - SamplePGO pass ---------- --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO loader pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h:448,Performance,load,loader,448,"//===- SampleProfile.h - SamplePGO pass ---------- --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO loader pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h:47,Performance,load,loader,47,// namespace vfs; /// The sample profiler data loader pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:406,Integrability,interface,interface,406,"//===- Transforms/IPO/SampleProfileProbe.h ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the pseudo probe implementation for; /// AutoFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:48,Security,hash,hash,48,// Map from tuples of Probe id and inline stack hash code to distribution; // factors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:67,Safety,detect,detect,67,"// A pseudo probe verifier that can be run after each IR passes to detect the; // violation of updating probe factors. In principle, the sum of distribution; // factor for a probe should be identical before and after a pass. For a; // function pass, the factor sum for a probe would be typically 100%.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:10,Security,hash,hash,10,/// A CFG hash code used to identify a function code changes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:36,Deployability,update,updater,36,"// Pseudo probe distribution factor updater.; // Sample profile annotation can happen in both LTO prelink and postlink. The; // postlink-time re-annotation can degrade profile quality because of prelink; // code duplication transformation, such as loop unrolling, jump threading,; // indirect call promotion etc. As such, samples corresponding to a source; // location may be aggregated multiple times in postlink. With a concept of; // distribution factor for pseudo probes, samples can be distributed among; // duplicated probes reasonable based on the assumption that optimizations; // duplicating code well-maintain the branch frequency information (BFI). This; // pass updates distribution factors for each pseudo probe at the end of the; // prelink pipeline, to reflect an estimated portion of the real execution; // count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:674,Deployability,update,updates,674,"// Pseudo probe distribution factor updater.; // Sample profile annotation can happen in both LTO prelink and postlink. The; // postlink-time re-annotation can degrade profile quality because of prelink; // code duplication transformation, such as loop unrolling, jump threading,; // indirect call promotion etc. As such, samples corresponding to a source; // location may be aggregated multiple times in postlink. With a concept of; // distribution factor for pseudo probes, samples can be distributed among; // duplicated probes reasonable based on the assumption that optimizations; // duplicating code well-maintain the branch frequency information (BFI). This; // pass updates distribution factors for each pseudo probe at the end of the; // prelink pipeline, to reflect an estimated portion of the real execution; // count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:755,Deployability,pipeline,pipeline,755,"// Pseudo probe distribution factor updater.; // Sample profile annotation can happen in both LTO prelink and postlink. The; // postlink-time re-annotation can degrade profile quality because of prelink; // code duplication transformation, such as loop unrolling, jump threading,; // indirect call promotion etc. As such, samples corresponding to a source; // location may be aggregated multiple times in postlink. With a concept of; // distribution factor for pseudo probes, samples can be distributed among; // duplicated probes reasonable based on the assumption that optimizations; // duplicating code well-maintain the branch frequency information (BFI). This; // pass updates distribution factors for each pseudo probe at the end of the; // prelink pipeline, to reflect an estimated portion of the real execution; // count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:571,Performance,optimiz,optimizations,571,"// Pseudo probe distribution factor updater.; // Sample profile annotation can happen in both LTO prelink and postlink. The; // postlink-time re-annotation can degrade profile quality because of prelink; // code duplication transformation, such as loop unrolling, jump threading,; // indirect call promotion etc. As such, samples corresponding to a source; // location may be aggregated multiple times in postlink. With a concept of; // distribution factor for pseudo probes, samples can be distributed among; // duplicated probes reasonable based on the assumption that optimizations; // duplicating code well-maintain the branch frequency information (BFI). This; // pass updates distribution factors for each pseudo probe at the end of the; // prelink pipeline, to reflect an estimated portion of the real execution; // count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h:54,Performance,perform,performed,54,"/// A set of parameters to control various transforms performed by IPSCCP pass.; /// Each of the boolean parameters can be set to:; /// true - enabling the transformation.; /// false - disabling the transformation.; /// Intended use is to create a default object, modify parameters with; /// additional setters and then pass it to IPSCCP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h:12,Performance,perform,perform,12,/// Pass to perform interprocedural constant propagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/StripDeadPrototypes.h:581,Availability,avail,available,581,"//===-- StripDeadPrototypes.h - Remove unused function declarations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions in the input module, looking for; // dead declarations and removes them. Dead declarations are declarations of; // functions for which no implementation is available (i.e., declarations for; // unused library functions).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/StripDeadPrototypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/StripDeadPrototypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:495,Testability,test,tested,495,"//===- WholeProgramDevirt.h - Whole-program devirt pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines parts of the whole-program devirtualization pass; // implementation that may be usefully unit tested.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:3,Performance,Cache,Cache,3,// Cache of the vtable's size in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:7,Testability,test,testing,7,// For testing only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:82,Security,access,accessed,82,// A pointer to the type identifier member through which the pointer to Fn is; // accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:137,Security,access,access-to-top,137,"// The minimum byte offset before the address point. This covers the bytes in; // the vtable object before the address point (e.g. RTTI, access-to-top,; // vtables for other base classes) and is equal to the offset from the start; // of the vtable object to the address point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:23,Energy Efficiency,allocate,allocated,23,// The number of bytes allocated (for the vtable plus the byte array) before; // the address point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:23,Energy Efficiency,allocate,allocated,23,// The number of bytes allocated (for the vtable plus the byte array) after; // the address point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:4,Performance,Perform,Perform,4,"/// Perform index-based whole program devirtualization on the \p Summary; /// index. Any devirtualized targets used by a type test in another module; /// are added to the \p ExportedGUIDs set. For any local devirtualized targets; /// only used within the defining module, the information necessary for; /// locating the corresponding WPD resolution is recorded for the ValueInfo; /// in case it is exported by cross module importing (in which case the; /// devirtualized target name will need adjustment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:126,Testability,test,test,126,"/// Perform index-based whole program devirtualization on the \p Summary; /// index. Any devirtualized targets used by a type test in another module; /// are added to the \p ExportedGUIDs set. For any local devirtualized targets; /// only used within the defining module, the information necessary for; /// locating the corresponding WPD resolution is recorded for the ValueInfo; /// in case it is exported by cross module importing (in which case the; /// devirtualized target name will need adjustment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:41,Deployability,update,update,41,/// Call after cross-module importing to update the recorded single impl; /// devirt target names for any locals that were exported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ADCE.h:406,Integrability,interface,interface,406,"//===- ADCE.h - Aggressive dead code elimination ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Aggressive Dead Code Elimination; // pass. This pass optimistically assumes that all instructions are dead until; // proven otherwise, allowing it to eliminate dead computations that other DCE; // passes do not catch, particularly involving loop computations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ADCE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ADCE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h:472,Performance,load,load,472,"//===---- AlignmentFromAssumptions.h ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h:655,Performance,load,loads,655,"//===---- AlignmentFromAssumptions.h ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1189,Energy Efficiency,reduce,reduce,1189,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1553,Performance,perform,perform,1553,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1656,Performance,optimiz,optimization,1656,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1810,Performance,load,load,1810,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:785,Usability,simpl,simple,785,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1730,Usability,simpl,simple,1730,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:37,Deployability,update,update,37,/// Add the user to the use list and update the cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DCE.h:406,Integrability,interface,interface,406,"//===- DCE.h - Dead code elimination ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Dead Code Elimination pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DCE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DCE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:479,Availability,redundant,redundant,479,"//===- DeadStoreElimination.h - Fast Dead Store Elimination -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a trivial dead store elimination that only considers; // basic-block local redundant stores.; //; // FIXME: This should eventually be extended to be a post-dominator tree; // traversal. Doing so would be pretty trivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:538,Modifiability,extend,extended,538,"//===- DeadStoreElimination.h - Fast Dead Store Elimination -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a trivial dead store elimination that only considers; // basic-block local redundant stores.; //; // FIXME: This should eventually be extended to be a post-dominator tree; // traversal. Doing so would be pretty trivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:479,Safety,redund,redundant,479,"//===- DeadStoreElimination.h - Fast Dead Store Elimination -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a trivial dead store elimination that only considers; // basic-block local redundant stores.; //; // FIXME: This should eventually be extended to be a post-dominator tree; // traversal. Doing so would be pretty trivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:86,Availability,redundant,redundant,86,/// This class implements a trivial dead store elimination. We consider; /// only the redundant stores that are local to a single Basic Block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:86,Safety,redund,redundant,86,/// This class implements a trivial dead store elimination. We consider; /// only the redundant stores that are local to a single Basic Block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DFAJumpThreading.h:406,Integrability,interface,interface,406,"//===- DFAJumpThreading.h - Threads a switch statement inside a loop ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the DFAJumpThreading pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DFAJumpThreading.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DFAJumpThreading.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:418,Integrability,interface,interface,418,"//===- EarlyCSE.h - Simple and fast CSE pass --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for a simple, fast CSE pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:20,Usability,Simpl,Simple,20,"//===- EarlyCSE.h - Simple and fast CSE pass --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for a simple, fast CSE pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:434,Usability,simpl,simple,434,"//===- EarlyCSE.h - Simple and fast CSE pass --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for a simple, fast CSE pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:149,Availability,redundant,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:149,Safety,redund,redundant,149,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:6,Usability,simpl,simple,6,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:73,Usability,simpl,simple,73,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h:404,Performance,optimiz,optimization,404,"//===- GuardWidening.h - ----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Guard widening is an optimization over the @llvm.experimental.guard intrinsic; // that (optimistically) combines multiple guards into one to have fewer checks; // at runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,Availability,redundant,redundant,25,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:491,Availability,redundant,redundant,491,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:414,Integrability,interface,interface,414,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:46,Performance,load,loads,46,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:562,Performance,load,load,562,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,Safety,redund,redundant,25,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:491,Safety,redund,redundant,491,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:76,Performance,perform,performed,76,"// end namespace gvn; /// A set of parameters to control various transforms performed by GVN pass.; // Each of the optional boolean parameters can be set to:; /// true - enabling the transformation.; /// false - disabling the transformation.; /// None - relying on a global default.; /// Intended use is to create a default object, modify parameters with; /// additional setters and then pass it to GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:31,Performance,load,loads,31,/// Enables or disables PRE of loads in GVN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:31,Performance,load,loads,31,/// Enables or disables PRE of loads in GVN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:89,Energy Efficiency,efficient,efficient,89,/// This class holds the mapping between values and value numbers. It is used; /// as an efficient mechanism to determine the expression-wise equivalence of; /// two values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:3,Performance,Cache,Cache,3,// Cache for phi-translate in scalarpre.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:185,Security,access,accessing,185,// This is set 'true' initially and also when new blocks have been added to; // the function being analyzed. This boolean is used to control the updating; // of BlockRPONumber prior to accessing the contents of BlockRPONumber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:23,Availability,redundant,redundant,23,// Helper functions of redundant load elimination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:33,Performance,load,load,33,// Helper functions of redundant load elimination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:23,Safety,redund,redundant,23,// Helper functions of redundant load elimination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:75,Availability,avail,available,75,/// Given a local dependency (Def or Clobber) determine if a value is; /// available for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:18,Integrability,depend,dependency,18,/// Given a local dependency (Def or Clobber) determine if a value is; /// available for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:93,Performance,load,load,93,/// Given a local dependency (Def or Clobber) determine if a value is; /// available for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:73,Availability,avail,available,73,"/// Given a list of non-local dependencies, determine if a value is; /// available for the load in each specified block. If it is, add it to; /// ValuesPerBlock. If not, add it to UnavailableBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:30,Integrability,depend,dependencies,30,"/// Given a list of non-local dependencies, determine if a value is; /// available for the load in each specified block. If it is, add it to; /// ValuesPerBlock. If not, add it to UnavailableBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:91,Performance,load,load,91,"/// Given a list of non-local dependencies, determine if a value is; /// available for the load in each specified block. If it is, add it to; /// ValuesPerBlock. If not, add it to UnavailableBlocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:39,Performance,Load,LoadBB,39,"/// Given a critical edge from Pred to LoadBB, find a load instruction; /// which is identical to Load from another successor of Pred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:54,Performance,load,load,54,"/// Given a critical edge from Pred to LoadBB, find a load instruction; /// which is identical to Load from another successor of Pred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:98,Performance,Load,Load,98,"/// Given a critical edge from Pred to LoadBB, find a load instruction; /// which is identical to Load from another successor of Pred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:21,Performance,load,load,21,/// Try to replace a load which executes on each loop iteraiton with Phi; /// translation of load in preheader and load(s) in conditionally executed; /// paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:93,Performance,load,load,93,/// Try to replace a load which executes on each loop iteraiton with Phi; /// translation of load in preheader and load(s) in conditionally executed; /// paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:115,Performance,load,load,115,/// Try to replace a load which executes on each loop iteraiton with Phi; /// translation of load in preheader and load(s) in conditionally executed; /// paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,Availability,redundant,redundant,25,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:70,Availability,Avail,AvailableLoads,70,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:38,Performance,Load,Load,38,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,Safety,redund,redundant,25,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:16,Integrability,rout,routines,16,// Other helper routines,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:47,Modifiability,parameteriz,parameterizing,47,/// Create a legacy GVN pass. This also allows parameterizing whether or not; /// MemDep is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:6,Usability,simpl,simple,6,/// A simple and fast domtree-based GVN pass to hoist common expressions; /// from sibling branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:48,Performance,load,load,48,// Compare the expression type for anything but load and store.; // For load and store we set the opcode to zero to make them equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:72,Performance,load,load,72,// Compare the expression type for anything but load and store.; // For load and store we set the opcode to zero to make them equal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:46,Security,hash,hash,46,"// It's theoretically possible for a thing to hash to zero. In that case,; // we will just compute the hash a few extra times, which is no worse that; // we did before, which was to compute it always.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:103,Security,hash,hash,103,"// It's theoretically possible for a thing to hash to zero. In that case,; // we will just compute the hash a few extra times, which is no worse that; // we did before, which was to compute it always.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:56,Security,hash,hash,56,// We deliberately leave the expression type out of the hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InductiveRangeCheckElimination.h:406,Integrability,interface,interface,406,"//===- InductiveRangeCheckElimination.h - IRCE ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Inductive Range Check Elimination; // loop pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InductiveRangeCheckElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InductiveRangeCheckElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:406,Integrability,interface,interface,406,"//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Induction Variable; // Simplification pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:36,Modifiability,Variab,Variable,36,"//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Induction Variable; // Simplification pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:434,Modifiability,Variab,Variable,434,"//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Induction Variable; // Simplification pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:45,Usability,Simpl,Simplification,45,"//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Induction Variable; // Simplification pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:447,Usability,Simpl,Simplification,447,"//===- IndVarSimplify.h - Induction Variable Simplification -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Induction Variable; // Simplification pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:4,Performance,Perform,Perform,4,/// Perform IV widening during the pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h:403,Performance,load,load,403,"//===- InferAlignment.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Infer alignment for load, stores and other memory operations based on; // trailing zero known bits information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:435,Usability,simpl,simplification,435,"//===- InstSimplifyPass.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Defines passes for running instruction simplification across chunks of IR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:502,Energy Efficiency,power,powerful,502,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:538,Performance,optimiz,optimization,538,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:403,Security,access,access,403,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:369,Testability,test,tests,369,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:20,Usability,simpl,simplification,20,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:98,Usability,simpl,simplification,98,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:296,Usability,simpl,simplification,296,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IVUsersPrinter.h:36,Modifiability,Variab,Variable,36,"//===- IVUsersPrinter.h - Induction Variable Users Printing -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IVUsersPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IVUsersPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h:46,Performance,perform,performs,46,"// end namespace jumpthreading; /// This pass performs 'jump threading', which looks at blocks that have; /// multiple predecessors and multiple successors. If one or more of the; /// predecessors of the block can be proven to always jump to one of the; /// successors, we forward the edge from the predecessor to the successor by; /// duplicating the contents of this block.; ///; /// An example of when this can occur is code like this:; ///; /// if () { ...; /// X = 4;; /// }; /// if (X < 3) {; ///; /// In this case, the unconditional branch at the end of the first if can be; /// revectored to the false side of the second if.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h:101,Performance,cache,cached,101,"/// Returns an existing instance of BPI if any, otherwise nullptr. By; /// ""existing"" we mean either cached result provided by FunctionAnalysisManger; /// or created by preceding call to 'getOrCreateBPI'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h:101,Performance,cache,cached,101,"/// Returns an existing instance of BFI if any, otherwise nullptr. By; /// ""existing"" we mean either cached result provided by FunctionAnalysisManger; /// or created by preceding call to 'getOrCreateBFI'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:1590,Modifiability,variab,variable,1590,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:383,Performance,perform,performs,383,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:749,Performance,load,loads,749,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:856,Performance,load,loads,856,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:917,Performance,load,load,917,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:1350,Performance,load,loads,1350,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:1514,Performance,load,loads,1514,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:613,Safety,safe,safe,613,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:4,Performance,Perform,Performs,4,/// Performs Loop Invariant Code Motion Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:4,Performance,Perform,Performs,4,/// Performs LoopNest Invariant Code Motion Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopBoundSplit.h:85,Modifiability,variab,variable,85,"/// This pass transforms loops that contain a conditional branch with induction; /// variable. For example, it transforms left code to right code:; ///; /// newbound = min(n, c); /// while (iv < n) { while(iv < newbound) {; /// A A; /// if (iv < c) B; /// B C; /// C }; /// if (iv != n) {; /// while (iv < n) {; /// A; /// C; /// }; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopBoundSplit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopBoundSplit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h:418,Integrability,interface,interface,418,"//===-------- LoopDataPrefetch.h - Loop Data Prefetching Pass ---*- C++ -*-===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Loop Data Prefetching Pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h:7,Performance,optimiz,optimization,7,/// An optimization pass inserting data prefetches in loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDeletion.h:406,Integrability,interface,interface,406,"//===- LoopDeletion.h - Loop Deletion ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Loop Deletion Pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDeletion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDeletion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h:507,Integrability,depend,dependence,507,"//===- LoopDistribute.cpp - Loop Distribution Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h:564,Integrability,depend,dependences,564,"//===- LoopDistribute.cpp - Loop Distribution Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop Distribution Pass. Its main focus is to; // distribute loops that cannot be vectorized due to dependence cycles. It; // tries to isolate the offending dependences into a new loop allowing; // vectorization of the remaining parts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDistribute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopFlatten.h:405,Integrability,interface,interface,405,"//===- LoopFlatten.h - Loop Flatten ---------------- -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Loop Flatten Pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopFlatten.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopFlatten.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h:536,Performance,perform,performance,536,"//===- LoopIdiomRecognize.h - Loop Idiom Recognize Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h:440,Usability,simpl,simple,440,"//===- LoopIdiomRecognize.h - Loop Idiom Recognize Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h:4,Performance,Perform,Performs,4,/// Performs Loop Idiom Recognize Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:393,Performance,perform,performs,393,"//===- LoopInstSimplify.h - Loop Inst Simplify Pass -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:38,Usability,Simpl,Simplify,38,"//===- LoopInstSimplify.h - Loop Inst Simplify Pass -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:426,Usability,simpl,simplification,426,"//===- LoopInstSimplify.h - Loop Inst Simplify Pass -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:4,Performance,Perform,Performs,4,/// Performs Loop Inst Simplify Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:23,Usability,Simpl,Simplify,23,/// Performs Loop Inst Simplify Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h:475,Performance,load,loaded,475,"//===- LoopLoadElimination.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This header defines the LoopLoadEliminationPass object. This pass forwards; /// loaded values around loop backedges to allow their use in subsequent; /// iterations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h:20,Performance,load,loads,20,/// Pass to forward loads in a loop around the backedge to subsequent; /// iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:762,Availability,avail,available,762,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:440,Deployability,pipeline,pipeline,440,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:519,Deployability,pipeline,pipeline,519,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1116,Deployability,pipeline,pipeline,1116,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1320,Energy Efficiency,reduce,reduce,1320,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1394,Performance,optimiz,optimizing,1394,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1423,Performance,optimiz,optimizing,1423,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:644,Usability,simpl,simplified,644,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1305,Usability,simpl,simplify,1305,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:30,Deployability,update,update,30,// Forward declarations of an update tracking API used in the pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:125,Availability,error,errors,125,"// FIXME: These are equivalent to the default move constructor/move; // assignment. However, using = default triggers linker errors due to the; // explicit instantiations below. Find a way to use the default and remove the; // duplicated code here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:160,Safety,detect,detection,160,// Specializations of `addPass` for `RepeatedPass`. These are necessary since; // `RepeatedPass` has a templated `run` method that will result in incorrect; // detection of `HasRunOnLoopT`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:247,Deployability,update,update,247,"/// This class provides an interface for updating the loop pass manager based; /// on mutations to the loop nest.; ///; /// A reference to an instance of this class is passed as an argument to each; /// Loop pass, and Loop passes should use it to update LPM infrastructure if; /// they modify the loop nest structure.; ///; /// \c LPMUpdater comes with two modes: the loop mode and the loop-nest mode. In; /// loop mode, all the loops in the function will be pushed into the worklist; /// and when new loops are added to the pipeline, their subloops are also; /// inserted recursively. On the other hand, in loop-nest mode, only top-level; /// loops are contained in the worklist and the addition of new (top-level); /// loops will not trigger the addition of their subloops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:525,Deployability,pipeline,pipeline,525,"/// This class provides an interface for updating the loop pass manager based; /// on mutations to the loop nest.; ///; /// A reference to an instance of this class is passed as an argument to each; /// Loop pass, and Loop passes should use it to update LPM infrastructure if; /// they modify the loop nest structure.; ///; /// \c LPMUpdater comes with two modes: the loop mode and the loop-nest mode. In; /// loop mode, all the loops in the function will be pushed into the worklist; /// and when new loops are added to the pipeline, their subloops are also; /// inserted recursively. On the other hand, in loop-nest mode, only top-level; /// loops are contained in the worklist and the addition of new (top-level); /// loops will not trigger the addition of their subloops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:27,Integrability,interface,interface,27,"/// This class provides an interface for updating the loop pass manager based; /// on mutations to the loop nest.; ///; /// A reference to an instance of this class is passed as an argument to each; /// Loop pass, and Loop passes should use it to update LPM infrastructure if; /// they modify the loop nest structure.; ///; /// \c LPMUpdater comes with two modes: the loop mode and the loop-nest mode. In; /// loop mode, all the loops in the function will be pushed into the worklist; /// and when new loops are added to the pipeline, their subloops are also; /// inserted recursively. On the other hand, in loop-nest mode, only top-level; /// loops are contained in the worklist and the addition of new (top-level); /// loops will not trigger the addition of their subloops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:145,Deployability,update,updates,145,"/// This can be queried by loop passes which run other loop passes (like pass; /// managers) to know whether the loop needs to be skipped due to updates to; /// the loop nest.; ///; /// If this returns true, the loop object may have been deleted, so passes; /// should take care not to touch the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:202,Integrability,rout,routine,202,"/// Loop passes should use this method to indicate they have deleted a loop; /// from the nest.; ///; /// Note that this loop must either be the current loop or a subloop of the; /// current loop. This routine must be called prior to removing the loop from; /// the loop nest.; ///; /// If this is called for the current loop, in addition to clearing any; /// state, this routine will mark that the current loop should be skipped by; /// the rest of the pass management infrastructure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:372,Integrability,rout,routine,372,"/// Loop passes should use this method to indicate they have deleted a loop; /// from the nest.; ///; /// Note that this loop must either be the current loop or a subloop of the; /// current loop. This routine must be called prior to removing the loop from; /// the loop nest.; ///; /// If this is called for the current loop, in addition to clearing any; /// state, this routine will mark that the current loop should be skipped by; /// the rest of the pass management infrastructure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:342,Usability,clear,clearing,342,"/// Loop passes should use this method to indicate they have deleted a loop; /// from the nest.; ///; /// Note that this loop must either be the current loop or a subloop of the; /// current loop. This routine must be called prior to removing the loop from; /// the loop nest.; ///; /// If this is called for the current loop, in addition to clearing any; /// state, this routine will mark that the current loop should be skipped by; /// the rest of the pass management infrastructure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:209,Deployability,pipeline,pipeline,209,/// Restart the current loop.; ///; /// Loop passes should call this method to indicate the current loop has been; /// sufficiently changed that it should be re-visited from the begining of; /// the loop pass pipeline rather than continuing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:32,Deployability,pipeline,pipeline,32,// Tell the currently in-flight pipeline to stop running.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:62,Testability,assert,asserts,62,// In debug builds we also track the parent loop to implement asserts even in; // the face of loop deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:520,Deployability,update,updater,520,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:4,Energy Efficiency,Adapt,Adaptor,4,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:430,Energy Efficiency,adapt,adaptor,430,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:573,Energy Efficiency,adapt,adaptor,573,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:4,Modifiability,Adapt,Adaptor,4,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:430,Modifiability,adapt,adaptor,430,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:573,Modifiability,adapt,adaptor,573,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:408,Safety,safe,safely,408,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:76,Energy Efficiency,adapt,adaptor,76,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:135,Energy Efficiency,adapt,adaptor,135,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:46,Integrability,wrap,wrap,46,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:76,Modifiability,adapt,adaptor,76,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:135,Modifiability,adapt,adaptor,135,"/// A function to deduce a loop pass type and wrap it in the templated; /// adaptor.; ///; /// If \p Pass is a loop pass, the returned adaptor will be in loop mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:114,Energy Efficiency,adapt,adaptor,114,"/// If \p Pass is a loop-nest pass, \p Pass will first be wrapped into a; /// \c LoopPassManager and the returned adaptor will be in loop-nest mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:58,Integrability,wrap,wrapped,58,"/// If \p Pass is a loop-nest pass, \p Pass will first be wrapped into a; /// \c LoopPassManager and the returned adaptor will be in loop-nest mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:114,Modifiability,adapt,adaptor,114,"/// If \p Pass is a loop-nest pass, \p Pass will first be wrapped into a; /// \c LoopPassManager and the returned adaptor will be in loop-nest mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:66,Energy Efficiency,adapt,adaptor,66,"/// If \p Pass is an instance of \c LoopPassManager, the returned adaptor will; /// be in loop-nest mode if the pass manager contains only loop-nest passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:66,Modifiability,adapt,adaptor,66,"/// If \p Pass is an instance of \c LoopPassManager, the returned adaptor will; /// be in loop-nest mode if the pass manager contains only loop-nest passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:70,Energy Efficiency,adapt,adaptor,70,"// Check if LPM contains any loop pass and if it does not, returns an adaptor; // in loop-nest mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:70,Modifiability,adapt,adaptor,70,"// Check if LPM contains any loop pass and if it does not, returns an adaptor; // in loop-nest mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h:4,Performance,Perform,Performs,4,/// Performs Loop Predication Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h:406,Integrability,interface,interface,406,"//===- LoopRotation.h - Loop Rotation -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Loop Rotation pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h:6,Usability,simpl,simple,6,/// A simple loop rotation transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopRotation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:614,Performance,perform,perform,614,"//===- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:38,Usability,Simpl,Simplification,38,"//===- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:413,Usability,Simpl,SimplifyCFG,413,"//===- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:4,Performance,Perform,Performs,4,/// Performs basic CFG simplifications to assist other loop passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:23,Usability,simpl,simplifications,23,/// Performs basic CFG simplifications to assist other loop passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:406,Integrability,interface,interface,406,"//===- LoopSink.h - Loop Sink Pass ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the Loop Sink pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:174,Deployability,pipeline,pipeline,174,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:312,Energy Efficiency,reduce,reduces,312,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:515,Performance,optimiz,optimization,515,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:29,Usability,guid,guided,29,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:595,Usability,simpl,simplify,595,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:797,Availability,avail,available,797,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:44,Energy Efficiency,Reduce,Reduce,44,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:516,Energy Efficiency,efficient,efficient,516,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:441,Modifiability,variab,variables,441,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:704,Modifiability,variab,variable,704,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:721,Modifiability,rewrite,rewrites,721,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:901,Modifiability,variab,variables,901,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:573,Performance,perform,performs,573,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:829,Performance,perform,performs,829,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:857,Performance,optimiz,optimizations,857,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:27,Energy Efficiency,Reduce,Reduce,27,/// Performs Loop Strength Reduce Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:4,Performance,Perform,Performs,4,/// Performs Loop Strength Reduce Pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h:6,Usability,simpl,simple,6,/// A simple loop rotation transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollAndJamPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h:59,Performance,perform,performed,59,"/// A set of parameters used to control various transforms performed by the; /// LoopUnroll pass. Each of the boolean parameters can be set to:; /// true - enabling the transformation.; /// false - disabling the transformation.; /// None - relying on a global default.; ///; /// There is also OptLevel parameter, which is used for additional loop unroll; /// tuning.; ///; /// Intended use is to create a default object, modify parameters with; /// additional setters and then pass it to LoopUnrollPass.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h:9,Performance,optimiz,optimization,9,"// Sets ""optimization level"" tuning parameter for loop unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h:107,Security,access,access,107,/// Loop unroll pass that will support both full and partial unrolling.; /// It is a function pass to have access to function and module analyses.; /// It will also put loops into canonical form (simplified and LCSSA).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h:196,Usability,simpl,simplified,196,/// Loop unroll pass that will support both full and partial unrolling.; /// It is a function pass to have access to function and module analyses.; /// It will also put loops into canonical form (simplified and LCSSA).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h:424,Performance,optimiz,optimized,424,"/// Run the pass over the function.; ///; /// This will lower all remaining 'objectsize' and 'is.constant'`; /// intrinsic calls in this function, even when the argument has no known; /// size or is not a constant respectively. The resulting constant is; /// propagated and conditional branches are resolved where possible.; /// This complements the Instruction Simplification and; /// Instruction Combination passes of the optimized pass chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h:362,Usability,Simpl,Simplification,362,"/// Run the pass over the function.; ///; /// This will lower all remaining 'objectsize' and 'is.constant'`; /// intrinsic calls in this function, even when the argument has no known; /// size or is not a constant respectively. The resulting constant is; /// propagated and conditional branches are resolved where possible.; /// This complements the Instruction Simplification and; /// Instruction Combination passes of the optimized pass chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h:340,Performance,optimiz,optimizer,340,"/// Run the pass over the function.; ///; /// This will lower all of the expect intrinsic calls in this function into; /// branch weight metadata. That metadata will subsequently feed the analysis; /// of the probabilities and frequencies of the CFG. After running this pass,; /// no more expect intrinsics remain, allowing the rest of the optimizer to; /// ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h:418,Availability,down,down,418,"//===- LowerMatrixIntrinsics.h - Lower matrix intrinsics. -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers matrix intrinsics down to vector operations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerMatrixIntrinsics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h:34,Performance,optimiz,optimization,34,"//===- MemCpyOptimizer.h - memcpy optimization ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h:393,Performance,perform,performs,393,"//===- MemCpyOptimizer.h - memcpy optimization ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:54,Performance,load,load,54,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:405,Performance,perform,performs,405,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:424,Performance,load,loads,424,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:497,Performance,load,loads,497,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:570,Performance,load,loads,570,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:657,Performance,load,load,657,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:860,Performance,load,load,860,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:950,Performance,optimiz,optimization,950,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:985,Performance,load,load,985,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:930,Safety,safe,safe,930,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1523,Energy Efficiency,efficient,efficiently,1523,"// }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1947,Modifiability,rewrite,rewrites,1947," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1993,Modifiability,rewrite,rewrites,1993," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:2978,Modifiability,extend,extended,2978,"eassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and muls for now. This should be extended; // and generalized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:447,Safety,redund,redundancy,447,"//===- NaryReassociate.h - Reassociate n-ary expressions --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1177,Safety,detect,detects,1177,"th LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations befo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:1496,Safety,redund,redundancy,1496," exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:462,Security,expose,exposed,462,"//===- NaryReassociate.h - Reassociate n-ary expressions --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:675,Usability,simpl,simplify,675,"//===- NaryReassociate.h - Reassociate n-ary expressions --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:114,Modifiability,rewrite,rewrite,114,"// Given GEP's I-th index = LHS + RHS, see whether &Base[..][LHS][..] or; // &Base[..][RHS][..] can be CSE'ed and rewrite GEP accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:3,Modifiability,Rewrite,Rewrites,3,// Rewrites I to (LHS op RHS) if LHS is computed already.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:37,Modifiability,extend,extends,37,"// GetElementPtrInst implicitly sign-extends an index if the index is shorter; // than the pointer size. This function returns whether Index is shorter than; // GEP's pointer size, i.e., whether Index needs to be sign-extended in order; // to be an index of GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h:218,Modifiability,extend,extended,218,"// GetElementPtrInst implicitly sign-extends an index if the index is shorter; // than the pointer size. This function returns whether Index is shorter than; // GEP's pointer size, i.e., whether Index needs to be sign-extended in order; // to be an index of GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NaryReassociate.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NewGVN.h:418,Integrability,interface,interface,418,"//===- NewGVN.h - Global Value Numbering Pass -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NewGVN.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/NewGVN.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2741,Deployability,Patch,Patches,2741,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:946,Integrability,wrap,wrapped,946,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1133,Integrability,rout,routine,1133,"art of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1224,Integrability,rout,routine,1224,"tion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:502,Modifiability,variab,variable,502,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:549,Modifiability,Rewrite,RewriteStatepointsForGC,549,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:785,Modifiability,Rewrite,RewriteStatepointsForGC,785,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1866,Performance,optimiz,optimizer,1866,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1939,Performance,optimiz,optimization,1939,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:36,Safety,Safe,Safepoints,36,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:408,Safety,safe,safepoints,408,"//===- PlaceSafepoints.h - Place GC Safepoints ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1652,Safety,avoid,avoid,1652,"he call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1914,Safety,avoid,avoid,1914,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2279,Safety,safe,safepoints,2279,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2335,Safety,safe,safepoint,2335,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2405,Safety,safe,safepoint,2405,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2431,Safety,safe,safepoint,2431,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2491,Safety,safe,safepoint,2491,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:2675,Safety,safe,safepoints,2675,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h:1279,Testability,log,logic,1279,"-------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/PlaceSafepoints.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Reg2Mem.h:406,Integrability,interface,interface,406,"//===- Reg2Mem.h - Convert registers to allocas -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the interface for the RegToMem Pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Reg2Mem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Reg2Mem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:402,Integrability,interface,interface,402,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:7,Modifiability,Rewrite,RewriteStatepointsForGC,7,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:416,Modifiability,Rewrite,Rewrite,416,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:469,Modifiability,rewrite,rewrites,469,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:543,Performance,perform,performed,543,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h:58,Availability,mask,masked,58,"//===- ScalarizeMaskedMemIntrin.h - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h:415,Availability,mask,masked,415,"//===- ScalarizeMaskedMemIntrin.h - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h:571,Availability,mask,mask,571,"//===- ScalarizeMaskedMemIntrin.h - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ScalarizeMaskedMemIntrin.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h:534,Performance,optimiz,optimization,534,"//===- Scalarizer.h --- Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass converts vector operations into scalar operations (or, optionally,; /// operations on smaller vector widths), in order to expose optimization; /// opportunities on the individual scalar operations.; /// It is mainly intended for targets that do not have vector units, but it; /// may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h:527,Security,expose,expose,527,"//===- Scalarizer.h --- Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass converts vector operations into scalar operations (or, optionally,; /// operations on smaller vector widths), in order to expose optimization; /// opportunities on the individual scalar operations.; /// It is mainly intended for targets that do not have vector units, but it; /// may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h:14,Performance,perform,performs,14,/// This pass performs function-level constant propagation and merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h:7,Usability,Simpl,SimpleLoopUnswitch,7,"//===- SimpleLoopUnswitch.h - Hoist loop-invariant control flow -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h:1160,Usability,simpl,simplified,1160,"that contain branches or switches on loop-; /// invariant conditions to have multiple loops. For example, it turns the left; /// into the right code:; ///; /// for (...) if (lic); /// A for (...); /// if (lic) A; B; C; /// B else; /// C for (...); /// A; C; ///; /// This can increase the size of the code exponentially (doubling it every time; /// a loop is unswitched) so we only unswitch if the resultant code will be; /// smaller than a threshold.; ///; /// This pass expects LICM to be run before it to hoist invariant conditions out; /// of the loop, to make the unswitching opportunity obvious.; ///; /// There is a taxonomy of unswitching that we use to classify different forms; /// of this transformaiton:; ///; /// - Trival unswitching: this is when the condition can be unswitched without; /// cloning any code from inside the loop. A non-trivial unswitch requires; /// code duplication.; ///; /// - Full unswitching: this is when the branch or switch is completely moved; /// from inside the loop to outside the loop. Partial unswitching removes the; /// branch from the clone of the loop but must leave a (somewhat simplified); /// branch in the original loop. While theoretically partial unswitching can; /// be done for switches, the requirements are extreme - we need the loop; /// invariant input to the switch to be sufficient to collapse to a single; /// successor in each clone.; ///; /// This pass always does trivial, full unswitching for both branches and; /// switches. For branches, it also always does trivial, partial unswitching.; ///; /// If enabled (via the constructor's `NonTrivial` parameter), this pass will; /// additionally do non-trivial, full unswitching for branches and switches, and; /// will do non-trivial, partial unswitching for branches.; ///; /// Because partial unswitching of switches is extremely unlikely to be possible; /// in practice and significantly complicates the implementation, this pass does; /// not currently implement that in any mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimpleLoopUnswitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:414,Integrability,interface,interface,414,"//===- SimplifyCFG.h - Simplify and canonicalize the CFG --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for the pass responsible for both; /// simplifying and canonicalizing the CFG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:7,Usability,Simpl,SimplifyCFG,7,"//===- SimplifyCFG.h - Simplify and canonicalize the CFG --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for the pass responsible for both; /// simplifying and canonicalizing the CFG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:23,Usability,Simpl,Simplify,23,"//===- SimplifyCFG.h - Simplify and canonicalize the CFG --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for the pass responsible for both; /// simplifying and canonicalizing the CFG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:463,Usability,simpl,simplifying,463,"//===- SimplifyCFG.h - Simplify and canonicalize the CFG --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for the pass responsible for both; /// simplifying and canonicalizing the CFG.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:273,Integrability,Depend,Depending,273,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:262,Performance,optimiz,optimizer,262,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:329,Performance,optimiz,optimize,329,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:14,Usability,simpl,simplify,14,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:95,Usability,simpl,simplifies,95,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:181,Performance,perform,performance,181,"/// The default constructor sets the pass options to create canonical IR,; /// rather than optimal IR. That is, by default we bypass transformations that; /// are likely to improve performance but make analysis for other passes more; /// difficult.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:35,Performance,optimiz,optimizations,35,/// Construct a pass with optional optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:2123,Deployability,pipeline,pipeline,2123,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:972,Performance,optimiz,optimized,972,"//===- SpeculativeExecution.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:1153,Performance,optimiz,optimization,1153,"//===- SpeculativeExecution.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:539,Usability,simpl,simple,539,"//===- SpeculativeExecution.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:1251,Usability,Simpl,SimplifyCFG,1251,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===---------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:1264,Usability,Simpl,SimplifyCFG,1264,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:1546,Usability,Simpl,SimplifyCFG,1546,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h:414,Integrability,interface,interface,414,"//===- SROA.h - Scalar Replacement Of Aggregates ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Scalar Replacement of; /// Aggregates pass. This pass provides both aggregate splitting and the; /// primary SSA formation used in the compiler.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h:107,Deployability,update,update,107,"/// If \p PreserveCFG is set, then the pass is not allowed to modify CFG; /// in any way, even if it would update CFG analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SROA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1098,Energy Efficiency,efficient,efficient,1098,"//===---- TailRecursionElimination.h ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1012,Modifiability,variab,variable,1012,"//===---- TailRecursionElimination.h ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1128,Performance,perform,performed,1128,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2136,Performance,perform,performed,2136,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2664,Performance,perform,performed,2664,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1957,Safety,Safe,Safely,1957,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2578,Safety,safe,safe,2578,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2767,Safety,detect,detect,2767,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:1574,Security,access,access,1574,"c; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2785,Security,access,access,2785,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h:2725,Testability,benchmark,benchmark,2725,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TailRecursionElimination.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:39,Availability,Redundant,Redundant,39,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:415,Availability,Redundant,Redundant,415,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:631,Availability,Redundant,Redundant,631,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:1166,Availability,Redundant,Redundant,1166,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:53,Performance,Load,Loads,53,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:429,Performance,Load,Loads,429,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:645,Performance,Load,Loads,645,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:1180,Performance,Load,Loads,1180,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:1200,Performance,perform,performance,1200,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:39,Safety,Redund,Redundant,39,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:415,Safety,Redund,Redundant,415,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:631,Safety,Redund,Redundant,631,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:1166,Safety,Redund,Redundant,1166,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:1462,Testability,test,testl,1462,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:37,Modifiability,variab,variable,37,/// Keeps track of the user of a TLS variable and the operand index; /// where the variable is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:83,Modifiability,variab,variable,83,/// Keeps track of the user of a TLS variable and the operand index; /// where the variable is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:25,Modifiability,variab,variable,25,/// Keeps track of a TLS variable candidate and its users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:37,Deployability,update,update,37,/// Add the user to the use list and update the cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:23,Modifiability,variab,variable,23,/// Keeps track of TLS variable candidates found in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h:442,Performance,perform,performed,442,"//===- WarnMissedTransforms.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Emit warnings if forced code transformations have not been performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:15,Modifiability,variab,variable,15,// Name of the variable that will be displayed by asan; // if a stack-related bug is reported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:15,Modifiability,variab,variable,15,// Size of the variable in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:30,Energy Efficiency,power,power,30,// Alignment of the variable (power of 2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:20,Modifiability,variab,variable,20,// Alignment of the variable (power of 2).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:22,Modifiability,variab,variables,22,// The array of stack variables. The elements may get reordered and changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:85,Energy Efficiency,power,power,85,"// The minimal size of the left-most redzone (header).; // At least 4 pointer sizes, power of 2, and >= Granularity.; // The resulting FrameSize should be multiple of MinHeaderSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:118,Modifiability,variab,variables,118,// Returns shadow bytes with marked red zones. This shadow represents the state; // if the stack frame when all local variables are inside of the own scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:134,Modifiability,variab,variables,134,// Returns shadow bytes with marked red zones and after scope. This shadow; // represents the state if the stack frame when all local variables are outside; // of the own scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h:22,Modifiability,variab,variables,22,// The array of stack variables. The elements may get reordered and changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ASanStackFrameLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:464,Performance,perform,performing,464,"//===- AssumeBundleBuilder.h - utils to build assume bundles ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contain tools to preserve informations. They should be used before; // performing a transformation that may move and delete instructions as those; // transformation may destroy or worsen information that can be derived from the; // IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:247,Availability,avail,available,247,/// Calls BuildAssumeFromInst and if the resulting llvm.assume is valid insert; /// if before I. This is usually what need to be done to salvage the knowledge; /// contained in the instruction I.; /// The AssumptionCache must be provided if it is available or the cache may; /// become silently be invalid.; /// The DominatorTree can optionally be provided to enable cross-block; /// reasoning.; /// This returns if a change was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:264,Performance,cache,cache,264,/// Calls BuildAssumeFromInst and if the resulting llvm.assume is valid insert; /// if before I. This is usually what need to be done to salvage the knowledge; /// contained in the instruction I.; /// The AssumptionCache must be provided if it is available or the cache may; /// become silently be invalid.; /// The DominatorTree can optionally be provided to enable cross-block; /// reasoning.; /// This returns if a change was made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:115,Availability,redundant,redundant,115,/// Build and return a new assume created from the provided knowledge; /// if the knowledge in the assume is fully redundant this will return nullptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:115,Safety,redund,redundant,115,/// Build and return a new assume created from the provided knowledge; /// if the knowledge in the assume is fully redundant this will return nullptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:111,Testability,test,testing,111,/// This pass will try to build an llvm.assume for every instruction in the; /// function. Its main purpose is testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:408,Performance,perform,perform,408,"//===- Transform/Utils/BasicBlockUtils.h - BasicBlock Utils -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on basic blocks, and; // instructions contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:94,Deployability,Update,Updates,94,"/// Replace contents of every block in \p BBs with single unreachable; /// instruction. If \p Updates is specified, collect all necessary DT updates; /// into this vector. If \p KeepOneInputPHIs is true, one-input Phis in; /// successors of blocks being deleted will be preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:141,Deployability,update,updates,141,"/// Replace contents of every block in \p BBs with single unreachable; /// instruction. If \p Updates is specified, collect all necessary DT updates; /// into this vector. If \p KeepOneInputPHIs is true, one-input Phis in; /// successors of blocks being deleted will be preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:258,Deployability,update,updates,258,"/// Delete the specified blocks from \p BB. The set of deleted blocks must have; /// no predecessors that are not being deleted themselves. \p BBs must have no; /// duplicating blocks. If there are loops among this set of blocks, all; /// relevant loop info updates should be done before this function is called.; /// If \p KeepOneInputPHIs is true, one-input Phis in successors of blocks; /// being deleted will be preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:108,Availability,failure,failure,108,"/// Attempts to merge a block into its predecessor, if possible. The return; /// value indicates success or failure.; /// By default do not merge blocks if BB's predecessor has multiple successors.; /// If PredecessorWithTwoSuccessors = true, the blocks can only be merged; /// if BB's Pred has a branch to BB and to AnotherBB, and BB has a single; /// successor Sing. In this case the branch will be updated with Sing instead of; /// BB, and BB will still be merged into its predecessor and removed.; /// If \p DT is not nullptr, update it directly; in that case, DTU must be; /// nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:401,Deployability,update,updated,401,"/// Attempts to merge a block into its predecessor, if possible. The return; /// value indicates success or failure.; /// By default do not merge blocks if BB's predecessor has multiple successors.; /// If PredecessorWithTwoSuccessors = true, the blocks can only be merged; /// if BB's Pred has a branch to BB and to AnotherBB, and BB has a single; /// successor Sing. In this case the branch will be updated with Sing instead of; /// BB, and BB will still be merged into its predecessor and removed.; /// If \p DT is not nullptr, update it directly; in that case, DTU must be; /// nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:531,Deployability,update,update,531,"/// Attempts to merge a block into its predecessor, if possible. The return; /// value indicates success or failure.; /// By default do not merge blocks if BB's predecessor has multiple successors.; /// If PredecessorWithTwoSuccessors = true, the blocks can only be merged; /// if BB's Pred has a branch to BB and to AnotherBB, and BB has a single; /// successor Sing. In this case the branch will be updated with Sing instead of; /// BB, and BB will still be merged into its predecessor and removed.; /// If \p DT is not nullptr, update it directly; in that case, DTU must be; /// nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:18,Availability,redundant,redundant,18,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:141,Availability,redundant,redundant,141,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:18,Safety,redund,redundant,18,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:141,Safety,redund,redundant,141,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:205,Deployability,update,updated,205,"/// Replace the instruction specified by BI with the instruction specified by I.; /// Copies DebugLoc from BI to I, if I doesn't already have a DebugLoc. The; /// original instruction is deleted and BI is updated to point to the new; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:80,Integrability,interface,interface,80,/// Option class for critical edge splitting.; ///; /// This provides a builder interface for overriding the default options used; /// during critical edge splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:53,Usability,simpl,simplify,53,"/// SplitCriticalEdge is guaranteed to preserve loop-simplify form if LI is; /// provided. If it cannot be preserved, no splitting will take place. If it; /// is not set, preserve loop-simplify form if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:185,Usability,simpl,simplify,185,"/// SplitCriticalEdge is guaranteed to preserve loop-simplify form if LI is; /// provided. If it cannot be preserved, no splitting will take place. If it; /// is not set, preserve loop-simplify form if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:98,Deployability,update,update,98,"/// If this edge is a critical edge, insert a new node to split the critical; /// edge. This will update the analyses passed in through the option struct.; /// This returns the new block if the edge was split, null otherwise.; ///; /// If MergeIdenticalEdges in the options struct is true (not the default),; /// *all* edges from TI to the specified successor will be merged into the same; /// critical edge block. This is most commonly interesting with switch; /// instructions, which may have many edges to any one destination. This; /// ensures that all edges to that dest go to one block instead of each going; /// to a different block, but isn't the standard definition of a ""critical; /// edge"".; ///; /// It is invalid to call this function on a critical edge that starts at an; /// IndirectBrInst. Splitting these edges will almost always create an invalid; /// program because the address of the new block won't be the one that is jumped; /// to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:180,Deployability,update,updates,180,"/// If an edge from Src to Dst is critical, split the edge and return true,; /// otherwise return false. This method requires that there be an edge between; /// the two blocks. It updates the analyses passed in the options struct",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:564,Deployability,update,updates,564,"/// This method introduces at least one new basic block into the function and; /// moves some of the predecessors of BB to be predecessors of the new block.; /// The new predecessors are indicated by the Preds array. The new block is; /// given a suffix of 'Suffix'. Returns new basic block to which predecessors; /// from Preds are now pointing.; ///; /// If BB is a landingpad block then additional basicblock might be introduced.; /// It will have Suffix+"".split_lp"". See SplitLandingPadPredecessors for more; /// details on this case.; ///; /// This currently updates the LLVM IR, DominatorTree, LoopInfo, and LCCSA but; /// no other analyses. In particular, it does not preserve LoopSimplify; /// (because it's complicated to handle the case where one of the edges being; /// split is an exit of a loop with other exits).; ///; /// FIXME: deprecated, switch to the DomTreeUpdater-based one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:564,Deployability,update,updates,564,"/// This method introduces at least one new basic block into the function and; /// moves some of the predecessors of BB to be predecessors of the new block.; /// The new predecessors are indicated by the Preds array. The new block is; /// given a suffix of 'Suffix'. Returns new basic block to which predecessors; /// from Preds are now pointing.; ///; /// If BB is a landingpad block then additional basicblock might be introduced.; /// It will have Suffix+"".split_lp"". See SplitLandingPadPredecessors for more; /// details on this case.; ///; /// This currently updates the LLVM IR, DominatorTree, LoopInfo, and LCCSA but; /// no other analyses. In particular, it does not preserve LoopSimplify; /// (because it's complicated to handle the case where one of the edges being; /// split is an exit of a loop with other exits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:471,Deployability,update,updates,471,"/// This method transforms the landing pad, OrigBB, by introducing two new basic; /// blocks into the function. One of those new basic blocks gets the; /// predecessors listed in Preds. The other basic block gets the remaining; /// predecessors of OrigBB. The landingpad instruction OrigBB is clone into both; /// of the new basic blocks. The new blocks are given the suffixes 'Suffix1' and; /// 'Suffix2', and are returned in the NewBBs vector.; ///; /// This currently updates the LLVM IR, DominatorTree, LoopInfo, and LCCSA but; /// no other analyses. In particular, it does not preserve LoopSimplify; /// (because it's complicated to handle the case where one of the edges being; /// split is an exit of a loop with other exits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:687,Deployability,Update,Updates,687,"/// Split the containing block at the specified instruction - everything before; /// SplitBefore stays in the old basic block, and the rest of the instructions; /// in the BB are moved to a new block. The two blocks are connected by a; /// conditional branch (with value of Cmp being the condition).; /// Before:; /// Head; /// SplitBefore; /// Tail; /// After:; /// Head; /// if (Cond); /// ThenBlock; /// SplitBefore; /// Tail; ///; /// If \p ThenBlock is not specified, a new block will be created for it.; /// If \p Unreachable is true, the newly created block will end with; /// UnreachableInst, otherwise it branches to Tail.; /// Returns the NewBasicBlock's terminator.; ///; /// Updates DTU and LI if given.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:276,Deployability,Update,Updates,276,"/// SplitBlockAndInsertIfThenElse is similar to SplitBlockAndInsertIfThen,; /// but also creates the ElseBlock.; /// Before:; /// Head; /// SplitBefore; /// Tail; /// After:; /// Head; /// if (Cond); /// ThenBlock; /// else; /// ElseBlock; /// SplitBefore; /// Tail; ///; /// Updates DT if given.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:1125,Deployability,Update,Updates,1125,"/// Split the containing block at the specified instruction - everything before; /// SplitBefore stays in the old basic block, and the rest of the instructions; /// in the BB are moved to a new block. The two blocks are connected by a; /// conditional branch (with value of Cmp being the condition).; /// Before:; /// Head; /// SplitBefore; /// Tail; /// After:; /// Head; /// if (Cond); /// TrueBlock; /// else; //// FalseBlock; /// SplitBefore; /// Tail; ///; /// If \p ThenBlock is null, the resulting CFG won't contain the TrueBlock. If; /// \p ThenBlock is non-null and points to non-null BasicBlock pointer, that; /// block will be inserted as the TrueBlock. Otherwise a new block will be; /// created. Likewise for the \p ElseBlock parameter.; /// If \p UnreachableThen or \p UnreachableElse is true, the corresponding newly; /// created blocks will end with UnreachableInst, otherwise with branches to; /// Tail. The function will not modify existing basic blocks passed to it. The; /// caller must ensure that Tail is reachable from Head.; /// Returns the newly created blocks in \p ThenBlock and \p ElseBlock.; /// Updates DTU and LI if given.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:254,Modifiability,variab,variable,254,"/// Insert a for (int i = 0; i < End; i++) loop structure (with the exception; /// that \p End is assumed > 0, and thus not checked on entry) at \p; /// SplitBefore. Returns the first insert point in the loop body, and the; /// PHINode for the induction variable (i.e. ""i"" above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:267,Integrability,contract,contract,267,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:284,Integrability,rout,routine,284,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:25,Performance,perform,performing,25,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:192,Performance,scalab,scalable,192,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:512,Security,access,access,512,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:105,Usability,simpl,simplify,105,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:296,Integrability,contract,contract,296,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:318,Integrability,rout,routine,318,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:25,Performance,perform,performing,25,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:221,Performance,scalab,scalable,221,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:541,Security,access,access,541,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:134,Usability,simpl,simplify,134,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:523,Deployability,update,update,523,"// Split critical edges where the source of the edge is an indirectbr; // instruction. This isn't always possible, but we can handle some easy cases.; // This is useful because MI is unable to split such critical edges,; // which means it will not be able to sink instructions along those edges.; // This is especially painful for indirect branches with many successors, where; // we end up having to prepare all outgoing values in the origin block.; //; // Our normal algorithm for splitting critical edges requires us to update; // the outgoing edges of the edge origin block, but for an indirectbr this; // is hard, since it would require finding and updating the block addresses; // the indirect branch uses. But if a block only has a single indirectbr; // predecessor, with the others being regular branches, we can do it in a; // different way.; // Say we have A -> D, B -> D, I -> D where only I -> D is an indirectbr.; // We can split D into D0 and D1, where D0 contains only the PHIs from D,; // and D1 is the D block body. We can then duplicate D0 as D0A and D0B, and; // create the following structure:; // A -> D0A, B -> D0A, I -> D0B, D0A -> D1, D0B -> D1; // If BPI and BFI aren't non-null, BPI/BFI will be updated accordingly.; // When `IgnoreBlocksWithoutPHI` is set to `true` critical edges leading to a; // block without phi-instructions will not be split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:1221,Deployability,update,updated,1221,"// Split critical edges where the source of the edge is an indirectbr; // instruction. This isn't always possible, but we can handle some easy cases.; // This is useful because MI is unable to split such critical edges,; // which means it will not be able to sink instructions along those edges.; // This is especially painful for indirect branches with many successors, where; // we end up having to prepare all outgoing values in the origin block.; //; // Our normal algorithm for splitting critical edges requires us to update; // the outgoing edges of the edge origin block, but for an indirectbr this; // is hard, since it would require finding and updating the block addresses; // the indirect branch uses. But if a block only has a single indirectbr; // predecessor, with the others being regular branches, we can do it in a; // different way.; // Say we have A -> D, B -> D, I -> D where only I -> D is an indirectbr.; // We can split D into D0 and D1, where D0 contains only the PHIs from D,; // and D1 is the D block body. We can then duplicate D0 as D0A and D0B, and; // create the following structure:; // A -> D0A, B -> D0A, I -> D0B, D0A -> D1, D0B -> D1; // If BPI and BFI aren't non-null, BPI/BFI will be updated accordingly.; // When `IgnoreBlocksWithoutPHI` is set to `true` critical edges leading to a; // block without phi-instructions will not be split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:610,Deployability,update,updates,610,"/// Given a set of incoming and outgoing blocks, create a ""hub"" such that every; /// edge from an incoming block InBB to an outgoing block OutBB is now split; /// into two edges, one from InBB to the hub and another from the hub to; /// OutBB. The hub consists of a series of guard blocks, one for each outgoing; /// block. Each guard block conditionally branches to the corresponding outgoing; /// block, or the next guard block in the chain. These guard blocks are returned; /// in the argument vector.; ///; /// Since the control flow edges from InBB to OutBB have now been replaced, the; /// function also updates any PHINodes in OutBB. For each such PHINode, the; /// operands corresponding to incoming blocks are moved to a new PHINode in the; /// hub, and the hub is made an operand of the original PHINode.; ///; /// Input CFG:; /// ----------; ///; /// Def; /// |; /// v; /// In1 In2; /// | |; /// | |; /// v v; /// Foo ---> Out1 Out2; /// |; /// v; /// Use; ///; ///; /// Create hub: Incoming = {In1, In2}, Outgoing = {Out1, Out2}; /// ----------------------------------------------------------; ///; /// Def; /// |; /// v; /// In1 In2 Foo; /// | Hub | |; /// | + - - | - - + |; /// | ' v ' V; /// +------> Guard1 -----> Out1; /// ' | '; /// ' v '; /// ' Guard2 -----> Out2; /// ' ' |; /// + - - - - - + |; /// v; /// Use; ///; /// Limitations:; /// -----------; /// 1. This assumes that all terminators in the CFG are direct branches (the; /// ""br"" instruction). The presence of any other control flow such as; /// indirectbr, switch or callbr will cause an assert.; ///; /// 2. The updates to the PHINodes are not sufficient to restore SSA; /// form. Consider a definition Def, its use Use, incoming block In2 and; /// outgoing block Out2, such that:; /// a. In2 is reachable from D or contains D.; /// b. U is reachable from Out2 or is contained in Out2.; /// c. U is not a PHINode if U is contained in Out2.; ///; /// Clearly, Def dominates Out2 since the program is valid SSA. But when ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:1594,Deployability,update,updates,1594," the control flow edges from InBB to OutBB have now been replaced, the; /// function also updates any PHINodes in OutBB. For each such PHINode, the; /// operands corresponding to incoming blocks are moved to a new PHINode in the; /// hub, and the hub is made an operand of the original PHINode.; ///; /// Input CFG:; /// ----------; ///; /// Def; /// |; /// v; /// In1 In2; /// | |; /// | |; /// v v; /// Foo ---> Out1 Out2; /// |; /// v; /// Use; ///; ///; /// Create hub: Incoming = {In1, In2}, Outgoing = {Out1, Out2}; /// ----------------------------------------------------------; ///; /// Def; /// |; /// v; /// In1 In2 Foo; /// | Hub | |; /// | + - - | - - + |; /// | ' v ' V; /// +------> Guard1 -----> Out1; /// ' | '; /// ' v '; /// ' Guard2 -----> Out2; /// ' ' |; /// + - - - - - + |; /// v; /// Use; ///; /// Limitations:; /// -----------; /// 1. This assumes that all terminators in the CFG are direct branches (the; /// ""br"" instruction). The presence of any other control flow such as; /// indirectbr, switch or callbr will cause an assert.; ///; /// 2. The updates to the PHINodes are not sufficient to restore SSA; /// form. Consider a definition Def, its use Use, incoming block In2 and; /// outgoing block Out2, such that:; /// a. In2 is reachable from D or contains D.; /// b. U is reachable from Out2 or is contained in Out2.; /// c. U is not a PHINode if U is contained in Out2.; ///; /// Clearly, Def dominates Out2 since the program is valid SSA. But when the; /// hub is introduced, there is a new path through the hub along which Use is; /// reachable from entry without passing through Def, and SSA is no longer; /// valid. To fix this, we need to look at all the blocks post-dominated by; /// the hub on the one hand, and dominated by Out2 on the other. This is left; /// for the caller to accomplish, since each specific use of this function; /// may have additional information which simplifies this fixup. For example,; /// see restoreSSA() in the UnifyLoopExits pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:1569,Testability,assert,assert,1569," the control flow edges from InBB to OutBB have now been replaced, the; /// function also updates any PHINodes in OutBB. For each such PHINode, the; /// operands corresponding to incoming blocks are moved to a new PHINode in the; /// hub, and the hub is made an operand of the original PHINode.; ///; /// Input CFG:; /// ----------; ///; /// Def; /// |; /// v; /// In1 In2; /// | |; /// | |; /// v v; /// Foo ---> Out1 Out2; /// |; /// v; /// Use; ///; ///; /// Create hub: Incoming = {In1, In2}, Outgoing = {Out1, Out2}; /// ----------------------------------------------------------; ///; /// Def; /// |; /// v; /// In1 In2 Foo; /// | Hub | |; /// | + - - | - - + |; /// | ' v ' V; /// +------> Guard1 -----> Out1; /// ' | '; /// ' v '; /// ' Guard2 -----> Out2; /// ' ' |; /// + - - - - - + |; /// v; /// Use; ///; /// Limitations:; /// -----------; /// 1. This assumes that all terminators in the CFG are direct branches (the; /// ""br"" instruction). The presence of any other control flow such as; /// indirectbr, switch or callbr will cause an assert.; ///; /// 2. The updates to the PHINodes are not sufficient to restore SSA; /// form. Consider a definition Def, its use Use, incoming block In2 and; /// outgoing block Out2, such that:; /// a. In2 is reachable from D or contains D.; /// b. U is reachable from Out2 or is contained in Out2.; /// c. U is not a PHINode if U is contained in Out2.; ///; /// Clearly, Def dominates Out2 since the program is valid SSA. But when the; /// hub is introduced, there is a new path through the hub along which Use is; /// reachable from entry without passing through Def, and SSA is no longer; /// valid. To fix this, we need to look at all the blocks post-dominated by; /// the hub on the one hand, and dominated by Out2 on the other. This is left; /// for the caller to accomplish, since each specific use of this function; /// may have additional information which simplifies this fixup. For example,; /// see restoreSSA() in the UnifyLoopExits pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:1932,Usability,Clear,Clearly,1932," the control flow edges from InBB to OutBB have now been replaced, the; /// function also updates any PHINodes in OutBB. For each such PHINode, the; /// operands corresponding to incoming blocks are moved to a new PHINode in the; /// hub, and the hub is made an operand of the original PHINode.; ///; /// Input CFG:; /// ----------; ///; /// Def; /// |; /// v; /// In1 In2; /// | |; /// | |; /// v v; /// Foo ---> Out1 Out2; /// |; /// v; /// Use; ///; ///; /// Create hub: Incoming = {In1, In2}, Outgoing = {Out1, Out2}; /// ----------------------------------------------------------; ///; /// Def; /// |; /// v; /// In1 In2 Foo; /// | Hub | |; /// | + - - | - - + |; /// | ' v ' V; /// +------> Guard1 -----> Out1; /// ' | '; /// ' v '; /// ' Guard2 -----> Out2; /// ' ' |; /// + - - - - - + |; /// v; /// Use; ///; /// Limitations:; /// -----------; /// 1. This assumes that all terminators in the CFG are direct branches (the; /// ""br"" instruction). The presence of any other control flow such as; /// indirectbr, switch or callbr will cause an assert.; ///; /// 2. The updates to the PHINodes are not sufficient to restore SSA; /// form. Consider a definition Def, its use Use, incoming block In2 and; /// outgoing block Out2, such that:; /// a. In2 is reachable from D or contains D.; /// b. U is reachable from Out2 or is contained in Out2.; /// c. U is not a PHINode if U is contained in Out2.; ///; /// Clearly, Def dominates Out2 since the program is valid SSA. But when the; /// hub is introduced, there is a new path through the hub along which Use is; /// reachable from entry without passing through Def, and SSA is no longer; /// valid. To fix this, we need to look at all the blocks post-dominated by; /// the hub on the one hand, and dominated by Out2 on the other. This is left; /// for the caller to accomplish, since each specific use of this function; /// may have additional information which simplifies this fixup. For example,; /// see restoreSSA() in the UnifyLoopExits pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:2435,Usability,simpl,simplifies,2435," the control flow edges from InBB to OutBB have now been replaced, the; /// function also updates any PHINodes in OutBB. For each such PHINode, the; /// operands corresponding to incoming blocks are moved to a new PHINode in the; /// hub, and the hub is made an operand of the original PHINode.; ///; /// Input CFG:; /// ----------; ///; /// Def; /// |; /// v; /// In1 In2; /// | |; /// | |; /// v v; /// Foo ---> Out1 Out2; /// |; /// v; /// Use; ///; ///; /// Create hub: Incoming = {In1, In2}, Outgoing = {Out1, Out2}; /// ----------------------------------------------------------; ///; /// Def; /// |; /// v; /// In1 In2 Foo; /// | Hub | |; /// | + - - | - - + |; /// | ' v ' V; /// +------> Guard1 -----> Out1; /// ' | '; /// ' v '; /// ' Guard2 -----> Out2; /// ' ' |; /// + - - - - - + |; /// v; /// Use; ///; /// Limitations:; /// -----------; /// 1. This assumes that all terminators in the CFG are direct branches (the; /// ""br"" instruction). The presence of any other control flow such as; /// indirectbr, switch or callbr will cause an assert.; ///; /// 2. The updates to the PHINodes are not sufficient to restore SSA; /// form. Consider a definition Def, its use Use, incoming block In2 and; /// outgoing block Out2, such that:; /// a. In2 is reachable from D or contains D.; /// b. U is reachable from Out2 or is contained in Out2.; /// c. U is not a PHINode if U is contained in Out2.; ///; /// Clearly, Def dominates Out2 since the program is valid SSA. But when the; /// hub is introduced, there is a new path through the hub along which Use is; /// reachable from entry without passing through Def, and SSA is no longer; /// valid. To fix this, we need to look at all the blocks post-dominated by; /// the hub on the one hand, and dominated by Out2 on the other. This is left; /// for the caller to accomplish, since each specific use of this function; /// may have additional information which simplifies this fixup. For example,; /// see restoreSSA() in the UnifyLoopExits pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:39,Usability,simpl,simple,39,// Check whether the function only has simple terminator:; // br/brcond/unreachable/ret,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:273,Usability,resume,resume,273,"// Returns true if these basic blocks belong to a presplit coroutine and the; // edge corresponds to the 'default' case in the switch statement in the; // pattern:; //; // %0 = call i8 @llvm.coro.suspend(token none, i1 false); // switch i8 %0, label %suspend [i8 0, label %resume; // i8 1, label %cleanup]; //; // i.e. the edge to the `%suspend` BB. This edge is special in that it will; // be elided by coroutine lowering (coro-split), and the `%suspend` BB needs; // to be kept as-is. It's not a real CFG edge - post-lowering, it will end; // up being a `ret`, and it must be thus lowerable to support symmetric; // transfer. For example:; // - this edge is not a loop exit edge if encountered in a loop (and should; // be ignored); // - must not be split for PGO instrumentation, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BreakCriticalEdges.h:679,Deployability,update,update,679,"//===- BreakCriticalEdges.h - Critical Edge Elimination Pass --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BreakCriticalEdges pass - Break all of the critical edges in the CFG by; // inserting a dummy basic block. This pass may be ""required"" by passes that; // cannot deal with critical edges. For this usage, the structure type is; // forward declared. This pass obviously invalidates the CFG, but can update; // dominator trees.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BreakCriticalEdges.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BreakCriticalEdges.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:404,Integrability,interface,interface,404,"//===- BuildLibCalls.h - Utility builder for libcalls -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:456,Performance,optimiz,optimization,456,"//===- BuildLibCalls.h - Utility builder for libcalls -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:393,Security,expose,exposes,393,"//===- BuildLibCalls.h - Utility builder for libcalls -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:125,Performance,optimiz,optimizations,125,"/// Analyze the name and prototype of the given function and set any; /// applicable attributes. Note that this merely helps optimizations on an; /// already existing function but does not consider mandatory attributes.; ///; /// If the library function is unavailable, this doesn't modify it.; ///; /// Returns true if any attributes were set and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:3,Safety,Avoid,Avoid,3,// Avoid an incorrect ordering that'd otherwise compile incorrectly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:42,Availability,avail,available,42,/// Check whether the library function is available on target and also that; /// it in the current Module is a Function with the right type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:88,Availability,avail,available,88,/// Check whether the overloaded floating point function; /// corresponding to \a Ty is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:78,Integrability,depend,depending,78,"/// Emit a call to the unary function DoubleFn, FloatFn or LongDoubleFn,; /// depending of the type of Op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:79,Integrability,depend,depending,79,"/// Emit a call to the binary function DoubleFn, FloatFn or LongDoubleFn,; /// depending of the type of Op1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h:405,Performance,optimiz,optimization,405,"//===- llvm/Transforms/Utils/BypassSlowDivision.h ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an optimization for div and rem on architectures that; // execute short instructions significantly faster than longer instructions.; // For example, on Intel Atom 32-bit divides are slow enough that during; // runtime it is profitable to check the value of the operands, and if they are; // positive and less than 256 use an unsigned 8-bit divide.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h:9,Performance,optimiz,optimization,9,"/// This optimization identifies DIV instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.; ///; /// This optimization may add basic blocks immediately after BB; for obvious; /// reasons, you shouldn't pass those blocks to bypassSlowDivision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h:157,Performance,optimiz,optimization,157,"/// This optimization identifies DIV instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.; ///; /// This optimization may add basic blocks immediately after BB; for obvious; /// reasons, you shouldn't pass those blocks to bypassSlowDivision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:48,Deployability,update,update,48,"//===- CallGraphUpdater.h - A (lazy) call graph update helper ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:415,Integrability,interface,interfaces,415,"//===- CallGraphUpdater.h - A (lazy) call graph update helper ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper to unify ""old style"" CallGraph and ""new style"" LazyCallGraph. This; /// simplifies the interface and the call sites, e.g., new and old pass manager; /// passes can share the same code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:99,Integrability,interface,interface,99,"/// Wrapper to unify ""old style"" CallGraph and ""new style"" LazyCallGraph. This; /// simplifies the interface and the call sites, e.g., new and old pass manager; /// passes can share the same code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:84,Usability,simpl,simplifies,84,"/// Wrapper to unify ""old style"" CallGraph and ""new style"" LazyCallGraph. This; /// simplifies the interface and the call sites, e.g., new and old pass manager; /// passes can share the same code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:17,Modifiability,variab,variables,17,///}; /// Old PM variables; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:17,Modifiability,variab,variables,17,///}; /// New PM variables; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:113,Deployability,update,update,113,"/// After an CGSCC pass changes a function in ways that affect the call; /// graph, this method can be called to update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:82,Deployability,update,update,82,"/// If a new function was created by outlining, this method can be called; /// to update the call graph for the new function. Note that the old one; /// still needs to be re-analyzed or manually updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h:195,Deployability,update,updated,195,"/// If a new function was created by outlining, this method can be called; /// to update the call graph for the new function. Note that the old one; /// still needs to be re-analyzed or manually updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallGraphUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:310,Availability,Failure,FailureReason,310,"/// Return true if the given indirect call site can be made to call \p Callee.; ///; /// This function ensures that the number and type of the call site's arguments; /// and return value match those of the given function. If the types do not; /// match exactly, they must at least be bitcast compatible. If \p FailureReason; /// is non-null and the indirect call cannot be promoted, the failure reason; /// will be stored in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:387,Availability,failure,failure,387,"/// Return true if the given indirect call site can be made to call \p Callee.; ///; /// This function ensures that the number and type of the call site's arguments; /// and return value match those of the given function. If the types do not; /// match exactly, they must at least be bitcast compatible. If \p FailureReason; /// is non-null and the indirect call cannot be promoted, the failure reason; /// will be stored in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:511,Integrability,Interface,Interface,511,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:541,Integrability,Interface,Interface,541,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:591,Integrability,Interface,Interface,591,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:619,Integrability,Interface,Interface,619,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:665,Integrability,Interface,Interface,665,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:692,Integrability,Interface,Interface,692,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:741,Integrability,Interface,Interface,741,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:573,Performance,load,load,573,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:647,Performance,load,load,647,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CanonicalizeAliases.h:4,Usability,Simpl,Simple,4,/// Simple pass that canonicalizes aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CanonicalizeAliases.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CanonicalizeAliases.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:200,Usability,simpl,simplification,200,"/// Like VMap, but maps only unsimplified instructions. Values in the map; /// may be dangling, it is only intended to be used via isSimplified(), to; /// check whether the main VMap mapping involves simplification or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:732,Deployability,update,updated,732,"/// Return a copy of the specified basic block, but without; /// embedding the block into a particular function. The block returned is an; /// exact copy of the specified basic block, without any remapping having been; /// performed. Because of this, this is only suitable for applications where; /// the basic block will be inserted into the same function that it was cloned; /// from (loop unrolling would use this, for example).; ///; /// Also, note that this function makes a direct copy of the basic block, and; /// can thus produce illegal LLVM code. In particular, it will copy any PHI; /// nodes from the original block, even though there are no predecessors for the; /// newly cloned block (thus, phi nodes will have to be updated). Also, this; /// block will branch to the old successors of the original block: these; /// successors will have to have any PHI nodes updated to account for the new; /// incoming edges.; ///; /// The correlation between instructions in the source and result basic blocks; /// is recorded in the VMap map.; ///; /// If you have a particular suffix you'd like to use to add to any cloned; /// names, specify it as the optional third parameter.; ///; /// If you would like the basic block to be auto-inserted into the end of a; /// function, you can specify it as the optional fourth parameter.; ///; /// If you would like to collect additional information about the cloned; /// function, you can specify a ClonedCodeInfo object with the optional fifth; /// parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:875,Deployability,update,updated,875,"/// Return a copy of the specified basic block, but without; /// embedding the block into a particular function. The block returned is an; /// exact copy of the specified basic block, without any remapping having been; /// performed. Because of this, this is only suitable for applications where; /// the basic block will be inserted into the same function that it was cloned; /// from (loop unrolling would use this, for example).; ///; /// Also, note that this function makes a direct copy of the basic block, and; /// can thus produce illegal LLVM code. In particular, it will copy any PHI; /// nodes from the original block, even though there are no predecessors for the; /// newly cloned block (thus, phi nodes will have to be updated). Also, this; /// block will branch to the old successors of the original block: these; /// successors will have to have any PHI nodes updated to account for the new; /// incoming edges.; ///; /// The correlation between instructions in the source and result basic blocks; /// is recorded in the VMap map.; ///; /// If you have a particular suffix you'd like to use to add to any cloned; /// names, specify it as the optional third parameter.; ///; /// If you would like the basic block to be auto-inserted into the end of a; /// function, you can specify it as the optional fourth parameter.; ///; /// If you would like to collect additional information about the cloned; /// function, you can specify a ClonedCodeInfo object with the optional fifth; /// parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:223,Performance,perform,performed,223,"/// Return a copy of the specified basic block, but without; /// embedding the block into a particular function. The block returned is an; /// exact copy of the specified basic block, without any remapping having been; /// performed. Because of this, this is only suitable for applications where; /// the basic block will be inserted into the same function that it was cloned; /// from (loop unrolling would use this, for example).; ///; /// Also, note that this function makes a direct copy of the basic block, and; /// can thus produce illegal LLVM code. In particular, it will copy any PHI; /// nodes from the original block, even though there are no predecessors for the; /// newly cloned block (thus, phi nodes will have to be updated). Also, this; /// block will branch to the old successors of the original block: these; /// successors will have to have any PHI nodes updated to account for the new; /// incoming edges.; ///; /// The correlation between instructions in the source and result basic blocks; /// is recorded in the VMap map.; ///; /// If you have a particular suffix you'd like to use to add to any cloned; /// names, specify it as the optional third parameter.; ///; /// If you would like the basic block to be auto-inserted into the end of a; /// function, you can specify it as the optional fourth parameter.; ///; /// If you would like to collect additional information about the cloned; /// function, you can specify a ClonedCodeInfo object with the optional fifth; /// parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:341,Deployability,update,updated,341,"/// Return a copy of the specified function and add it to that; /// function's module. Also, any references specified in the VMap are changed; /// to refer to their mapped value instead of the original one. If any of the; /// arguments to the function are in the VMap, the arguments are deleted from; /// the resultant function. The VMap is updated to include mappings from all of; /// the instructions and basicblocks in the function from their old to new; /// values. The final argument captures information about the cloned code if; /// non-null.; ///; /// \pre VMap contains no non-identity GlobalValue mappings.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:1048,Deployability,update,updated,1048,"/// Clone OldFunc into NewFunc, transforming the old arguments into references; /// to VMap values. Note that if NewFunc already has basic blocks, the ones; /// cloned into it will be added to the end of the function. This function; /// fills in a list of return instructions, and can optionally remap types; /// and/or append the specified suffix to all values cloned.; ///; /// If \p Changes is \a CloneFunctionChangeType::LocalChangesOnly, VMap is; /// required to contain no non-identity GlobalValue mappings. Otherwise,; /// referenced metadata will be cloned.; ///; /// If \p Changes is less than \a CloneFunctionChangeType::DifferentModule; /// indicating cloning into the same module (even if it's LocalChangesOnly), if; /// debug info metadata transitively references a \a DISubprogram, it will be; /// cloned, effectively upgrading \p Changes to GlobalChanges while suppressing; /// cloning of types and compile units.; ///; /// If \p Changes is \a CloneFunctionChangeType::DifferentModule, the new; /// module's \c !llvm.dbg.cu will get updated with any newly created compile; /// units. (\a CloneFunctionChangeType::ClonedModule leaves that work for the; /// caller.); ///; /// FIXME: Consider simplifying this function by splitting out \a; /// CloneFunctionMetadataInto() and expecting / updating callers to call it; /// first when / how it's needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:1206,Usability,simpl,simplifying,1206,"/// Clone OldFunc into NewFunc, transforming the old arguments into references; /// to VMap values. Note that if NewFunc already has basic blocks, the ones; /// cloned into it will be added to the end of the function. This function; /// fills in a list of return instructions, and can optionally remap types; /// and/or append the specified suffix to all values cloned.; ///; /// If \p Changes is \a CloneFunctionChangeType::LocalChangesOnly, VMap is; /// required to contain no non-identity GlobalValue mappings. Otherwise,; /// referenced metadata will be cloned.; ///; /// If \p Changes is less than \a CloneFunctionChangeType::DifferentModule; /// indicating cloning into the same module (even if it's LocalChangesOnly), if; /// debug info metadata transitively references a \a DISubprogram, it will be; /// cloned, effectively upgrading \p Changes to GlobalChanges while suppressing; /// cloning of types and compile units.; ///; /// If \p Changes is \a CloneFunctionChangeType::DifferentModule, the new; /// module's \c !llvm.dbg.cu will get updated with any newly created compile; /// units. (\a CloneFunctionChangeType::ClonedModule leaves that work for the; /// caller.); ///; /// FIXME: Consider simplifying this function by splitting out \a; /// CloneFunctionMetadataInto() and expecting / updating callers to call it; /// first when / how it's needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:77,Usability,simpl,simple,77,"/// This works exactly like CloneFunctionInto,; /// except that it does some simple constant prop and DCE on the fly. The; /// effect of this is to copy significantly less code in cases where (for; /// example) a function call with constant arguments is inlined, and those; /// constant arguments cause a significant amount of code in the callee to be; /// dead. Since this doesn't produce an exactly copy of the input, it can't be; /// used for things like CloneFunction or CloneModule.; ///; /// If ModuleLevelChanges is false, VMap contains no non-identity GlobalValue; /// mappings.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:37,Deployability,update,update,37,"/// If non-null, InlineFunction will update the callgraph to reflect the; /// changes it makes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:4,Deployability,Update,Update,4,"/// Update profile for callee as well as cloned version. We need to do this; /// for regular inlining, but not for inlining from sample profile loader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:144,Performance,load,loader,144,"/// Update profile for callee as well as cloned version. We need to do this; /// for regular inlining, but not for inlining from sample profile loader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:524,Integrability,rout,routine,524,"/// This function inlines the called function into the basic; /// block of the caller. This returns false if it is not possible to inline; /// this call. The program is still in a well defined state if this occurs; /// though.; ///; /// Note that this only does one level of inlining. For example, if the; /// instruction 'call B' is inlined, and 'B' calls 'C', then the call to 'C' now; /// exists in the instruction stream. Similarly this will inline a recursive; /// function by one level.; ///; /// Note that while this routine is allowed to cleanup and optimize the; /// *inlined* code to minimize the actual inserted code, it must not delete; /// code in the caller as users of this routine may have pointers to; /// instructions in the caller that need to remain stable.; ///; /// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed; /// and all varargs at the callsite will be passed to any calls to; /// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs; /// are only used by ForwardVarArgsTo.; ///; /// The callee's function attributes are merged into the callers' if; /// MergeAttributes is set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:689,Integrability,rout,routine,689,"/// This function inlines the called function into the basic; /// block of the caller. This returns false if it is not possible to inline; /// this call. The program is still in a well defined state if this occurs; /// though.; ///; /// Note that this only does one level of inlining. For example, if the; /// instruction 'call B' is inlined, and 'B' calls 'C', then the call to 'C' now; /// exists in the instruction stream. Similarly this will inline a recursive; /// function by one level.; ///; /// Note that while this routine is allowed to cleanup and optimize the; /// *inlined* code to minimize the actual inserted code, it must not delete; /// code in the caller as users of this routine may have pointers to; /// instructions in the caller that need to remain stable.; ///; /// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed; /// and all varargs at the callsite will be passed to any calls to; /// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs; /// are only used by ForwardVarArgsTo.; ///; /// The callee's function attributes are merged into the callers' if; /// MergeAttributes is set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:558,Performance,optimiz,optimize,558,"/// This function inlines the called function into the basic; /// block of the caller. This returns false if it is not possible to inline; /// this call. The program is still in a well defined state if this occurs; /// though.; ///; /// Note that this only does one level of inlining. For example, if the; /// instruction 'call B' is inlined, and 'B' calls 'C', then the call to 'C' now; /// exists in the instruction stream. Similarly this will inline a recursive; /// function by one level.; ///; /// Note that while this routine is allowed to cleanup and optimize the; /// *inlined* code to minimize the actual inserted code, it must not delete; /// code in the caller as users of this routine may have pointers to; /// instructions in the caller that need to remain stable.; ///; /// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed; /// and all varargs at the callsite will be passed to any calls to; /// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs; /// are only used by ForwardVarArgsTo.; ///; /// The callee's function attributes are merged into the callers' if; /// MergeAttributes is set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:92,Deployability,Update,Updates,92,/// Clones a loop \p OrigLoop. Returns the loop and the blocks in \p; /// Blocks.; ///; /// Updates LoopInfo and DominatorTree assuming the loop is dominated by block; /// \p LoopDomBB. Insert the new blocks before block specified in \p Before.; /// Note: Only innermost loops are supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:4,Deployability,Update,Updates,4,/// Updates profile information by adjusting the entry count by adding; /// EntryDelta then scaling callsite information by the new count divided by the; /// old count. VMap is used during inlinng to also update the new clone,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:205,Deployability,update,update,205,/// Updates profile information by adjusting the entry count by adding; /// EntryDelta then scaling callsite information by the new count divided by the; /// old count. VMap is used during inlinng to also update the new clone,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:4,Energy Efficiency,Adapt,Adapt,4,"/// Adapt the metadata for the specified instruction according to the; /// provided mapping. This is normally used after cloning an instruction, when; /// some noalias scopes needed to be cloned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:4,Modifiability,Adapt,Adapt,4,"/// Adapt the metadata for the specified instruction according to the; /// provided mapping. This is normally used after cloning an instruction, when; /// some noalias scopes needed to be cloned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,Energy Efficiency,adapt,adapt,50,/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// NewBlocks basicblocks to the cloned versions.; /// 'Ext' will be added to the duplicate scope names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,Modifiability,adapt,adapt,50,/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// NewBlocks basicblocks to the cloned versions.; /// 'Ext' will be added to the duplicate scope names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,Energy Efficiency,adapt,adapt,50,"/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// [IStart, IEnd] (IEnd included !) range to the cloned versions. 'Ext' will be; /// added to the duplicate scope names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:50,Modifiability,adapt,adapt,50,"/// Clone the specified noalias decl scopes. Then adapt all instructions in the; /// [IStart, IEnd] (IEnd included !) range to the cloned versions. 'Ext' will be; /// added to the duplicate scope names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:6,Performance,cache,cache,6,/// A cache for the CodeExtractor analysis. The operation \ref; /// CodeExtractor::extractCodeRegion is guaranteed not to invalidate this; /// object. This object should conservatively be considered invalid if any; /// other mutating operations on the IR occur.; ///; /// Constructing this object is O(n) in the size of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:29,Performance,load,load,29,"/// Base memory addresses of load/store instructions, grouped by block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:59,Performance,load,load,59,"/// Check whether \p BB contains an instruction thought to load from, store; /// to, or otherwise clobber the alloca \p Addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:100,Integrability,interface,interface,100,"/// Utility class for extracting code into a new function.; ///; /// This utility provides a simple interface for extracting some sequence of; /// code into its own function, replacing it with a call to that function. It; /// also provides various methods to query about the nature and result of; /// such a transformation.; ///; /// The rough algorithm used is:; /// 1) Find both the inputs and outputs for the extracted region.; /// 2) Pass the inputs as arguments, remapping them within the extracted; /// function to arguments.; /// 3) Add allocas for any scalar outputs, adding all of the outputs' allocas; /// as arguments, and inserting stores to the arguments for any scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:93,Usability,simpl,simple,93,"/// Utility class for extracting code into a new function.; ///; /// This utility provides a simple interface for extracting some sequence of; /// code into its own function, replacing it with a call to that function. It; /// also provides various methods to query about the nature and result of; /// such a transformation.; ///; /// The rough algorithm used is:; /// 1) Find both the inputs and outputs for the extracted region.; /// 2) Pass the inputs as arguments, remapping them within the extracted; /// function to arguments.; /// 3) Add allocas for any scalar outputs, adding all of the outputs' allocas; /// as arguments, and inserting stores to the arguments for any scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:412,Safety,safe,safe,412,"/// Create a code extractor for a sequence of blocks.; ///; /// Given a sequence of basic blocks where the first block in the sequence; /// dominates the rest, prepare a code extractor object for pulling this; /// sequence out into its new function. When a DominatorTree is also given,; /// extra checking and transformations are enabled. If AllowVarArgs is true,; /// vararg functions can be extracted. This is safe, if all vararg handling; /// code is extracted, including vastart. If AllowAlloca is true, then; /// extraction of blocks containing alloca instructions would be possible,; /// however code extractor won't validate whether extraction is legal.; /// Any new allocations will be placed in the AllocationBlock, unless; /// it is null, in which case it will be placed in the entry block of; /// the function from which the code is being extracted.; /// If ArgsInZeroAddressSpace param is set to true, then the aggregate; /// param pointer of the outlined function is declared in zero address; /// space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:623,Security,validat,validate,623,"/// Create a code extractor for a sequence of blocks.; ///; /// Given a sequence of basic blocks where the first block in the sequence; /// dominates the rest, prepare a code extractor object for pulling this; /// sequence out into its new function. When a DominatorTree is also given,; /// extra checking and transformations are enabled. If AllowVarArgs is true,; /// vararg functions can be extracted. This is safe, if all vararg handling; /// code is extracted, including vastart. If AllowAlloca is true, then; /// extraction of blocks containing alloca instructions would be possible,; /// however code extractor won't validate whether extraction is legal.; /// Any new allocations will be placed in the AllocationBlock, unless; /// it is null, in which case it will be placed in the entry block of; /// the function from which the code is being extracted.; /// If ArgsInZeroAddressSpace param is set to true, then the aggregate; /// param pointer of the outlined function is declared in zero address; /// space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:4,Performance,Perform,Perform,4,"/// Perform the extraction, returning the new function.; ///; /// Returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:77,Integrability,interface,interface,77,"/// Perform the extraction, returning the new function and providing an; /// interface to see what was categorized as inputs and outputs.; ///; /// \param CEAC - Cache to speed up operations for the CodeExtractor when; /// hoisting, and extracting lifetime values and assumes.; /// \param Inputs [out] - filled with values marked as inputs to the; /// newly outlined function.; /// \param Outputs [out] - filled with values marked as outputs to the; /// newly outlined function.; /// \returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:4,Performance,Perform,Perform,4,"/// Perform the extraction, returning the new function and providing an; /// interface to see what was categorized as inputs and outputs.; ///; /// \param CEAC - Cache to speed up operations for the CodeExtractor when; /// hoisting, and extracting lifetime values and assumes.; /// \param Inputs [out] - filled with values marked as inputs to the; /// newly outlined function.; /// \param Outputs [out] - filled with values marked as outputs to the; /// newly outlined function.; /// \returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:162,Performance,Cache,Cache,162,"/// Perform the extraction, returning the new function and providing an; /// interface to see what was categorized as inputs and outputs.; ///; /// \param CEAC - Cache to speed up operations for the CodeExtractor when; /// hoisting, and extracting lifetime values and assumes.; /// \param Inputs [out] - filled with values marked as inputs to the; /// newly outlined function.; /// \param Outputs [out] - filled with values marked as outputs to the; /// newly outlined function.; /// \returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:112,Availability,error,errors,112,/// Verify that assumption cache isn't stale after a region is extracted.; /// Returns true when verifier finds errors. AssumptionCache is passed as; /// parameter to make this function stateless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:27,Performance,cache,cache,27,/// Verify that assumption cache isn't stale after a region is extracted.; /// Returns true when verifier finds errors. AssumptionCache is passed as; /// parameter to make this function stateless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:4,Testability,Test,Test,4,"/// Test whether this code extractor is eligible.; ///; /// Based on the blocks used when constructing the code extractor,; /// determine whether it is eligible for extraction.; ///; /// Checks that varargs handling (with vastart and vaend) is only done in; /// the outlined blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:108,Performance,perform,performing,108,"/// Compute the set of input values and output values for the code.; ///; /// These can be used either when performing the extraction or to evaluate; /// the expected size of a call to the extracted function. Note that this; /// work cannot be cached between the two as once we decide to extract; /// a code sequence, that sequence is modified, including changing these; /// sets, before extraction occurs. These modifications won't have any; /// significant impact on the cost however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:244,Performance,cache,cached,244,"/// Compute the set of input values and output values for the code.; ///; /// These can be used either when performing the extraction or to evaluate; /// the expected size of a call to the extracted function. Note that this; /// work cannot be cached between the two as once we decide to extract; /// a code sequence, that sequence is modified, including changing these; /// sets, before extraction occurs. These modifications won't have any; /// significant impact on the cost however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:118,Safety,safe,safe,118,/// Check if life time marker nodes can be hoisted/sunk into the outline; /// region.; ///; /// Returns true if it is safe to do the code motion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:322,Integrability,wrap,wrapping,322,/// Find the set of allocas whose life ranges are contained within the; /// outlined region.; ///; /// Allocas which have life_time markers contained in the outlined region; /// should be pushed to the outlined function. The address bitcasts that; /// are used by the lifetime markers are also candidates for shrink-; /// wrapping. The instructions that need to be sunk are collected in; /// 'Allocas'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:57,Performance,optimiz,optimizing,57,"/// Find a layout of nodes (basic blocks) of a given CFG optimizing jump; /// locality and thus processor I-cache utilization. This is achieved via; /// increasing the number of fall-through jumps and co-locating frequently; /// executed nodes together.; /// The nodes are assumed to be indexed by integers from [0, |V|) so that the; /// current order is the identity permutation.; /// \p NodeSizes: The sizes of the nodes (in bytes).; /// \p NodeCounts: The execution counts of the nodes in the profile.; /// \p EdgeCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \returns The best block order found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:108,Performance,cache,cache,108,"/// Find a layout of nodes (basic blocks) of a given CFG optimizing jump; /// locality and thus processor I-cache utilization. This is achieved via; /// increasing the number of fall-through jumps and co-locating frequently; /// executed nodes together.; /// The nodes are assumed to be indexed by integers from [0, |V|) so that the; /// current order is the identity permutation.; /// \p NodeSizes: The sizes of the nodes (in bytes).; /// \p NodeCounts: The execution counts of the nodes in the profile.; /// \p EdgeCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \returns The best block order found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:226,Performance,cache,cache,226,"/// Estimate the ""quality"" of a given node order in CFG. The higher the score,; /// the better the order is. The score is designed to reflect the locality of; /// the given order, which is anti-correlated with the number of I-cache misses; /// in a typical execution of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:34,Performance,Cache,Cache-Directed,34,/// Algorithm-specific params for Cache-Directed Sort. The values are tuned for; /// the best performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:70,Performance,tune,tuned,70,/// Algorithm-specific params for Cache-Directed Sort. The values are tuned for; /// the best performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:94,Performance,perform,performance,94,/// Algorithm-specific params for Cache-Directed Sort. The values are tuned for; /// the best performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:20,Performance,cache,cache,20,/// The size of the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:30,Performance,cache,cache,30,/// The size of a line in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:8,Energy Efficiency,power,power,8,/// The power exponent for the distance-based locality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:12,Performance,Cache,Cache-Directed,12,/// Apply a Cache-Directed Sort for functions represented by a call graph.; /// The placement is done by optimizing the call locality by co-locating; /// frequently executed functions.; /// \p FuncSizes: The sizes of the nodes (in bytes).; /// \p FuncCounts: The execution counts of the nodes in the profile.; /// \p CallCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \p CallOffsets: The offsets of the calls from their source nodes.; /// \returns The best function order found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:105,Performance,optimiz,optimizing,105,/// Apply a Cache-Directed Sort for functions represented by a call graph.; /// The placement is done by optimizing the call locality by co-locating; /// frequently executed functions.; /// \p FuncSizes: The sizes of the nodes (in bytes).; /// \p FuncCounts: The execution counts of the nodes in the profile.; /// \p CallCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \p CallOffsets: The offsets of the calls from their source nodes.; /// \returns The best function order found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:46,Modifiability,config,config,46,/// Apply a Cache-Directed Sort with a custom config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:12,Performance,Cache,Cache-Directed,12,/// Apply a Cache-Directed Sort with a custom config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:432,Safety,safe,safe,432,"//===- Transform/Utils/CodeMoverUtils.h - CodeMover Utils -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions determine movements are safe on basic blocks, and; // instructions contained within a function.; //; // Please note that this is work in progress, and the functionality is not; // ready for broader production use.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:31,Safety,safe,safely,31,/// Return true if \p I can be safely moved before \p InsertPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:81,Safety,safe,safely,81,/// Return true if all instructions (except the terminator) in \p BB can be; /// safely moved before \p InsertPoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:114,Safety,safe,safe,114,"/// Move instructions, in an order-preserving manner, from \p FromBB to the; /// beginning of \p ToBB when proven safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:108,Safety,safe,safe,108,"/// Move instructions, in an order-preserving manner, from \p FromBB to the end; /// of \p ToBB when proven safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:391,Integrability,Interface,Interface,391,"//===- Debugify.h - Check debug info preservation in optimizations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Interface to the `debugify` synthetic/original debug info testing; /// utility.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:53,Performance,optimiz,optimizations,53,"//===- Debugify.h - Check debug info preservation in optimizations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Interface to the `debugify` synthetic/original debug info testing; /// utility.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:449,Testability,test,testing,449,"//===- Debugify.h - Check debug info preservation in optimizations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Interface to the `debugify` synthetic/original debug info testing; /// utility.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:8,Modifiability,variab,variable,8,// Maps variable into dbg users (#dbg values/declares for this variable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:63,Modifiability,variab,variable,63,// Maps variable into dbg users (#dbg values/declares for this variable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:233,Availability,error,error,233,"/// Add synthesized debug information to a module.; ///; /// \param M The module to add debug information to.; /// \param Functions A range of functions to add debug information to.; /// \param Banner A prefix string to add to debug/error messages.; /// \param ApplyToMF A call back that will add debug information to the; /// MachineFunction for a Function. If nullptr, then the; /// MachineFunction (if any) will not be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:239,Integrability,message,messages,239,"/// Add synthesized debug information to a module.; ///; /// \param M The module to add debug information to.; /// \param Functions A range of functions to add debug information to.; /// \param Banner A prefix string to add to debug/error messages.; /// \param ApplyToMF A call back that will add debug information to the; /// MachineFunction for a Function. If nullptr, then the; /// MachineFunction (if any) will not be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:307,Availability,error,error,307,/// Collect original debug information before a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:386,Availability,error,error,386,/// Collect original debug information before a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:313,Integrability,message,messages,313,/// Collect original debug information before a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:392,Integrability,message,messages,392,/// Collect original debug information before a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:304,Availability,error,error,304,/// Check original debug information after a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:383,Availability,error,error,383,/// Check original debug information after a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:310,Integrability,message,messages,310,/// Check original debug information after a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:389,Integrability,message,messages,389,/// Check original debug information after a pass.; ///; /// \param M The module to collect debug information from.; /// \param Functions A range of functions to collect debug information from.; /// \param DebugInfoBeforePass DI metadata before a pass.; /// \param Banner A prefix string to add to debug/error messages.; /// \param NameOfWrappedPass A name of a pass to add to debug/error messages.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:30,Integrability,wrap,wraps,30,/// DebugifyCustomPassManager wraps each pass with the debugify passes if; /// needed.; /// NOTE: We support legacy custom pass manager only.; /// TODO: Add New PM support for custom pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:3,Integrability,Wrap,Wrap,3,"// Wrap each pass with (-check)-debugify passes if requested, making; // exceptions for passes which shouldn't see -debugify instrumentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:161,Performance,optimiz,optimizations,161,"// Either apply -debugify/-check-debugify before/after each pass and collect; // debug info loss statistics, or collect and check original debug info in; // the optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h:23,Deployability,Upgrade,Upgrade,23,"//===- DXILUpgrade.h - Upgrade DXIL metadata to LLVM constructs -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h:4,Deployability,Upgrade,Upgrade,4,/// Upgrade DXIL-style metadata into their LLVM representations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/DXILUpgrade.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:115,Modifiability,variab,variables,115,"/// This class evaluates LLVM IR, producing the Constant representing each SSA; /// instruction. Changes to global variables are stored in a mapping that can; /// be iterated over after the evaluation is complete. Once an evaluation call; /// fails, the evaluation object should not be reused.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:20,Safety,detect,detect,20,"/// This is used to detect recursion. In pathological situations we could hit; /// exponential behavior, but at least there is nothing unbounded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:34,Deployability,update,update,34,"/// For each store we execute, we update this map. Loads check this to get; /// the most up-to-date value. If evaluation is successful, this state is; /// committed to the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:51,Performance,Load,Loads,51,"/// For each store we execute, we update this map. Loads check this to get; /// the most up-to-date value. If evaluation is successful, this state is; /// committed to the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:57,Modifiability,variab,variable,57,"/// To 'execute' an alloca, we create a temporary global variable to represent; /// its body. This vector is needed so we can delete the temporary globals; /// when we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:17,Modifiability,variab,variables,17,/// These global variables have been marked invariant by the static; /// constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:55,Usability,simpl,simple,55,/// These are constants we have checked and know to be simple enough to live; /// in a static initializer of a global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:483,Deployability,update,updated,483,"/// GlobalNumberState assigns an integer to each global value in the program,; /// which is used by the comparison routine to order references to globals. This; /// state must be preserved throughout the pass, because Functions and other; /// globals need to maintain their relative order. Globals are assigned a number; /// when they are first visited. This order is deterministic, and so the; /// assigned numbers are as well. When two functions are merged, neither number; /// is updated. If the symbols are weak, this would be incorrect. If they are; /// strong, then one will be replaced at all references to the other, and so; /// direct callsites will now see one or the other symbol, and no update is; /// necessary. Note that if we were guaranteed unique names, we could just; /// compare those, but this would not work for stripped bitcodes or for those; /// few symbols without a name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:699,Deployability,update,update,699,"/// GlobalNumberState assigns an integer to each global value in the program,; /// which is used by the comparison routine to order references to globals. This; /// state must be preserved throughout the pass, because Functions and other; /// globals need to maintain their relative order. Globals are assigned a number; /// when they are first visited. This order is deterministic, and so the; /// assigned numbers are as well. When two functions are merged, neither number; /// is updated. If the symbols are weak, this would be incorrect. If they are; /// strong, then one will be replaced at all references to the other, and so; /// direct callsites will now see one or the other symbol, and no update is; /// necessary. Note that if we were guaranteed unique names, we could just; /// compare those, but this would not work for stripped bitcodes or for those; /// few symbols without a name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:115,Integrability,rout,routine,115,"/// GlobalNumberState assigns an integer to each global value in the program,; /// which is used by the comparison routine to order references to globals. This; /// state must be preserved throughout the pass, because Functions and other; /// globals need to maintain their relative order. Globals are assigned a number; /// when they are first visited. This order is deterministic, and so the; /// assigned numbers are as well. When two functions are merged, neither number; /// is updated. If the symbols are weak, this would be incorrect. If they are; /// strong, then one will be replaced at all references to the other, and so; /// direct callsites will now see one or the other symbol, and no update is; /// necessary. Note that if we were guaranteed unique names, we could just; /// compare those, but this would not work for stripped bitcodes or for those; /// few symbols without a name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:52,Modifiability,Config,Config,52,"// Each GlobalValue is mapped to an identifier. The Config ensures when RAUW; // occurs, the mapping does not change. Tracking changes is unnecessary, and; // also problematic for weak symbols (which may be overwritten).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:165,Availability,avail,available,165,/// FunctionComparator - Compares two functions to determine whether or not; /// they will generate machine code with the same behaviour. DataLayout is; /// used if available. The comparator always fails conservatively (erring on the; /// side of claiming that two functions are different).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:4,Testability,Test,Test,4,/// Test whether the two functions have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:4,Testability,Test,Test,4,/// Test whether two basic blocks have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:2190,Safety,avoid,avoid,2190,"with greater address space is; /// greater.; /// Stage 4: Types are neither vectors, nor pointers. And they differ.; /// We don't know how to bitcast them. So, we better don't do it,; /// and return types comparison result (so it determines the; /// relationship among constants we don't know how to bitcast).; ///; /// Just for clearance, let's see how the set of constants could look; /// on single dimension axis:; ///; /// [NFCT], [FCT, ""others""], [FCT, pointers], [FCT, vectors]; /// Where: NFCT - Not a FirstClassType; /// FCT - FirstClassTyp:; ///; /// 2. Compare raw contents.; /// It ignores types on this stage and only compares bits from L and R.; /// Returns 0, if L and R has equivalent contents.; /// -1 or 1 if values are different.; /// Pretty trivial:; /// 2.1. If contents are numbers, compare numbers.; /// Ints with greater bitwidth are greater. Ints with same bitwidths; /// compared by their contents.; /// 2.2. ""And so on"". Just to avoid discrepancies with comments; /// perhaps it would be better to read the implementation itself.; /// 3. And again about overall picture. Let's look back at how the ordered set; /// of constants will look like:; /// [NFCT], [FCT, ""others""], [FCT, pointers], [FCT, vectors]; ///; /// Now look, what could be inside [FCT, ""others""], for example:; /// [FCT, ""others""] =; /// [; /// [double 0.1], [double 1.23],; /// [i32 1], [i32 2],; /// { double 1.0 }, ; StructTyID, NumElements = 1; /// { i32 1 }, ; StructTyID, NumElements = 1; /// { double 1, i32 1 }, ; StructTyID, NumElements = 2; /// { i32 1, double 1 } ; StructTyID, NumElements = 2; /// ]; ///; /// Let's explain the order. Float numbers will be less than integers, just; /// because of cmpType terms: FloatTyID < IntegerTyID.; /// Floats (with same fltSemantics) are sorted according to their value.; /// Then you can see integers, and they are, like a floats,; /// could be easy sorted among each others.; /// The structures. Structures are grouped at the tail, again because of thei",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:3427,Testability,log,logic,3427,"], [FCT, vectors]; ///; /// Now look, what could be inside [FCT, ""others""], for example:; /// [FCT, ""others""] =; /// [; /// [double 0.1], [double 1.23],; /// [i32 1], [i32 2],; /// { double 1.0 }, ; StructTyID, NumElements = 1; /// { i32 1 }, ; StructTyID, NumElements = 1; /// { double 1, i32 1 }, ; StructTyID, NumElements = 2; /// { i32 1, double 1 } ; StructTyID, NumElements = 2; /// ]; ///; /// Let's explain the order. Float numbers will be less than integers, just; /// because of cmpType terms: FloatTyID < IntegerTyID.; /// Floats (with same fltSemantics) are sorted according to their value.; /// Then you can see integers, and they are, like a floats,; /// could be easy sorted among each others.; /// The structures. Structures are grouped at the tail, again because of their; /// TypeID: StructTyID > IntegerTyID > FloatTyID.; /// Structures with greater number of elements are greater. Structures with; /// greater elements going first are greater.; /// The same logic with vectors, arrays and other possible complex types.; ///; /// Bitcastable constants.; /// Let's assume, that some constant, belongs to some group of; /// ""so-called-equal"" values with different types, and at the same time; /// belongs to another group of constants with equal types; /// and ""really"" equal values.; ///; /// Now, prove that this is impossible:; ///; /// If constant A with type TyA is bitcastable to B with type TyB, then:; /// 1. All constants with equal types to TyA, are bitcastable to B. Since; /// those should be vectors (if TyA is vector), pointers; /// (if TyA is pointer), or else (if TyA equal to TyB), those types should; /// be equal to TyB.; /// 2. All constants with non-equal, but bitcastable types to TyA, are; /// bitcastable to B.; /// Once again, just because we allow it to vectors and pointers only.; /// This statement could be expanded as below:; /// 2.1. All vectors with equal bitwidth to vector A, has equal bitwidth to; /// vector B, and thus bitcastable to B as well.; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1564,Usability,clear,clearance,1564,"tage 1: Types that satisfies isFirstClassType conditions are always; /// greater then others.; /// Stage 2: Vector is greater then non-vector.; /// If both types are vectors, then vector with greater bitwidth is; /// greater.; /// If both types are vectors with the same bitwidth, then types; /// are bitcastable, and we can skip other stages, and go to contents; /// comparison.; /// Stage 3: Pointer types are greater than non-pointers. If both types are; /// pointers of the same address space - go to contents comparison.; /// Different address spaces: pointer with greater address space is; /// greater.; /// Stage 4: Types are neither vectors, nor pointers. And they differ.; /// We don't know how to bitcast them. So, we better don't do it,; /// and return types comparison result (so it determines the; /// relationship among constants we don't know how to bitcast).; ///; /// Just for clearance, let's see how the set of constants could look; /// on single dimension axis:; ///; /// [NFCT], [FCT, ""others""], [FCT, pointers], [FCT, vectors]; /// Where: NFCT - Not a FirstClassType; /// FCT - FirstClassTyp:; ///; /// 2. Compare raw contents.; /// It ignores types on this stage and only compares bits from L and R.; /// Returns 0, if L and R has equivalent contents.; /// -1 or 1 if values are different.; /// Pretty trivial:; /// 2.1. If contents are numbers, compare numbers.; /// Ints with greater bitwidth are greater. Ints with same bitwidths; /// compared by their contents.; /// 2.2. ""And so on"". Just to avoid discrepancies with comments; /// perhaps it would be better to read the implementation itself.; /// 3. And again about overall picture. Let's look back at how the ordered set; /// of constants will look like:; /// [NFCT], [FCT, ""others""], [FCT, pointers], [FCT, vectors]; ///; /// Now look, what could be inside [FCT, ""others""], for example:; /// [FCT, ""others""] =; /// [; /// [double 0.1], [double 1.23],; /// [i32 1], [i32 2],; /// { double 1.0 }, ; StructTyID, NumElements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:880,Performance,Load,Load,880,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:907,Performance,Load,Load,907,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:949,Performance,Load,Load,949,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:995,Performance,Load,Load,995,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1052,Performance,Load,Load,1052,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1100,Performance,Load,Load,1100,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1238,Integrability,depend,depends,1238,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1487,Modifiability,variab,variable,1487,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:1546,Modifiability,variab,variable,1546,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:787,Safety,Safe,Safety,787,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:822,Safety,safe,safe,822,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:462,Performance,perform,perform,462,"//===- FunctionImportUtils.h - Importing support utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the FunctionImportGlobalProcessing class which is used; // to perform the necessary global value handling for function importing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:351,Availability,avail,available,351,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:235,Security,access,access,235,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:437,Security,access,access,437,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:552,Security,access,access,552,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:398,Usability,clear,clear,398,"/// Set to true (only applicatable to ELF -fpic) if dso_local should be; /// dropped for a declaration.; ///; /// On ELF, the assembler is conservative and assumes a global default; /// visibility symbol can be interposable. No direct access relocation is; /// allowed, if the definition is not in the translation unit, even if the; /// definition is available in the linkage unit. Thus we need to clear; /// dso_local to disable direct access.; ///; /// This flag should not be set for -fno-pic or -fpie, which would; /// unnecessarily disable direct access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:42,Security,validat,validate,42,"/// Set of llvm.*used values, in order to validate that we don't try; /// to promote any non-renamable values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:92,Testability,assert,assertion,92,"/// Check if the given value is a local that can't be renamed (promoted).; /// Only used in assertion checking, and disabled under NDEBUG since the Used; /// set will not be populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:92,Modifiability,variab,variables,92,/// Process globals so that they can be used in ThinLTO. This includes; /// promoting local variables so that they can be reference externally by; /// thin lto imported globals and converting strong external globals to; /// available_externally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:4,Performance,Perform,Perform,4,/// Perform in-place global value handling on the given Module for; /// exported local functions renamed and promoted for ThinLTO.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:10,Safety,safe,safe,10,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that constants cannot be cyclic, so this test is pretty easy to; /// implement recursively.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:129,Testability,test,test,129,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that constants cannot be cyclic, so this test is pretty easy to; /// implement recursively.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:31,Performance,load,loaded,31,/// True if the global is ever loaded. If the global isn't ever loaded it; /// can be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:64,Performance,load,loaded,64,/// True if the global is ever loaded. If the global isn't ever loaded it; /// can be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:47,Security,access,accessing,47,"/// These start out null/false. When the first accessing function is noticed,; /// it is recorded. When a second different accessing function is noticed,; /// HasMultipleAccessingFunctions is set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:123,Security,access,accessing,123,"/// These start out null/false. When the first accessing function is noticed,; /// it is recorded. When a second different accessing function is noticed,; /// HasMultipleAccessingFunctions is set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h:402,Performance,perform,perform,402,"//===-- GuardUtils.h - Utils for work with guards ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform transformations related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h:7,Integrability,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.h - TLI to VFABI attribute injection ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h:52,Integrability,inject,injection,52,"//===- InjectTLIMAppings.h - TLI to VFABI attribute injection ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h:7,Security,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.h - TLI to VFABI attribute injection ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h:52,Security,inject,injection,52,"//===- InjectTLIMAppings.h - TLI to VFABI attribute injection ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InjectTLIMappings.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:58,Testability,log,logic,58,/// InstructionWorklist - This is the worklist management logic for; /// InstCombine and other simplification passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:95,Usability,simpl,simplification,95,/// InstructionWorklist - This is the worklist management logic for; /// InstCombine and other simplification passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:34,Availability,down,down,34,"// Don't bother moving everything down, just null out the slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:27,Usability,simpl,simplified,27,"/// When an instruction is simplified, add all users of the instruction; /// to the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:123,Usability,simpl,simplified,123,"/// When an instruction is simplified, add all users of the instruction; /// to the work lists because they might get more simplified now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h:18,Usability,clear,clear,18,"// Do an explicit clear, this shrinks the map if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/InstructionWorklist.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h:615,Performance,tune,tuned,615,"//===- llvm/Transforms/Utils/IntegerDivision.h ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an implementation of 32bit and 64bit scalar integer; // division for targets that don't have native support. It's largely derived; // from compiler-rt's implementations of __udivsi3 and __udivmoddi4,; // but hand-tuned for targets that prefer less control flow.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h:824,Availability,redundant,redundant,824,"//===- LCSSA.h - Loop-closed SSA transform Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h:966,Performance,optimiz,optimizations,966,"//===- LCSSA.h - Loop-closed SSA transform Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h:824,Safety,redund,redundant,824,"//===- LCSSA.h - Loop-closed SSA transform Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h:1010,Usability,simpl,simpler,1010,"//===- LCSSA.h - Loop-closed SSA transform Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LibCallsShrinkWrap.h:37,Integrability,Wrap,Wrap,37,"//===- LibCallsShrinkWrap.h - Shrink Wrap Library Calls -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LibCallsShrinkWrap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LibCallsShrinkWrap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:30,Performance,perform,perform,30,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:408,Performance,perform,perform,408,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:369,Deployability,update,updated,369,"//===----------------------------------------------------------------------===//; // Local constant propagation.; //; /// If a terminator instruction is predicated on a constant value, convert it; /// into an unconditional branch to the constant destination.; /// This is a nontrivial operation because the successors of this basic block; /// must have their PHI nodes updated.; /// Also calls RecursivelyDeleteTriviallyDeadInstructions() on any branch/switch; /// conditions and indirectbr addresses this might make dead if; /// DeleteDeadConditions is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:344,Availability,down,down,344,/// Return true if the result produced by the instruction has no side effects on; /// any paths other than where it is used. This is less conservative than; /// wouldInstructionBeTriviallyDead which is based on the assumption; /// that the use count will be 0. An example usage of this API is for; /// identifying instructions that can be sunk down to use(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:338,Integrability,rout,routine,338,"/// Delete all of the instructions in `DeadInsts`, and all other instructions; /// that deleting these in turn causes to be trivially dead.; ///; /// The initial instructions in the provided vector must all have empty use; /// lists and satisfy `isInstructionTriviallyDead`.; ///; /// `DeadInsts` will be used as scratch storage for this routine and will be; /// empty afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:46,Usability,simpl,simplify,46,"/// Scan the specified basic block and try to simplify any instructions in it; /// and recursively delete dead instructions.; ///; /// This returns true if it changed the code, note that it can delete; /// instructions in other blocks as well in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:118,Modifiability,variab,variable,118,"/// Replace all the uses of an SSA value in @llvm.dbg intrinsics with; /// undef. This is useful for signaling that a variable, e.g. has been; /// found dead and hence it's unavailable at a given program point.; /// Returns true if the dbg values have been changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:204,Performance,optimiz,optimization,204,"/// This function is used to do simplification of a CFG. For example, it; /// adjusts branches to branches to eliminate the extra hop, it eliminates; /// unreachable basic blocks, and does other peephole optimization of the CFG.; /// It returns true if a modification was made, possibly deleting the basic; /// block that was pointed to. LoopHeaders is an optional input parameter; /// providing the set of loop headers that SimplifyCFG should not eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:32,Usability,simpl,simplification,32,"/// This function is used to do simplification of a CFG. For example, it; /// adjusts branches to branches to eliminate the extra hop, it eliminates; /// unreachable basic blocks, and does other peephole optimization of the CFG.; /// It returns true if a modification was made, possibly deleting the basic; /// block that was pointed to. LoopHeaders is an optional input parameter; /// providing the set of loop headers that SimplifyCFG should not eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:425,Usability,Simpl,SimplifyCFG,425,"/// This function is used to do simplification of a CFG. For example, it; /// adjusts branches to branches to eliminate the extra hop, it eliminates; /// unreachable basic blocks, and does other peephole optimization of the CFG.; /// It returns true if a modification was made, possibly deleting the basic; /// block that was pointed to. LoopHeaders is an optional input parameter; /// providing the set of loop headers that SimplifyCFG should not eliminate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:171,Testability,log,logical,171,"/// If this basic block is ONLY a setcc and a branch, and if a predecessor; /// branches to us and one of our successors, fold the setcc into the; /// predecessor and use logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:123,Energy Efficiency,allocate,allocated,123,"/// This function takes a virtual register computed by an Instruction and; /// replaces it with a slot in the stack frame, allocated via alloca.; /// This allows the CFG to be changed around without fear of invalidating the; /// SSA information for the value. It returns the pointer to the alloca inserted; /// to create a stack slot for X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:119,Energy Efficiency,allocate,allocated,119,"/// This function takes a virtual register computed by a phi node and replaces; /// it with a slot in the stack frame, allocated via alloca. The phi node is; /// deleted and it returns the pointer to the alloca inserted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:335,Availability,reliab,reliable,335,"/// If the specified pointer points to an object that we control, try to modify; /// the object's alignment to PrefAlign. Returns a minimum known alignment of; /// the value after the operation, which may be lower than PrefAlign.; ///; /// Increating value alignment isn't often possible though. If alignment is; /// important, a more reliable approach is to simply align all global variables; /// and allocation instructions to their preferred alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:383,Modifiability,variab,variables,383,"/// If the specified pointer points to an object that we control, try to modify; /// the object's alignment to PrefAlign. Returns a minimum known alignment of; /// the value after the operation, which may be lower than PrefAlign.; ///; /// Increating value alignment isn't often possible though. If alignment is; /// important, a more reliable approach is to simply align all global variables; /// and allocation instructions to their preferred alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:359,Usability,simpl,simply,359,"/// If the specified pointer points to an object that we control, try to modify; /// the object's alignment to PrefAlign. Returns a minimum known alignment of; /// the value after the operation, which may be lower than PrefAlign.; ///; /// Increating value alignment isn't often possible though. If alignment is; /// important, a more reliable approach is to simply align all global variables; /// and allocation instructions to their preferred alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:434,Availability,reliab,reliable,434,"/// Try to ensure that the alignment of \p V is at least \p PrefAlign bytes. If; /// the owning object can be modified and has an alignment less than \p; /// PrefAlign, it will be increased and \p PrefAlign returned. If the alignment; /// cannot be increased, the known alignment of the value is returned.; ///; /// It is not always possible to modify the alignment of the underlying object,; /// so if alignment is important, a more reliable approach is to simply align; /// all global variables and allocation instructions to their preferred; /// alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:487,Modifiability,variab,variables,487,"/// Try to ensure that the alignment of \p V is at least \p PrefAlign bytes. If; /// the owning object can be modified and has an alignment less than \p; /// PrefAlign, it will be increased and \p PrefAlign returned. If the alignment; /// cannot be increased, the known alignment of the value is returned.; ///; /// It is not always possible to modify the alignment of the underlying object,; /// so if alignment is important, a more reliable approach is to simply align; /// all global variables and allocation instructions to their preferred; /// alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:458,Usability,simpl,simply,458,"/// Try to ensure that the alignment of \p V is at least \p PrefAlign bytes. If; /// the owning object can be modified and has an alignment less than \p; /// PrefAlign, it will be increased and \p PrefAlign returned. If the alignment; /// cannot be increased, the known alignment of the value is returned.; ///; /// It is not always possible to modify the alignment of the underlying object,; /// so if alignment is important, a more reliable approach is to simply align; /// all global variables and allocation instructions to their preferred; /// alignment from the beginning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:48,Performance,load,load,48,/// Inserts a llvm.dbg.value intrinsic before a load of an alloca'd value; /// that has an associated llvm.dbg.declare intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:643,Deployability,update,updates,643,"/// Point debug users of \p From to \p To or salvage them. Use this function; /// only when replacing all uses of \p From with \p To, with a guarantee that; /// \p From is going to be deleted.; ///; /// Follow these rules to prevent use-before-def of \p To:; /// . If \p To is a linked Instruction, set \p DomPoint to \p To.; /// . If \p To is an unlinked Instruction, set \p DomPoint to the Instruction; /// \p To will be inserted after.; /// . If \p To is not an Instruction (e.g a Constant), the choice of; /// \p DomPoint is arbitrary. Pick \p From for simplicity.; ///; /// If a debug user cannot be preserved without reordering variable updates or; /// introducing a use-before-def, it is either salvaged (\ref salvageDebugInfo); /// or deleted. Returns true if any debug users were updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:789,Deployability,update,updated,789,"/// Point debug users of \p From to \p To or salvage them. Use this function; /// only when replacing all uses of \p From with \p To, with a guarantee that; /// \p From is going to be deleted.; ///; /// Follow these rules to prevent use-before-def of \p To:; /// . If \p To is a linked Instruction, set \p DomPoint to \p To.; /// . If \p To is an unlinked Instruction, set \p DomPoint to the Instruction; /// \p To will be inserted after.; /// . If \p To is not an Instruction (e.g a Constant), the choice of; /// \p DomPoint is arbitrary. Pick \p From for simplicity.; ///; /// If a debug user cannot be preserved without reordering variable updates or; /// introducing a use-before-def, it is either salvaged (\ref salvageDebugInfo); /// or deleted. Returns true if any debug users were updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:634,Modifiability,variab,variable,634,"/// Point debug users of \p From to \p To or salvage them. Use this function; /// only when replacing all uses of \p From with \p To, with a guarantee that; /// \p From is going to be deleted.; ///; /// Follow these rules to prevent use-before-def of \p To:; /// . If \p To is a linked Instruction, set \p DomPoint to \p To.; /// . If \p To is an unlinked Instruction, set \p DomPoint to the Instruction; /// \p To will be inserted after.; /// . If \p To is not an Instruction (e.g a Constant), the choice of; /// \p DomPoint is arbitrary. Pick \p From for simplicity.; ///; /// If a debug user cannot be preserved without reordering variable updates or; /// introducing a use-before-def, it is either salvaged (\ref salvageDebugInfo); /// or deleted. Returns true if any debug users were updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:557,Usability,simpl,simplicity,557,"/// Point debug users of \p From to \p To or salvage them. Use this function; /// only when replacing all uses of \p From with \p To, with a guarantee that; /// \p From is going to be deleted.; ///; /// Follow these rules to prevent use-before-def of \p To:; /// . If \p To is a linked Instruction, set \p DomPoint to \p To.; /// . If \p To is an unlinked Instruction, set \p DomPoint to the Instruction; /// \p To will be inserted after.; /// . If \p To is not an Instruction (e.g a Constant), the choice of; /// \p DomPoint is arbitrary. Pick \p From for simplicity.; ///; /// If a debug user cannot be preserved without reordering variable updates or; /// introducing a use-before-def, it is either salvaged (\ref salvageDebugInfo); /// or deleted. Returns true if any debug users were updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:123,Deployability,Update,Updates,123,"/// Replace 'BB's terminator with one that does not have an unwind successor; /// block. Rewrites `invoke` to `call`, etc. Updates any PHIs in unwind; /// successor. Returns the instruction that replaced the original terminator,; /// which might be a call in case the original terminator was an invoke.; ///; /// \param BB Block whose terminator will be replaced. Its terminator must; /// have an unwind successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:89,Modifiability,Rewrite,Rewrites,89,"/// Replace 'BB's terminator with one that does not have an unwind successor; /// block. Rewrites `invoke` to `call`, etc. Updates any PHIs in unwind; /// successor. Returns the instruction that replaced the original terminator,; /// which might be a call in case the original terminator was an invoke.; ///; /// \param BB Block whose terminator will be replaced. Its terminator must; /// have an unwind successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:4,Deployability,Patch,Patch,4,/// Patch the replacement so that it is not more restrictive than the value; /// being replaced. It assumes that the replacement does not get moved from; /// its original position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:109,Safety,safe,safepoint,109,"/// Return true if this call calls a gc leaf function.; ///; /// A leaf function is a function that does not safepoint the thread during its; /// execution. During a call or invoke to such a function, the callers stack; /// does not have to be made parseable.; ///; /// Most passes can and should ignore this information, and it is only used; /// during lowering by the GC infrastructure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:42,Performance,load,load,42,/// Copy a nonnull metadata node to a new load instruction.; ///; /// This handles mapping it to range metadata if the new load is an integer; /// load instead of a pointer load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:123,Performance,load,load,123,/// Copy a nonnull metadata node to a new load instruction.; ///; /// This handles mapping it to range metadata if the new load is an integer; /// load instead of a pointer load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:147,Performance,load,load,147,/// Copy a nonnull metadata node to a new load instruction.; ///; /// This handles mapping it to range metadata if the new load is an integer; /// load instead of a pointer load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:173,Performance,load,load,173,/// Copy a nonnull metadata node to a new load instruction.; ///; /// This handles mapping it to range metadata if the new load is an integer; /// load instead of a pointer load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:40,Performance,load,load,40,/// Copy a range metadata node to a new load instruction.; ///; /// This handles mapping it to nonnull metadata if the new load is a pointer; /// load instead of an integer load and the range doesn't cover null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:123,Performance,load,load,123,/// Copy a range metadata node to a new load instruction.; ///; /// This handles mapping it to nonnull metadata if the new load is a pointer; /// load instead of an integer load and the range doesn't cover null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:146,Performance,load,load,146,/// Copy a range metadata node to a new load instruction.; ///; /// This handles mapping it to nonnull metadata if the new load is a pointer; /// load instead of an integer load and the range doesn't cover null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:173,Performance,load,load,173,/// Copy a range metadata node to a new load instruction.; ///; /// This handles mapping it to nonnull metadata if the new load is a pointer; /// load instead of an integer load and the range doesn't cover null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:309,Safety,avoid,avoid,309,"//===----------------------------------------------------------------------===//; // Sanitizer utilities; //; /// Given a CallInst, check if it calls a string function known to CodeGen,; /// and mark it with NoBuiltin if so. To be used by sanitizers that intend; /// to intercept string functions and want to avoid converting them to target; /// specific instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:85,Security,Sanitiz,Sanitizer,85,"//===----------------------------------------------------------------------===//; // Sanitizer utilities; //; /// Given a CallInst, check if it calls a string function known to CodeGen,; /// and mark it with NoBuiltin if so. To be used by sanitizers that intend; /// to intercept string functions and want to avoid converting them to target; /// specific instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:239,Security,sanitiz,sanitizers,239,"//===----------------------------------------------------------------------===//; // Sanitizer utilities; //; /// Given a CallInst, check if it calls a string function known to CodeGen,; /// and mark it with NoBuiltin if so. To be used by sanitizers that intend; /// to intercept string functions and want to avoid converting them to target; /// specific instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:367,Modifiability,variab,variable,367,"// Keeps track of the structure of a loop. This is similar to llvm::Loop,; // except that it is more lightweight and can track the state of a loop through; // changing and potentially invalid IR. This structure also formalizes the; // kinds of loops we can deal with -- ones that have a single latch that is also; // an exiting block *and* have a canonical induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:308,Modifiability,variab,variable,308,"/// This class is used to constrain loops to run within a given iteration space.; /// The algorithm this class implements is given a Loop and a range [Begin,; /// End). The algorithm then tries to break out a ""main loop"" out of the loop; /// it is given in a way that the ""main loop"" runs with the induction variable; /// in a subset of [Begin, End). The algorithm emits appropriate pre and post; /// loops to run any remaining iterations. The pre loop runs any iterations in; /// which the induction variable is < Begin, and the post loop runs any; /// iterations in which the induction variable is >= End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:501,Modifiability,variab,variable,501,"/// This class is used to constrain loops to run within a given iteration space.; /// The algorithm this class implements is given a Loop and a range [Begin,; /// End). The algorithm then tries to break out a ""main loop"" out of the loop; /// it is given in a way that the ""main loop"" runs with the induction variable; /// in a subset of [Begin, End). The algorithm emits appropriate pre and post; /// loops to run any remaining iterations. The pre loop runs any iterations in; /// which the induction variable is < Begin, and the post loop runs any; /// iterations in which the induction variable is >= End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:588,Modifiability,variab,variable,588,"/// This class is used to constrain loops to run within a given iteration space.; /// The algorithm this class implements is given a Loop and a range [Begin,; /// End). The algorithm then tries to break out a ""main loop"" out of the loop; /// it is given in a way that the ""main loop"" runs with the induction variable; /// in a subset of [Begin, End). The algorithm emits appropriate pre and post; /// loops to run any remaining iterations. The pre loop runs any iterations in; /// which the induction variable is < Begin, and the post loop runs any; /// iterations in which the induction variable is >= End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the iteration space of the loop denoted by (LS, Preheader). The; // iteration space of the rewritten loop ends at ExitLoopAt. The start of the; // iteration space is not changed. `ExitLoopAt' is assumed to be slt; // `OriginalHeaderCount'.; //; // If there are iterations left to execute, control is made to jump to; // `ContinuationBlock', otherwise they take the normal loop exit. The; // returned `RewrittenRangeInfo' object is populated as follows:; //; // .PseudoExit is a basic block that unconditionally branches to; // `ContinuationBlock'.; //; // .ExitSelector is a basic block that decides, on exit from the loop,; // whether to branch to the ""true"" exit or to `PseudoExit'.; //; // .PHIValuesAtPseudoExit are PHINodes in `PseudoExit' that compute the value; // for each PHINode in the loop header on taking the pseudo exit.; //; // After changeIterationSpaceEnd, `Preheader' is no longer a legitimate; // preheader because it is made to branch to the loop header only; // conditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h:177,Modifiability,rewrite,rewrites,177,// `ContinuationBlockAndPreheader' was the continuation block for some call to; // `changeIterationSpaceEnd' and is the preheader to the loop denoted by `LS'.; // This function rewrites the PHI nodes in `LS.Header' to start with the; // correct value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopConstrainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:42,Performance,perform,perform,42,"//===- LoopRotationUtils.h - Utilities to perform loop rotation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides utilities to convert a loop into a loop with bottom test.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:454,Testability,test,test,454,"//===- LoopRotationUtils.h - Utilities to perform loop rotation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides utilities to convert a loop into a loop with bottom test.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:61,Performance,perform,perform,61,"/// Convert a loop into a loop with bottom test. It may; /// perform loop latch simplication as well if the flag RotationOnly; /// is false. The flag Threshold represents the size threshold of the loop; /// header. If the loop header's size exceeds the threshold, the loop rotation; /// will give up. The flag IsUtilMode controls the heuristic used in the; /// LoopRotation. If it is true, the profitability heuristic will be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:43,Testability,test,test,43,"/// Convert a loop into a loop with bottom test. It may; /// perform loop latch simplication as well if the flag RotationOnly; /// is false. The flag Threshold represents the size threshold of the loop; /// header. If the loop header's size exceeds the threshold, the loop rotation; /// will give up. The flag IsUtilMode controls the heuristic used in the; /// LoopRotation. If it is true, the profitability heuristic will be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:80,Usability,simpl,simplication,80,"/// Convert a loop into a loop with bottom test. It may; /// perform loop latch simplication as well if the flag RotationOnly; /// is false. The flag Threshold represents the size threshold of the loop; /// header. If the loop header's size exceeds the threshold, the loop rotation; /// will give up. The flag IsUtilMode controls the heuristic used in the; /// LoopRotation. If it is true, the profitability heuristic will be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:1727,Deployability,update,updates,1727,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:393,Performance,perform,performs,393,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:464,Usability,simpl,simpler,464,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:530,Usability,simpl,simpler,530,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:709,Usability,simpl,simplifies,709,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:1050,Usability,simpl,simplifies,1050,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:1522,Usability,simpl,simplifycfg,1522,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:223,Deployability,update,update,223,"/// Simplify each loop in a loop nest recursively.; ///; /// This takes a potentially un-simplified loop L (and its children) and turns; /// it into a simplified loop nest with preheaders and single backedges. It will; /// update \c DominatorTree, \c LoopInfo, \c ScalarEvolution and \c MemorySSA; /// analyses if they're non-null, and LCSSA if \c PreserveLCSSA is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:4,Usability,Simpl,Simplify,4,"/// Simplify each loop in a loop nest recursively.; ///; /// This takes a potentially un-simplified loop L (and its children) and turns; /// it into a simplified loop nest with preheaders and single backedges. It will; /// update \c DominatorTree, \c LoopInfo, \c ScalarEvolution and \c MemorySSA; /// analyses if they're non-null, and LCSSA if \c PreserveLCSSA is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:89,Usability,simpl,simplified,89,"/// Simplify each loop in a loop nest recursively.; ///; /// This takes a potentially un-simplified loop L (and its children) and turns; /// it into a simplified loop nest with preheaders and single backedges. It will; /// update \c DominatorTree, \c LoopInfo, \c ScalarEvolution and \c MemorySSA; /// analyses if they're non-null, and LCSSA if \c PreserveLCSSA is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:151,Usability,simpl,simplified,151,"/// Simplify each loop in a loop nest recursively.; ///; /// This takes a potentially un-simplified loop L (and its children) and turns; /// it into a simplified loop nest with preheaders and single backedges. It will; /// update \c DominatorTree, \c LoopInfo, \c ScalarEvolution and \c MemorySSA; /// analyses if they're non-null, and LCSSA if \c PreserveLCSSA is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:202,Deployability,update,update,202,"/// Ensure that all exit blocks of the loop are dedicated exits.; ///; /// For any loop exit block with non-loop predecessors, we split the loop; /// predecessors to use a dedicated loop exit block. We update the dominator; /// tree and loop info if provided, and will preserve LCSSA if requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:351,Integrability,rout,routine,351,"/// Ensures LCSSA form for every instruction from the Worklist in the scope of; /// innermost containing loop.; ///; /// For the given instruction which have uses outside of the loop, an LCSSA PHI; /// node is inserted and the uses outside the loop are rewritten to use this; /// node.; ///; /// LoopInfo and DominatorTree are required and, since the routine makes no; /// changes to CFG, preserved.; ///; /// Returns true if any modifications are made.; ///; /// This function may introduce unused PHI nodes. If \p PHIsToRemove is not; /// nullptr, those are added to it (before removing, the caller has to check if; /// they still do not have any uses). Otherwise the PHIs are directly removed.; ///; /// If \p InsertedPHIs is not nullptr, inserted phis will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:107,Security,access,access,107,/// Flags controlling how much is checked when sinking or hoisting; /// instructions. The number of memory access in the loop (and whether there; /// are too many) is determined in the constructors when using MemorySSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:471,Safety,safe,safety,471,"/// Walk the specified region of the CFG (defined by all blocks; /// dominated by the specified block, and that are in the current loop) in; /// reverse depth first order w.r.t the DominatorTree. This allows us to visit; /// uses before definitions, allowing us to sink a loop body in one pass without; /// iteration. Takes DomTreeNode, AAResults, LoopInfo, DominatorTree,; /// TargetLibraryInfo, Loop, AliasSet information for all; /// instructions of the loop and loop safety information as; /// arguments. Diagnostics is emitted via \p ORE. It returns changed status.; /// \p CurLoop is a loop to do sinking on. \p OutermostLoop is used only when; /// this function is called by \p sinkRegionForLoopNest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:464,Safety,safe,safety,464,"/// Walk the specified region of the CFG (defined by all blocks; /// dominated by the specified block, and that are in the current loop) in depth; /// first order w.r.t the DominatorTree. This allows us to visit definitions; /// before uses, allowing us to hoist a loop body in one pass without iteration.; /// Takes DomTreeNode, AAResults, LoopInfo, DominatorTree,; /// TargetLibraryInfo, Loop, AliasSet information for all; /// instructions of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:694,Safety,safe,safe,694,"/// Walk the specified region of the CFG (defined by all blocks; /// dominated by the specified block, and that are in the current loop) in depth; /// first order w.r.t the DominatorTree. This allows us to visit definitions; /// before uses, allowing us to hoist a loop body in one pass without iteration.; /// Takes DomTreeNode, AAResults, LoopInfo, DominatorTree,; /// TargetLibraryInfo, Loop, AliasSet information for all; /// instructions of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:33,Modifiability,variab,variable,33,/// Return true if the induction variable \p IV in a Loop whose latch is; /// \p LatchBlock would become dead if the exit test \p Cond were removed.; /// Conservatively returns false if analysis is insufficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:122,Testability,test,test,122,/// Return true if the induction variable \p IV in a Loop whose latch is; /// \p LatchBlock would become dead if the exit test \p Cond were removed.; /// Conservatively returns false if analysis is insufficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:339,Deployability,update,updates,339,"/// This function deletes dead loops. The caller of this function needs to; /// guarantee that the loop is infact dead.; /// The function requires a bunch or prerequisites to be present:; /// - The loop needs to be in LCSSA form; /// - The loop needs to have a Preheader; /// - A unique dedicated exit block must exist; ///; /// This also updates the relevant analysis information in \p DT, \p SE, \p LI; /// and \p MSSA if pointers to those are provided.; /// It also updates the loop PM if an updater struct is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:469,Deployability,update,updates,469,"/// This function deletes dead loops. The caller of this function needs to; /// guarantee that the loop is infact dead.; /// The function requires a bunch or prerequisites to be present:; /// - The loop needs to be in LCSSA form; /// - The loop needs to have a Preheader; /// - A unique dedicated exit block must exist; ///; /// This also updates the relevant analysis information in \p DT, \p SE, \p LI; /// and \p MSSA if pointers to those are provided.; /// It also updates the loop PM if an updater struct is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:495,Deployability,update,updater,495,"/// This function deletes dead loops. The caller of this function needs to; /// guarantee that the loop is infact dead.; /// The function requires a bunch or prerequisites to be present:; /// - The loop needs to be in LCSSA form; /// - The loop needs to have a Preheader; /// - A unique dedicated exit block must exist; ///; /// This also updates the relevant analysis information in \p DT, \p SE, \p LI; /// and \p MSSA if pointers to those are provided.; /// It also updates the loop PM if an updater struct is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:94,Performance,load,loads,94,"/// Try to promote memory values to scalars by sinking stores out of; /// the loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant. It takes a set of must-alias values, Loop exit blocks; /// vector, loop exit blocks insertion point vector, PredIteratorCache,; /// LoopInfo, DominatorTree, Loop, AliasSet information for all instructions; /// of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:474,Safety,safe,safety,474,"/// Try to promote memory values to scalars by sinking stores out of; /// the loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant. It takes a set of must-alias values, Loop exit blocks; /// vector, loop exit blocks insertion point vector, PredIteratorCache,; /// LoopInfo, DominatorTree, Loop, AliasSet information for all instructions; /// of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:704,Safety,safe,safe,704,"/// Try to promote memory values to scalars by sinking stores out of; /// the loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant. It takes a set of must-alias values, Loop exit blocks; /// vector, loop exit blocks insertion point vector, PredIteratorCache,; /// LoopInfo, DominatorTree, Loop, AliasSet information for all instructions; /// of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:94,Performance,scalab,scalable,94,"/// Find a combination of metadata (""llvm.loop.vectorize.width"" and; /// ""llvm.loop.vectorize.scalable.enable"") for a loop and use it to construct a; /// ElementCount. If the metadata ""llvm.loop.vectorize.width"" cannot be found; /// then std::nullopt is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:282,Modifiability,Inherit,InheritOptionsAttrsPrefix,282,"/// Create a new loop identifier for a loop created from a loop transformation.; ///; /// @param OrigLoopID The loop ID of the loop before the transformation.; /// @param FollowupAttrs List of attribute names that contain attributes to be; /// added to the new loop ID.; /// @param InheritOptionsAttrsPrefix Selects which attributes should be inherited; /// from the original loop. The following values; /// are considered:; /// nullptr : Inherit all attributes from @p OrigLoopID.; /// """" : Do not inherit any attribute from @p OrigLoopID; only use; /// those specified by a followup attribute.; /// ""<prefix>"": Inherit all attributes except those which start with; /// <prefix>; commonly used to remove metadata for the; /// applied transformation.; /// @param AlwaysNew If true, do not try to reuse OrigLoopID and never return; /// std::nullopt.; ///; /// @return The loop ID for the after-transformation loop. The following values; /// can be returned:; /// std::nullopt : No followup attribute was found; it is up to the; /// transformation to choose attributes that make sense.; /// @p OrigLoopID: The original identifier can be reused.; /// nullptr : The new loop has no attributes.; /// MDNode* : A new unique loop identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:343,Modifiability,inherit,inherited,343,"/// Create a new loop identifier for a loop created from a loop transformation.; ///; /// @param OrigLoopID The loop ID of the loop before the transformation.; /// @param FollowupAttrs List of attribute names that contain attributes to be; /// added to the new loop ID.; /// @param InheritOptionsAttrsPrefix Selects which attributes should be inherited; /// from the original loop. The following values; /// are considered:; /// nullptr : Inherit all attributes from @p OrigLoopID.; /// """" : Do not inherit any attribute from @p OrigLoopID; only use; /// those specified by a followup attribute.; /// ""<prefix>"": Inherit all attributes except those which start with; /// <prefix>; commonly used to remove metadata for the; /// applied transformation.; /// @param AlwaysNew If true, do not try to reuse OrigLoopID and never return; /// std::nullopt.; ///; /// @return The loop ID for the after-transformation loop. The following values; /// can be returned:; /// std::nullopt : No followup attribute was found; it is up to the; /// transformation to choose attributes that make sense.; /// @p OrigLoopID: The original identifier can be reused.; /// nullptr : The new loop has no attributes.; /// MDNode* : A new unique loop identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:439,Modifiability,Inherit,Inherit,439,"/// Create a new loop identifier for a loop created from a loop transformation.; ///; /// @param OrigLoopID The loop ID of the loop before the transformation.; /// @param FollowupAttrs List of attribute names that contain attributes to be; /// added to the new loop ID.; /// @param InheritOptionsAttrsPrefix Selects which attributes should be inherited; /// from the original loop. The following values; /// are considered:; /// nullptr : Inherit all attributes from @p OrigLoopID.; /// """" : Do not inherit any attribute from @p OrigLoopID; only use; /// those specified by a followup attribute.; /// ""<prefix>"": Inherit all attributes except those which start with; /// <prefix>; commonly used to remove metadata for the; /// applied transformation.; /// @param AlwaysNew If true, do not try to reuse OrigLoopID and never return; /// std::nullopt.; ///; /// @return The loop ID for the after-transformation loop. The following values; /// can be returned:; /// std::nullopt : No followup attribute was found; it is up to the; /// transformation to choose attributes that make sense.; /// @p OrigLoopID: The original identifier can be reused.; /// nullptr : The new loop has no attributes.; /// MDNode* : A new unique loop identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:499,Modifiability,inherit,inherit,499,"/// Create a new loop identifier for a loop created from a loop transformation.; ///; /// @param OrigLoopID The loop ID of the loop before the transformation.; /// @param FollowupAttrs List of attribute names that contain attributes to be; /// added to the new loop ID.; /// @param InheritOptionsAttrsPrefix Selects which attributes should be inherited; /// from the original loop. The following values; /// are considered:; /// nullptr : Inherit all attributes from @p OrigLoopID.; /// """" : Do not inherit any attribute from @p OrigLoopID; only use; /// those specified by a followup attribute.; /// ""<prefix>"": Inherit all attributes except those which start with; /// <prefix>; commonly used to remove metadata for the; /// applied transformation.; /// @param AlwaysNew If true, do not try to reuse OrigLoopID and never return; /// std::nullopt.; ///; /// @return The loop ID for the after-transformation loop. The following values; /// can be returned:; /// std::nullopt : No followup attribute was found; it is up to the; /// transformation to choose attributes that make sense.; /// @p OrigLoopID: The original identifier can be reused.; /// nullptr : The new loop has no attributes.; /// MDNode* : A new unique loop identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:613,Modifiability,Inherit,Inherit,613,"/// Create a new loop identifier for a loop created from a loop transformation.; ///; /// @param OrigLoopID The loop ID of the loop before the transformation.; /// @param FollowupAttrs List of attribute names that contain attributes to be; /// added to the new loop ID.; /// @param InheritOptionsAttrsPrefix Selects which attributes should be inherited; /// from the original loop. The following values; /// are considered:; /// nullptr : Inherit all attributes from @p OrigLoopID.; /// """" : Do not inherit any attribute from @p OrigLoopID; only use; /// those specified by a followup attribute.; /// ""<prefix>"": Inherit all attributes except those which start with; /// <prefix>; commonly used to remove metadata for the; /// applied transformation.; /// @param AlwaysNew If true, do not try to reuse OrigLoopID and never return; /// std::nullopt.; ///; /// @return The loop ID for the after-transformation loop. The following values; /// can be returned:; /// std::nullopt : No followup attribute was found; it is up to the; /// transformation to choose attributes that make sense.; /// @p OrigLoopID: The original identifier can be reused.; /// nullptr : The new loop has no attributes.; /// MDNode* : A new unique loop identifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:127,Deployability,update,update,127,/// @}; /// Set input string into loop metadata by keeping other values intact.; /// If the string is already in loop metadata update value if it is; /// different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:207,Deployability,update,updated,207,"/// Set a loop's branch weight metadata to reflect that loop has \p; /// EstimatedTripCount iterations and \p EstimatedLoopInvocationWeight exits; /// through latch. Returns true if metadata is successfully updated, false; /// otherwise. Note that loop must have a latch block which controls loop exit; /// in order to succeed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:110,Availability,fault,faults,110,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:144,Availability,fault,faulting,144,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:242,Energy Efficiency,efficient,efficiently,242,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:271,Integrability,rout,routine,271,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:487,Performance,load,loads,487,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:621,Performance,optimiz,optimization,621,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:60,Energy Efficiency,reduce,reduce,60,/// Generates an ordered vector reduction using extracts to reduce the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:57,Energy Efficiency,reduce,reduce,57,/// Generates a vector reduction using shufflevectors to reduce the value.; /// Fast-math-flags are propagated using the IRBuilder's setting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:26,Testability,log,logical,26,"/// Get the intersection (logical and) of all of the potential IR flags; /// of each scalar operation (VL) that will be converted into a vector (I).; /// If OpValue is non-null, we only consider operations similar to OpValue; /// when intersecting.; /// Flag set: NSW, NUW (if IncludeWrapFlags is true), exact, and all of; /// fast-math.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:495,Deployability,update,updated,495,"/// Set weights for \p UnrolledLoop and \p RemainderLoop based on weights for; /// \p OrigLoop and the following distribution of \p OrigLoop iteration among \p; /// UnrolledLoop and \p RemainderLoop. \p UnrolledLoop receives weights that; /// reflect TC/UF iterations, and \p RemainderLoop receives weights that reflect; /// the remaining TC%UF iterations.; ///; /// Note that \p OrigLoop may be equal to either \p UnrolledLoop or \p; /// RemainderLoop in which case weights for \p OrigLoop are updated accordingly.; /// Note also behavior is undefined if \p UnrolledLoop and \p RemainderLoop are; /// equal. \p UF must be greater than zero.; /// If \p OrigLoop has no profile info associated nothing happens.; ///; /// This utility may be useful for such optimizations as unroller and; /// vectorizer as it's typical transformation for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:756,Performance,optimiz,optimizations,756,"/// Set weights for \p UnrolledLoop and \p RemainderLoop based on weights for; /// \p OrigLoop and the following distribution of \p OrigLoop iteration among \p; /// UnrolledLoop and \p RemainderLoop. \p UnrolledLoop receives weights that; /// reflect TC/UF iterations, and \p RemainderLoop receives weights that reflect; /// the remaining TC%UF iterations.; ///; /// Note that \p OrigLoop may be equal to either \p UnrolledLoop or \p; /// RemainderLoop in which case weights for \p OrigLoop are updated accordingly.; /// Note also behavior is undefined if \p UnrolledLoop and \p RemainderLoop are; /// equal. \p UF must be greater than zero.; /// If \p OrigLoop has no profile info associated nothing happens.; ///; /// This utility may be useful for such optimizations as unroller and; /// vectorizer as it's typical transformation for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:453,Usability,simpl,simplifications,453,"/// Utility that implements appending of loops onto a worklist given LoopInfo.; /// Calls the templated utility taking a Range of loops, handing it the Loops; /// in LoopInfo, iterated in reverse. This is because the loops are stored in; /// RPO w.r.t. the control flow graph in LoopInfo. For the purpose of unrolling,; /// loop deletion, and LICM, we largely want to work forward across the CFG so; /// that we visit defs before uses and can propagate simplifications from one; /// loop nest into the next. Calls appendReversedLoopsToWorklist with the; /// already reversed loops in LI.; /// FIXME: Consider changing the order in LoopInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:43,Security,access,accessed,43,/// Add code that checks at runtime if the accessed arrays in \p PointerChecks; /// overlap. Returns the final comparator value or NULL if no check is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:695,Deployability,update,update,695,"/// Check if the loop header has a conditional branch that is not; /// loop-invariant, because it involves load instructions. If all paths from; /// either the true or false successor to the header or loop exists do not; /// modify the memory feeding the condition, perform 'partial unswitching'. That; /// is, duplicate the instructions feeding the condition in the pre-header. Then; /// unswitch on the duplicated condition. The condition is now known in the; /// unswitched version for the 'invariant' path through the original loop.; ///; /// If the branch condition of the header is partially invariant, return a pair; /// containing the instructions to duplicate and a boolean Constant to update; /// the condition in the loops created for the true or false successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:107,Performance,load,load,107,"/// Check if the loop header has a conditional branch that is not; /// loop-invariant, because it involves load instructions. If all paths from; /// either the true or false successor to the header or loop exists do not; /// modify the memory feeding the condition, perform 'partial unswitching'. That; /// is, duplicate the instructions feeding the condition in the pre-header. Then; /// unswitch on the duplicated condition. The condition is now known in the; /// unswitched version for the 'invariant' path through the original loop.; ///; /// If the branch condition of the header is partially invariant, return a pair; /// containing the instructions to duplicate and a boolean Constant to update; /// the condition in the loops created for the true or false successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:266,Performance,perform,perform,266,"/// Check if the loop header has a conditional branch that is not; /// loop-invariant, because it involves load instructions. If all paths from; /// either the true or false successor to the header or loop exists do not; /// modify the memory feeding the condition, perform 'partial unswitching'. That; /// is, duplicate the instructions feeding the condition in the pre-header. Then; /// unswitch on the duplicated condition. The condition is now known in the; /// unswitched version for the 'invariant' path through the original loop.; ///; /// If the branch condition of the header is partially invariant, return a pair; /// containing the instructions to duplicate and a boolean Constant to update; /// the condition in the loops created for the true or false successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:420,Performance,perform,perform,420,"//===- LoopVersioning.h - Utility to version a loop -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:514,Security,access,accesses,514,"//===- LoopVersioning.h - Utility to version a loop -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:108,Deployability,update,updates,108,"/// Performs the CFG manipulation part of versioning the loop including; /// the DominatorTree and LoopInfo updates.; ///; /// The loop that was used to construct the class will be the ""versioned"" loop; /// i.e. the loop that will receive control if all the memchecks pass.; ///; /// This allows the loop transform pass to operate on the same loop regardless; /// of whether versioning was necessary or not:; ///; /// for each loop L:; /// analyze L; /// if versioning is necessary version L; /// transform L",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:4,Performance,Perform,Performs,4,"/// Performs the CFG manipulation part of versioning the loop including; /// the DominatorTree and LoopInfo updates.; ///; /// The loop that was used to construct the class will be the ""versioned"" loop; /// i.e. the loop that will receive control if all the memchecks pass.; ///; /// This allows the loop transform pass to operate on the same loop regardless; /// of whether versioning was necessary or not:; ///; /// for each loop L:; /// analyze L; /// if versioning is necessary version L; /// transform L",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:137,Integrability,wrap,wrapper,137,/// Annotate memory instructions in the versioned loop with no-alias; /// metadata based on the memchecks issued.; ///; /// This is just wrapper that calls prepareNoAliasMetadata and; /// annotateInstWithNoAlias on the instructions of the versioned loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:4,Security,Expose,Expose,4,/// Expose LoopVersioning as a pass. Currently this is only used for; /// unit-testing. It adds all memchecks necessary to remove all may-aliasing; /// array accesses from the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:158,Security,access,accesses,158,/// Expose LoopVersioning as a pass. Currently this is only used for; /// unit-testing. It adds all memchecks necessary to remove all may-aliasing; /// array accesses from the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:79,Testability,test,testing,79,/// Expose LoopVersioning as a pass. Currently this is only used for; /// unit-testing. It adds all memchecks necessary to remove all may-aliasing; /// array accesses from the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h:45,Performance,load,load,45,/// Convert the given Cmpxchg into primitive load and compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h:42,Performance,load,load,42,"/// Convert the given RMWI into primitive load and stores,; /// assuming that doing so is legal. Return true if the lowering; /// succeeds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerGlobalDtors.h:431,Integrability,wrap,wrapper,431,"//===- LowerGlobalDtors.h - Lower @llvm.global_dtors ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers @llvm.global_dtors by creating wrapper functions that are; // registered in @llvm.global_ctors and which contain a call to `__cxa_atexit`; // to register their destructor functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerGlobalDtors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerGlobalDtors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h:127,Performance,load,loader,127,/// Pass to replace calls to ifuncs with indirect calls. This could be used to; /// support ifunc on systems where the program loader does not natively support; /// it. Constant initializer uses of ifuncs are not handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerInvoke.h:668,Usability,simpl,simplifycfg,668,"//===- LowerInvoke.h - Eliminate Invoke instructions ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is designed for use by code generators which do not yet; // support stack unwinding. This pass converts 'invoke' instructions to 'call'; // instructions, so that any exception-handling 'landingpad' blocks become dead; // code (which can be removed by running the '-simplifycfg' pass afterwards).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerInvoke.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerInvoke.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerSwitch.h:414,Modifiability,rewrite,rewrites,414,"//===- LowerSwitch.h - Eliminate Switch instructions ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LowerSwitch transformation rewrites switch instructions with a sequence; // of branches, which allows targets to get away with not implementing the; // switch instruction until it is convenient.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerSwitch.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerSwitch.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h:14,Deployability,update,updated,14,/// The index updated on every iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h:94,Deployability,Update,Updates,94,"/// Creates a new loop with header, body and latch blocks that iterates from; /// [0, Bound). Updates \p Preheader to branch to the new header and uses \p; /// Exit as exit block. Adds the new loop blocks to \L and applies dominator; /// tree updates to \p DTU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h:243,Deployability,update,updates,243,"/// Creates a new loop with header, body and latch blocks that iterates from; /// [0, Bound). Updates \p Preheader to branch to the new header and uses \p; /// Exit as exit block. Adds the new loop blocks to \L and applies dominator; /// tree updates to \p DTU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MatrixUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h:40,Integrability,wrap,wrapper,40,"//===- Mem2Reg.h - The -mem2reg pass, a wrapper around the Utils lib ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h:410,Integrability,wrap,wrapper,410,"//===- Mem2Reg.h - The -mem2reg pass, a wrapper around the Utils lib ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h:463,Security,expose,exposed,463,"//===- Mem2Reg.h - The -mem2reg pass, a wrapper around the Utils lib ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h:398,Usability,simpl,simple,398,"//===- Mem2Reg.h - The -mem2reg pass, a wrapper around the Utils lib ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Mem2Reg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h:97,Testability,log,logic,97,"// FIXME: Once we get to more remarks like this one, we need to re-evaluate how; // much of this logic should actually go into the remark emitter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h:44,Modifiability,variab,variable,44,"/// Gather more information about \p V as a variable. This can be debug info,; /// information from the alloca, etc. Since \p V can represent more than a; /// single variable, they will all be added to the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h:166,Modifiability,variab,variable,166,"/// Gather more information about \p V as a variable. This can be debug info,; /// information from the alloca, etc. Since \p V can represent more than a; /// single variable, they will all be added to the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MemoryOpRemark.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h:421,Integrability,message,messages,421,"//===--- MisExpect.h - Check the use of llvm.expect with PGO data ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This contains code to emit diagnostic messages for potentially incorrect; // usage of the llvm.expect intrinsic. This utility extracts the threshold; // values from metadata associated with the instrumented Branch or Switch; // instruction. The threshold values are then used to determine if a diagnostic; // should be emitted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h:460,Integrability,wrap,wrapper,460,"/// checkExpectAnnotations - compares PGO counters to the thresholds used; /// for llvm.expect and warns if the PGO counters are outside of the expected; /// range. It extracts the expected weights from the MD_prof weights attatched; /// to the instruction, which are assumed to come from lowered llvm.expect; /// intrinsics. The RealWeights parameter and the extracted expected weights are; /// then passed to verifyMisexpect() for verification. It is a thin wrapper; /// around the checkFrontendInstrumentation and checkBackendInstrumentation APIs; ///; /// \param I The Instruction being checked; /// \param ExistingWeights A vector of profile weights for each target block; /// \param IsFrontend A boolean describing if this is Frontend instrumentation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/MisExpect.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:408,Performance,perform,perform,408,"//===-- ModuleUtils.h - Functions to manipulate Modules ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on Modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:88,Integrability,wrap,wraps,88,/// Append F to the list of global ctors of module M with the given Priority.; /// This wraps the function in the appropriate structure and stores it along; /// side other global constructors. For details see; /// https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:278,Modifiability,variab,variable,278,/// Append F to the list of global ctors of module M with the given Priority.; /// This wraps the function in the appropriate structure and stores it along; /// side other global constructors. For details see; /// https://llvm.org/docs/LangRef.html#the-llvm-global-ctors-global-variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,Security,sanitiz,sanitizer,12,/// Creates sanitizer constructor function.; /// \return Returns pointer to constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,Security,sanitiz,sanitizer,12,"/// Creates sanitizer constructor function, and calls sanitizer's init; /// function from it.; /// \return Returns pair of pointers to constructor, and init functions; /// respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:54,Security,sanitiz,sanitizer,54,"/// Creates sanitizer constructor function, and calls sanitizer's init; /// function from it.; /// \return Returns pair of pointers to constructor, and init functions; /// respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,Security,sanitiz,sanitizer,12,"/// Creates sanitizer constructor function lazily. If a constructor and init; /// function already exist, this function returns it. Otherwise it calls \c; /// createSanitizerCtorAndInitFunctions. The FunctionsCreatedCallback is invoked; /// in that case, passing the new Ctor and Init function.; ///; /// \return Returns pair of pointers to constructor, and init functions; /// respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:54,Security,hash,hash,54,/// Rename all the anon globals in the module using a hash computed from; /// the list of public globals in the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:103,Availability,alive,alive,103,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:201,Availability,alive,alive,201,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:440,Integrability,rout,routine,440,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:604,Safety,safe,safe,604,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:411,Performance,perform,performs,411,"/// Produce a unique identifier for this module by taking the MD5 sum of; /// the names of the module's strong external symbols that are not comdat; /// members.; ///; /// This identifier is normally guaranteed to be unique, or the program would; /// fail to link due to multiply defined symbols.; ///; /// If the module has no strong external symbols (such a module may still have a; /// semantic effect if it performs global initialization), we cannot produce a; /// unique identifier for this module, so we return the empty string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:68,Performance,load,loaded,68,"/// Lower all calls to ifuncs by replacing uses with indirect calls loaded out; /// of a global table initialized in a global constructor. This will introduce; /// one constructor function and adds it to llvm.global_ctors. The constructor; /// will call the resolver function once for each ifunc.; ///; /// Leaves any unhandled constant initializer uses as-is.; ///; /// If \p IFuncsToLower is empty, all ifuncs in the module will be lowered.; /// If \p IFuncsToLower is non-empty, only the selected ifuncs will be lowered.; ///; /// The processed ifuncs without remaining users will be removed from the; /// module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/NameAnonGlobals.h:4,Usability,Simpl,Simple,4,/// Simple pass that provides a name to every anonymous globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/NameAnonGlobals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/NameAnonGlobals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:1537,Energy Efficiency,reduce,reduce,1537,"//===- PredicateInfo.h - Build PredicateInfo ----------------------*-C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the PredicateInfo analysis, which creates an Extended; /// SSA form for operations used in branch comparisons and llvm.assume; /// comparisons.; ///; /// Copies of these operations are inserted into the true/false edge (and after; /// assumes), and information attached to the copies. All uses of the original; /// operation in blocks dominated by the true/false edge (and assume), are; /// replaced with uses of the copies. This enables passes to easily and sparsely; /// propagate condition based info into the operations that may be affected.; ///; /// Example:; /// %cmp = icmp eq i32 %x, 50; /// br i1 %cmp, label %true, label %false; /// true:; /// ret i32 %x; /// false:; /// ret i32 1; ///; /// will become; ///; /// %cmp = icmp eq i32, %x, 50; /// br i1 %cmp, label %true, label %false; /// true:; /// %x.0 = call \@llvm.ssa_copy.i32(i32 %x); /// ret i32 %x.0; /// false:; /// ret i32 1; ///; /// Using getPredicateInfoFor on x.0 will give you the comparison it is; /// dominated by (the icmp), and that you are located in the true edge of that; /// comparison, which tells you x.0 is 50.; ///; /// In order to reduce the number of copies inserted, predicateinfo is only; /// inserted where it would actually be live. This means if there are no uses of; /// an operation dominated by the branch edges, or by an assume, the associated; /// predicate info is never inserted.; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:462,Modifiability,Extend,Extended,462,"//===- PredicateInfo.h - Build PredicateInfo ----------------------*-C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the PredicateInfo analysis, which creates an Extended; /// SSA form for operations used in branch comparisons and llvm.assume; /// comparisons.; ///; /// Copies of these operations are inserted into the true/false edge (and after; /// assumes), and information attached to the copies. All uses of the original; /// operation in blocks dominated by the true/false edge (and assume), are; /// replaced with uses of the copies. This enables passes to easily and sparsely; /// propagate condition based info into the operations that may be affected.; ///; /// Example:; /// %cmp = icmp eq i32 %x, 50; /// br i1 %cmp, label %true, label %false; /// true:; /// ret i32 %x; /// false:; /// ret i32 1; ///; /// will become; ///; /// %cmp = icmp eq i32, %x, 50; /// br i1 %cmp, label %true, label %false; /// true:; /// %x.0 = call \@llvm.ssa_copy.i32(i32 %x); /// ret i32 %x.0; /// false:; /// ret i32 1; ///; /// Using getPredicateInfoFor on x.0 will give you the comparison it is; /// dominated by (the icmp), and that you are located in the true edge of that; /// comparison, which tells you x.0 is 50.; ///; /// In order to reduce the number of copies inserted, predicateinfo is only; /// inserted where it would actually be live. This means if there are no uses of; /// an operation dominated by the branch edges, or by an assume, the associated; /// predicate info is never inserted.; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:85,Usability,simpl,simply,85,"// Provides predicate information for assumes. Since assumes are always true,; // we simply provide the assume instruction, so you can tell your relative; // position to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:79,Security,access,accesses,79,"/// Encapsulates PredicateInfo, including all data associated with memory; /// accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h:49,Integrability,wrap,wrapper,49,"// Used by PredicateInfo annotater, dumpers, and wrapper pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PredicateInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h:404,Integrability,interface,interface,404,"//===- PromoteMemToReg.h - Promote Allocas to Scalars -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to promote alloca instructions to SSA; // registers, by using the SSA construction algorithm.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h:393,Security,expose,exposes,393,"//===- PromoteMemToReg.h - Promote Allocas to Scalars -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to promote alloca instructions to SSA; // registers, by using the SSA construction algorithm.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h:96,Performance,load,loads,96,"/// Return true if this alloca is legal for promotion.; ///; /// This is true if there are only loads, stores, and lifetime markers; /// (transitively) using this alloca. This also enforces that there is only; /// ever one layer of bitcasts or GEPs between the alloca and the lifetime; /// markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1061,Performance,load,load,1061,"==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===---------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1068,Performance,load,load,1068,"==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===---------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1125,Performance,load,load,1125,"Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h:1895,Performance,load,load,1895,"Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements relative lookup table converter that converts; /// lookup tables to relative lookup tables to make them PIC-friendly.; ///; /// Switch lookup table example:; /// @switch.table.foo = private unnamed_addr constant [3 x i8*]; /// [; /// i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0),; /// i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i64 0, i64 0); /// ], align 8; ///; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %switch.gep = getelementptr inbounds [3 x i8*],; /// [3 x i8*]* @switch.table.foo, i64 0, i64 %1; /// %switch.load = load i8*, i8** %switch.gep, align 8; /// ret i8* %switch.load; ///; /// Switch lookup table will become a relative lookup table that; /// consists of relative offsets.; ///; /// @reltable.foo = private unnamed_addr constant [3 x i32]; /// [; /// i32 trunc (i64 sub (i64 ptrtoint ([5 x i8]* @.str to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.1 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32),; /// i32 trunc (i64 sub (i64 ptrtoint ([4 x i8]* @.str.2 to i64),; /// i64 ptrtoint ([3 x i32]* @reltable.foo to i64)) to i32); /// ], align 4; ///; /// IR after converting to a relative lookup table:; /// switch.lookup:; /// %1 = sext i32 %cond to i64; /// %reltable.shift = shl i64 %1, 2; /// %reltable.intrinsic = call i8* @llvm.load.relative.i64(; /// i8* bitcast ([3 x i32]* @reltable.foo to i8*),; /// i64 %reltable.shift); /// ret i8* %reltable.intrinsic; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/RelLookupTableConverter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:412,Integrability,interface,interface,412,"//===- Transforms/Utils/SampleProfileInference.h ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the profile inference algorithm, profi.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,Integrability,wrap,wrapper,6,/// A wrapper of a binary basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,Integrability,wrap,wrapper,6,/// A wrapper of a jump between two basic blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:6,Integrability,wrap,wrapper,6,/// A wrapper of binary function with basic blocks and jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:120,Performance,tune,tuned,120,"/// Various thresholds and options controlling the behavior of the profile; /// inference algorithm. Default values are tuned for several large-scale; /// applications, and can be modified via corresponding command-line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:170,Safety,avoid,avoid,170,/// Try to infer branch probabilities mimicking implementation of; /// BranchProbabilityInfo. Unlikely taken branches are marked so that the; /// inference algorithm can avoid sending flow along corresponding edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:113,Availability,error,errors,113,// Extract the resulting weights from the control flow; // All weights are increased by one to avoid propagation errors introduced by; // zero weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:95,Safety,avoid,avoid,95,// Extract the resulting weights from the control flow; // All weights are increased by one to avoid propagation errors introduced by; // zero weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:418,Integrability,interface,interface,418,"////===- SampleProfileLoadBaseImpl.h - Profile loader base impl --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO profile loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:47,Performance,load,loader,47,"////===- SampleProfileLoadBaseImpl.h - Profile loader base impl --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO profile loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:456,Performance,load,loader,456,"////===- SampleProfileLoadBaseImpl.h - Profile loader base impl --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO profile loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:163,Integrability,inject,injected,163,// end namespace afdo_detail; // This class serves sample counts correlation for SampleProfileLoader by; // analyzing pseudo probes and their function descriptors injected by; // SampleProfileProber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:163,Security,inject,injected,163,// end namespace afdo_detail; // This class serves sample counts correlation for SampleProfileLoader by; // analyzing pseudo probes and their function descriptors injected by; // SampleProfileProber.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:32,Performance,load,load,32,/// Name of the profile file to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:42,Performance,load,load,42,/// Name of the profile remapping file to load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:25,Performance,load,load,25,/// VirtualFileSystem to load profile files from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:4,Performance,Optimiz,Optimization,4,/// Optimization Remark Emitter used to emit diagnostic remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:44,Performance,load,load,44,/// Clear all the per-function data used to load samples and propagate weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:4,Usability,Clear,Clear,4,/// Clear all the per-function data used to load samples and propagate weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:357,Security,checksum,checksum,357,"// If none of the instruction has FunctionSample, we choose to return zero; // value sample to indicate the BB is cold. This could happen when the; // instruction is from inlinee and no profile data is found.; // FIXME: This should not be affected by the source drift issue as 1) if the; // newly added function is top-level inliner, it won't match the CFG checksum; // in the function profile or 2) if it's the inlinee, the inlinee should have; // a profile, otherwise it wouldn't be inlined. For non-probe based profile,; // we can improve it by adding a switch for profile-sample-block-accurate for; // block level counts in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:377,Deployability,Update,UpdateBlockCount,377,"/// Propagate weights through incoming/outgoing edges.; ///; /// If the weight of a basic block is known, and there is only one edge; /// with an unknown weight, we can calculate the weight of that edge.; ///; /// Similarly, if all the edges have a known count, we can calculate the; /// count of the basic block, if needed.; ///; /// \param F Function to process.; /// \param UpdateBlockCount Whether we should update basic block counts that; /// has already been annotated.; ///; /// \returns True if new weights were assigned to edges or blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:412,Deployability,update,update,412,"/// Propagate weights through incoming/outgoing edges.; ///; /// If the weight of a basic block is known, and there is only one edge; /// with an unknown weight, we can calculate the weight of that edge.; ///; /// Similarly, if all the edges have a known count, we can calculate the; /// count of the basic block, if needed.; ///; /// \param F Function to process.; /// \param UpdateBlockCount Whether we should update basic block counts that; /// has already been annotated.; ///; /// \returns True if new weights were assigned to edges or blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:183,Usability,simpl,simply,183,"// After visiting all the edges, there are three cases that we; // can handle immediately:; //; // - All the edge weights are known (i.e., NumUnknownEdges == 0).; // In this case, we simply check that the sum of all the edges; // is the same as BB's weight. If not, we change BB's weight; // to match. Additionally, if BB had not been visited before,; // we mark it visited.; //; // - Only one edge is unknown and BB has already been visited.; // In this case, we can compute the weight of the edge by; // subtracting the total block weight from all the known; // edge weights. If the edges weight more than BB, then the; // edge of the last remaining edge is set to zero.; //; // - There exists a self-referential edge and the weight of BB is; // known. In this case, this edge can be based on BB's weight.; // We add up all the other known edges and set the weight on; // the self-referential edge as we did in the previous case.; //; // In any other case, we must continue iterating. Eventually,; // all edges will get a weight, or iteration will stop when; // it reaches SampleProfileMaxPropagateIterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:40,Usability,usab,usable,40,// Flow-based profile inference is only usable with BasicBlock instantiation; // of SampleProfileLoaderBaseImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:869,Usability,simpl,simple,869,"/// Generate branch weight metadata for all branches in \p F.; ///; /// Branch weights are computed out of instruction samples using a; /// propagation heuristic. Propagation proceeds in 3 phases:; ///; /// 1- Assignment of block weights. All the basic blocks in the function; /// are initial assigned the same weight as their most frequently; /// executed instruction.; ///; /// 2- Creation of equivalence classes. Since samples may be missing from; /// blocks, we can fill in the gaps by setting the weights of all the; /// blocks in the same equivalence class to the same weight. To compute; /// the concept of equivalence, we use dominance and loop information.; /// Two blocks B1 and B2 are in the same equivalence class if B1; /// dominates B2, B2 post-dominates B1 and both are in the same loop.; ///; /// 3- Propagation of block weights into edges. This uses a simple; /// propagation heuristic. The following rules are applied to every; /// block BB in the CFG:; ///; /// - If BB has a single predecessor/successor, then the weight; /// of that edge is the weight of the block.; ///; /// - If all the edges are known except one, and the weight of the; /// block is already known, the weight of the unknown edge will; /// be the weight of the block minus the sum of all the known; /// edges. If the sum of all the known edges is larger than BB's weight,; /// we set the unknown edge weight to zero.; ///; /// - If there is a self-referential edge, and the weight of the block is; /// known, the weight for that edge is set to the weight of the block; /// minus the weight of the other incoming edges to that block (if; /// known).; ///; /// Since this propagation is not guaranteed to finalize for every CFG, we; /// only allow it to proceed for a limited number of iterations (controlled; /// by -sample-profile-max-propagate-iterations).; ///; /// FIXME: Try to replace this propagation heuristic with a scheme; /// that is guaranteed to finalize. A work-list approach similar to; /// the st",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:105,Usability,GUID,GUIDs,105,"// Add an entry count to the function using the samples gathered at the; // function entry.; // Sets the GUIDs that are inlined in the profiled binary. This is used; // for ThinLink to make correct liveness analysis, and also make the IR; // match the profiled binary before annotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:383,Safety,avoid,avoid,383,"// If we utilize a flow-based count inference, then we trust the computed; // counts and set the entry count as computed by the algorithm. This is; // primarily done to sync the counts produced by profi and BFI inference,; // which uses the entry count for mass propagation.; // If profi produces a zero-value for the entry count, we fallback to; // Samples->getHeadSamples() + 1 to avoid functions with zero count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:471,Availability,avail,available,471,"/// Get the line number for the function header.; ///; /// This looks up function \p F in the current compilation unit and; /// retrieves the line number where the function is defined. This is; /// line 0 for all the samples read from the profile file. Every line; /// number is relative to this line.; ///; /// \param F Function object to query.; ///; /// \returns the line number where \p F is defined. If it returns 0,; /// it means that there is no debug information available for \p F.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:47,Performance,load,loader,47,"////===- SampleProfileLoadBaseUtil.h - Profile loader util func --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the utility functions for the sampled PGO loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:456,Performance,load,loader,456,"////===- SampleProfileLoadBaseUtil.h - Profile loader util func --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the utility functions for the sampled PGO loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:159,Safety,detect,detect,159,/// Coverage map for sampling records.; ///; /// This map keeps a record of sampling records that have been matched to; /// an IR instruction. This is used to detect some form of staleness in; /// profiles (see flag -sample-profile-check-coverage).; ///; /// Each entry in the map corresponds to a FunctionSamples instance. This is; /// another map that counts how many times the sample record at the; /// given location has been used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:240,Availability,avail,available,240,"/// Number of samples used from the profile.; ///; /// When a sampling record is used for the first time, the samples from; /// that record are added to this accumulator. Coverage is later computed; /// based on the total number of samples available in this function and; /// its callsites.; ///; /// Note that this accumulator tracks samples used from a single function; /// and all the inlined callsites. Strictly, we should have a map of counters; /// keyed by FunctionSamples pointers, but these stats are cleared after; /// every function, so we just need to keep a single counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:510,Usability,clear,cleared,510,"/// Number of samples used from the profile.; ///; /// When a sampling record is used for the first time, the samples from; /// that record are added to this accumulator. Coverage is later computed; /// based on the total number of samples available in this function and; /// its callsites.; ///; /// Note that this accumulator tracks samples used from a single function; /// and all the inlined callsites. Strictly, we should have a map of counters; /// keyed by FunctionSamples pointers, but these stats are cleared after; /// every function, so we just need to keep a single counter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:20,Modifiability,variab,variable,20,/// Create a global variable to flag FSDiscriminators are used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:7,Security,Sanitiz,SanitizerStats,7,"//===- SanitizerStats.h - Sanitizer statistics gathering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Declares functions and data structures for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:26,Security,Sanitiz,Sanitizer,26,"//===- SanitizerStats.h - Sanitizer statistics gathering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Declares functions and data structures for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:425,Security,sanitiz,sanitizer,425,"//===- SanitizerStats.h - Sanitizer statistics gathering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Declares functions and data structures for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:48,Security,sanitiz,sanitizer,48,// Number of bits in data that are used for the sanitizer kind. Needs to match; // __sanitizer::kKindBits in compiler-rt/lib/stats/stats.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:97,Security,sanitiz,sanitizer,97,/// Generates code into B that increments a location-specific counter tagged; /// with the given sanitizer kind SK.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:232,Deployability,release,release,232,"/// This class uses information about analyze scalars to rewrite expressions; /// in canonical form.; ///; /// Clients should create an instance of this class when rewriting is needed,; /// and destroy it when finished to allow the release of the associated; /// memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:57,Modifiability,rewrite,rewrite,57,"/// This class uses information about analyze scalars to rewrite expressions; /// in canonical form.; ///; /// Clients should create an instance of this class when rewriting is needed,; /// and destroy it when finished to allow the release of the associated; /// memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:23,Performance,cache,caches,23,"// InsertedExpressions caches Values for reuse, so must track RAUW.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:17,Modifiability,variab,variables,17,// The induction variables generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:244,Modifiability,variab,variable,244,"/// When true, SCEVExpander tries to expand expressions in ""canonical"" form.; /// When false, expressions are expanded in a more literal form.; ///; /// In ""canonical"" form addrecs are expanded as arithmetic based on a; /// canonical induction variable. Note that CanonicalMode doesn't guarantee; /// that all expressions are expanded in ""canonical"" form. For some; /// expressions literal mode can be preferred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:217,Deployability,update,updated,217,// RAII object that stores the current insertion point and restores it when; // the object is destroyed. This includes the debug location. Duplicated; // from InsertPointGuard to add SetInsertPoint() which is used to updated; // InsertPointGuards stack when insert points are moved during SCEV; // expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:26,Safety,avoid,avoid,26,"// In assert-less builds, avoid crashing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:6,Testability,assert,assert-less,6,"// In assert-less builds, avoid crashing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:25,Modifiability,variab,variable,25,/// Return the induction variable increment's IV operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:43,Safety,safe,safe,43,"/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are safe to speculate anywhere their operands are; /// defined, and the expander is capable of expanding the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:109,Safety,safe,safe,109,"/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are safe to speculate anywhere their operands are; /// defined, and the expander is capable of expanding the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:43,Safety,safe,safe,43,/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are defined and safe to speculate at the specified; /// location and their operands are defined at this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:121,Safety,safe,safe,121,/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are defined and safe to speculate at the specified; /// location and their operands are defined at this location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:41,Performance,cache,cached,41,"// When we change the post-inc loop set, cached expansions may no; // longer be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:152,Performance,optimiz,optimization,152,/// Disable the behavior of expanding expressions in canonical form rather; /// than in a more literal form. Non-canonical mode is useful for late; /// optimization passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:4,Usability,Clear,Clear,4,/// Clear the current insertion point. This is useful if the instruction; /// that had been serving as the insertion point may have been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:75,Modifiability,rewrite,rewriter,75,"/// Return true if the specified instruction was inserted by the code; /// rewriter. If so, the client should not modify the instruction. Note that; /// this also includes instructions re-used during expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:263,Performance,perform,perform,263,/// Determine whether there is an existing expansion of S that can be reused.; /// This is used to check whether S can be expanded cheaply.; ///; /// L is a hint which tells in which loop to look for the suitable value.; ///; /// Note that this function does not perform an exhaustive search. I.e if it; /// didn't find any value it does not mean that there is no such value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:108,Availability,redundant,redundant,108,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:79,Safety,avoid,avoid,79,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:108,Safety,redund,redundant,108,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:204,Safety,safe,safe,204,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:108,Integrability,interface,interface,108,//===----------------------------------------------------------------------===//; //; /// SCCPSolver - This interface class is a general purpose solver for Sparse; /// Conditional Constant Propagation (SCCP).; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:158,Modifiability,variab,variable,158,/// trackValueOfGlobalVariable - Clients can use this method to; /// inform the SCCPSolver that it should track loads and stores to the; /// specified global variable if it can. This is only legal to call if; /// performing Interprocedural SCCP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:112,Performance,load,loads,112,/// trackValueOfGlobalVariable - Clients can use this method to; /// inform the SCCPSolver that it should track loads and stores to the; /// specified global variable if it can. This is only legal to call if; /// performing Interprocedural SCCP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:213,Performance,perform,performing,213,/// trackValueOfGlobalVariable - Clients can use this method to; /// inform the SCCPSolver that it should track loads and stores to the; /// specified global variable if it can. This is only legal to call if; /// performing Interprocedural SCCP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:177,Safety,safe,safe,177,"/// resolvedUndefsIn - While solving the dataflow for a function, we assume; /// that branches on undef values cannot reach any of their successors.; /// However, this is not a safe assumption. After we solve dataflow, this; /// method should be use to handle this. If this returns true, the solver; /// should be rerun.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:88,Modifiability,variab,variables,88,/// getTrackedGlobals - Get and return the set of inferred initializers for; /// global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:228,Modifiability,inherit,inherited,228,"/// Set the Lattice Value for the arguments of a specialization \p F.; /// If an argument is Constant then its lattice value is marked with the; /// corresponding actual argument in \p Args. Otherwise, its lattice value; /// is inherited (copied) from the corresponding formal argument in \p Args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:528,Deployability,pipeline,pipeline,528,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:482,Integrability,depend,depending,482,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:515,Performance,optimiz,optimization,515,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:7,Usability,Simpl,SimplifyCFGOptions,7,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:52,Usability,Simpl,SimplifyCFG,52,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:441,Usability,Simpl,SimplifyCFG,441,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:404,Integrability,interface,interface,404,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:428,Modifiability,variab,variable,428,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:569,Modifiability,variab,variables,569,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:30,Usability,Simpl,SimplifyIndVar,30,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:437,Usability,simpl,simplification,437,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:541,Usability,simpl,simplify,541,"//===-- llvm/Transforms/Utils/SimplifyIndVar.h - Indvar Utils ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines in interface for induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:4,Integrability,Interface,Interface,4,/// Interface for visiting interesting IV users that are recognized but not; /// simplified by this utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:81,Usability,simpl,simplified,81,/// Interface for visiting interesting IV users that are recognized but not; /// simplified by this utility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:70,Modifiability,variab,variable,70,/// simplifyUsersOfIV - Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:4,Usability,simpl,simplifyUsersOfIV,4,/// simplifyUsersOfIV - Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:24,Usability,Simpl,Simplify,24,/// simplifyUsersOfIV - Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:50,Modifiability,variab,variables,50,/// SimplifyLoopIVs - Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:4,Usability,Simpl,SimplifyLoopIVs,4,/// SimplifyLoopIVs - Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:22,Usability,Simpl,Simplify,22,/// SimplifyLoopIVs - Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:40,Modifiability,variab,variables,40,/// Collect information about induction variables that are used by sign/zero; /// extend operations. This information is recorded by CollectExtend and provides; /// the input to WidenIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:82,Modifiability,extend,extend,82,/// Collect information about induction variables that are used by sign/zero; /// extend operations. This information is recorded by CollectExtend and provides; /// the input to WidenIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:20,Modifiability,Variab,Variables,20,/// Widen Induction Variables - Extend the width of an IV to cover its; /// widest uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h:32,Modifiability,Extend,Extend,32,/// Widen Induction Variables - Extend the width of an IV to cover its; /// widest uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyIndVar.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:404,Integrability,interface,interface,404,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:456,Performance,optimiz,optimization,456,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:393,Security,expose,exposes,393,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:7,Usability,Simpl,SimplifyLibCalls,7,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:41,Usability,simpl,simplifier,41,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:233,Performance,optimiz,optimizations,233,"/// This class implements simplifications for calls to fortified library; /// functions (__st*cpy_chk, __memcpy_chk, __memmove_chk, __memset_chk), to,; /// when possible, replace them with their non-checking counterparts.; /// Other optimizations can also be done, but it's possible to disable them and; /// only simplify needless use of the checking versions (when the object size; /// is unknown) by passing true for OnlyLowerUnknownSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:26,Usability,simpl,simplifications,26,"/// This class implements simplifications for calls to fortified library; /// functions (__st*cpy_chk, __memcpy_chk, __memmove_chk, __memset_chk), to,; /// when possible, replace them with their non-checking counterparts.; /// Other optimizations can also be done, but it's possible to disable them and; /// only simplify needless use of the checking versions (when the object size; /// is unknown) by passing true for OnlyLowerUnknownSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:313,Usability,simpl,simplify,313,"/// This class implements simplifications for calls to fortified library; /// functions (__st*cpy_chk, __memcpy_chk, __memmove_chk, __memset_chk), to,; /// when possible, replace them with their non-checking counterparts.; /// Other optimizations can also be done, but it's possible to disable them and; /// only simplify needless use of the checking versions (when the object size; /// is unknown) by passing true for OnlyLowerUnknownSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:62,Performance,optimiz,optimizations,62,"/// LibCallSimplifier - This class implements a collection of optimizations; /// that replace well formed calls to library functions with a more optimal; /// form. For example, replacing 'printf(""Hello!"")' with 'puts(""Hello!"")'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:13,Integrability,wrap,wrapper,13,/// Internal wrapper for RAUW that is the default implementation.; ///; /// Other users may provide an alternate function with this signature instead; /// of this one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:13,Integrability,wrap,wrapper,13,/// Internal wrapper for eraseFromParent that is the default implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:4,Performance,optimiz,optimizeCall,4,/// optimizeCall - Take the given call instruction and return a more; /// optimal value to replace the instruction with or 0 if a more; /// optimal form can't be found. Note that the returned value may; /// be equal to the instruction being optimized. In this case all; /// other instructions that use the given instruction were modified; /// and the given instruction is dead.; /// The call must not be an indirect call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:241,Performance,optimiz,optimized,241,/// optimizeCall - Take the given call instruction and return a more; /// optimal value to replace the instruction with or 0 if a more; /// optimal form can't be found. Note that the returned value may; /// be equal to the instruction being optimized. In this case all; /// other instructions that use the given instruction were modified; /// and the given instruction is dead.; /// The call must not be an indirect call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:34,Performance,Optimiz,Optimizations,34,// String and Memory Library Call Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:13,Performance,optimiz,optimize,13,// Helper to optimize stpncpy and strncpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:3,Integrability,Wrap,Wrapper,3,// Wrapper for all String/Memory Library Call Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:46,Performance,Optimiz,Optimizations,46,// Wrapper for all String/Memory Library Call Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:16,Performance,Optimiz,Optimizations,16,// Math Library Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:3,Integrability,Wrap,Wrapper,3,// Wrapper for all floating point library call optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:47,Performance,optimiz,optimizations,47,// Wrapper for all floating point library call optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:24,Performance,Optimiz,Optimizations,24,// Integer Library Call Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:34,Performance,Optimiz,Optimizations,34,// Formatting and IO Library Call Optimizations,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:19,Performance,optimiz,optimize,19,/// Shared code to optimize strlen+wcslen and strnlen+wcsnlen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:47,Performance,optimiz,optimization,47,"//===- llvm/Transforms/Utils/SizeOpts.h - size optimization -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:424,Performance,optimiz,optimization,424,"//===- llvm/Transforms/Utils/SizeOpts.h - size optimization -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:28,Testability,test,test,28,// A query call from a unit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:58,Performance,optimiz,optimized,58,/// Returns true if function \p F is suggested to be size-optimized based on the; /// profile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:62,Performance,optimiz,optimized,62,/// Returns true if basic block \p BB is suggested to be size-optimized based on; /// the profile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h:565,Performance,optimiz,optimization,565,"//===- SplitModule.h - Split a module into partitions -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function llvm::SplitModule, which splits a module; // into multiple linkable partitions. It can be used to implement parallel code; // generation for link-time optimization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:39,Deployability,Update,Update,39,"//===- SSAUpdater.h - Unstructured SSA Update Tool --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the SSAUpdater class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:185,Modifiability,rewrite,rewrite,185,/// Helper class for SSA formation on a set of values defined in; /// multiple blocks.; ///; /// This is used when code duplication or another unstructured; /// transformation wants to rewrite a set of uses of one value with uses of a; /// set of values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:56,Deployability,update,updates,56,/// Reset this object to get ready for a new set of SSA updates with; /// type 'Ty'.; ///; /// PHI nodes get a name based on 'Name'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block; /// with the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:495,Availability,Avail,AvailableVals,495,"/// Construct SSA form, materializing a value that is live in the; /// middle of the specified block.; ///; /// \c GetValueInMiddleOfBlock is the same as \c GetValueAtEndOfBlock except; /// in one important case: if there is a definition of the rewritten value; /// after the 'use' in BB. Consider code like this:; ///; /// \code; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; /// \endcode; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:539,Modifiability,rewrite,rewriter,539,"/// Construct SSA form, materializing a value that is live in the; /// middle of the specified block.; ///; /// \c GetValueInMiddleOfBlock is the same as \c GetValueAtEndOfBlock except; /// in one important case: if there is a definition of the rewritten value; /// after the 'use' in BB. Consider code like this:; ///; /// \code; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; /// \endcode; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a use of the symbolic value.; ///; /// This handles PHI nodes, which use their value in the corresponding; /// predecessor. Note that this will not work if the use is supposed to be; /// rewritten to a value defined in the same block as the use, but above it.; /// Any 'AddAvailableValue's added for the use's block will be considered to; /// be below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:248,Availability,avail,available,248,"/// Rewrite debug value intrinsics to conform to a new SSA form.; ///; /// This will scout out all the debug value instrinsics associated with; /// the instruction. Anything outside of its block will have its; /// value set to the new SSA value if available, and undef if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite debug value intrinsics to conform to a new SSA form.; ///; /// This will scout out all the debug value instrinsics associated with; /// the instruction. Anything outside of its block will have its; /// value set to the new SSA value if available, and undef if not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:26,Modifiability,Rewrite,RewriteUse,26,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:113,Modifiability,rewrite,rewrite,113,"/// Rewrite a use like \c RewriteUse but handling in-block definitions.; ///; /// This version of the method can rewrite uses in the same block as; /// a definition, because it assumes that all uses of a value are below any; /// inserted values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:47,Performance,load,loads,47,"/// Helper class for promoting a collection of loads and stores into SSA; /// Form using the SSAUpdater.; ///; /// This handles complexities that SSAUpdater doesn't, such as multiple loads; /// and stores in one block.; ///; /// Clients of this class are expected to subclass this and implement the; /// virtual methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:183,Performance,load,loads,183,"/// Helper class for promoting a collection of loads and stores into SSA; /// Form using the SSAUpdater.; ///; /// This handles complexities that SSAUpdater doesn't, such as multiple loads; /// and stores in one block.; ///; /// Clients of this class are expected to subclass this and implement the; /// virtual methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:58,Performance,load,loads,58,"/// This does the promotion.; ///; /// Insts is a list of loads and stores to promote, and Name is the basename; /// for the PHIs to insert. After this is complete, the loads and stores are; /// removed from the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:169,Performance,load,loads,169,"/// This does the promotion.; ///; /// Insts is a list of loads and stores to promote, and Name is the basename; /// for the PHIs to insert. After this is complete, the loads and stores are; /// removed from the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:178,Energy Efficiency,efficient,efficient,178,/// Return true if the specified instruction is in the Inst list.; ///; /// The Insts list is the one passed into the constructor. Clients should; /// implement this with a more efficient version if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,Availability,avail,available,77,/// This hook is invoked after all the stores are found and inserted as; /// available values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,Performance,load,load,77,/// Clients can choose to implement this to get notified right before; /// a load is RAUW'd another value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:14,Deployability,update,update,14,/// Called to update debug info associated with the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:57,Performance,load,loads,57,/// Return false if a sub-class wants to keep one of the loads/stores; /// after the SSA construction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:43,Deployability,Update,Update,43,"//===- SSAUpdaterBulk.h - Unstructured SSA Update Tool ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the SSAUpdaterBulk class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:259,Deployability,update,update,259,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:418,Deployability,update,updates,418,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:185,Modifiability,rewrite,rewrite,185,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:284,Modifiability,Rewrite,RewriteAllUses,284,"/// Helper class for SSA formation on a set of values defined in multiple; /// blocks.; ///; /// This is used when code duplication or another unstructured transformation; /// wants to rewrite a set of uses of one value with uses of a set of values.; /// The update is done only when RewriteAllUses is called, all other methods are; /// used for book-keeping. That helps to share some common computations between; /// updates of different uses (which is not the case when traditional SSAUpdater; /// is used).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:14,Modifiability,variab,variable,14,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:34,Modifiability,rewrite,rewriter,34,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:139,Modifiability,variab,variable,139,"/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls. The return value is the variable ID,; /// which needs to be passed to AddAvailableValue and AddUse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block with; /// the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:57,Deployability,update,updated,57,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:98,Modifiability,Rewrite,RewriteAllUses,98,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:30,Deployability,update,updates,30,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:101,Deployability,update,update,101,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:4,Performance,Perform,Perform,4,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:30,Deployability,Update,Updater,30,"//===- SSAUpdaterImpl.h - SSA Updater Implementation ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a template that implements the core algorithm for the; // SSAUpdater and MachineSSAUpdater.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:116,Performance,cache,cached,116,/// BBInfo - Per-basic block information used internally by SSAUpdaterImpl.; /// The predecessors of each block are cached here since pred_iterator is; /// slow and we need to iterate over the blocks at least a few times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:26,Availability,avail,available,26,// Block that defines the available value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:31,Availability,Avail,AvailableVals,31,"/// GetValue - Check to see if AvailableVals has an entry for the specified; /// BB and if so, return it. If not, construct SSA form by first; /// calculating the required placement of PHIs and then inserting new PHIs; /// where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:171,Usability,Simpl,Simple,171,"/// FindDominators - Calculate the dominator tree for the subset of the CFG; /// corresponding to the basic blocks on the BlockList. This uses the; /// algorithm from: ""A Simple, Fast Dominance Algorithm"" by Cooper, Harvey; /// and Kennedy, published in Software--Practice and Experience, 2001,; /// 4:1-10. Because the CFG subset does not include any edges leading into; /// blocks that define the value, the results are not the usual dominator; /// tree. The CFG subset has a single pseudo-entry node with edges to a set; /// of root nodes for blocks that define the value. The dominators for this; /// subset CFG are not the standard dominators but they are adequate for; /// placing PHIs within the subset CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:60,Availability,Avail,AvailableVal,60,/// Check all predecessors and if all of them have the same AvailableVal use; /// it as value for block represented by Info. Return true if singluar value; /// is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:250,Availability,avail,available,250,"/// FindAvailableVal - If this block requires a PHI, first check if an; /// existing PHI matches the PHI placement and reaching definitions computed; /// earlier, and if not, create a new PHI. Visit all the block's; /// predecessors to calculate the available value for each one and fill in; /// the incoming values for a new PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:14,Availability,avail,available,14,// Record the available value to speed up subsequent uses of this; // SSAUpdater for the same value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:17,Usability,clear,clear,17,// Match failed: clear all the PHITag values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:98,Availability,Avail,AvailableVals,98,"/// RecordMatchingPHIs - For each PHI node that matches, record it in both; /// the BBMap and the AvailableVals mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:459,Modifiability,Rewrite,Rewriter,459,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:493,Modifiability,Rewrite,Rewriter,493,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:522,Modifiability,rewrite,rewrite,522,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:776,Modifiability,Rewrite,Rewriter,776,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:1075,Performance,perform,performing,1075,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:799,Security,expose,exposed,799,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:1403,Security,sanitiz,sanitizers,1403,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:36,Modifiability,rewrite,rewrite,36,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:96,Modifiability,rewrite,rewrite,96,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:189,Modifiability,rewrite,rewrite,189,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:212,Modifiability,Rewrite,RewriteMapParser,212,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:377,Modifiability,rewrite,rewrite,377,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:404,Modifiability,variab,variable,404,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:628,Modifiability,rewrite,rewrite,628,"/// The basic entity representing a rewrite operation. It serves as the base; /// class for any rewrite descriptor. It has a certain set of specializations; /// which describe a particular rewrite.; ///; /// The RewriteMapParser can be used to parse a mapping file that provides the; /// mapping for rewriting the symbols. The descriptors individually describe; /// whether to rewrite a function, global variable, or global alias. Each of; /// these can be selected either by explicitly providing a name for the ones to; /// be rewritten or providing a (posix compatible) regular expression that will; /// select the symbols to rewrite. This descriptor list is passed to the; /// SymbolRewriter pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:26,Modifiability,rewrite,rewrites,26,/// function - descriptor rewrites a function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:11,Modifiability,variab,variable,11,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:33,Modifiability,rewrite,rewrites,33,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:51,Modifiability,variab,variable,51,/// global variable - descriptor rewrites a global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:29,Modifiability,rewrite,rewrites,29,/// named alias - descriptor rewrites a global alias,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:516,Performance,perform,perform,516,"//===- llvm/Transforms/Utils/UnrollLoop.h - Unrolling utilities -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:77,Deployability,configurat,configuration,77,"/// Returns loop size estimation for unrolled loop, given the unrolling; /// configuration specified by UP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:77,Modifiability,config,configuration,77,"/// Returns loop size estimation for unrolled loop, given the unrolling; /// configuration specified by UP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:414,Integrability,interface,interface,414,"//===- ValueMapper.h - Remapping for constants and metadata -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MapValue interface which is used by various parts of; // the Transforms/Utils library to implement cloning and linking facilities.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:173,Safety,abort,aborts,173,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:287,Testability,assert,assertions,287,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:396,Testability,assert,assertion,396,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:1732,Deployability,Update,Update,1732,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:683,Energy Efficiency,schedul,schedule,683,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:751,Energy Efficiency,schedul,scheduleMapGlobalInitializer,751,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:792,Energy Efficiency,schedul,scheduleMapAppendingVariable,792,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:833,Energy Efficiency,schedul,scheduleMapGlobalAlias,833,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:868,Energy Efficiency,schedul,scheduleMapGlobalIFunc,868,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:903,Energy Efficiency,schedul,scheduleRemapFunction,903,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:1190,Energy Efficiency,schedul,schedule,1190,"/// Context for (re-)mapping values (and metadata).; ///; /// A shared context used for mapping and remapping of Value and Metadata; /// instances using \a ValueToValueMapTy, \a RemapFlags, \a; /// ValueMapTypeRemapper, and \a ValueMaterializer.; ///; /// There are a number of top-level entry points:; /// - \a mapValue() (and \a mapConstant());; /// - \a mapMetadata() (and \a mapMDNode());; /// - \a remapInstruction();; /// - \a remapFunction(); and; /// - \a remapGlobalObjectMetadata().; ///; /// The \a ValueMaterializer can be used as a callback, but cannot invoke any; /// of these top-level functions recursively. Instead, callbacks should use; /// one of the following to schedule work lazily in the \a ValueMapper; /// instance:; /// - \a scheduleMapGlobalInitializer(); /// - \a scheduleMapAppendingVariable(); /// - \a scheduleMapGlobalAlias(); /// - \a scheduleMapGlobalIFunc(); /// - \a scheduleRemapFunction(); ///; /// Sometimes a callback needs a different mapping context. Such a context can; /// be registered using \a registerAlternateMappingContext(), which takes an; /// alternate \a ValueToValueMapTy and \a ValueMaterializer and returns a ID to; /// pass into the schedule*() functions.; ///; /// TODO: lib/Linker really doesn't need the \a ValueHandle in the \a; /// ValueToValueMapTy. We should template \a ValueMapper (and its; /// implementation classes), and explicitly instantiate on two concrete; /// instances of \a ValueMap (one as \a ValueToValueMap, and one with raw \a; /// Value pointers). It may be viable to do away with \a TrackingMDRef in the; /// \a Metadata side map for the lib/Linker case as well, in which case we'll; /// need a new template parameter on \a ValueMap.; ///; /// TODO: Update callers of \a RemapInstruction() and \a MapValue() (etc.) to; /// use \a ValueMapper directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:114,Energy Efficiency,schedul,schedule,114,/// Register an alternate mapping context.; ///; /// Returns a MappingContextID that can be used with the various schedule*(); /// API to switch in a different value map on-the-fly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:490,Integrability,depend,depending,490,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:587,Integrability,wrap,wrapping,587,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:705,Integrability,depend,depending,705,"/// Look up or compute a value in the value map.; ///; /// Return a mapped value for a function-local value (Argument, Instruction,; /// BasicBlock), or compute and memoize a value for a Constant.; ///; /// 1. If \c V is in VM, return the result.; /// 2. Else if \c V can be materialized with \c Materializer, do so, memoize; /// it in \c VM, and return it.; /// 3. Else if \c V is a function-local value, return nullptr.; /// 4. Else if \c V is a \a GlobalValue, return \c nullptr or \c V depending; /// on \a RF_NullMapMissingGlobalValues.; /// 5. Else if \c V is a \a MetadataAsValue wrapping a LocalAsMetadata,; /// recurse on the local SSA value, and return nullptr or ""metadata !{}"" on; /// missing depending on RF_IgnoreMissingValues.; /// 6. Else if \c V is a \a MetadataAsValue, rewrap the return of \a; /// MapMetadata().; /// 7. Else, compute the equivalent constant, and return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:323,Integrability,wrap,wrap,323,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:510,Integrability,depend,depending,510,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:717,Integrability,wrap,wrapping,717,"/// Lookup or compute a mapping for a piece of metadata.; ///; /// Compute and memoize a mapping for \c MD.; ///; /// 1. If \c MD is mapped, return it.; /// 2. Else if \a RF_NoModuleLevelChanges or \c MD is an \a MDString, return; /// \c MD.; /// 3. Else if \c MD is a \a ConstantAsMetadata, call \a MapValue() and; /// re-wrap its return (returning nullptr on nullptr).; /// 4. Else, \c MD is an \a MDNode. These are remapped, along with their; /// transitive operands. Distinct nodes are duplicated or moved depending; /// on \a RF_MoveDistinctNodes. Uniqued nodes are remapped like constants.; ///; /// \note \a LocalAsMetadata is completely unsupported by \a MapMetadata.; /// Instead, use \a MapValue() with its wrapping \a MetadataAsValue instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:37,Safety,safe,safety,37,/// Version of MapMetadata with type safety for MDNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:235,Testability,assert,assert,235,"/// Convert the instruction operands from referencing the current values into; /// those specified by VM.; ///; /// If \a RF_IgnoreMissingLocals is set and an operand can't be found via \a; /// MapValue(), use the old value. Otherwise assert that this doesn't happen.; ///; /// Note that \a MapValue() only returns \c nullptr for SSA values missing from; /// \c VM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:34,Safety,safe,safety,34,/// Version of MapValue with type safety for Constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:407,Integrability,rout,routines,407,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:768,Integrability,rout,routines,768,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:838,Integrability,rout,routines,838,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:910,Integrability,rout,routines,910,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:462,Performance,perform,perform,462,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:654,Performance,load,load,654,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:722,Performance,load,load,722,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:55,Performance,load,load,55,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:152,Performance,load,loaded,152,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:170,Performance,Load,LoadedTy,170,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:198,Performance,load,load,198,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:208,Availability,failure,failure,208,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:207,Availability,failure,failure,207,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:100,Performance,load,load,100,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:219,Availability,failure,failure,219,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Performance,Load,LoadPtr,61,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:38,Performance,Load,Load,38,"/// If analyzeLoadFromClobberingStore/Load returned an offset, this function; /// can be used to actually perform the extraction of the bits from the store.; /// It inserts instructions to do so at InsertPt, and returns the extracted; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:106,Performance,perform,perform,106,"/// If analyzeLoadFromClobberingStore/Load returned an offset, this function; /// can be used to actually perform the extraction of the bits from the store.; /// It inserts instructions to do so at InsertPt, and returns the extracted; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:50,Performance,perform,performs,50,"// This is the same as getValueForLoad, except it performs no insertion.; // It only allows constant inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:103,Performance,perform,perform,103,"/// If analyzeLoadFromClobberingMemInst returned an offset, this function can be; /// used to actually perform the extraction of the bits from the memory; /// intrinsic. It inserts instructions to do so at InsertPt, and returns the; /// extracted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:55,Performance,perform,performs,55,"// This is the same as getStoreValueForLoad, except it performs no insertion.; // It returns nullptr if it cannot produce a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:7,Performance,Load,LoadStoreVectorizer,7,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:37,Performance,Load,Load,37,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:49,Performance,Load,LoadStoreVectorizer,49,/// Create a legacy pass manager instance of the LoadStoreVectorizer pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:996,Availability,failure,failure,996,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:1017,Integrability,message,message,1017,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:624,Modifiability,Extend,Extending,624,"//===- llvm/Transforms/Vectorize/LoopVectorizationLegality.h ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines the LoopVectorizationLegality class. Original code; /// in Loop Vectorizer has been moved out to its own file for modularity; /// and reusability.; ///; /// Currently, it works for innermost loop vectorization. Extending this to; /// outer loop vectorization is a TODO item.; ///; /// Also provides:; /// 1) LoopVectorizeHints class which keeps a number of loop annotations; /// locally for easy look up. It has the ability to write them back as; /// loop metadata, upon request.; /// 2) LoopVectorizationRequirements class for lazy bail out for the purpose; /// of reporting useful failure to vectorize message.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:318,Deployability,update,update,318,"/// Utility class for getting and setting loop vectorizer hints in the form; /// of loop metadata.; /// This class keeps a number of loop annotations locally (as member variables); /// and can, upon request, write them back as metadata on the loop. It will; /// initially scan the loop for existing metadata, and will update the local; /// values based on information in the loop.; /// We cannot write all values to metadata, as the mere presence of some info,; /// for example 'force', means a decision has been made. So, we need to be; /// careful NOT to add them if the user hasn't specifically asked so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:169,Modifiability,variab,variables,169,"/// Utility class for getting and setting loop vectorizer hints in the form; /// of loop metadata.; /// This class keeps a number of loop annotations locally (as member variables); /// and can, upon request, write them back as metadata on the loop. It will; /// initially scan the loop for existing metadata, and will update the local; /// values based on information in the loop.; /// We cannot write all values to metadata, as the mere presence of some info,; /// for example 'force', means a decision has been made. So, we need to be; /// careful NOT to add them if the user hasn't specifically asked so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:31,Security,validat,validation,31,/// Hint - associates name and validation with the hint value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:46,Performance,scalab,scalable,46,/// Says whether we should use fixed width or scalable vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:25,Safety,unsafe,unsafe,25,/// True if there is any unsafe math in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:32,Performance,scalab,scalable,32,/// Disables vectorization with scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Performance,scalab,scalable,26,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:82,Performance,scalab,scalable,82,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:170,Performance,scalab,scalable,170,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:20,Performance,scalab,scalable,20,/// \return true if scalable vectorization has been explicitly disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:303,Availability,error,error,303,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:190,Safety,unsafe,unsafe,190,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:3,Safety,Avoid,Avoid,3,"// Avoid FP vectorization if the target is unsure about proper support.; // This may be related to the SIMD unit in the target not handling; // IEEE 754 FP ops properly, or bad single-to-double promotions.; // Otherwise, a sequence of vectorized loops, even without reduction,; // could lead to different end results on the destination vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:50,Deployability,update,update,50,/// Find hints specified in the loop metadata and update local values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:573,Availability,avail,availability,573,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:613,Modifiability,variab,variable,613,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:825,Modifiability,variab,variable,825,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:862,Modifiability,variab,variables,862,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:361,Security,access,accesses,361,"/// LoopVectorizationLegality checks if it is legal to vectorize a loop, and; /// to what vectorization factor.; /// This class does not look at the profitability of vectorization, only the; /// legality. This class has two main kinds of checks:; /// * Memory checks - The code in canVectorizeMemory checks if vectorization; /// will change the order of memory accesses in a way that will change the; /// correctness of the program.; /// * Scalars checks - The code in canVectorizeInstrs and canVectorizeMemory; /// checks for a number of different conditions, such as the availability of a; /// single induction variable, that all types are supported and vectorize-able,; /// etc. This code reflects the capabilities of InnerLoopVectorizer.; /// This class is also used by InnerLoopVectorizer for identifying; /// induction variable and the different reduction variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:34,Modifiability,variab,variables,34,/// InductionList saves induction variables and maps them to the; /// induction descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:77,Availability,mask,masking,77,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:127,Availability,mask,masking,127,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:110,Performance,load,loads,110,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:34,Modifiability,variab,variable,34,/// Returns the primary induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Modifiability,variab,variables,26,/// Returns the reduction variables found in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,Modifiability,variab,variables,26,/// Returns the induction variables found in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:52,Modifiability,variab,variable,52,/// Returns True if V is a Phi node of an induction variable in this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Availability,redundant,redundant,107,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Safety,redund,redundant,107,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,Availability,redundant,redundant,120,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:56,Modifiability,variab,variable,56,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,Safety,redund,redundant,120,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:38,Modifiability,variab,variable,38,/// Returns True if PN is a reduction variable in this loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:125,Modifiability,variab,variable,125,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:183,Modifiability,variab,variable,183,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:251,Performance,load,load,251,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:29,Performance,load,load,29,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:49,Security,access,accesses,49,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:80,Availability,mask,mask,80,/// Returns true if vector representation of the instruction \p I; /// requires mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:104,Availability,avail,available,104,/// Returns true if there is at least one function call in the loop which; /// has a vectorized variant available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,Performance,perform,performs,64,/// Return true if we can vectorize this outer loop. The method performs; /// specific checks for outer loop vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:133,Availability,mask,masking,133,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:279,Availability,Mask,MaskedOp,279,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:377,Availability,mask,masked,377,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,Performance,load,loads,107,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:150,Safety,Safe,SafePtrs,150,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Deployability,Update,Updates,4,/// Updates the vectorization state by adding \p Phi to the inductions list.; /// This can set \p Phi as the main induction of the loop if \p Phi is a; /// better choice for the main induction than the existing one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:6,Integrability,wrap,wrapper,6,/// A wrapper around ScalarEvolution used to add runtime SCEV checks.; /// Applies dynamic knowledge to simplify SCEV expressions in the context; /// of existing SCEV assumptions. The analysis will also add a minimal set; /// of new predicates if this is required to enable vectorization and; /// unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:104,Usability,simpl,simplify,104,/// A wrapper around ScalarEvolution used to add runtime SCEV checks.; /// Applies dynamic knowledge to simplify SCEV expressions in the context; /// of existing SCEV assumptions. The analysis will also add a minimal set; /// of new predicates if this is required to enable vectorization and; /// unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:4,Integrability,Interface,Interface,4,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:22,Performance,optimiz,optimization,22,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:67,Modifiability,variab,variable,67,// --- vectorization state --- //; /// Holds the primary induction variable. This is the counter of the; /// loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:24,Modifiability,variab,variables,24,/// Holds the reduction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:31,Modifiability,variab,variables,31,/// Holds all of the induction variables that we found in the loop.; /// Notice that inductions don't need to start at zero and that induction; /// variables can be pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:148,Modifiability,variab,variables,148,/// Holds all of the induction variables that we found in the loop.; /// Notice that inductions don't need to start at zero and that induction; /// variables can be pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,Availability,redundant,redundant,126,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:48,Deployability,update,update,48,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:83,Modifiability,variab,variables,83,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,Safety,redund,redundant,126,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:42,Modifiability,variab,variables,42,/// Allowed outside users. This holds the variables that can be accessed from; /// outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,Security,access,accessed,64,/// Allowed outside users. This holds the variables that can be accessed from; /// outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:19,Performance,cache,cache,19,/// The assumption cache analysis is used to compute the minimum type size in; /// which a reduction can be computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:92,Availability,mask,masked,92,/// While vectorizing these instructions we have to generate a; /// call to the appropriate masked intrinsic or drop them in case of; /// conditional assumes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:58,Performance,optimiz,optimizations,58,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:46,Usability,guid,guided,46,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:1944,Modifiability,variab,variable,1944,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:2065,Modifiability,Variab,Variable,2065,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:1088,Performance,perform,performs,1088,"f the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the LLVM loop vectorizer. This pass modifies 'vectorizable' loops; // and generates target-independent LLVM-IR.; // The vectorizer uses the TargetTransformInfo analysis to estimate the costs; // of instructions in order to estimate the profitability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:2195,Security,access,access,2195,"ability of vectorization.; //; // The loop vectorizer combines consecutive loop iterations into a single; // 'wide' iteration. After this transformation the index is incremented; // by the SIMD vector width, and not by one.; //; // This pass has four parts:; // 1. The main loop pass that drives the different parts.; // 2. LoopVectorizationLegality - A unit that checks for the legality; // of the vectorization.; // 3. InnerLoopVectorizer - A unit that performs the actual; // widening of instructions.; // 4. LoopVectorizationCostModel - A unit that checks for the profitability; // of vectorization. It decides on the optimal vector width, which; // can be one, if vectorization is not profitable.; //; // There is a development effort going on to migrate loop vectorizer to the; // VPlan infrastructure and to introduce outer loop vectorization support (see; // docs/VectorizationPlan.rst and; // http://lists.llvm.org/pipermail/llvm-dev/2017-December/119523.html). For this; // purpose, we temporarily introduced the VPlan-native vectorization path: an; // alternative vectorization path that is natively implemented on top of the; // VPlan infrastructure. See EnableVPlanNativePath for enabling.; //; //===----------------------------------------------------------------------===//; //; // The reduction-variable vectorization is based on the paper:; // D. Nuzman and R. Henderson. Multi-platform Auto-vectorization.; //; // Variable uniformity checks are inspired by:; // Karrenberg, R. and Hack, S. Whole Function Vectorization.; //; // The interleaved access vectorization is based on the paper:; // Dorit Nuzman, Ira Rosen and Ayal Zaks. Auto-Vectorization of Interleaved; // Data for SIMD; //; // Other ideas/concepts are from:; // A. Zaks and D. Nuzman. Autovectorization in GCC-two years later.; //; // S. Maleki, Y. Gao, M. Garzaran, T. Wong and D. Padua. An Evaluation of; // Vectorizing Compilers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:126,Performance,cache,caches,126,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:50,Usability,simpl,simplification,50,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:195,Usability,simpl,simplifications,195,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:28,Availability,failure,failure,28,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:112,Performance,optimiz,optimization,112,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:27,Integrability,message,message,27,"/// Reports an informative message: print \p Msg for debugging purposes as well; /// as an optimization remark. Uses either \p I as location of the remark, or; /// otherwise \p TheLoop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:91,Performance,optimiz,optimization,91,"/// Reports an informative message: print \p Msg for debugging purposes as well; /// as an optimization remark. Uses either \p I as location of the remark, or; /// otherwise \p TheLoop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:643,Performance,perform,performs,643,"//===- SLPVectorizer.h ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:433,Safety,detect,detects,433,"//===- SLPVectorizer.h ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:195,Energy Efficiency,reduce,reduce,195,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:278,Energy Efficiency,reduce,reduce,278,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:231,Security,access,access,231,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:337,Energy Efficiency,reduce,reduced,337,"/// Try to find horizontal reduction or otherwise, collect instructions; /// for postponed vectorization attempts.; /// \a P if not null designates phi node the reduction is fed into; /// (with reduction operators \a Root or one of its operands, in a basic block; /// \a BB).; /// \returns true if a horizontal reduction was matched and reduced.; /// \returns false if \a V is null or not an instruction,; /// or a horizontal reduction was not matched or not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:32,Performance,Optimiz,Optimize,32,"//===-------- VectorCombine.h - Optimize partial vector operations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:393,Performance,optimiz,optimizes,393,"//===-------- VectorCombine.h - Optimize partial vector operations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:4,Performance,Optimiz,Optimize,4,/// Optimize scalar/vector interactions in IR using target cost models.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:18,Performance,perform,perform,18,"/// If true, only perform beneficial early IR transforms. Do not introduce new; /// vector operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:20,Deployability,install,installation,20,/// Get Windows SDK installation directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:29,Modifiability,variab,variables,29,// Check various environment variables to try and find a toolchain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:37,Deployability,install,installs,37,"// Query the Setup Config server for installs, then pick the newest version; // and find its default VC toolchain. If `VCToolsVersion` is specified, that; // version is preferred over the latest version.; //; // This is the preferred way to discover new Visual Studios, as they're no; // longer listed in the registry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:19,Modifiability,Config,Config,19,"// Query the Setup Config server for installs, then pick the newest version; // and find its default VC toolchain. If `VCToolsVersion` is specified, that; // version is preferred over the latest version.; //; // This is the preferred way to discover new Visual Studios, as they're no; // longer listed in the registry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h:42,Deployability,install,installs,42,"// Look in the registry for Visual Studio installs, and use that to get; // a toolchain path. VS2017 and newer don't get added to the registry.; // So if we find something here, we know that it's an older version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCPaths.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:333,Energy Efficiency,charge,charge,333,"// <copyright file=""Program.cpp"" company=""Microsoft Corporation"">; // Copyright (C) Microsoft Corporation. All rights reserved.; // Licensed under the MIT license.; // </copyright>; // <license>; // The MIT License (MIT); //; // Copyright (C) Microsoft Corporation. All rights reserved.; //; // Permission is hereby granted, free of charge, to any person obtaining; // a copy of this software and associated documentation files (the ""Software""),; // to deal in the Software without restriction, including without limitation the; // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; // sell copies of the Software, and to permit persons to whom the Software is; // furnished to do so, subject to the following conditions:; //; // The above copyright notice and this permission notice shall be included in; // all copies or substantial portions of the Software.; //; // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; // SOFTWARE.; // </license>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:1241,Integrability,CONTRACT,CONTRACT,1241,"// <copyright file=""Program.cpp"" company=""Microsoft Corporation"">; // Copyright (C) Microsoft Corporation. All rights reserved.; // Licensed under the MIT license.; // </copyright>; // <license>; // The MIT License (MIT); //; // Copyright (C) Microsoft Corporation. All rights reserved.; //; // Permission is hereby granted, free of charge, to any person obtaining; // a copy of this software and associated documentation files (the ""Software""),; // to deal in the Software without restriction, including without limitation the; // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or; // sell copies of the Software, and to permit persons to whom the Software is; // furnished to do so, subject to the following conditions:; //; // The above copyright notice and this permission notice shall be included in; // all copies or substantial portions of the Software.; //; // THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; // SOFTWARE.; // </license>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:32,Deployability,install,installation,32,/// <summary>; /// The instance installation path exists.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:22,Availability,reboot,reboot,22,/// <summary>; /// No reboot is required for the instance.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:54,Deployability,install,install,54,/// <summary>; /// The instance represents a complete install.; /// </summary>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:11,Integrability,interface,interface,11,// Forward interface declarations; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:3,Integrability,Interface,Interface,3,// Interface definitions; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:248,Availability,failure,failure,248,"/// <summary>; /// Gets the instance identifier (should match the name of the parent instance; /// directory).; /// </summary>; /// <param name=""pbstrInstanceId"">The instance identifier.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:287,Availability,failure,failure,287,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:57,Deployability,install,installation,57,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:90,Deployability,install,installed,90,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:182,Deployability,install,installation,182,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:215,Deployability,install,installed,215,"/// <summary>; /// Gets the local date and time when the installation was originally; /// installed.; /// </summary>; /// <param name=""pInstallDate"">The local date and time when the installation; /// was originally installed.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:371,Availability,failure,failure,371,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:47,Deployability,install,installation,47,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:216,Deployability,install,installation,216,"/// <summary>; /// Gets the unique name of the installation, often indicating the branch and; /// other information used for telemetry.; /// </summary>; /// <param name=""pbstrInstallationName"">The unique name of the installation,; /// often indicating the branch and other information used for; /// telemetry.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:247,Availability,failure,failure,247,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:40,Deployability,install,installation,40,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:147,Deployability,install,installation,147,"/// <summary>; /// Gets the path to the installation root of the product.; /// </summary>; /// <param name=""pbstrInstallationPath"">The path to the installation root of; /// the product.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:260,Availability,failure,failure,260,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:51,Deployability,install,installed,51,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:171,Deployability,install,installed,171,"/// <summary>; /// Gets the version of the product installed in this instance.; /// </summary>; /// <param name=""pbstrInstallationVersion"">The version of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:341,Availability,failure,failure,341,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:64,Deployability,install,installed,64,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:252,Deployability,install,installed,252,"/// <summary>; /// Gets the display name (title) of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the display name.</param>; /// <param name=""pbstrDisplayName"">The display name (title) of the product; /// installed in this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:322,Availability,failure,failure,322,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:55,Deployability,install,installed,55,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:228,Deployability,install,installed,228,"/// <summary>; /// Gets the description of the product installed in this instance.; /// </summary>; /// <param name=""lcid"">The LCID for the description.</param>; /// <param name=""pbstrDescription"">The description of the product installed in; /// this instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:487,Availability,failure,failure,487,"/// <summary>; /// Resolves the optional relative path to the root path of the instance.; /// </summary>; /// <param name=""pwszRelativePath"">A relative path within the instance to; /// resolve, or NULL to get the root path.</param>; /// <param name=""pbstrAbsolutePath"">The full path to the optional relative; /// path within the instance. If the relative path is NULL, the root path will; /// always terminate in a backslash.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:181,Availability,failure,failure,181,"/// <summary>; /// Gets the state of the instance.; /// </summary>; /// <param name=""pState"">The state of the instance.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:258,Availability,failure,failure,258,"/// <summary>; /// Gets an array of package references registered to the instance.; /// </summary>; /// <param name=""ppsaPackages"">Pointer to an array of <see; /// cref=""ISetupPackageReference""/>.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// packages property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:387,Availability,failure,failure,387,"/// <summary>; /// Gets a pointer to the <see cref=""ISetupPackageReference""/> that represents; /// the registered product.; /// </summary>; /// <param name=""ppPackage"">Pointer to an instance of <see; /// cref=""ISetupPackageReference""/>. This may be NULL if <see; /// cref=""GetState""/> does not return <see cref=""eComplete""/>.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist and E_NOTFOUND if the; /// packages property is not defined.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:73,Availability,avail,available,73,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:190,Availability,avail,available,190,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:262,Availability,failure,failure,262,"/// <summary>; /// Gets the relative path to the product application, if available.; /// </summary>; /// <param name=""pbstrProductPath"">The relative path to the product; /// application, if available.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_FILENOTFOUND if the instance state does not exist.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:35,Deployability,install,installed,35,"/// <summary>; /// A enumerator of installed <see cref=""ISetupInstance""/> objects.; /// </summary>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:680,Energy Efficiency,allocate,allocated,680,"/// <summary>; /// Retrieves the next set of product instances in the enumeration sequence.; /// </summary>; /// <param name=""celt"">The number of product instances to retrieve.</param>; /// <param name=""rgelt"">A pointer to an array of <see; /// cref=""ISetupInstance""/>.</param>; /// <param name=""pceltFetched"">A pointer to the number of product instances; /// retrieved. If celt is 1 this parameter may be NULL.</param>; /// <returns>S_OK if the number of elements were fetched, S_FALSE if nothing; /// was fetched (at end of enumeration), E_INVALIDARG if celt is greater than; /// 1 and pceltFetched is NULL, or E_OUTOFMEMORY if an <see; /// cref=""ISetupInstance""/> could not be allocated.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:297,Integrability,interface,interface,297,"/// <summary>; /// Creates a new enumeration object in the same state as the current; /// enumeration object: the new object points to the same place in the; /// enumeration sequence.; /// </summary>; /// <param name=""ppenum"">A pointer to a pointer to a new <see; /// cref=""IEnumSetupInstances""/> interface. If the method fails, this; /// parameter is undefined.</param>; /// <returns>S_OK if a clone was returned; otherwise, E_OUTOFMEMORY.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:248,Availability,failure,failure,248,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:62,Deployability,install,installed,62,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:153,Deployability,install,installed,153,"/// <summary>; /// Enumerates all completed product instances installed.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of completed, installed; /// product instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:211,Availability,failure,failure,211,"/// <summary>; /// Enumerates all product instances.; /// </summary>; /// <param name=""ppEnumInstances"">An enumeration of all product; /// instances.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:192,Availability,failure,failure,192,"/// <summary>; /// Gets the general package identifier.; /// </summary>; /// <param name=""pbstrId"">The general package identifier.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:189,Availability,failure,failure,189,"/// <summary>; /// Gets the version of the package.; /// </summary>; /// <param name=""pbstrVersion"">The version of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:231,Availability,failure,failure,231,"/// <summary>; /// Gets the target process architecture of the package.; /// </summary>; /// <param name=""pbstrChip"">The target process architecture of the; /// package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:229,Availability,failure,failure,229,"/// <summary>; /// Gets the language and optional region identifier.; /// </summary>; /// <param name=""pbstrLanguage"">The language and optional region; /// identifier.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:198,Availability,failure,failure,198,"/// <summary>; /// Gets the build branch of the package.; /// </summary>; /// <param name=""pbstrBranch"">The build branch of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:180,Availability,failure,failure,180,"/// <summary>; /// Gets the type of the package.; /// </summary>; /// <param name=""pbstrType"">The type of the package.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:251,Availability,failure,failure,251,"/// <summary>; /// Gets the unique identifier consisting of all defined tokens.; /// </summary>; /// <param name=""pbstrUniqueId"">The unique identifier consisting of all; /// defined tokens.</param>; /// <returns>Standard HRESULT indicating success or failure, including; /// E_UNEXPECTED if no Id was defined (required).</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:96,Integrability,interface,interface,96,"/// <summary>; /// Helper functions.; /// </summary>; /// <remarks>; /// You can query for this interface from the <see cref=""SetupConfiguration""/>; /// class.; /// </remarks>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:391,Availability,failure,failure,391,"/// <summary>; /// Parses a dotted quad version string into a 64-bit unsigned integer.; /// </summary>; /// <param name=""pwszVersion"">The dotted quad version string to parse, e.g.; /// 1.2.3.4.</param>; /// <param name=""pullVersion"">A 64-bit unsigned integer representing the; /// version. You can compare this to other versions.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:660,Availability,failure,failure,660,"/// <summary>; /// Parses a dotted quad version string into a 64-bit unsigned integer.; /// </summary>; /// <param name=""pwszVersionRange"">The string containing 1 or 2 dotted quad; /// version strings to parse, e.g. [1.0,) that means 1.0.0.0 or newer.</param>; /// <param name=""pullMinVersion"">A 64-bit unsigned integer representing the; /// minimum version, which may be 0. You can compare this to other; /// versions.</param>; /// <param name=""pullMaxVersion"">A 64-bit unsigned integer representing the; /// maximum version, which may be MAXULONGLONG. You can compare this to other; /// versions.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:470,Availability,failure,failure,470,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:146,Deployability,install,installed,146,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h:316,Deployability,install,installed,316,"// Function declarations; //; /// <summary>; /// Gets an <see cref=""ISetupConfiguration""/> that provides information about; /// product instances installed on the machine.; /// </summary>; /// <param name=""ppConfiguration"">The <see cref=""ISetupConfiguration""/> that; /// provides information about product instances installed on the; /// machine.</param>; /// <param name=""pReserved"">Reserved for future use.</param>; /// <returns>Standard HRESULT indicating success or failure.</returns>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsDriver/MSVCSetupApi.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h:567,Security,access,access,567,"//===-- WindowsManifestMerger.h ---------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This file provides a utility for merging Microsoft .manifest files. These; // files are xml documents which contain meta-information about applications,; // such as whether or not admin access is required, system compatibility,; // versions, etc. Part of the linking process of an executable may require; // merging several of these .manifest files using a tree-merge following; // specific rules. Unfortunately, these rules are not documented well; // anywhere. However, a careful investigation of the behavior of the original; // Microsoft Manifest Tool (mt.exe) revealed the rules of this merge. As the; // saying goes, code is the best documentation, so please look below if you are; // interested in the exact merging requirements.; //; // Ref:; // https://msdn.microsoft.com/en-us/library/windows/desktop/aa374191(v=vs.85).aspx; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsManifest/WindowsManifestMerger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h:434,Availability,avail,available,434,"//===-- ResourceScriptToken.h -----------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This declares the .rc script tokens.; // The list of available tokens is located at ResourceScriptTokenList.h.; //; // Ref: msdn.microsoft.com/en-us/library/windows/desktop/aa380599(v=vs.85).aspx; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h:302,Safety,safe,safe,302,// A definition of a single resource script token. Each token has its kind; // (declared in ResourceScriptTokenList) and holds a value - a reference; // representation of the token.; // RCToken does not claim ownership on its value. A memory buffer containing; // the token value should be stored in a safe place and cannot be freed; // nor reallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/WindowsResource/ResourceScriptToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h:30,Usability,clear,clear,30,"/// The flush() function will clear out the current state of the visitor, to; /// allow for explicitly flushing a block's records to the currently; /// recognized thread and process combination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockIndexer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h:475,Energy Efficiency,consumption,consumption,475,"//===- BlockPrinter.h - FDR Block Pretty Printer -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the RecordVisitor which formats a block of records for; // easier human consumption.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h:511,Testability,log,log,511,"//===- BlockVerifier.h - FDR Block Verifier -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the RecordVisitor which verifies a sequence of records; // associated with a block, following the FDR mode log format's specifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h:64,Availability,error,error,64,"// Transitions the current record to the new record, records an error on; // invalid transitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/BlockVerifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:34,Testability,Log,Log,34,"//===- FDRLogBuilder.h - XRay FDR Log Building Utility --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:8,Testability,Log,LogBuilder,8,/// The LogBuilder class allows for creating ad-hoc collections of records; /// through the `add<...>(...)` function. An example use of this API is in; /// crafting arbitrary sequences of records:; ///; /// auto Records = LogBuilder(); /// .add<BufferExtents>(256); /// .add<NewBufferRecord>(1); /// .consume();; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h:222,Testability,Log,LogBuilder,222,/// The LogBuilder class allows for creating ad-hoc collections of records; /// through the `add<...>(...)` function. An example use of this API is in; /// crafting arbitrary sequences of records:; ///; /// auto Records = LogBuilder(); /// .add<BufferExtents>(256); /// .add<NewBufferRecord>(1); /// .consume();; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRLogBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h:5,Deployability,Pipeline,PipelineConsumer,5,"// A PipelineConsumer applies a set of visitors to every consumed Record, in the; // order by which the visitors are added to the pipeline in the order of; // appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h:130,Deployability,pipeline,pipeline,130,"// A PipelineConsumer applies a set of visitors to every consumed Record, in the; // order by which the visitors are added to the pipeline in the order of; // appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:54,Availability,Error,Error,54,/// All producer implementations must yield either an Error or a non-nullptr; /// unique_ptr<Record>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:87,Testability,log,log,87,"// Helper function which gets the next record by speculatively reading through; // the log, finding a buffer extents record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:45,Performance,load,loading,45,/// This producer encapsulates the logic for loading a File-backed; /// RecordProducer hidden behind a DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:35,Testability,log,logic,35,/// This producer encapsulates the logic for loading a File-backed; /// RecordProducer hidden behind a DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h:155,Testability,log,log,155,// What follows are specific Metadata record types which encapsulate the; // information associated with specific metadata record types in an FDR mode; // log.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecords.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h:42,Testability,Log,Log,42,"//===- FDRTraceExpander.h - XRay FDR Mode Log Expander --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // We define an FDR record visitor which can re-constitute XRayRecord instances; // from a sequence of FDR mode records in arrival order into a collection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceExpander.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:383,Testability,Test,Test,383,"//===- FDRTraceWriter.h - XRay FDR Trace Writer -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Test a utility that can write out XRay FDR Mode formatted trace files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:353,Security,validat,validation,353,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:92,Testability,log,log,92,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h:129,Testability,test,testing,129,"/// The FDRTraceWriter allows us to hand-craft an XRay Flight Data Recorder; /// (FDR) mode log file. This is used primarily for testing, generating; /// sequences of FDR records that can be read/processed. It can also be used to; /// generate various kinds of execution traces without using the XRay runtime.; /// Note that this writer does not do any validation, but uses the types of; /// records defined in the FDRRecords.h file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRTraceWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:421,Performance,load,load,421,"//===- FileHeaderReader.h - XRay Trace File Header Reading Function -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions that can load an XRay log header from various; // sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:434,Testability,log,log,434,"//===- FileHeaderReader.h - XRay Trace File Header Reading Function -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions that can load an XRay log header from various; // sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:29,Performance,load,loading,29,/// Convenience function for loading the file header given a data extractor at a; /// specified offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:733,Availability,avail,available,733,"/// A Graph object represents a Directed Graph and is used in XRay to compute; /// and store function call graphs and associated statistical information.; ///; /// The graph takes in four template parameters, these are:; /// - VertexAttribute, this is a structure which is stored for each vertex.; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each edge; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each variable; /// - VI, this is a type over which DenseMapInfo is defined and is the type; /// used look up strings, available as VertexIdentifier.; /// - If the built in DenseMapInfo is not defined, provide a specialization; /// class type here.; ///; /// Graph is CopyConstructible, CopyAssignable, MoveConstructible and; /// MoveAssignable but is not EqualityComparible or LessThanComparible.; ///; /// Usage Example Graph with weighted edges and vertices:; /// Graph<int, int, int> G;; ///; /// G[1] = 0;; /// G[2] = 2;; /// G[{1,2}] = 1;; /// G[{2,1}] = -1;; /// for(const auto &v : G.vertices()){; /// // Do something with the vertices in the graph;; /// }; /// for(const auto &e : G.edges()){; /// // Do something with the edges in the graph;; /// }; ///; /// Usage Example with StrRef keys.; /// Graph<int, double, StrRef> StrG;; /// char va[] = ""Vertex A"";; /// char vaa[] = ""Vertex A"";; /// char vb[] = ""Vertex B""; // Vertices are referenced by String Refs.; /// G[va] = 0;; /// G[vb] = 1;; /// G[{va, vb}] = 1.0;; /// cout() << G[vaa] << "" "" << G[{vaa, vb}]; //prints ""0 1.0"".; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:620,Modifiability,variab,variable,620,"/// A Graph object represents a Directed Graph and is used in XRay to compute; /// and store function call graphs and associated statistical information.; ///; /// The graph takes in four template parameters, these are:; /// - VertexAttribute, this is a structure which is stored for each vertex.; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each edge; /// Must be DefaultConstructible, CopyConstructible, CopyAssignable and; /// Destructible.; /// - EdgeAttribute, this is a structure which is stored for each variable; /// - VI, this is a type over which DenseMapInfo is defined and is the type; /// used look up strings, available as VertexIdentifier.; /// - If the built in DenseMapInfo is not defined, provide a specialization; /// class type here.; ///; /// Graph is CopyConstructible, CopyAssignable, MoveConstructible and; /// MoveAssignable but is not EqualityComparible or LessThanComparible.; ///; /// Usage Example Graph with weighted edges and vertices:; /// Graph<int, int, int> G;; ///; /// G[1] = 0;; /// G[2] = 2;; /// G[{1,2}] = 1;; /// G[{2,1}] = -1;; /// for(const auto &v : G.vertices()){; /// // Do something with the vertices in the graph;; /// }; /// for(const auto &e : G.edges()){; /// // Do something with the edges in the graph;; /// }; ///; /// Usage Example with StrRef keys.; /// Graph<int, double, StrRef> StrG;; /// char va[] = ""Vertex A"";; /// char vaa[] = ""Vertex A"";; /// char vb[] = ""Vertex B""; // Vertices are referenced by String Refs.; /// G[va] = 0;; /// G[vb] = 1;; /// G[{va, vb}] = 1.0;; /// cout() << G[vaa] << "" "" << G[{vaa, vb}]; //prints ""0 1.0"".; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Energy Efficiency,adapt,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Integrability,adapter,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:16,Modifiability,adapt,adapter,16,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:185,Performance,perform,performed,185,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:94,Security,access,access,94,/// Returns a view object allowing iteration over the vertices of the graph.; /// also allows access to the size of the vertex set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:91,Security,access,access,91,/// Returns a view object allowing iteration over the edges of the graph.; /// also allows access to the size of the edge set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:47,Availability,error,error,47,"/// Looks up a vertex with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:46,Availability,error,error,46,"/// Looks up an edge with Identifier I, or an error if it does not exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:161,Deployability,update,update,161,"/// Inserts an edge into the graph with Identifier Val.first, and; /// Attribute Val.second. If the key is already in the map, it returns false; /// and doesn't update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:161,Deployability,update,update,161,"/// Inserts an edge into the graph with Identifier Val.first, and; /// Attribute Val.second. If the key is already in the map, it returns false; /// and doesn't update the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:395,Integrability,interface,interface,395,"//===- InstrumentationMap.h - XRay Instrumentation Map ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the interface for extracting the instrumentation map from an; // XRay-instrumented binary.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:4,Performance,Load,Loads,4,/// Loads the instrumentation map from |Filename|. This auto-deduces the type of; /// the instrumentation map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:163,Integrability,interface,interface,163,"/// The InstrumentationMap represents the computed function id's and indicated; /// function addresses from an object file (or a YAML file). This provides an; /// interface to just the mapping between the function id, and the function; /// address.; ///; /// We also provide raw access to the actual instrumentation map entries we find; /// associated with a particular object file.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:279,Security,access,access,279,"/// The InstrumentationMap represents the computed function id's and indicated; /// function addresses from an object file (or a YAML file). This provides an; /// interface to just the mapping between the function id, and the function; /// address.; ///; /// We also provide raw access to the actual instrumentation map entries we find; /// associated with a particular object file.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:19,Security,access,accessor,19,/// Provides a raw accessor to the unordered map of function addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:22,Security,access,access,22,/// Provide read-only access to the entries of the instrumentation map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:431,Performance,latency,latency,431,"//===- Profile.h - XRay Profile Abstraction -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:123,Availability,error,errors,123,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:228,Availability,Error,Error,228,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:34,Performance,load,load,34,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:149,Performance,load,loading,149,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:96,Availability,error,error,96,/// Provides a sequence of function IDs from a previously interned PathID.; ///; /// Returns an error if |P| had not been interned before into the Profile.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:81,Availability,error,error,81,/// Appends a fully-formed Block instance into the Profile.; ///; /// Returns an error condition in the following cases:; ///; /// - The PathData component of the Block is empty; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:714,Availability,error,error,714,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:57,Performance,load,loaded,57,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:391,Performance,load,loaded,391,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:453,Performance,load,loadTraceFile,453,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:284,Security,access,accessor,284,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:79,Testability,log,log,79,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:144,Testability,log,logic,144,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:473,Testability,log,log,473,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:27,Performance,load,loaded,27,/// Provides access to the loaded XRay trace file header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:13,Security,access,access,13,/// Provides access to the loaded XRay trace file header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,Performance,load,load,34,/// This function will attempt to load XRay trace records from the provided; /// |Filename|.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,Performance,load,load,34,/// This function will attempt to load XRay trace records from the provided; /// DataExtractor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:435,Testability,log,log,435,"//===- XRayRecord.h - XRay Trace Record -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file replicates the record definition for XRay log entries. This should; // follow the evolution of the log record versions supported in the compiler-rt; // xray project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:492,Testability,log,log,492,"//===- XRayRecord.h - XRay Trace Record -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file replicates the record definition for XRay log entries. This should; // follow the evolution of the log record versions supported in the compiler-rt; // xray project.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:141,Availability,avail,available,141,/// XRay traces all have a header providing some top-matter information useful; /// to help tools determine how to interpret the information available in the; /// trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:21,Integrability,depend,depending,21,// This is different depending on the type of xray record. The naive format; // stores a Wallclock timespec. FDR logging stores the size of a thread; // buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:113,Testability,log,logging,113,// This is different depending on the type of xray record. The naive format; // stores a Wallclock timespec. FDR logging stores the size of a thread; // buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:170,Performance,load,loader,170,/// Determines the supported types of records that could be seen in XRay traces.; /// This may or may not correspond to actual record types in the raw trace (as; /// the loader implementation may synthesize this information in the process of; /// of loading).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:250,Performance,load,loading,250,/// Determines the supported types of records that could be seen in XRay traces.; /// This may or may not correspond to actual record types in the raw trace (as; /// the loader implementation may synthesize this information in the process of; /// of loading).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:171,Testability,log,logical,171,"/// An XRayRecord is the denormalized view of data associated in a trace. These; /// records may not correspond to actual entries in the raw traces, but they are; /// the logical representation of records in a higher-level event log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:229,Testability,log,log,229,"/// An XRayRecord is the denormalized view of data associated in a trace. These; /// records may not correspond to actual entries in the raw traces, but they are; /// the logical representation of records in a higher-level event log.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:52,Testability,log,log,52,/// Get the full 8 bytes of the TSC when we get the log record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h:437,Testability,log,log,437,"//===- YAMLXRayRecord.h - XRay Record YAML Support Definitions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Types and traits specialisations for YAML I/O of XRay log entries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/YAMLXRayRecord.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:47,Integrability,Interface,Interface,47,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:676,Integrability,interface,interface,676,"/*===-- llvm-c/Analysis.h - Analysis Library C Interface --------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMAnalysis.a, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h:37,Safety,abort,abort,37,/* verifier will print to stderr and abort() */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:49,Integrability,Interface,Interface,49,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:678,Integrability,interface,interface,678,"/*===-- llvm-c/BitReader.h - BitReader Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitReader.a, which *|; |* implements input of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:268,Availability,error,error,268,"/**; * @defgroup LLVMCBitReader Bit Reader; * @ingroup LLVMC; *; * @{; */; /* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. This is deprecated. Use LLVMParseBitcode2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:274,Integrability,message,message,274,"/**; * @defgroup LLVMCBitReader Bit Reader; * @ingroup LLVMC; *; * @{; */; /* Builds a module from the bitcode in the specified memory buffer, returning a; reference to the module via the OutModule parameter. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage. This is deprecated. Use LLVMParseBitcode2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:193,Availability,error,error,193,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:199,Integrability,message,message,199,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:103,Performance,perform,performs,103,"/** Reads a module from the specified path, returning via the OutMP parameter; a module provider which performs lazy deserialization. Returns 0 on success.; Optionally returns a human-readable error message via OutMessage.; This is deprecated. Use LLVMGetBitcodeModuleInContext2. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h:110,Performance,perform,performs,110,"/** Reads a module from the given memory buffer, returning via the OutMP; * parameter a module provider which performs lazy deserialization.; *; * Returns 0 on success.; *; * Takes ownership of \p MemBuf if (and only if) the module was read; * successfully. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:49,Integrability,Interface,Interface,49,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h:679,Integrability,interface,interface,679,"/*===-- llvm-c/BitWriter.h - BitWriter Library C Interface ------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMBitWriter.a, which *|; |* implements output of the LLVM bitcode format. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/BitWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:92,Deployability,Release,Released,92,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:35,Integrability,Interface,Interface,35,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:362,Integrability,interface,interface,362,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:536,Safety,avoid,avoid,536,/*===-- llvm-c/blake3.h - BLAKE3 C Interface ----------------------*- C -*-===*\; |* *|; |* Released into the public domain with CC0 1.0 *|; |* See 'llvm/lib/Support/BLAKE3/LICENSE' for info. *|; |* SPDX-License-Identifier: CC0-1.0 *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to LLVM's BLAKE3 implementation. *|; |* Original BLAKE3 C API: https://github.com/BLAKE3-team/BLAKE3/tree/1.3.1/c *|; |* *|; |* Symbols are prefixed with 'llvm' to avoid a potential conflict with *|; |* another BLAKE3 version within the same program. *|; |* *|; \*===----------------------------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h:204,Availability,down,down,204,"// The stack size is MAX_DEPTH + 1 because we do lazy merging. For example,; // with 7 chunks, we have 3 entries in the stack. Adding an 8th chunk; // requires a 4th entry, rather than merging everything down to 1, because we; // don't know whether more input is coming. This is different from how the; // reference implementation does things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/blake3.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/blake3.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:42,Integrability,Interface,Interface,42,"/*===-- llvm-c/Comdat.h - Module Comdat C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to COMDAT. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Comdat.h - Module Comdat C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to COMDAT. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h:25,Performance,perform,performed,25,///< No deduplication is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Comdat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Comdat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:39,Integrability,Interface,Interface,39,"/*===-- llvm-c/Core.h - Core Library C Interface ------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMCore.a, which implements *|; |* the LLVM intermediate representation. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Core.h - Core Library C Interface ------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMCore.a, which implements *|; |* the LLVM intermediate representation. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:33,Integrability,interface,interface,33,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:240,Integrability,interface,interface,240,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:512,Integrability,interface,interface,512,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:668,Integrability,depend,depend,668,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:723,Safety,safe,safe,723,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:69,Security,expose,exposes,69,"/**; * @defgroup LLVMC LLVM-C: C interface to LLVM; *; * This module exposes parts of the LLVM library as a C API.; *; * @{; */; /**; * @defgroup LLVMCTransforms Transforms; */; /**; * @defgroup LLVMCCore Core; *; * This modules provide an interface to libLLVMCore, which implements; * the LLVM intermediate representation as well as other related types; * and utilities.; *; * Many exotic languages can interoperate with C code but have a harder time; * with C++ due to name mangling. So in addition to C, this interface enables; * tools written in such languages.; *; * @{; */; /**; * @defgroup LLVMCCoreTypes Types and Enumerations; *; * @{; */; /// External users depend on the following values being stable. It is not safe; /// to reorder them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:3,Testability,Log,Logical,3,/* Logical Operators */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:5,Performance,Scalab,Scalable,5,/**< Scalable SIMD vector type */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:20,Security,access,accessible,20,/**< Function to be accessible from DLL. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:7,Performance,load,load,7,/**< A load or store which is not atomic */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Performance,load,loads,109,/**< Acquire provides a barrier of the sort; necessary to acquire a lock to access other; memory with normal loads and stores. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:76,Security,access,access,76,/**< Acquire provides a barrier of the sort; necessary to acquire a lock to access other; memory with normal loads and stores. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:5,Deployability,Release,Release,5,"/**< Release is similar to Acquire, but with; a barrier of the sort necessary to release; a lock. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:81,Deployability,release,release,81,"/**< Release is similar to Acquire, but with; a barrier of the sort necessary to release; a lock. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:37,Deployability,Release,Release,37,/**< provides both an Acquire and a; Release barrier (for fences and; operations which both read and write; memory). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Deployability,Release,Release,47,"/**< provides Acquire semantics; for loads and Release; semantics for stores.; Additionally, it guarantees; that a total ordering exists; between all; SequentiallyConsistent; operations. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:37,Performance,load,loads,37,"/**< provides Acquire semantics; for loads and Release; semantics for stores.; Additionally, it guarantees; that a total ordering exists; between all; SequentiallyConsistent; operations. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:16,Availability,error,error,16,"/**; * Emits an error if two values disagree, otherwise the resulting value is; * that of the operands.; *; * @see Module::ModFlagBehavior::Error; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:140,Availability,Error,Error,140,"/**; * Emits an error if two values disagree, otherwise the resulting value is; * that of the operands.; *; * @see Module::ModFlagBehavior::Error; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:421,Availability,error,error,421,"/**; * Adds a requirement that another module flag be present and have a; * specified value after linking is performed. The value must be a metadata; * pair, where the first element of the pair is the ID of the module flag; * to be restricted, and the second element of the pair is the value the; * module flag should be restricted to. This behavior can be used to; * restrict the allowable results (via triggering of an error) of linking; * IDs with the **Override** behavior.; *; * @see Module::ModFlagBehavior::Require; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Performance,perform,performed,109,"/**; * Adds a requirement that another module flag be present and have a; * specified value after linking is performed. The value must be a metadata; * pair, where the first element of the pair is the ID of the module flag; * to be restricted, and the second element of the pair is the value the; * module flag should be restricted to. This behavior can be used to; * restrict the allowable results (via triggering of an error) of linking; * IDs with the **Override** behavior.; *; * @see Module::ModFlagBehavior::Require; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:160,Availability,error,error,160,"/**; * Uses the specified value, regardless of the behavior or value of the; * other module. If both modules specify **Override**, but the values; * differ, an error will be emitted.; *; * @see Module::ModFlagBehavior::Override; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,Performance,optimiz,optimizations,46,/**; * Flags to indicate what fast-math-style optimizations are allowed; * on operations.; *; * See https://llvm.org/docs/LangRef.html#fast-math-flags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:60,Modifiability,variab,variables,60,/**; * @}; */; /** Deallocate and destroy all ManagedStatic variables.; @see llvm::llvm_shutdown; @see ManagedStatic */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:118,Deployability,patch,patch,118,"/*===-- Version query -----------------------------------------------------===*/; /**; * Return the major, minor, and patch version of LLVM; *; * The version components are returned via the function's three output; * parameters or skipped if a NULL pointer was supplied.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:8,Availability,Error,Error,8,/*===-- Error handling ----------------------------------------------------===*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:235,Safety,safe,safe,235,"/**; * @defgroup LLVMCCoreContext Contexts; *; * Contexts are execution states for the core LLVM IR system.; *; * Most types are tied to a context instance. Multiple contexts can; * exist simultaneously. A single context is not thread safe. However,; * different contexts can execute on different threads simultaneously.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:124,Availability,avail,available,124,"/**; * Set whether the given context discards all value names.; *; * If true, only the names of GlobalValue objects will be available in the IR.; * This can be used to save memory and runtime, especially in release mode.; *; * @see LLVMContext::setDiscardValueNames(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:207,Deployability,release,release,207,"/**; * Set whether the given context discards all value names.; *; * If true, only the names of GlobalValue objects will be available in the IR.; * This can be used to save memory and runtime, especially in release mode.; *; * @see LLVMContext::setDiscardValueNames(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:253,Availability,avail,available,253,"/**; * Return an unique id given the name of a enum attribute,; * or 0 if no attribute by that name exists.; *; * See http://llvm.org/docs/LangRef.html#parameter-attributes; * and http://llvm.org/docs/LangRef.html#function-attributes; * for the list of available attributes.; *; * NB: Attribute names and/or id are subject to change without; * going through the C API deprecation cycle.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:57,Availability,Error,ErrorMessage,57,"/**; * Print a representation of a module to a file. The ErrorMessage needs to be; * disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.; *; * @see Module::print(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:242,Availability,alive,alive,242,"/**; * @}; */; /**; * @defgroup LLVMCCoreType Types; *; * Types represent the type of a value.; *; * Types are associated with a context instance. The context internally; * deduplicates types so there is only 1 instance of a specific type; * alive at a time. In other words, a unique type is shared among all; * consumers within a context.; *; * A Type in the C API corresponds to llvm::Type.; *; * Types have the following hierarchy:; *; * types:; * integer type; * real type; * function type; * sequence types:; * array type; * pointer type; * vector type; * void type; * label type; * opaque type; *; * @{; */; /**; * Obtain the enumerated type of a Type instance.; *; * @see llvm::Type:getTypeID(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:99,Energy Efficiency,allocate,allocated,99,"/**; * Obtain the types of a function's parameters.; *; * The Dest parameter should point to a pre-allocated array of; * LLVMTypeRef at least LLVMCountParamTypes() large. On return, the; * first LLVMCountParamTypes() entries in the array will be populated; * with LLVMTypeRef instances.; *; * @param FunctionTy The function type to operate on.; * @param Dest Memory address of an array to be filled with result.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:94,Energy Efficiency,allocate,allocated,94,"/**; * Get the elements within a structure.; *; * The function is passed the address of a pre-allocated array of; * LLVMTypeRef at least LLVMCountStructElementTypes() long. After; * invocation, this array will be populated with the structure's; * elements. The objects in the destination array will have a lifetime; * of the structure type itself, which is the lifetime of the context it; * is contained in.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:67,Performance,scalab,scalable,67,/**; * Create a vector type that contains a defined type and has a scalable; * number of elements.; *; * The created type will exist in the context thats its element type; * exists in.; *; * @see llvm::ScalableVectorType::get(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:202,Performance,Scalab,ScalableVectorType,202,/**; * Create a vector type that contains a defined type and has a scalable; * number of elements.; *; * The created type will exist in the context thats its element type; * exists in.; *; * @see llvm::ScalableVectorType::get(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:28,Performance,scalab,scalable,28,/**; * Obtain the (possibly scalable) number of elements in a vector type.; *; * This only works on types that represent vectors (fixed or scalable).; *; * @see llvm::VectorType::getNumElements(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:139,Performance,scalab,scalable,139,/**; * Obtain the (possibly scalable) number of elements in a vector type.; *; * This only works on types that represent vectors (fixed or scalable).; *; * @see llvm::VectorType::getNumElements(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:343,Availability,avail,available,343,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:559,Availability,avail,available,559,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:287,Integrability,Depend,Depending,287,"/**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreValues Values; *; * The bulk of LLVM's object model consists of values, which comprise a very; * rich type hierarchy.; *; * LLVMValueRef essentially represents llvm::Value. There is a rich; * hierarchy of classes within this type. Depending on the instance; * obtained, not all APIs are available.; *; * Callers can determine the type of an LLVMValueRef by calling the; * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These; * functions are defined by a macro, so it isn't obvious which are; * available by looking at the Doxygen source code. Instead, look at the; * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list; * of value names given. These value names also correspond to classes in; * the llvm::Value hierarchy.; *; * @{; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:182,Availability,avail,available,182,"/**; * @defgroup LLVMCCoreValueGeneral General APIs; *; * Functions in this section work on all LLVMValueRef instances,; * regardless of their sub-type. They correspond to functions available; * on llvm::Value.; *; * @{; */; /**; * Obtain the type of a value.; *; * @see llvm::Value::getType(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:148,Availability,avail,available,148,/**; * Obtain the next use of a value.; *; * This effectively advances the iterator. It returns NULL if you are on; * the final use and no more are available.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:766,Modifiability,extend,extend,766,"/**; * @defgroup LLVMCCoreValueConstantScalar Scalar constants; *; * Functions in this group model LLVMValueRef instances that correspond; * to constants referring to scalar types.; *; * For integer types, the LLVMTypeRef parameter should correspond to a; * llvm::IntegerType instance and the returned LLVMValueRef will; * correspond to a llvm::ConstantInt.; *; * For floating point types, the LLVMTypeRef returned corresponds to a; * llvm::ConstantFP.; *; * @{; */; /**; * Obtain a constant value for an integer type.; *; * The returned value corresponds to a llvm::ConstantInt.; *; * @see llvm::ConstantInt::get(); *; * @param IntTy Integer type to obtain value of.; * @param N The value the returned instance should refer to.; * @param SignExtend Whether to sign extend the produced value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:125,Availability,avail,available,125,"/**; * Obtain a constant value for an integer parsed from a string.; *; * A similar API, LLVMConstIntOfStringAndSize is also available. If the; * string's length is available, it is preferred to call that function; * instead.; *; * @see llvm::ConstantInt::get(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:165,Availability,avail,available,165,"/**; * Obtain a constant value for an integer parsed from a string.; *; * A similar API, LLVMConstIntOfStringAndSize is also available. If the; * string's length is available, it is preferred to call that function; * instead.; *; * @see llvm::ConstantInt::get(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:132,Availability,avail,available,132,"/**; * Obtain a constant for a floating point value parsed from a string.; *; * A similar API, LLVMConstRealOfStringAndSize is also available. It; * should be used if the input string's length is known.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:23,Modifiability,extend,extended,23,/**; * Obtain the zero extended value for an integer constant value.; *; * @see llvm::ConstantInt::getZExtValue(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:23,Modifiability,extend,extended,23,/**; * Obtain the sign extended value for an integer constant value.; *; * @see llvm::ConstantInt::getSExtValue(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:149,Modifiability,variab,variables,149,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:160,Performance,load,load,160,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:301,Performance,Load,LoadInst,301,"/**; * @defgroup LLVMCCoreValueWithAlignment Values with alignment; *; * Functions in this group only apply to values with alignment, i.e.; * global variables, load and store instructions.; */; /**; * Obtain the preferred alignment of the value.; * @see llvm::AllocaInst::getAlignment(); * @see llvm::LoadInst::getAlignment(); * @see llvm::StoreInst::getAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::getAlignment(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:104,Performance,Load,LoadInst,104,/**; * Set the preferred alignment of the value.; * @see llvm::AllocaInst::setAlignment(); * @see llvm::LoadInst::setAlignment(); * @see llvm::StoreInst::setAlignment(); * @see llvm::AtomicRMWInst::setAlignment(); * @see llvm::AtomicCmpXchgInst::setAlignment(); * @see llvm::GlobalValue::setAlignment(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:88,Usability,clear,clearMetadata,88,/**; * Removes all metadata attachments from this value.; *; * @see llvm::GlobalObject::clearMetadata(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:75,Modifiability,Variab,Variables,75,/**; * @}; */; /**; * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables; *; * This group contains functions that operate on global variable values.; *; * @see llvm::GlobalVariable; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:144,Modifiability,variab,variable,144,/**; * @}; */; /**; * @defgroup LLVMCoreValueConstantGlobalVariable Global Variables; *; * This group contains functions that operate on global variable values.; *; * @see llvm::GlobalVariable; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:20,Integrability,depend,dependent,20,/**; * Add a target-dependent attribute to a function; * @see llvm::AttrBuilder::addAttribute(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:79,Energy Efficiency,allocate,allocated,79,/**; * Obtain the parameters in a function.; *; * The takes a pointer to a pre-allocated array of LLVMValueRef that is; * at least LLVMCountParams() long. This array will be filled with; * LLVMValueRef instances which correspond to the parameters the; * function receives. Each LLVMValueRef corresponds to a llvm::Argument; * instance.; *; * @see llvm::Function::arg_begin(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:139,Integrability,wrap,wrapped,139,/**; * Obtain the next parameter to a function.; *; * This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is; * actually a wrapped iterator) and obtains the next parameter from the; * underlying iterator.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:156,Availability,alive,alive,156,/**; * Remove a global indirect function from its parent module.; *; * This unlinks the global indirect function from its containing module but; * keeps it alive.; *; * @see llvm::GlobalIFunc::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:145,Energy Efficiency,allocate,allocated,145,/**; * Obtain all of the basic blocks in a function.; *; * This operates on a function value. The BasicBlocks parameter is a; * pointer to a pre-allocated array of LLVMBasicBlockRef of at least; * LLVMCountBasicBlocks() in length. This array is populated with; * LLVMBasicBlockRef instances.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:137,Availability,alive,alive,137,/**; * Remove a basic block from a function.; *; * This deletes the basic block from its containing function but keep; * the basic block alive.; *; * @see llvm::BasicBlock::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:123,Availability,alive,alive,123,/**; * Remove an instruction.; *; * The instruction specified is removed from its containing building; * block but is kept alive.; *; * @see llvm::Instruction::removeFromParent(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:62,Integrability,rout,routine,62,/**; * Determine whether an instruction is a terminator. This routine is named to; * be compatible with historical functions that did this by querying the; * underlying C++ type.; *; * @see llvm::Instruction::isTerminator(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:7,Deployability,Update,Update,7,/**; * Update the specified successor to point at the provided block.; *; * @see llvm::Instruction::setSuccessor; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:223,Energy Efficiency,allocate,allocated,223,/**; * @}; */; /**; * @defgroup LLVMCCoreValueInstructionAlloca Allocas; *; * Functions in this group only apply to instructions that map to; * llvm::AllocaInst instances.; *; * @{; */; /**; * Obtain the type that is being allocated by the alloca instruction.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:247,Integrability,interface,interface,247,/**; * @}; */; /**; * @}; */; /**; * @}; */; /**; * @defgroup LLVMCCoreInstructionBuilder Instruction Builders; *; * An instruction builder represents a point within a basic block and is; * the exclusive means of building instructions using the C interface.; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:72,Usability,clear,clear,72,"/**; * Set location information used by debugging information.; *; * To clear the location metadata of the given instruction, pass NULL to \p Loc.; *; * @see llvm::IRBuilder::SetCurrentDebugLocation(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:84,Usability,clear,clear,84,"/**; * Set the default floating-point math metadata for the given builder.; *; * To clear the metadata, pass NULL to \p FPMathTag.; *; * @see llvm::IRBuilder::setDefaultFPMathTag(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:132,Energy Efficiency,allocate,allocated,132,"/**; * Obtain the basic blocks acting as handlers for a catchswitch instruction.; *; * The Handlers parameter should point to a pre-allocated array of; * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the; * first LLVMGetNumHandlers() entries in the array will be populated; * with LLVMBasicBlockRef instances.; *; * @param CatchSwitch The catchswitch instruction to operate on.; * @param Handlers Memory address of an array to be filled with basic blocks.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Performance,optimiz,optimizations,47,/**; * Get the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:48,Performance,optimiz,optimizations,48,/**; * Sets the flags for which fast-math-style optimizations are allowed for this; * value.; *; * Only valid on floating point instructions.; * @see LLVMCanValueUseFastMathFlags; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:41,Availability,mask,mask,41,/**; * Get the number of elements in the mask of a ShuffleVector instruction.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:15,Availability,mask,mask,15,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:49,Availability,mask,mask,49,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:151,Availability,mask,mask,151,/**; * Get the mask value at position Elt in the mask of a ShuffleVector; * instruction.; *; * \Returns the result of \c LLVMGetUndefMaskElem() if the mask value is; * poison at that position.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:143,Deployability,pipeline,pipeline,143,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:166,Deployability,pipeline,pipeline,166,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:202,Performance,optimiz,optimization,202,/**; * @}; */; /**; * @defgroup LLVMCCorePassManagers Pass Managers; * @ingroup LLVMCCore; *; * @{; */; /** Constructs a new whole-module pass pipeline. This type of pipeline is; suitable for link-time optimization and whole-module transformations.; @see llvm::PassManager::PassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:47,Deployability,pipeline,pipeline,47,/** Constructs a new function-by-function pass pipeline over the module; provider. It does not take ownership of the module provider. This type of; pipeline is suitable for code generation and JIT compilation tasks.; @see llvm::FunctionPassManager::FunctionPassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:148,Deployability,pipeline,pipeline,148,/** Constructs a new function-by-function pass pipeline over the module; provider. It does not take ownership of the module provider. This type of; pipeline is suitable for code generation and JIT compilation tasks.; @see llvm::FunctionPassManager::FunctionPassManager */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:83,Energy Efficiency,schedul,scheduled,83,"/** Initializes, executes on the provided module, and finalizes all of the; passes scheduled in the pass manager. Returns 1 if any of the passes; modified the module, 0 otherwise.; @see llvm::PassManager::run(Module&) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:43,Energy Efficiency,schedul,scheduled,43,"/** Initializes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doInitialization */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:40,Energy Efficiency,schedul,scheduled,40,"/** Executes all of the function passes scheduled in the function pass manager; on the provided function. Returns 1 if any of the passes modified the; function, false otherwise.; @see llvm::FunctionPassManager::run(Function&) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:41,Energy Efficiency,schedul,scheduled,41,"/** Finalizes all of the function passes scheduled in the function pass; manager. Returns 1 if any of the passes modified the module, 0 otherwise.; @see llvm::FunctionPassManager::doFinalization */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:31,Deployability,pipeline,pipeline,31,"/** Frees the memory of a pass pipeline. For function pipelines, does not free; the module provider.; @see llvm::PassManagerBase::~PassManagerBase. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:54,Deployability,pipeline,pipelines,54,"/** Frees the memory of a pass pipeline. For function pipelines, does not free; the module provider.; @see llvm::PassManagerBase::~PassManagerBase. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:164,Performance,Multi-thread,Multi-threading,164,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:109,Safety,safe,safe,109,/**; * @}; */; /**; * @defgroup LLVMCCoreThreading Threading; *; * Handle the structures needed to make LLVM safe for multithreading.; *; * @{; */; /** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. This function always returns; LLVMIsMultithreaded(). */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:16,Performance,Multi-thread,Multi-threading,16,/** Deprecated: Multi-threading can only be enabled/disabled with the compile; time define LLVM_ENABLE_THREADS. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h:46,Safety,safe,safe,46,/** Check whether LLVM is executing in thread-safe mode or not.; @see llvm::llvm_is_multithreaded */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Core.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Core.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h:584,Modifiability,portab,portability,584,"/*===-- include/llvm-c/DataTypes.h - Define fixed size types ------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file contains definitions to figure out the size of _HOST_ data types.*|; |* This file is important because different host OS's define different macros,*|; |* which makes portability tough. This file exports the following *|; |* definitions: *|; |* *|; |* [u]int(32|64)_t : typedefs for signed and unsigned 32/64 bit system types*|; |* [U]INT(8|16|32|64)_(MIN|MAX) : Constants for the min and max values. *|; |* *|; |* No library is required when using these functions. *|; |* *|; |*===----------------------------------------------------------------------===*/; /* Please leave this file C-compatible. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DataTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:477,Integrability,interface,interface,477,"//===------------ DebugInfo.h - LLVM C API Debug Info API -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file declares the C API endpoints for generating DWARF Debug Info; ///; /// Note: This interface is experimental. It is *NOT* stable, and may be; /// changed without warning.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variables,49,/**; * Finalize a specific subprogram.; * No new variables may be added to this subprogram afterwards.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:488,Performance,optimiz,optimization,488,"/**; * A CompileUnit provides an anchor for all debugging; * information generated during this instance of compilation.; * \param Lang Source programming language, eg.; * \c LLVMDWARFSourceLanguageC99; * \param FileRef File info.; * \param Producer Identify the producer of debugging information; * and code. Usually this is a compiler; * version string.; * \param ProducerLen The length of the C string passed to \c Producer.; * \param isOptimized A boolean flag which indicates whether optimization; * is enabled or not.; * \param Flags This string lists command line options. This; * string is directly embedded in debug info; * output which may be used by a tool; * analyzing generated debugging information.; * \param FlagsLen The length of the C string passed to \c Flags.; * \param RuntimeVer This indicates runtime version for languages like; * Objective-C.; * \param SplitName The name of the file that we'll split debug info; * out into.; * \param SplitNameLen The length of the C string passed to \c SplitName.; * \param Kind The kind of debug information to generate.; * \param DWOId The DWOId if this is a split skeleton compile unit.; * \param SplitDebugInlining Whether to emit inline debug info.; * \param DebugInfoForProfiling Whether to emit extra debug info for; * profile collection.; * \param SysRoot The Clang system root (value of -isysroot).; * \param SysRootLen The length of the C string passed to \c SysRoot.; * \param SDK The SDK. On Darwin, the last component of the sysroot.; * \param SDKLen The length of the C string passed to \c SDK.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:291,Modifiability,Config,ConfigMacros,291,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:415,Modifiability,Config,ConfigMacrosLen,415,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:471,Modifiability,Config,ConfigMacros,471,/**; * Creates a new descriptor for a module with the specified parent scope.; * \param Builder The \c DIBuilder.; * \param ParentScope The parent scope containing this module declaration.; * \param Name Module name.; * \param NameLen The length of the C string passed to \c Name.; * \param ConfigMacros A space-separated shell-quoted list of -D macro; definitions as they would appear on a command line.; * \param ConfigMacrosLen The length of the C string passed to \c ConfigMacros.; * \param IncludePath The path to the module map file.; * \param IncludePathLen The length of the C string passed to \c IncludePath.; * \param APINotesFile The path to an API notes file for the module.; * \param APINotesFileLen The length of the C string passed to \c APINotestFile.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:330,Modifiability,variab,variable,330,/**; * Create a new descriptor for the specified subprogram.; * \param Builder The \c DIBuilder.; * \param Scope Function scope.; * \param Name Function name.; * \param NameLen Length of enumeration name.; * \param LinkageName Mangled function name.; * \param LinkageNameLen Length of linkage name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Function type.; * \param IsLocalToUnit True if this function is not externally visible.; * \param IsDefinition True if this is a function definition.; * \param ScopeLine Set to the beginning of the scope this starts; * \param Flags E.g.: \c LLVMDIFlagLValueReference. These flags are; * used to emit dwarf attributes.; * \param IsOptimized True if optimization is ON.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:742,Performance,optimiz,optimization,742,/**; * Create a new descriptor for the specified subprogram.; * \param Builder The \c DIBuilder.; * \param Scope Function scope.; * \param Name Function name.; * \param NameLen Length of enumeration name.; * \param LinkageName Mangled function name.; * \param LinkageNameLen Length of linkage name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Function type.; * \param IsLocalToUnit True if this function is not externally visible.; * \param IsDefinition True if this is a function definition.; * \param ScopeLine Set to the beginning of the scope this starts; * \param Flags E.g.: \c LLVMDIFlagLValueReference. These flags are; * used to emit dwarf attributes.; * \param IsOptimized True if optimization is ON.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:62,Modifiability,variab,variable,62,"/**; * Create a descriptor for an imported function, type, or variable. Suitable; * for e.g. FORTRAN-style USE declarations.; * \param Builder The DIBuilder.; * \param Scope The scope this module is imported into.; * \param Decl The declaration (or definition) of a function, type,; or variable.; * \param File File where the declaration is located.; * \param Line Line number of the declaration.; * \param Name A name that uniquely identifies this imported; declaration.; * \param NameLen The length of the C string passed to \c Name.; * \param Elements Renamed elements.; * \param NumElements Number of renamed elements.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:286,Modifiability,variab,variable,286,"/**; * Create a descriptor for an imported function, type, or variable. Suitable; * for e.g. FORTRAN-style USE declarations.; * \param Builder The DIBuilder.; * \param Scope The scope this module is imported into.; * \param Decl The declaration (or definition) of a function, type,; or variable.; * \param File File where the declaration is located.; * \param Line Line number of the declaration.; * \param Name A name that uniquely identifies this imported; declaration.; * \param NameLen The length of the C string passed to \c Name.; * \param Elements Renamed elements.; * \param NumElements Number of renamed elements.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:67,Modifiability,variab,variable,67,"/**; * Create debugging information entry for Objective-C instance variable.; * \param Builder The DIBuilder.; * \param Name Member name.; * \param NameLen The length of the C string passed to \c Name.; * \param File File where this member is defined.; * \param LineNo Line number.; * \param SizeInBits Member size.; * \param AlignInBits Member alignment.; * \param OffsetInBits Member offset.; * \param Flags Flags to encode member attribute, e.g. private; * \param Ty Parent type.; * \param PropertyNode Property associated with this ivar.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:55,Modifiability,inherit,inheritance,55,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:197,Modifiability,inherit,inherits,197,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:336,Modifiability,inherit,inheritance,336,"/**; * Create debugging information entry to establish inheritance relationship; * between two types.; * \param Builder The DIBuilder.; * \param Ty Original type.; * \param BaseTy Base type. Ty is inherits from base.; * \param BaseOffset Base offset.; * \param VBPtrOffset Virtual base pointer offset.; * \param Flags Flags to describe inheritance attribute, e.g. private; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,/**; * Create a new descriptor for the specified variable which has a complex; * address expression for its address.; * \param Builder The DIBuilder.; * \param Addr An array of complex address operations.; * \param Length Length of the address operation array.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,"/**; * Create a new descriptor for the specified variable that does not have an; * address, but does have a constant value.; * \param Builder The DIBuilder.; * \param Value The constant value.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:49,Modifiability,variab,variable,49,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:75,Modifiability,Variab,Variable,75,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:118,Modifiability,variab,variable,118,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:230,Modifiability,variab,variable,230,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:338,Modifiability,variab,variable,338,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:402,Modifiability,Variab,Variable,402,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:474,Modifiability,variab,variable,474,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:664,Modifiability,variab,variables,664,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:697,Modifiability,Variab,Variable,697,/**; * Create a new descriptor for the specified variable.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LinkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Expr The location of the global relative to the attached; * GlobalVariable.; * \param Decl Reference to the corresponding declaration.; * variables.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:63,Modifiability,variab,variable,63,/**; * Retrieves the \c DIVariable associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getVariable(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:109,Modifiability,variab,variable,109,/**; * Retrieves the \c DIVariable associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getVariable(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:65,Modifiability,variab,variable,65,/**; * Retrieves the \c DIExpression associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getExpression(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:111,Modifiability,variab,variable,111,/**; * Retrieves the \c DIExpression associated with this global variable expression.; * \param GVE The global variable expression.; *; * @see llvm::DIGlobalVariableExpression::getExpression(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:60,Modifiability,variab,variable,60,/**; * Get the metadata of the file associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getFile(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:88,Modifiability,variab,variable,88,/**; * Get the metadata of the file associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getFile(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:61,Modifiability,variab,variable,61,/**; * Get the metadata of the scope associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getScope(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:89,Modifiability,variab,variable,89,/**; * Get the metadata of the scope associated with a given variable.; * \param Var The variable object.; *; * @see DIVariable::getScope(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:56,Modifiability,variab,variable,56,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:126,Modifiability,Variab,Variable,126,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:169,Modifiability,variab,variable,169,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:281,Modifiability,variab,variable,281,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:388,Modifiability,variab,variable,388,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:452,Modifiability,Variab,Variable,452,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:524,Modifiability,variab,variable,524,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:647,Modifiability,Variab,Variable,647,/**; * Create a new descriptor for the specified global variable that is temporary; * and meant to be RAUWed.; * \param Scope Variable scope.; * \param Name Name of the variable.; * \param NameLen The length of the C string passed to \c Name.; * \param Linkage Mangled name of the variable.; * \param LnkLen The length of the C string passed to \c Linkage.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Variable Type.; * \param LocalToUnit Boolean flag indicate whether this variable is; * externally visible or not.; * \param Decl Reference to the corresponding declaration.; * \param AlignInBits Variable alignment(or 0 if no alignment attr was; * specified); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:152,Modifiability,variab,variable,152,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:195,Modifiability,variab,variable,195,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:282,Modifiability,variab,variable,282,/**; * Insert a new llvm.dbg.declare intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:276,Modifiability,variab,variable,276,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:319,Modifiability,variab,variable,319,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:406,Modifiability,variab,variable,406,"/**; * Insert a new llvm.dbg.declare intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Storage The storage of the variable to declare.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:144,Modifiability,variab,variable,144,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:176,Modifiability,variab,variable,176,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:263,Modifiability,variab,variable,263,/**; * Insert a new llvm.dbg.value intrinsic call before the given instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Instr Instruction acting as a location for the new intrinsic.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:268,Modifiability,variab,variable,268,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:300,Modifiability,variab,variable,300,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:387,Modifiability,variab,variable,387,"/**; * Insert a new llvm.dbg.value intrinsic call at the end of the given basic; * block. If the basic block has a terminator instruction, the intrinsic is; * inserted before that terminator instruction.; * \param Builder The DIBuilder.; * \param Val The value of the variable.; * \param VarInfo The variable's debug info descriptor.; * \param Expr A complex location expression for the variable.; * \param DebugLoc Debug info location.; * \param Block Basic block acting as a location for the new intrinsic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:48,Modifiability,variab,variable,48,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:127,Modifiability,variab,variable,127,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:167,Modifiability,Variab,Variable,167,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:210,Modifiability,variab,variable,210,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:256,Modifiability,variab,variable,256,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:356,Modifiability,variab,variable,356,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:489,Modifiability,Variab,Variable,489,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:429,Performance,optimiz,optimizations,429,"/**; * Create a new descriptor for a local auto variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; * \param AlignInBits Variable alignment.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:56,Modifiability,variab,variable,56,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:135,Modifiability,variab,variable,135,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:175,Modifiability,Variab,Variable,175,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:218,Modifiability,variab,variable,218,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:281,Modifiability,variab,variable,281,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:335,Modifiability,variab,variable,335,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:435,Modifiability,variab,variable,435,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:508,Performance,optimiz,optimizations,508,"/**; * Create a new descriptor for a function parameter variable.; * \param Builder The DIBuilder.; * \param Scope The local scope the variable is declared in.; * \param Name Variable name.; * \param NameLen Length of variable name.; * \param ArgNo Unique argument number for this variable; starts at 1.; * \param File File where this variable is defined.; * \param LineNo Line number.; * \param Ty Metadata describing the type of the variable.; * \param AlwaysPreserve If true, this descriptor will survive optimizations.; * \param Flags Flags.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h:66,Usability,clear,clear,66,"/**; * Set the debug location for the given instruction.; *; * To clear the location metadata of the given instruction, pass NULL to \p Loc.; *; * @see llvm::Instruction::setDebugLoc(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h:523,Integrability,interface,interface,523,"/*===-- llvm-c/Deprecated.h - Deprecation macro -------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares LLVM_ATTRIBUTE_C_DEPRECATED() macro, which can be *|; |* used to deprecate functions in the C interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Deprecated.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:54,Integrability,Interface,Interface,54,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:438,Integrability,interface,interface,438,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:522,Integrability,interface,interface,522,"/*===-- llvm-c/Disassembler.h - Disassembler Public C Interface ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a disassembler library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h:23,Performance,latency,latency,23,/* The option to print latency information alongside instructions */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Disassembler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:158,Performance,load,load,158,"/**; * The type for the symbol lookup function. This may be called by the; * disassembler for things like adding a comment for a PC plus a constant; * offset load instruction to use a symbol name instead of a load address value.; * It is passed the block information is saved when the disassembler context is; * created and the ReferenceValue to look up as a symbol. If no symbol is found; * for the ReferenceValue NULL is returned. The ReferenceType of the; * instruction is passed indirectly as is the PC of the instruction in; * ReferencePC. If the output reference can be determined its type is returned; * indirectly in ReferenceType along with ReferenceName if any, or that is set; * to NULL.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:209,Performance,load,load,209,"/**; * The type for the symbol lookup function. This may be called by the; * disassembler for things like adding a comment for a PC plus a constant; * offset load instruction to use a symbol name instead of a load address value.; * It is passed the block information is saved when the disassembler context is; * created and the ReferenceValue to look up as a symbol. If no symbol is found; * for the ReferenceValue NULL is returned. The ReferenceType of the; * instruction is passed indirectly as is the PC of the instruction in; * ReferencePC. If the output reference can be determined its type is returned; * indirectly in ReferenceType along with ReferenceName if any, or that is set; * to NULL.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:45,Performance,load,load,45,/* The input reference is from a PC relative load instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:40,Testability,stub,stub,40,/* The output reference is to as symbol stub. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:44,Integrability,message,message,44,/* The output reference is to a Objective-C message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h:44,Integrability,message,message,44,/* The output reference is to a Objective-C message ref. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/DisassemblerTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:20,Availability,Error,Error,20,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:36,Availability,Error,Error,36,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:452,Availability,Error,Error,452,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:50,Integrability,Interface,Interface,50,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:432,Integrability,interface,interface,432,"/*===------- llvm-c/Error.h - llvm::Error class C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's Error class. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,Error,Error,28,/**; * @defgroup LLVMCError Error Handling; * @ingroup LLVMC; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:30,Availability,error,error,30,/**; * Opaque reference to an error instance. Null serves as the 'success' value.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:7,Availability,Error,Error,7,/**; * Error type identifier.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:41,Availability,error,error,41,"/**; * Returns the type id for the given error instance, which must be a failure; * value (i.e. non-null).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:73,Availability,failure,failure,73,"/**; * Returns the type id for the given error instance, which must be a failure; * value (i.e. non-null).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,error,error,28,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:86,Availability,error,error,86,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:218,Availability,error,error,218,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:133,Usability,usab,usable,133,"/**; * Dispose of the given error without handling it. This operation consumes the; * error, and the given LLVMErrorRef value is not usable once this call returns.; * Note: This method *only* needs to be called if the error is not being passed; * to some other consuming operation, e.g. LLVMGetErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:34,Availability,error,error,34,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:77,Availability,error,error,77,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:40,Integrability,message,message,40,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:127,Usability,usab,usable,127,"/**; * Returns the given string's error message. This operation consumes the error,; * and the given LLVMErrorRef value is not usable once this call returns.; * The caller is responsible for disposing of the string by calling; * LLVMDisposeErrorMessage.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:28,Availability,error,error,28,/**; * Dispose of the given error message.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h:34,Integrability,message,message,34,/**; * Dispose of the given error message.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Error.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Error.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:15,Availability,Error,ErrorHandling,15,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:33,Availability,Error,Error,33,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:452,Availability,error,error,452,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:50,Integrability,Interface,Interface,50,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/ErrorHandling.h - Error Handling C Interface -------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to LLVM's error handling mechanism. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:23,Availability,error,error,23,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:74,Availability,error,error,74,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:7,Deployability,Install,Install,7,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:268,Deployability,install,install,268,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:58,Safety,detect,detects,58,"/**; * Install a fatal error handler. By default, if LLVM detects a fatal error, it; * will call exit(1). This may not be appropriate in many contexts. For example,; * doing exit(1) will bypass many crash reporting/tracing system tools. This; * function allows you to install a callback that will be invoked prior to the; * call to exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:23,Availability,error,error,23,/**; * Reset the fatal error handler. This resets LLVM's fatal error handling; * behavior to the default.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h:63,Availability,error,error,63,/**; * Reset the fatal error handler. This resets LLVM's fatal error handling; * behavior to the default.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ErrorHandling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/ExecutionEngine.h - ExecutionEngine Lib C Iface --*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMExecutionEngine.o, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:683,Integrability,interface,interface,683,"/*===-- llvm-c/ExecutionEngine.h - ExecutionEngine Lib C Iface --*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMExecutionEngine.o, which *|; |* implements various analyses of the LLVM IR. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:556,Availability,error,error,556,"/**; * Create an MCJIT execution engine for a module, with the given options. It is; * the responsibility of the caller to ensure that all fields in Options up to; * the given SizeOfOptions are initialized. It is correct to pass a smaller; * value of SizeOfOptions that omits some fields. The canonical way of using; * this is:; *; * LLVMMCJITCompilerOptions options;; * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));; * ... fill in those options you care about; * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),; * &error);; *; * Note that this is also correct, though possibly suboptimal:; *; * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:687,Availability,error,error,687,"/**; * Create an MCJIT execution engine for a module, with the given options. It is; * the responsibility of the caller to ensure that all fields in Options up to; * the given SizeOfOptions are initialized. It is correct to pass a smaller; * value of SizeOfOptions that omits some fields. The canonical way of using; * this is:; *; * LLVMMCJITCompilerOptions options;; * LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));; * ... fill in those options you care about; * LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),; * &error);; *; * Note that this is also correct, though possibly suboptimal:; *; * LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:20,Availability,error,error,20,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:74,Availability,error,error,74,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:85,Integrability,message,message,85,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:117,Usability,clear,cleared,117,"/// Returns true on error, false on success. If true is returned then the error; /// message is copied to OutStr and cleared in the ExecutionEngine instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:506,Availability,error,error,506,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:279,Energy Efficiency,Allocate,AllocateCodeSection,279,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:299,Energy Efficiency,Allocate,Allocate,299,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:357,Energy Efficiency,Allocate,AllocateDataSection,357,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:377,Energy Efficiency,Allocate,Allocate,377,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:470,Performance,cache,cache,470,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h:16,Usability,simpl,simple,16,"/**; * Create a simple custom MCJIT memory manager. This memory manager can; * intercept allocations in a module-oblivious way. This will return NULL; * if any of the passed functions are NULL.; *; * @param Opaque An opaque client object to pass back to the callbacks.; * @param AllocateCodeSection Allocate a block of memory for executable code.; * @param AllocateDataSection Allocate a block of memory for data.; * @param FinalizeMemory Set page permissions and flush cache. Return 0 on; * success, 1 on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExecutionEngine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h:26,Integrability,Wrap,Wrapper,26,"/*===- llvm-c/ExternC.h - Wrapper for 'extern ""C""' ----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h:442,Integrability,wrap,wrapper,442,"/*===- llvm-c/ExternC.h - Wrapper for 'extern ""C""' ----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:40,Integrability,Interface,Interface,40,"/*===-- llvm-c/IRReader.h - IR Reader C Interface -----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the IR Reader. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/IRReader.h - IR Reader C Interface -----------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the IR Reader. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h:253,Availability,error,errors,253,/**; * @defgroup LLVMCCoreIRReader IR Reader; * @ingroup LLVMCCore; *; * @{; */; /**; * Read LLVM IR from a memory buffer and convert it into an in-memory Module; * object. Returns 0 on success.; * Optionally returns a human-readable description of any errors that; * occurred during parsing IR. OutMessage must be disposed with; * LLVMDisposeMessage.; *; * @see llvm::ParseIR(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/IRReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/IRReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:42,Integrability,Interface,Interface,42,"/*===-- llvm-c/Linker.h - Module Linker C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the module/file/archive linker. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Linker.h - Module Linker C Interface -------------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the module/file/archive linker. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:125,Availability,error,error,125,"/* Links the source module into the destination module. The source module is; * destroyed.; * The return value is true if an error occurred, false otherwise.; * Use the diagnostic handler to get any diagnostic message.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h:210,Integrability,message,message,210,"/* Links the source module into the destination module. The source module is; * destroyed.; * The return value is true if an error occurred, false otherwise.; * Use the diagnostic handler to get any diagnostic message.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Linker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Linker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:435,Integrability,interface,interface,435,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:687,Integrability,interface,interface,687,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:770,Integrability,interface,interface,770,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:508,Usability,simpl,simple,508,"/*===----------- llvm-c/LLJIT.h - OrcV2 LLJIT C bindings ----------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the LLJIT class in *|; |* libLLVMOrcJIT.a, which provides a simple MCJIT-like ORC JIT. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:489,Modifiability,layers,layers,489,/**; * @defgroup LLVMCExecutionEngineLLJIT LLJIT; * @ingroup LLVMCExecutionEngine; *; * @{; */; /**; * A function for constructing an ObjectLinkingLayer instance to be used; * by an LLJIT instance.; *; * Clients can call LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator to; * set the creator function to use when constructing an LLJIT instance.; * This can be used to override the default linking layer implementation; * that would otherwise be chosen by LLJITBuilder.; *; * Object linking layers returned by this function will become owned by the; * LLJIT instance. The client is not responsible for managing their lifetimes; * after the function returns.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:149,Availability,error,error,149,/**; * Dispose of an LLVMOrcLLJITBuilderRef. This should only be called if ownership; * has not been passed to LLVMOrcCreateLLJIT (e.g. because some error prevented; * that function from being called).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:205,Safety,detect,detectHost,205,/**; * Set the JITTargetMachineBuilder to be used when constructing the LLJIT; * instance. Calling this function is optional: if it is not called then the; * LLJITBuilder will use JITTargeTMachineBuilder::detectHost to construct a; * JITTargetMachineBuilder.; *; * This function takes ownership of the JTMB argument: clients should not; * dispose of the JITTargetMachineBuilder after calling this function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h:225,Availability,error,error,225,"/**; * Create an LLJIT instance from an LLJITBuilder.; *; * This operation takes ownership of the Builder argument: clients should not; * dispose of the builder after calling this function (even if the function; * returns an error). If a null Builder argument is provided then a; * default-constructed LLJITBuilder will be used.; *; * On success the resulting LLJIT instance is uniquely owned by the client and; * automatically manages the memory of all JIT'd code and all modules that are; * transferred to it (e.g. via LLVMOrcLLJITAddLLVMIRModule). Disposing of the; * LLJIT instance will free all memory managed by the JIT, including JIT'd code; * and not-yet compiled modules.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJIT.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:435,Integrability,interface,interface,435,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:798,Integrability,interface,interface,798,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:881,Integrability,interface,interface,881,"/*===------- llvm-c/LLJITUtils.h - Advanced LLJIT features --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface for extra utilities to be used with *|; |* the LLJIT class from the llvm-c/LLJIT.h header. It requires to following *|; |* link libraries in addition to libLLVMOrcJIT.a: *|; |* - libLLVMOrcDebugging.a *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:123,Deployability,Install,Install,123,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:135,Modifiability,plugin,plugin,135,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h:204,Security,expose,expose,204,/**; * @defgroup LLVMCExecutionEngineLLJITUtils LLJIT Utilities; * @ingroup LLVMCExecutionEngineLLJIT; *; * @{; */; /**; * Install the plugin that submits debug objects to the executor. Executors must; * expose the llvm_orc_registerJITLoaderGDBWrapper symbol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/LLJITUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:36,Integrability,Interface,Interface,36,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:436,Integrability,interface,interface,436,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:539,Integrability,interface,interface,539,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:471,Performance,optimiz,optimization,471,"/*===-- llvm-c/lto.h - LTO Public C Interface ---------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides public interface to an abstract link time optimization*|; |* library. LLVM provides an implementation of this interface for use with *|; |* llvm bitcode files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:26,Performance,load,loaded,26,/** opaque reference to a loaded object module */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:24,Availability,error,error,24,/**; * Returns the last error string or NULL if last operation was successful.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Performance,load,loadable,29,/**; * Checks if a file is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Performance,load,loadable,29,/**; * Checks if a file is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,Performance,load,loadable,31,/**; * Checks if a buffer is a loadable object file.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:31,Performance,load,loadable,31,/**; * Checks if a buffer is a loadable object compiled for requested target.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:58,Availability,error,error,58,/**; * Loads an object file from disk.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:60,Availability,error,error,60,/**; * Loads an object file from memory.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from memory.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:88,Availability,error,error,88,/**; * Loads an object file from memory with an extra path argument.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=9; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from memory with an extra path argument.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=9; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:275,Availability,error,error,275,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:54,Performance,Load,Loads,54,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:131,Safety,safe,safe,131,"/**; * Loads an object file in its own context.; *; * Loads an object file in its own LLVMContext. This function call is; * thread-safe. However, modules created this way should not be merged into an; * lto_code_gen_t using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:197,Availability,error,error,197,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:58,Performance,Load,Loads,58,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:125,Safety,safe,safe,125,/**; * Loads an object file in the codegen context.; *; * Loads an object file into the same context as \c cg. The module is safe to; * add using \a lto_codegen_add_module().; *; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=11; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:97,Availability,error,error,97,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:97,Availability,error,error,97,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Load,Loads,7,/**; * Loads an object file from disk. The seek point of fd is not preserved.; * Returns NULL on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,Energy Efficiency,allocate,allocated,35,/**; * Frees all memory internally allocated by the module.; * Upon return the lto_module_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:282,Availability,error,error,282,"/**; * If targeting mach-o on darwin, this function gets the CPU type and subtype; * that will end up being encoded in the mach-o header. These are the values; * that can be found in mach/machine.h.; *; * \p out_cputype and \p out_cpusubtype must be non-NULL.; *; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=27; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:175,Availability,error,error,175,"/**; * Diagnostic handler type.; * \p severity defines the severity.; * \p diag is the actual diagnostic.; * The diagnostic is not prefixed by any of severity keyword, e.g., 'error: '.; * \p ctxt is used to pass the context set with the diagnostic handler.; *; * \since LTO_API_VERSION=7; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:57,Availability,error,error,57,/**; * Instantiates a code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; * All modules added using \a lto_codegen_add_module() must have been created; * in the same context as the codegen.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:61,Energy Efficiency,allocate,allocated,61,/**; * Frees all code generator and all memory it internally allocated.; * Upon return the lto_code_gen_t is no longer valid.; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:103,Availability,error,error,103,/**; * Add an object module to the set of modules for which code will be generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \c cg and \c mod must both be in the same context. See \a; * lto_codegen_create_in_local_context() and \a; * lto_module_create_in_codegen_context().; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:66,Availability,error,error,66,/**; * Sets if debug info should be generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:66,Availability,error,error,66,/**; * Sets which PIC code model to generated.; * Returns true on error (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:171,Performance,optimiz,optimized,171,"/**; * Adds to a list of all global symbols that must exist in the final generated; * code. If a function is not listed there, it might be inlined into every usage; * and optimized away.; *; * \since prior to LTO_API_VERSION=3; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:139,Availability,error,error,139,/**; * Writes a new object file at the specified path that contains the; * merged contents of all modules added so far.; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=5; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:402,Availability,failure,failure,402,"/**; * Generates code for all added modules into one native object file.; * This calls lto_codegen_optimize then lto_codegen_compile_optimized.; *; * On success returns a pointer to a generated mach-o/ELF buffer and; * length set to the buffer size. The buffer is owned by the; * lto_code_gen_t and will be freed when lto_codegen_dispose(); * is called, or lto_codegen_compile() is called again.; * On failure, returns NULL (check lto_get_error_message() for details).; *; * \since prior to LTO_API_VERSION=3; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:284,Availability,error,error,284,"/**; * Generates code for all added modules into one native object file.; * This calls lto_codegen_optimize then lto_codegen_compile_optimized (instead; * of returning a generated mach-o/ELF buffer, it writes to a file).; *; * The name of the file is written to name. Returns true on error.; *; * \since LTO_API_VERSION=5; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:64,Availability,error,error,64,/**; * Runs optimization for the merged module. Returns true on error.; *; * \since LTO_API_VERSION=12; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:12,Performance,optimiz,optimization,12,/**; * Runs optimization for the merged module. Returns true on error.; *; * \since LTO_API_VERSION=12; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:410,Availability,failure,failure,410,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:30,Performance,optimiz,optimized,30,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:109,Performance,optimiz,optimizations,109,"/**; * Generates code for the optimized merged module into one native object file.; * It will not run any IR optimizations on the merged module.; *; * On success returns a pointer to a generated mach-o/ELF buffer and length set; * to the buffer size. The buffer is owned by the lto_code_gen_t and will be; * freed when lto_codegen_dispose() is called, or; * lto_codegen_compile_optimized() is called again. On failure, returns NULL; * (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=12; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:47,Availability,avail,available,47,"/**; * Parses options immediately, making them available as early as possible. For; * example during executing codegen::InitTargetOptionsFromCodeGenFlags. Since; * parsing shud only happen once, only one of lto_codegen_debug_options or; * lto_set_debug_options should be called.; *; * This function takes one or more options separated by spaces.; * Warning: passing file paths through this function may confuse the argument; * parser if the paths contain spaces.; *; * \since LTO_API_VERSION=28; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:53,Performance,optimiz,optimization,53,/**; * Sets if we should run internalize pass during optimization and code; * generation.; *; * \since LTO_API_VERSION=14; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:35,Energy Efficiency,allocate,allocated,35,/**; * Frees all memory internally allocated by the LTO input file.; * Upon return the lto_module_t is no longer valid.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:29,Integrability,depend,dependent,29,/**; * Returns the number of dependent library specifiers; * for the given LTO input file.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:23,Integrability,depend,dependent,23,/**; * Returns the ith dependent library specifier; * for the given LTO input file. The returned; * string is not null-terminated.; *; * \since LTO_API_VERSION=24; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:108,Integrability,wrap,wrap,108,/**; * @} // endgoup LLVMCLTO; * @defgroup LLVMCTLTO ThinLTO; * @ingroup LLVMC; *; * @{; */; /**; * Type to wrap a single object returned by ThinLTO.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:65,Availability,error,error,65,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:280,Performance,perform,perform,280,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:300,Performance,optimiz,optimizations,300,"/**; * Instantiates a ThinLTO code generator.; * Returns NULL on error (check lto_get_error_message() for details).; *; *; * The ThinLTOCodeGenerator is not intended to be reuse for multiple; * compilation: the model is that the client adds modules to the generator and; * ask to perform the ThinLTO optimizations / codegen, and finally destroys the; * codegenerator.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:56,Energy Efficiency,allocate,allocated,56,/**; * Frees the generator and all memory it internally allocated.; * Upon return the thinlto_code_gen_t is no longer valid.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:191,Availability,avail,available,191,"/**; * Add a module to a ThinLTO code generator. Identifier has to be unique among; * all the modules in a code generator. The data buffer stays owned by the; * client, and is expected to be available for the entire lifetime of the; * thinlto_code_gen_t it is added to.; *; * On failure, returns NULL (check lto_get_error_message() for details).; *; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:279,Availability,failure,failure,279,"/**; * Add a module to a ThinLTO code generator. Identifier has to be unique among; * all the modules in a code generator. The data buffer stays owned by the; * client, and is expected to be available for the entire lifetime of the; * thinlto_code_gen_t it is added to.; *; * On failure, returns NULL (check lto_get_error_message() for details).; *; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Optimiz,Optimize,7,/**; * Optimize and codegen all the modules added to the codegenerator using; * ThinLTO. Resulting objects are accessible using thinlto_module_get_object().; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:111,Security,access,accessible,111,/**; * Optimize and codegen all the modules added to the codegenerator using; * ThinLTO. Resulting objects are accessible using thinlto_module_get_object().; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:176,Availability,avail,available,176,/**; * Returns a reference to the ith object file produced by the ThinLTO; * CodeGenerator.; *; * Client should use \p thinlto_module_get_num_objects() to get the number of; * available objects.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:178,Availability,avail,available,178,/**; * Returns the path to the ith object file produced by the ThinLTO; * CodeGenerator.; *; * Client should use \p thinlto_module_get_num_object_files() to get the number; * of available objects.; *; * \since LTO_API_VERSION=21; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:65,Availability,error,error,65,/**; * Sets which PIC code model to generate.; * Returns true on error (check lto_get_error_message() for details).; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:131,Availability,avail,available,131,/**; * Sets the path to a directory to use as a storage for temporary bitcode files.; * The intention is to make the bitcode files available for debugging at various; * stage of the pipeline.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:182,Deployability,pipeline,pipeline,182,/**; * Sets the path to a directory to use as a storage for temporary bitcode files.; * The intention is to make the bitcode files available for debugging at various; * stage of the pipeline.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:190,Availability,avail,available,190,"/**; * Set the path to a directory where to save generated object files. This; * path can be used by a linker to request on-disk files instead of in-memory; * buffers. When set, results are available through; * thinlto_module_get_object_file() instead of thinlto_module_get_object().; *; * \since LTO_API_VERSION=21; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Performance,Perform,Perform,7,/**; * Perform CodeGen only: disable all other stages.; *; * \since LTO_API_VERSION=19; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:7,Testability,Test,Test,7,/**; * Test if a module has support for ThinLTO linking.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:178,Performance,optimiz,optimized,178,"/**; * Adds a symbol to the list of global symbols that must exist in the final; * generated code. If a function is not listed there, it might be inlined into; * every usage and optimized away. For every single module, the functions; * referenced from code outside of the ThinLTO modules need to be added here.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:208,Performance,optimiz,optimized,208,"/**; * Adds a symbol to the list of global symbols that are cross-referenced between; * ThinLTO files. If the ThinLTO CodeGenerator can ensure that every; * references from a ThinLTO module to this symbol is optimized away, then; * the symbol can be discarded.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:70,Performance,Cache,Cache,70,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:151,Performance,cache,cache,151,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:162,Performance,cache,cache,162,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:287,Performance,cache,cache,287,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:611,Performance,cache,cache,611,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:889,Performance,cache,cache,889,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:1006,Performance,cache,cache,1006,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:453,Safety,avoid,avoid,453,"/**; * @} // endgoup LLVMCTLTO; * @defgroup LLVMCTLTO_CACHING ThinLTO Cache Control; * @ingroup LLVMCTLTO; *; * These entry points control the ThinLTO cache. The cache is intended to; * support incremental builds, and thus needs to be persistent across builds.; * The client enables the cache by supplying a path to an existing directory.; * The code generator will use this to store objects files that may be reused; * during a subsequent build.; * To avoid filling the disk space, a few knobs are provided:; * - The pruning interval limits the frequency at which the garbage collector; * will try to scan the cache directory to prune expired entries.; * Setting to a negative number disables the pruning.; * - The pruning expiration time indicates to the garbage collector how old an; * entry needs to be to be removed.; * - Finally, the garbage collector can be instructed to prune the cache until; * the occupied space goes below a threshold.; * @{; */; /**; * Sets the path to a directory to use as a cache storage for incremental build.; * Setting this activates caching.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:16,Performance,cache,cache,16,"/**; * Sets the cache pruning interval (in seconds). A negative value disables the; * pruning. An unspecified default value will be applied, and a value of 0 will; * force prunning to occur.; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:105,Availability,avail,available,105,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:239,Availability,avail,available,239,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:409,Availability,Avail,AvailableSpace,409,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:474,Availability,Avail,AvailableSpace,474,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:281,Energy Efficiency,reduce,reduced,281,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:24,Performance,cache,cache,24,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:194,Performance,cache,cache,194,"/**; * Sets the maximum cache size that can be persistent across build, in terms of; * percentage of the available space on the disk. Set to 100 to indicate; * no limit, 50 to indicate that the cache size will not be left over half the; * available space. A value over 100 will be reduced to 100, a value of 0 will; * be ignored. An unspecified default value will be applied.; *; * The formula looks like:; * AvailableSpace = FreeSpace + ExistingCacheSize; * NewCacheSize = AvailableSpace * P/100; *; * \since LTO_API_VERSION=18; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:60,Performance,cache,cache,60,/**; * Sets the expiration (in seconds) for an entry in the cache. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=18; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:94,Availability,avail,available,94,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:158,Availability,avail,available,158,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:130,Energy Efficiency,reduce,reduced,130,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:36,Performance,cache,cache,36,/**; * Sets the maximum size of the cache directory (in bytes). A value over the; * amount of available space on the disk will be reduced to the amount of; * available space. An unspecified default value will be applied. A value of 0; * will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h:47,Performance,cache,cache,47,/**; * Sets the maximum number of files in the cache directory. An unspecified; * default value will be applied. A value of 0 will be ignored.; *; * \since LTO_API_VERSION=22; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/lto.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/lto.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Object.h - Object Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMObject.a, which */; /* implements object file reading and writing. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:674,Integrability,interface,interface,674,"/*===-- llvm-c/Object.h - Object Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMObject.a, which */; /* implements object file reading and writing. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:108,Integrability,wrap,wrappers,108,/**; * @defgroup LLVMCObject Object file reading and writing; * @ingroup LLVMC; *; * @{; */; // Opaque type wrappers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:431,Availability,Error,ErrorMessage,431,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:479,Availability,error,error,479,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:555,Integrability,message,message,555,"/**; * Create a binary file from the given memory buffer.; *; * The exact type of the binary file will be inferred automatically, and the; * appropriate implementation selected. The context may be NULL except if; * the resulting file is an LLVM IR file.; *; * The memory buffer is not consumed by this function. It is the responsibilty; * of the caller to free it with \c LLVMDisposeMemoryBuffer.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * @see llvm::object::createBinary; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:174,Availability,Error,ErrorMessage,174,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:222,Availability,error,error,222,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:298,Integrability,message,message,298,"/*; * For a Mach-O universal binary file, retrieves the object file corresponding; * to the given architecture if it is present as a slice.; *; * If NULL is returned, the \p ErrorMessage parameter is populated with the; * error's description. It is then the caller's responsibility to free this; * message by calling \c LLVMDisposeMessage.; *; * It is the responsiblity of the caller to free the returned object file by; * calling \c LLVMDisposeBinary.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:14,Security,access,accessors,14,// SectionRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:13,Security,access,accessors,13,// SymbolRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:17,Security,access,accessors,17,// RelocationRef accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Object.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:435,Integrability,interface,interface,435,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:885,Integrability,interface,interface,885,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:968,Integrability,interface,interface,968,"/*===---------------- llvm-c/Orc.h - OrcV2 C bindings -----------*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to libLLVMOrcJIT.a, which implements *|; |* JIT compilation of LLVM IR. Minimal documentation of C API specific issues *|; |* (especially memory ownership rules) is provided. Core Orc concepts are *|; |* documented in llvm/docs/ORCv2.rst and APIs are documented in the C++ *|; |* headers *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Availability,Error,Error,7,/**; * Error reporter function.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:186,Integrability,contract,contract,186,/**; * A MaterializationUnit materialize callback.; *; * Ownership of the Ctx and MR arguments passes to the callback which must; * adhere to the LLVMOrcMaterializationResponsibilityRef contract (see comment; * for that type).; *; * If this callback is called then the LLVMOrcMaterializationUnitDestroy; * callback will NOT be called.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:152,Deployability,release,released,152,/**; * A MaterializationUnit discard callback.; *; * Ownership of JD and Symbol remain with the caller: These arguments should; * not be disposed of or released.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:397,Availability,error,errors,397,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:462,Availability,error,errors,462,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:543,Availability,error,error,543,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:342,Deployability,release,release,342,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:357,Energy Efficiency,allocate,allocated,357,"/**; * An opaque lookup state object. Instances of this type can be captured to; * suspend a lookup while a custom generator function attempts to produce a; * definition.; *; * If a client captures a lookup state object then they must eventually call; * LLVMOrcLookupStateContinueLookup to restart the lookup. This is required; * in order to release memory allocated for the lookup state, even if errors; * have occurred while the lookup was suspended (if these errors have made the; * lookup impossible to complete then it will issue its own error before; * destruction).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:962,Availability,error,errors,962,"/**; * A custom generator function. This can be used to create a custom generator; * object using LLVMOrcCreateCustomCAPIDefinitionGenerator. The resulting; * object can be attached to a JITDylib, via LLVMOrcJITDylibAddGenerator, to; * receive callbacks when lookups fail to match existing definitions.; *; * GeneratorObj will contain the address of the custom generator object.; *; * Ctx will contain the context object passed to; * LLVMOrcCreateCustomCAPIDefinitionGenerator.; *; * LookupState will contain a pointer to an LLVMOrcLookupStateRef object. This; * can optionally be modified to make the definition generation process; * asynchronous: If the LookupStateRef value is copied, and the original; * LLVMOrcLookupStateRef set to null, the lookup will be suspended. Once the; * asynchronous definition process has been completed clients must call; * LLVMOrcLookupStateContinueLookup to continue the lookup (this should be; * done unconditionally, even if errors have occurred in the mean time, to; * free the lookup state memory and notify the query object of the failures).; * If LookupState is captured this function must return LLVMErrorSuccess.; *; * The Kind argument can be inspected to determine the lookup kind (e.g.; * as-if-during-static-link, or as-if-during-dlsym).; *; * The JD argument specifies which JITDylib the definitions should be generated; * into.; *; * The JDLookupFlags argument can be inspected to determine whether the original; * lookup included non-exported symbols.; *; * Finally, the LookupSet argument contains the set of symbols that could not; * be found in JD already (the set of generation candidates).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1071,Availability,failure,failures,1071,"/**; * A custom generator function. This can be used to create a custom generator; * object using LLVMOrcCreateCustomCAPIDefinitionGenerator. The resulting; * object can be attached to a JITDylib, via LLVMOrcJITDylibAddGenerator, to; * receive callbacks when lookups fail to match existing definitions.; *; * GeneratorObj will contain the address of the custom generator object.; *; * Ctx will contain the context object passed to; * LLVMOrcCreateCustomCAPIDefinitionGenerator.; *; * LookupState will contain a pointer to an LLVMOrcLookupStateRef object. This; * can optionally be modified to make the definition generation process; * asynchronous: If the LookupStateRef value is copied, and the original; * LLVMOrcLookupStateRef set to null, the lookup will be suspended. Once the; * asynchronous definition process has been completed clients must call; * LLVMOrcLookupStateContinueLookup to continue the lookup (this should be; * done unconditionally, even if errors have occurred in the mean time, to; * free the lookup state memory and notify the query object of the failures).; * If LookupState is captured this function must return LLVMErrorSuccess.; *; * The Kind argument can be inspected to determine the lookup kind (e.g.; * as-if-during-static-link, or as-if-during-dlsym).; *; * The JD argument specifies which JITDylib the definitions should be generated; * into.; *; * The JDLookupFlags argument can be inspected to determine whether the original; * lookup included non-exported symbols.; *; * Finally, the LookupSet argument contains the set of symbols that could not; * be found in JD already (the set of generation candidates).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:339,Security,access,accessed,339,"/**; * A function for applying transformations as part of an transform layer.; *; * Implementations of this type are responsible for managing the lifetime; * of the Module pointed to by ModInOut: If the LLVMModuleRef value is; * overwritten then the function is responsible for disposing of the incoming; * module. If the module is simply accessed/mutated in-place then ownership; * returns to the caller and the function does not need to do any lifetime; * management.; *; * Clients can call LLVMOrcLLJITGetIRTransformLayer to obtain the transform; * layer of a LLJIT instance, and use LLVMOrcIRTransformLayerSetTransform; * to set the function. This can be used to override the default transform; * layer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:332,Usability,simpl,simply,332,"/**; * A function for applying transformations as part of an transform layer.; *; * Implementations of this type are responsible for managing the lifetime; * of the Module pointed to by ModInOut: If the LLVMModuleRef value is; * overwritten then the function is responsible for disposing of the incoming; * module. If the module is simply accessed/mutated in-place then ownership; * returns to the caller and the function does not need to do any lifetime; * management.; *; * Clients can call LLVMOrcLLJITGetIRTransformLayer to obtain the transform; * layer of a LLJIT instance, and use LLVMOrcIRTransformLayerSetTransform; * to set the function. This can be used to override the default transform; * layer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:522,Availability,error,error,522,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:347,Security,access,accessed,347,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:340,Usability,simpl,simply,340,"/**; * A function for applying transformations to an object file buffer.; *; * Implementations of this type are responsible for managing the lifetime; * of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef; * value is overwritten then the function is responsible for disposing of the; * incoming buffer. If the buffer is simply accessed/mutated in-place then; * ownership returns to the caller and the function does not need to do any; * lifetime management.; *; * The transform is allowed to return an error, in which case the ObjInOut; * buffer should be disposed of and set to null.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:23,Availability,error,error,23,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:82,Availability,error,error,82,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:123,Availability,failure,failure,123,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:202,Availability,failure,failure,202,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:280,Availability,error,error,280,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:376,Availability,Failure,FailureToMaterialize,376,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:397,Availability,error,error,397,"/**; * Attach a custom error reporter function to the ExecutionSession.; *; * The error reporter will be called to deliver failure notices that can not be; * directly reported to a caller. For example, failure to resolve symbols in; * the JIT linker is typically reported via the error reporter (callers; * requesting definitions from the JIT will typically be delivered a; * FailureToMaterialize error instead).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:98,Deployability,release,release,98,"/**; * Clear all unreferenced symbol string pool entries.; *; * This can be called at any time to release unused entries in the; * ExecutionSession's string pool. Since it locks the pool (preventing; * interning of any new strings) it is recommended that it only be called; * infrequently, ideally when the caller has reason to believe that some; * entries will have become unreferenced, e.g. after removing a module or; * closing a JITDylib.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Usability,Clear,Clear,7,"/**; * Clear all unreferenced symbol string pool entries.; *; * This can be called at any time to release unused entries in the; * ExecutionSession's string pool. Since it locks the pool (preventing; * interning of any new strings) it is recommended that it only be called; * infrequently, ideally when the caller has reason to believe that some; * entries will have become unreferenced, e.g. after removing a module or; * closing a JITDylib.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:184,Deployability,release,released,184,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:464,Performance,perform,perform,464,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:400,Testability,test,test,400,"/**; * Intern a string in the ExecutionSession's SymbolStringPool and return a; * reference to it. This increments the ref-count of the pool entry, and the; * returned value should be released once the client is done with it by; * calling LLVMOrcReleaseSymbolStringPoolEntry.; *; * Since strings are uniqued within the SymbolStringPool; * LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string; * equality.; *; * Note that this function does not perform linker-mangling on the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:219,Availability,failure,failure,219,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:343,Availability,error,error,343,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:487,Deployability,release,release,487,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:288,Security,access,accessed,288,"/**; * Callback type for ExecutionSession lookups.; *; * If Err is LLVMErrorSuccess then Result will contain a pointer to a; * list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.; *; * If Err is a failure value then Result and Ctx are undefined and should; * not be accessed. The Callback is responsible for handling the error; * value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).; *; * The caller retains ownership of the Result array and will release all; * contained symbol names. Clients are responsible for retaining any symbol; * names that they wish to hold after the function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:909,Availability,error,error,909,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1005,Availability,failure,failure,1005,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:719,Deployability,release,release,719,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:1272,Energy Efficiency,allocate,allocate,1272,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:64,Integrability,wrap,wrapper,64,"/**; * Look up symbols in an execution session.; *; * This is a wrapper around the general ExecutionSession::lookup function.; *; * The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags); * pairs that describe the search order. The JITDylibs will be searched in the; * given order to try to find the symbols in the Symbols argument.; *; * The Symbols argument should contain a null-terminated array of; * (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be; * searched for. This function takes ownership of the elements of the Symbols; * array. The Name fields of the Symbols elements are taken to have been; * retained by the client for this function. The client should *not* release the; * Name fields, but are still responsible for destroying the array itself.; *; * The HandleResult function will be called once all searched for symbols have; * been found, or an error occurs. The HandleResult function will be passed an; * LLVMErrorRef indicating success or failure, and (on success) a; * null-terminated LLVMOrcCSymbolMapPairs array containing the function result,; * and the Ctx value passed to the lookup function.; *; * The client is fully responsible for managing the lifetime of the Ctx object.; * A common idiom is to allocate the context prior to the lookup and deallocate; * it in the handler.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Energy Efficiency,Reduce,Reduces,7,/**; * Reduces the ref-count for of a SymbolStringPool entry.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:163,Deployability,release,released,163,/**; * Return the c-string for the given symbol. This string will remain valid until; * the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been; * released).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:7,Energy Efficiency,Reduce,Reduces,7,/**; * Reduces the ref-count of a ResourceTracker.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:147,Availability,error,error,147,/**; * Dispose of a JITDylib::DefinitionGenerator. This should only be called if; * ownership has not been passed to a JITDylib (e.g. because some error; * prevented the client from calling LLVMOrcJITDylibAddGenerator).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:550,Deployability,release,release,550,"/**; * Create a custom MaterializationUnit.; *; * Name is a name for this MaterializationUnit to be used for identification; * and logging purposes (e.g. if this MaterializationUnit produces an; * object buffer then the name of that buffer will be derived from this name).; *; * The Syms list contains the names and linkages of the symbols provided by this; * unit. This function takes ownership of the elements of the Syms array. The; * Name fields of the array elements are taken to have been retained for this; * function. The client should *not* release the elements of the array, but is; * still responsible for destroying the array itself.; *; * The InitSym argument indicates whether or not this MaterializationUnit; * contains static initializers. If three are no static initializers (the common; * case) then this argument should be null. If there are static initializers; * then InitSym should be set to a unique name that also appears in the Syms; * list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag; * set. This function takes ownership of the InitSym, which should have been; * retained twice on behalf of this function: once for the Syms entry and once; * for InitSym. If clients wish to use the InitSym value after this function; * returns they must retain it once more for themselves.; *; * If any of the symbols in the Syms list is looked up then the Materialize; * function will be called.; *; * If any of the symbols in the Syms list is overridden then the Discard; * function will be called.; *; * The caller owns the underling MaterializationUnit and is responsible for; * either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing; * of it by calling LLVMOrcDisposeMaterializationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:131,Testability,log,logging,131,"/**; * Create a custom MaterializationUnit.; *; * Name is a name for this MaterializationUnit to be used for identification; * and logging purposes (e.g. if this MaterializationUnit produces an; * object buffer then the name of that buffer will be derived from this name).; *; * The Syms list contains the names and linkages of the symbols provided by this; * unit. This function takes ownership of the elements of the Syms array. The; * Name fields of the array elements are taken to have been retained for this; * function. The client should *not* release the elements of the array, but is; * still responsible for destroying the array itself.; *; * The InitSym argument indicates whether or not this MaterializationUnit; * contains static initializers. If three are no static initializers (the common; * case) then this argument should be null. If there are static initializers; * then InitSym should be set to a unique name that also appears in the Syms; * list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag; * set. This function takes ownership of the InitSym, which should have been; * retained twice on behalf of this function: once for the Syms entry and once; * for InitSym. If clients wish to use the InitSym value after this function; * returns they must retain it once more for themselves.; *; * If any of the symbols in the Syms list is looked up then the Materialize; * function will be called.; *; * If any of the symbols in the Syms list is overridden then the Discard; * function will be called.; *; * The caller owns the underling MaterializationUnit and is responsible for; * either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing; * of it by calling LLVMOrcDisposeMaterializationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:69,Deployability,release,release,69,/**; * Disposes of the passed LLVMOrcCSymbolFlagsMap.; *; * Does not release the entries themselves.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:80,Deployability,release,release,80,/**; * Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .; *; * Does not release the symbols themselves.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:482,Availability,error,error,482,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:544,Availability,error,error,544,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:567,Availability,failure,failure,567,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:621,Availability,error,error,621,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:92,Deployability,update,update,92,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:580,Integrability,depend,dependency,580,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:729,Integrability,depend,dependencies,729,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:647,Testability,log,log,647,"/**; * Notifies the target JITDylib that the given symbols have been resolved.; * This will update the given symbols' addresses in the JITDylib, and notify; * any pending queries on the given symbols of their resolution. The given; * symbols must be ones covered by this MaterializationResponsibility; * instance. Individual calls to this method may resolve a subset of the; * symbols, but all symbols must have been resolved prior to calling emit.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies; * have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:209,Availability,error,error,209,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:271,Availability,error,error,271,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:294,Availability,failure,failure,294,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:348,Availability,error,error,348,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:307,Integrability,depend,dependency,307,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:459,Integrability,depend,dependencies,459,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:374,Testability,log,log,374,/**; * Notifies the target JITDylib (and any pending queries on that JITDylib); * that all symbols covered by this MaterializationResponsibility instance; * have been emitted.; *; * This method will return an error if any symbols being resolved have been; * moved to the error state due to the failure of a dependency. If this; * method returns an error then clients should log it and call; * LLVMOrcMaterializationResponsibilityFailMaterialization.; * If no dependencies have been registered for the symbols covered by this; * MaterializationResponsibility then this method is guaranteed to return; * LLVMErrorSuccess.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:353,Availability,error,errors,353,"/**; * Attempt to claim responsibility for new definitions. This method can be; * used to claim responsibility for symbols that are added to a; * materialization unit during the compilation process (e.g. literal pool; * symbols). Symbol linkage rules are the same as for symbols that are; * defined up front: duplicate strong definitions will result in errors.; * Duplicate weak definitions will be discarded (in which case they will; * not be added to this responsibility instance).; *; * This method can be used by materialization units that want to add; * additional symbols at materialization time (e.g. stubs, compile; * callbacks, metadata); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:608,Testability,stub,stubs,608,"/**; * Attempt to claim responsibility for new definitions. This method can be; * used to claim responsibility for symbols that are added to a; * materialization unit during the compilation process (e.g. literal pool; * symbols). Symbol linkage rules are the same as for symbols that are; * defined up front: duplicate strong definitions will result in errors.; * Duplicate weak definitions will be discarded (in which case they will; * not be added to this responsibility instance).; *; * This method can be used by materialization units that want to add; * additional symbols at materialization time (e.g. stubs, compile; * callbacks, metadata); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:100,Availability,error,error,100,"/**; * Notify all not-yet-emitted covered by this MaterializationResponsibility; * instance that an error has occurred.; * This will remove all symbols covered by this MaterializationResponsibility; * from the target JITDylib, and send an error to any queries waiting on; * these symbols.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:239,Availability,error,error,239,"/**; * Notify all not-yet-emitted covered by this MaterializationResponsibility; * instance that an error has occurred.; * This will remove all symbols covered by this MaterializationResponsibility; * from the target JITDylib, and send an error to any queries waiting on; * these symbols.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:12,Integrability,depend,dependencies,12,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:138,Integrability,Depend,Dependencies,138,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:340,Integrability,Depend,Dependence,340,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:448,Integrability,Depend,Dependence,448,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:605,Integrability,Depend,Dependencies,605,"/**; * Adds dependencies to a symbol that the MaterializationResponsibility is; * responsible for.; *; * This function takes ownership of Dependencies struct. The Names; * array have been retained for this function. This allows the following; * pattern...; *; * LLVMOrcSymbolStringPoolEntryRef Names[] = {...};; * LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}; * LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,; * 1);; *; * ... without requiring cleanup of the elements of the Names array afterwards.; *; * The client is still responsible for deleting the Dependencies.Names array; * itself.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:12,Integrability,depend,dependencies,12,/**; * Adds dependencies to all symbols that the MaterializationResponsibility is; * responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for; * notes about memory responsibility.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:206,Deployability,install,install,206,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:312,Deployability,configurat,configuration,312,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:312,Modifiability,config,configuration,312,"/**; * Create a ""bare"" JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * This call does not install any library code or symbols into the newly; * created JITDylib. The client is responsible for all configuration.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:280,Deployability,install,install,280,"/**; * Create a JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * If a Platform is attached to the ExecutionSession then; * Platform::setupJITDylib will be called to install standard platform symbols; * (e.g. standard library interposes). If no Platform is installed then this; * call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will; * always return success.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:371,Deployability,install,installed,371,"/**; * Create a JITDylib.; *; * The client is responsible for ensuring that the JITDylib's name is unique,; * e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.; *; * If a Platform is attached to the ExecutionSession then; * Platform::setupJITDylib will be called to install standard platform symbols; * (e.g. standard library interposes). If no Platform is installed then this; * call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will; * always return success.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:153,Deployability,release,released,153,"/**; * Return a reference to a newly created resource tracker associated with JD.; * The tracker is returned with an initial ref-count of 1, and must be released; * with LLVMOrcReleaseResourceTracker when no longer needed.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:84,Usability,clear,clear,84,"/**; * Calls remove on all trackers associated with this JITDylib, see; * JITDylib::clear().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:546,Availability,error,error,546,"/**; * Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect; * static library symbols into the JITDylib. On success the resulting; * generator is owned by the client. Ownership is typically transferred by; * adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,; *; * Call with the optional TargetTriple argument will succeed if the file at; * the given path is a static library or a MachO universal binary containing a; * static library that is compatible with the given triple. Otherwise it will; * return an error.; *; * THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!; * ; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:321,Availability,alive,alive,321,/**; * Create a ThreadSafeContext containing a new LLVMContext.; *; * Ownership of the underlying ThreadSafeContext data is shared: Clients; * can and should dispose of their ThreadSafeContext as soon as they no longer; * need to refer to it directly. Other references (e.g. from ThreadSafeModules); * will keep the data alive as long as it is needed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:30,Integrability,wrap,wrapped,30,/**; * Get a reference to the wrapped LLVMContext.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:33,Integrability,wrap,wrapper,33,/**; * Create a ThreadSafeModule wrapper around the given LLVM module. This takes; * ownership of the M argument which should not be disposed of or referenced; * after this function returns.; *; * Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT; * (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer; * responsible for it. If it is not transferred to the JIT then the client; * should call LLVMOrcDisposeThreadSafeModule to dispose of it.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:129,Availability,error,error,129,/**; * Dispose of a ThreadSafeModule. This should only be called if ownership has; * not been passed to LLJIT (e.g. because some error prevented the client from; * adding this to the JIT).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h:43,Safety,detect,detecting,43,/**; * Create a JITTargetMachineBuilder by detecting the host.; *; * On success the client owns the resulting JITTargetMachineBuilder. It must be; * passed to a consuming operation (e.g.; * LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling; * LLVMOrcDisposeJITTargetMachineBuilder.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Orc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Orc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:697,Integrability,interface,interface,697,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:780,Integrability,interface,interface,780,"/*===-- llvm-c/OrcEE.h - OrcV2 C bindings ExecutionEngine utils -*- C++ -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to ExecutionEngine based utils, e.g. *|; |* RTDyldObjectLinkingLayer (based on RuntimeDyld) in Orc. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; |* Note: This interface is experimental. It is *NOT* stable, and may be *|; |* changed without warning. Only C API usage documentation is *|; |* provided. See the C++ documentation for all higher level ORC API *|; |* details. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:122,Usability,simpl,simplify,122,"/**; * Create a RTDyldObjectLinkingLayer instance using MCJIT-memory-manager-like; * callbacks.; *; * This is intended to simplify transitions for existing MCJIT clients. The; * callbacks used are similar (but not identical) to the callbacks for; * LLVMCreateSimpleMCJITMemoryManager: Unlike MCJIT, RTDyldObjectLinkingLayer; * will create a new memory manager for each object linked by calling the given; * CreateContext callback. This allows for code removal by destroying each; * allocator individually. Every allocator will be destroyed (if it has not been; * already) at RTDyldObjectLinkingLayer destruction time, and the; * NotifyTerminating callback will be called to indicate that no further; * allocation contexts will be created.; *; * To implement MCJIT-like behavior clients can implement CreateContext,; * NotifyTerminating, and Destroy as:; *; * void *CreateContext(void *CtxCtx) { return CtxCtx; }; * void NotifyTerminating(void *CtxCtx) { MyOriginalDestroy(CtxCtx); }; * void Destroy(void *Ctx) { }; *; * This scheme simply reuses the CreateContextCtx pointer as the one-and-only; * allocation context.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h:1032,Usability,simpl,simply,1032,"/**; * Create a RTDyldObjectLinkingLayer instance using MCJIT-memory-manager-like; * callbacks.; *; * This is intended to simplify transitions for existing MCJIT clients. The; * callbacks used are similar (but not identical) to the callbacks for; * LLVMCreateSimpleMCJITMemoryManager: Unlike MCJIT, RTDyldObjectLinkingLayer; * will create a new memory manager for each object linked by calling the given; * CreateContext callback. This allows for code removal by destroying each; * allocator individually. Every allocator will be destroyed (if it has not been; * already) at RTDyldObjectLinkingLayer destruction time, and the; * NotifyTerminating callback will be called to indicate that no further; * allocation contexts will be created.; *; * To implement MCJIT-like behavior clients can implement CreateContext,; * NotifyTerminating, and Destroy as:; *; * void *CreateContext(void *CtxCtx) { return CtxCtx; }; * void NotifyTerminating(void *CtxCtx) { MyOriginalDestroy(CtxCtx); }; * void Destroy(void *Ctx) { }; *; * This scheme simply reuses the CreateContextCtx pointer as the one-and-only; * allocation context.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/OrcEE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:44,Integrability,Interface,Interface,44,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:438,Integrability,interface,interface,438,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:528,Integrability,interface,interface,528,"/*===-- llvm-c/Remarks.h - Remarks Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a remark diagnostics library. *|; |* LLVM provides an implementation of this interface. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:90,Performance,optimiz,optimizations,90,"/**; * The type of the remark. For example, it can allow users to only keep the; * missed optimizations from the compiler.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:122,Availability,avail,available,122,/**; * Get the next argument in \p Remark from the position of \p It.; *; * Returns `NULL` if there are no more arguments available.; *; * The lifetime of the returned value is bound to the lifetime of \p Remark.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,Safety,avoid,avoid,214,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:214,Safety,avoid,avoid,214,/**; * Creates a remark parser that can be used to parse the buffer located in \p; * Buf of size \p Size bytes.; *; * \p Buf cannot be `NULL`.; *; * This function should be paired with LLVMRemarkParserDispose() to avoid; * leaking resources.; *; * \since REMARKS_API_VERSION=1; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:421,Availability,error,error,421,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:588,Availability,error,error,588,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:615,Availability,error,error,615,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:696,Availability,error,error,696,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:785,Availability,error,error,785,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:1134,Deployability,Release,Release,1134,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:597,Integrability,message,message,597,"/**; * Returns the next remark in the file.; *; * The value pointed to by the return value needs to be disposed using a call to; * LLVMRemarkEntryDispose().; *; * All the entries in the returned value that are of LLVMRemarkStringRef type; * will become invalidated once a call to LLVMRemarkParserDispose is made.; *; * If the parser reaches the end of the buffer, the return value will be `NULL`.; *; * In the case of an error, the return value will be `NULL`, and:; *; * 1) LLVMRemarkParserHasError() will return `1`.; *; * 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error; * message.; *; * An error may occur if:; *; * 1) An argument is invalid.; *; * 2) There is a parsing error. This can occur on things like malformed YAML.; *; * 3) There is a Remark semantic error. This can occur on well-formed files with; * missing or extra fields.; *; * Here is a quick example of the usage:; *; * ```; * LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);; * LLVMRemarkEntryRef Remark = NULL;; * while ((Remark = LLVMRemarkParserGetNext(Parser))) {; * // use Remark; * LLVMRemarkEntryDispose(Remark); // Release memory.; * }; * bool HasError = LLVMRemarkParserHasError(Parser);; * LLVMRemarkParserDispose(Parser);; * ```; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:48,Availability,error,error,48,/**; * Returns `1` if the parser encountered an error while parsing the buffer.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:54,Availability,error,error,54,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:89,Availability,error,error,89,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:267,Deployability,release,released,267,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:60,Integrability,message,message,60,"/**; * Returns a null-terminated string containing an error message.; *; * In case of no error, the result is `NULL`.; *; * The memory of the string is bound to the lifetime of \p Parser. If; * LLVMRemarkParserDispose() is called, the memory of the string will be; * released.; *; * \since REMARKS_API_VERSION=0; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h:7,Deployability,Release,Releases,7,/**; * Releases all the resources used by \p Parser.; *; * \since REMARKS_API_VERSION=0; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Remarks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Remarks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:37,Integrability,Interface,Interface,37,"/*===-- llvm-c/Support.h - Support C Interface --------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the LLVM support library. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:432,Integrability,interface,interface,432,"/*===-- llvm-c/Support.h - Support C Interface --------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines the C interface to the LLVM support library. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:76,Performance,load,loads,76,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:226,Performance,Load,LoadLibraryPermanently,226,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:130,Safety,safe,safe,130,/**; * @addtogroup LLVMCCore; *; * @{; */; /**; * This function permanently loads the dynamic library at the given path.; * It is safe to call this function multiple times for the same library.; *; * @see sys::DynamicLibrary::LoadLibraryPermanently(); */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h:56,Performance,load,loaded,56,"/**; * This function will search through all previously loaded dynamic; * libraries for the symbol \p symbolName. If it is found, the address of; * that symbol is returned. If not, null is returned.; *; * @see sys::DynamicLibrary::SearchForAddressOfSymbol(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Support.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Support.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/Target.h - Target Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMTarget.a, which */; /* implements target information. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:661,Integrability,interface,interface,661,"/*===-- llvm-c/Target.h - Target Lib C Iface --------------------*- C++ -*-===*/; /* */; /* Part of the LLVM Project, under the Apache License v2.0 with LLVM */; /* Exceptions. */; /* See https://llvm.org/LICENSE.txt for license information. */; /* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception */; /* */; /*===----------------------------------------------------------------------===*/; /* */; /* This header declares the C interface to libLLVMTarget.a, which */; /* implements target information. */; /* */; /* Many exotic languages can interoperate with C code but have a harder time */; /* with C++ due to name mangling. So in addition to C, this interface enables */; /* tools written in such languages. */; /* */; /*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:63,Availability,avail,available,63,/* Declare all of the target-initialization functions that are available. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available assembly printer initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available assembly parser initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:22,Availability,avail,available,22,/* Declare all of the available disassembler initialization functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:105,Availability,avail,available,105,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:136,Modifiability,config,configured,136,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:91,Security,access,access,91,/** LLVMInitializeAllTargetInfos - The main program should call this function if; it wants access to all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:102,Availability,avail,available,102,/** LLVMInitializeAllTargets - The main program should call this function if it; wants to link in all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:133,Modifiability,config,configured,133,/** LLVMInitializeAllTargets - The main program should call this function if it; wants to link in all available targets that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:103,Availability,avail,available,103,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:136,Modifiability,config,configured,136,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:89,Security,access,access,89,/** LLVMInitializeAllTargetMCs - The main program should call this function if; it wants access to all available target MC that LLVM is configured to; support. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:158,Availability,avail,available,158,"/** LLVMInitializeAllAsmPrinters - The main program should call this function if; it wants all asm printers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:121,Modifiability,config,configured,121,"/** LLVMInitializeAllAsmPrinters - The main program should call this function if; it wants all asm printers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:156,Availability,avail,available,156,"/** LLVMInitializeAllAsmParsers - The main program should call this function if; it wants all asm parsers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:119,Modifiability,config,configured,119,"/** LLVMInitializeAllAsmParsers - The main program should call this function if; it wants all asm parsers that LLVM is configured to support, to make them; available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:161,Availability,avail,available,161,"/** LLVMInitializeAllDisassemblers - The main program should call this function; if it wants all disassemblers that LLVM is configured to support, to make; them available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:124,Modifiability,config,configured,124,"/** LLVMInitializeAllDisassemblers - The main program should call this function; if it wants all disassemblers that LLVM is configured to support, to make; them available via the TargetRegistry. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h:49,Modifiability,variab,variable,49,/** Computes the preferred alignment of a global variable in bytes for a target.; See the method llvm::DataLayout::getPreferredAlignment. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Target.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Target.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:58,Integrability,Interface,Interface,58,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:435,Integrability,interface,interface,435,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:701,Integrability,interface,interface,701,"/*===-- llvm-c/TargetMachine.h - Target Machine Library C Interface - C++ -*-=*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header declares the C interface to the Target and TargetMachine *|; |* classes, which can be used to generate assembly or object files. *|; |* *|; |* Many exotic languages can interoperate with C code but have a harder time *|; |* with C++ due to name mangling. So in addition to C, this interface enables *|; |* tools written in such languages. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:124,Availability,error,error,124,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:133,Availability,Error,ErrorMessage,133,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:186,Integrability,message,message,186,/** Finds the target corresponding to the given triple and stores it in \p T.; Returns 0 on success. Optionally returns any error in ErrorMessage.; Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:189,Deployability,release,released,189,/*===-- Target Machine ----------------------------------------------------===*/; /**; * Create a new set of options for an llvm::TargetMachine.; *; * The returned option structure must be released with; * LLVMDisposeTargetMachineOptions() after the call to; * LLVMCreateTargetMachineWithOptions().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:178,Deployability,configurat,configuration,178,/**; * Create a new llvm::TargetMachine.; *; * \param T the target to create a machine for.; * \param Triple a triple describing the target machine.; * \param Options additional configuration (see; * LLVMCreateTargetMachineOptions()).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:178,Modifiability,config,configuration,178,/**; * Create a new llvm::TargetMachine.; *; * \param T the target to create a machine for.; * \param Triple a triple describing the target machine.; * \param Options additional configuration (see; * LLVMCreateTargetMachineOptions()).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:8,Safety,abort,abort,8,/** Set abort behaviour when global instruction selection fails to lower/select; * an instruction. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:148,Availability,error,error,148,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:157,Availability,Error,ErrorMessage,157,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:76,Integrability,wrap,wraps,76,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h:209,Integrability,message,message,209,/** Emits an asm or object file for the given module to the filename. This; wraps several c++ only classes (among them a file stream). Returns any; error in ErrorMessage. Use LLVMDisposeMessage to dispose the message. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/TargetMachine.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:29,Integrability,Interface,Interface,29,"/*===-- llvm-c/Support.h - C Interface Types declarations ---------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines types used by the C interface to LLVM. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:446,Integrability,interface,interface,446,"/*===-- llvm-c/Support.h - C Interface Types declarations ---------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines types used by the C interface to LLVM. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:545,Availability,down,downcasts,545,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:655,Integrability,interface,interfaces,655,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:40,Modifiability,polymorphi,polymorphic,40,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:526,Performance,perform,performs,526,"/* Opaque types. */; /**; * LLVM uses a polymorphic type hierarchy which C cannot represent, therefore; * parameters must be passed as base types. Despite the declared types, most; * of the functions provided operate only on branches of the type hierarchy.; * The declared parameter names are descriptive and specify which type is; * required. Additionally, each type hierarchy is documented along with the; * functions that operate upon it. For more detail, refer to LLVM's C++ code.; * If in doubt, refer to Core.cpp, which performs parameter downcasts in the; * form unwrap<RequiredType>(Param).; */; /**; * Used to pass regions of memory through LLVM interfaces.; *; * @see llvm::MemoryBuffer; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h:7,Integrability,Interface,Interface,7,"/**; * Interface used to provide a module to JIT or interpreter.; * This is now just a synonym for llvm::Module, but we have to keep using the; * different type to keep binary compatibility.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Types.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Types.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:440,Integrability,interface,interface,440,"/*===-- llvm-c/Transform/PassBuilder.h - PassBuilder for LLVM C ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header contains the LLVM-C interface into the new pass manager *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:288,Deployability,pipeline,pipelines,288,"/**; * Construct and run a set of passes over a module; *; * This function takes a string with the passes that should be used. The format; * of this string is the same as opt's -passes argument for the new pass; * manager. Individual passes may be specified, separated by commas. Full; * pipelines may also be invoked using `default<O3>` and friends. See opt for; * full reference of the Passes format.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:7,Deployability,Toggle,Toggle,7,"/**; * Toggle adding the VerifierPass for the PassBuilder, ensuring all functions; * inside the module is valid.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:7,Deployability,Toggle,Toggle,7,/**; * Toggle debug logging when running the PassBuilder; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:20,Testability,log,logging,20,/**; * Toggle debug logging when running the PassBuilder; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h:25,Energy Efficiency,allocate,allocated,25,/**; * Dispose of a heap-allocated PassBuilderOptions instance; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Transforms/PassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:49,Integrability,Interface,Interface,49,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:430,Integrability,interface,interface,430,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:472,Integrability,interface,interface,472,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:616,Integrability,interface,interface,616,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:729,Safety,detect,detect,729,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:718,Testability,test,tests,718,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:711,Usability,simpl,simple,711,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:1185,Usability,simpl,simple,1185,"//==- AliasAnalysis.cpp - Generic Alias Analysis Interface Implementation --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the generic AliasAnalysis interface which is used as the; // common interface used by all clients and implementations of alias analysis.; //; // This file also implements the default version of the AliasAnalysis interface; // that is to be used when no other implementation is specified. This does some; // simple tests that detect obvious cases: two different global pointers cannot; // alias, a global cannot alias a malloc, two different mallocs cannot alias,; // etc.; //; // This alias analysis implementation really isn't very good for anything, but; // it is very fast, and makes a nice clean default implementation. Because it; // handles lots of little corner cases, other, more complex, alias analysis; // implementations may choose to rely on this pass to resolve these simple and; // easy cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:87,Testability,test,testing,87,/// Allow disabling BasicAA from the AA results. This is particularly useful; /// when testing to isolate a single AA implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:191,Integrability,depend,dependency,191,"// AAResults preserves the AAManager by default, due to the stateless nature; // of AliasAnalysis. There is no need to check whether it has been preserved; // explicitly. Check if any module dependency was invalidated and caused the; // AAManager to be invalidated. Invalidate ourselves in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:32,Integrability,depend,dependencies,32,"// Check if any of the function dependencies were invalidated, and invalidate; // ourselves in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Integrability,depend,depend,17,"// Everything we depend on is still fine, so are we. Nothing to invalidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:84,Security,access,access,84,"// Otherwise, check if the call modifies or references the; // location this memory access defines. The best we can say; // is that if the call references what this instruction; // defines, it must be clobbered by this location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:213,Security,access,accessible,213,"// Try to refine the mod-ref info further using other API entry points to the; // aggregate set of AA results.; // We can completely ignore inaccessible memory here, because MemoryLocations; // can only reference accessible memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:20,Availability,mask,mask,20,"// Apply the ModRef mask. This ensures that if Loc is a constant memory; // location, we take into account the fact that the call definitely could not; // modify the memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:51,Integrability,depend,dependence,51,"// If they both only read from memory, there is no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:40,Integrability,depend,dependence,40,"// If Call1 only reads memory, the only dependence on Call2 can be; // from Call1 reading memory written by Call2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Security,access,access,17,"// If Call2 only access memory through arguments, accumulate the mod/ref; // information from Call1's references to the memory referenced by; // Call2's arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:73,Integrability,depend,dependence,73,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:160,Integrability,depend,dependence,160,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:244,Integrability,depend,dependence,244,"// ArgModRefC2 indicates what Call2 might do to Call2ArgLoc, and the; // dependence of Call1 on that location is the inverse:; // - If Call2 modifies location, dependence exists if Call1 reads or; // writes.; // - If Call2 only reads location, dependence exists if Call1 writes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:90,Deployability,update,update,90,"// ModRefC1 indicates what Call1 might do to Call2ArgLoc, and we use; // above ArgMask to update dependence info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:97,Integrability,depend,dependence,97,"// ModRefC1 indicates what Call1 might do to Call2ArgLoc, and we use; // above ArgMask to update dependence info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:17,Security,access,accesses,17,"// If Call1 only accesses memory through arguments, check if Call2 references; // any of the memory referenced by Call1's arguments. If not, return NoModRef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:10,Performance,load,load,10,"// If the load address doesn't alias the given address, it doesn't read; // or write the specified memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:16,Performance,load,load,16,"// Otherwise, a load just reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:22,Availability,mask,mask,22,"// Examine the ModRef mask. If Mod isn't present, then return NoModRef.; // This ensures that if Loc is a constant memory location, we take into; // account the fact that the store definitely could not modify the memory; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:76,Availability,mask,mask,76,"// All we know about a fence instruction is what we get from the ModRef; // mask: if Loc is a constant memory location, the fence definitely could; // not modify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:103,Security,access,accessed,103,"// If the va_arg address cannot alias the pointer in question, then the; // specified memory cannot be accessed by the va_arg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:11,Deployability,Release,Release,11,// Acquire/Release cmpxchg has properties that matter for arbitrary addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:67,Security,access,access,67,"// If the cmpxchg address does not alias the location, it does not access; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:11,Deployability,Release,Release,11,// Acquire/Release atomicrmw has properties that matter for arbitrary addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:69,Security,access,access,69,"// If the atomicrmw address does not alias the location, it does not access; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:439,Testability,test,test,439,"/// Return information about whether a particular call site modifies; /// or reads the specified memory location \p MemLoc before instruction \p I; /// in a BasicBlock.; /// FIXME: this is really just shoring-up a deficiency in alias analysis.; /// BasicAA isn't willing to spend linear time determining whether an alloca; /// was captured before or after this particular call, while we are. However,; /// with a smarter AA in place, this test is just wasting compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:297,Availability,avail,available,297,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:12,Integrability,wrap,wrapper,12,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:117,Integrability,interface,interface,117,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:357,Modifiability,config,configured,357,"/// Run the wrapper pass to rebuild an aggregation over known AA passes.; ///; /// This is the legacy pass manager's interface to the new-style AA results; /// aggregation object. Because this is somewhat shoe-horned into the legacy; /// pass manager, we hard code all the specific alias analyses available into; /// it. While the particular set enabled is configured via commandline flags,; /// adding a new alias analysis to LLVM will require adding support for it to; /// this list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:279,Availability,down,down,279,"// NB! This *must* be reset before adding new AA results to the new; // AAResults object because in the legacy pass manager, each instance; // of these will refer to the *same* immutable analyses, registering and; // unregistering themselves with them. We need to carefully tear down the; // previous object first, in this case replacing it with an empty one, before; // registering new results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:21,Availability,avail,available,21,"// BasicAA is always available for function analyses. Also, we add it first; // so that it can trump TBAA results when it proves MustAlias.; // FIXME: TBAA should have an explicit mode to support this and then we; // should reconsider the ordering here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:43,Availability,avail,available,43,// Populate the results with the currently available AAs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:6,Availability,avail,available,6,"// If available, run an external AA providing callback over the results as; // well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:7,Performance,load,load,7,// The load case works because isNonEscapingLocalObject considers all; // stores to be escapes (it passes true for the StoreCaptures argument; // to PointerMayBeCaptured).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:193,Performance,load,load,193,"// The inttoptr case works because isNonEscapingLocalObject considers all; // means of converting or equating a pointer to an int (ptrtoint, ptr store; // which could be followed by an integer load, ptr<->int compare) as; // escaping, and objects located at well-known addresses via platform-specific; // means cannot be considered non-escaping local objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:27,Security,access,accessible,27,"// A noalias return is not accessible from any other code. If the pointer; // does not escape prior to the unwind, then the caller cannot access the; // memory either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:138,Security,access,access,138,"// A noalias return is not accessible from any other code. If the pointer; // does not escape prior to the unwind, then the caller cannot access the; // memory either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:115,Performance,perform,perform,115,"// We don't consider globals as writable: While the physical memory is writable,; // we may not have provenance to perform the write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp:29,Performance,load,load,29,"// iterate over all pairs of load, store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysisEvaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:3,Deployability,Update,Update,3,// Update the alias and access types of this set...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:24,Security,access,access,24,// Update the alias and access types of this set...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:3,Deployability,Update,Update,3,// Update TotalAliasSetSize only if not forwarding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:83,Availability,down,downgrade,83,"// If we cannot find a must-alias with any of the existing MemoryLocs, we; // must downgrade to may-alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:291,Availability,avail,available,291,"/// mergeAliasSetsForMemoryLocation - Given a memory location, merge all alias; /// sets that may alias it. Return the unified set, or nullptr if no aliasing; /// set was found. A known existing alias set for the pointer value of the; /// memory location can be passed in (or nullptr if not available). MustAliasAll; /// is updated to true/false if the memory location is found to MustAlias all; /// the sets it merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:324,Deployability,update,updated,324,"/// mergeAliasSetsForMemoryLocation - Given a memory location, merge all alias; /// sets that may alias it. Return the unified set, or nullptr if no aliasing; /// set was found. A known existing alias set for the pointer value of the; /// memory location can be passed in (or nullptr if not available). MustAliasAll; /// is updated to true/false if the memory location is found to MustAlias all; /// the sets it merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:14,Performance,perform,perform,14,"// Otherwise, perform the actual merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:29,Performance,Cache,Cache,29,"//===- AssumptionCache.cpp - Cache finding @llvm.assume calls -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:30,Safety,avoid,avoid,30,// Try using find_as first to avoid creating extra value handles just for the; // purpose of doing the lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:88,Performance,cache,cache,88,"// Go through all instructions in all blocks, add all calls to @llvm.assume; // to this cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:3,Deployability,Update,Update,3,// Update affected values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:61,Testability,assert,asserts,61,"// We expect the number of assumptions to be small, so in an asserts build; // check that we don't accumulate duplicates and that all assumptions point; // to the same function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:46,Safety,avoid,avoid,46,"// We probe the function map twice to try and avoid creating a value handle; // around the function in common cases. This makes insertion a bit slower,; // but if we have to insert we're going to scan the whole function so that; // shouldn't matter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:19,Performance,cache,cache,19,"// Ok, build a new cache by scanning the function, insert it and the value; // handle into our map, and return the newly populated cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:131,Performance,cache,cache,131,"// Ok, build a new cache by scanning the function, insert it and the value; // handle into our map, and return the newly populated cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:129,Deployability,update,update,129,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:254,Deployability,update,updated,254,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:155,Performance,cache,cache,155,// FIXME: In the long term the verifier should not be controllable with a; // flag. We should either fix all passes to correctly update the assumption; // cache and enable the verifier unconditionally or somehow arrange for the; // assumption list to be updated automatically by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:464,Integrability,interface,interface,464,"//===- BasicAliasAnalysis.cpp - Stateless Alias Analysis Impl -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the primary stateless implementation of the; // Alias Analysis interface that implements identities (two different; // globals cannot alias, etc), but does no stateful analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:118,Integrability,depend,depends,118,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been. Note that we; // may be created without handles to some analyses and in that case don't; // depend on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:232,Integrability,depend,depend,232,"// We don't care if this analysis itself is preserved, it has no state. But; // we need to check that the analyses it depends on have been. Note that we; // may be created without handles to some analyses and in that case don't; // depend on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:630,Energy Efficiency,allocate,allocated,630,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:1141,Usability,simpl,simplicity,1141,"// Note that the meanings of the ""object"" are slightly different in the; // following contexts:; // c1: llvm::getObjectSize(); // c2: llvm.objectsize() intrinsic; // c3: isObjectSmallerThan(); // c1 and c2 share the same meaning; however, the meaning of ""object"" in c3; // refers to the ""entire object"".; //; // Consider this example:; // char *p = (char*)malloc(100); // char *q = p+80;; //; // In the context of c1 and c2, the ""object"" pointed by q refers to the; // stretch of memory of q[0:19]. So, getObjectSize(q) should return 20.; //; // However, in the context of c3, the ""object"" refers to the chunk of memory; // being allocated. So, the ""object"" has 100 bytes, and q points to the middle; // the ""object"". In case q is passed to isObjectSmallerThan() as the 1st; // parameter, before the llvm::getObjectSize() is called to get the size of; // entire object, we should:; // - either rewind the pointer q to the base-address of the object in; // question (in this case rewind to p), or; // - just give up. It is up to caller to make sure the pointer is pointing; // to the base address the object.; //; // We go for 2nd option for simplicity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:89,Security,access,accesses,89,"// If we have dereferenceability information we know a lower bound for the; // extent as accesses for a lower offset would be valid. We need to exclude; // the ""or null"" part if null is a valid pointer. We can ignore frees, as an; // access after free would be undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:234,Security,access,access,234,"// If we have dereferenceability information we know a lower bound for the; // extent as accesses for a lower offset would be valid. We need to exclude; // the ""or null"" part if null is a valid pointer. We can ignore frees, as an; // access after free would be undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:83,Security,access,accessed,83,"// If queried with a precise location size, we assume that location size to be; // accessed, thus valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:262,Integrability,wrap,wrap-arounds,262,"/// To ensure a pointer offset fits in an integer of size IndexSize; /// (in bits) when that size is smaller than the maximum index size. This is; /// an issue, for example, in particular for 32b pointers with negative indices; /// that rely on two's complement wrap-arounds for precise alias information; /// where the maximum index size is 64b.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:161,Integrability,wrap,wrapping,161,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:194,Integrability,wrap,wraps,194,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:104,Safety,avoid,avoid,104,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:71,Usability,simpl,simply,71,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:105,Modifiability,variab,variable,105,"// Represents the internal structure of a GEP, decomposed into a base pointer,; // constant offsets, and variable scaled indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:10,Modifiability,variab,variable,10,// Scaled variable (non-constant) indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:40,Performance,scalab,scalable,40,// Don't attempt to analyze GEPs if the scalable index is not zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Modifiability,extend,extended,81,"// If the integer type is smaller than the index size, it is implicitly; // sign extended or truncated to index size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:49,Modifiability,variab,variable,49,"// If we already had an occurrence of this index variable, merge this; // scale into it. For example, we want to handle:; // A[x][x] -> x*16 + x*4 -> x*20; // This also ensures that 'x' only appears in the index list once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:16,Integrability,wrap,wrap-arounds,16,// Take care of wrap-arounds,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:112,Integrability,depend,dependence,112,"// These intrinsics can read arbitrary memory, and additionally modref; // inaccessible memory to model control dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:225,Usability,simpl,simple,225,"/// Checks to see if the specified callsite can clobber the specified memory; /// object.; ///; /// Since we only look at local properties of this function, we really can't; /// say much about this query. We do, however, use simple ""address taken""; /// analysis on local objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:31,Energy Efficiency,allocate,allocated,31,"// A call can access a locally allocated object either because it is passed as; // an argument to the call, or because it has escaped prior to the call.; //; // Make sure the object has not escaped here, and then check that none of the; // call arguments alias the object below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:14,Security,access,access,14,"// A call can access a locally allocated object either because it is passed as; // an argument to the call, or because it has escaped prior to the call.; //; // Make sure the object has not escaped here, and then check that none of the; // call arguments alias the object below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:16,Security,access,access,16,"// Call doesn't access memory through this operand, so we don't care; // if it aliases with Object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:148,Integrability,rout,routines,148,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:248,Integrability,rout,routines,248,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:263,Security,access,access,263,"// If the call is malloc/calloc like, we can assume that it doesn't; // modify any IR visible value. This is only valid because we assume these; // routines do not read values visible in the IR. TODO: Consider special; // casing realloc and strdup routines which access only their arguments as; // well. Or alternatively, replace all of this with inaccessiblememonly once; // that's implemented fully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:26,Security,access,accessed,26,// Be conservative if the accessed pointer may alias the allocation -; // fallback to the generic handling below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:111,Integrability,depend,dependencies,111,"// Like assumes, invariant.start intrinsics were also marked as arbitrarily; // writing so that proper control dependencies are maintained but they never; // mod any particular memory location visible to the IR.; // *Unlike* assumes (which are now modeled as NoModRef), invariant.start; // intrinsic is now modeled as reading memory. This prevents hoisting the; // invariant.start intrinsic over stores. Consider:; // *ptr = 40;; // *ptr = 50;; // invariant_start(ptr); // int val = *ptr;; // print(val);; //; // This cannot be transformed to:; //; // *ptr = 40;; // invariant_start(ptr); // *ptr = 50;; // int val = *ptr;; // print(val);; //; // The transformation will cause the second store to be ignored (based on; // rules of invariant.start) and print 40, while the first program always; // prints 50.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Integrability,depend,dependencies,81,"// Guard intrinsics are marked as arbitrarily writing so that proper control; // dependencies are maintained but they never mods any particular memory; // location.; //; // *Unlike* assumes, guard intrinsics are modeled as reading memory since the; // heap state at the point the guard is issued needs to be consistent in case; // the guard invokes the ""deopt"" continuation.; // NB! This function is *not* commutative, so we special case two; // possibilities for guard intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:160,Integrability,rout,routines,160,"// TODO: We can handle other cases here; // 1) For GC languages, arguments to functions are often required to be; // base pointers.; // 2) Result of allocation routines are often base pointers. Leverage TLI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Safety,avoid,avoid,81,// TODO: This limitation exists for compile-time reasons. Relax it if we; // can avoid exponential pathological cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:11,Security,access,accesses,11,"// If both accesses have unknown size, we can only check whether the base; // objects don't alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:184,Performance,scalab,scalable,184,"// If an inbounds GEP would have to start from an out of bounds address; // for the two to alias, then we can assume noalias.; // TODO: Remove !isScalable() once BasicAA fully support scalable location; // size",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,Performance,perform,performing,81,"// For GEPs with identical offsets, we can preserve the size and AAInfo; // when performing the alias check on the underlying objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:21,Performance,scalab,scalable,21,// Bail on analysing scalable LocationSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:72,Performance,cache,cache,72,"// Memory referenced by right pointer is nested. Save the offset in; // cache. Note that originally offset estimated as GEP1-V2, but; // AliasResult contains the shift that represents GEP1+Offset=V2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:15,Security,access,accesses,15,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:176,Security,access,accesses,176,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:256,Security,access,access,256,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:33,Security,access,accessed,33,"// Compute ranges of potentially accessed bytes for both accesses. If the; // interseciton is empty, there can be no overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:57,Security,access,accesses,57,"// Compute ranges of potentially accessed bytes for both accesses. If the; // interseciton is empty, there can be no overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:80,Integrability,wrap,wrapping,80,// Check if abs(V*Scale) >= abs(Scale) holds in the presence of; // potentially wrapping math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:199,Integrability,wrap,wrap,199,// If Scale is small enough so that abs(V*Scale) >= abs(Scale) holds.; // The max value of abs(V) is 2^ValOrigBW - 1. Multiplying with a; // constant smaller than 2^(bitwidth(Val) - ValOrigBW) won't wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:97,Integrability,wrap,wrapping,97,"// Refine MinAbsVarIndex, if abs(Scale*V) >= abs(Scale) holds in the; // presence of potentially wrapping math.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:136,Safety,avoid,avoid,136,"// VarIndex = Scale*V0 + (-Scale)*V1.; // If V0 != V1 then abs(VarIndex) >= abs(Scale).; // Check that MayBeCrossIteration is false, to avoid reasoning about; // inequality of values across loop iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:85,Energy Efficiency,efficient,efficient,85,"// If the values are PHIs in the same block, we can do a more precise; // as well as efficient check: just check for aliases between the values; // on corresponding edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:292,Modifiability,variab,variable,292,"// To control potential compile time explosion, we choose to be; // conserviate when we have more than one Phi input. It is important; // that we handle the single phi case as that lets us handle LCSSA; // phi nodes and (combined with the recursive phi handling) simple; // pointer induction variable patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:263,Usability,simpl,simple,263,"// To control potential compile time explosion, we choose to be; // conserviate when we have more than one Phi input. It is important; // that we handle the single phi case as that lets us handle LCSSA; // phi nodes and (combined with the recursive phi handling) simple; // pointer induction variable patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:52,Performance,load,load,52,"// If one pointer is the result of a call/invoke or load and the other is a; // non-escaping local object within the same function, then we know the; // object couldn't escape to a point where the call could return it.; //; // Note that if the pointers are in different functions, there are a; // variety of complications. A call with a nocapture argument may still; // temporary store the nocapture argument's value in a temporary memory; // location if that memory location doesn't escape. Or it may pass a; // nocapture value to other functions as long as they don't capture it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:22,Security,access,access,22,"// If the size of one access is larger than the entire object on the other; // side, then we know such behavior is undefined and can assume no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:38,Modifiability,rewrite,rewrites,38,"// This is often a no-op; instcombine rewrites this for us. No-op; // getUnderlyingObject calls are fast, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:431,Performance,cache,cache,431,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:14,Security,access,accesses,14,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:41,Security,access,accessed,41,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:127,Security,access,accesses,127,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:382,Security,access,accesses,382,"// If one the accesses may be before the accessed pointer, canonicalize this; // by using unknown after-pointer sizes for both accesses. This is; // equivalent, because regardless of which pointer is lower, one of them; // will always came after the other, as long as the underlying objects aren't; // disjoint. We do this so that the rest of BasicAA does not have to deal; // with accesses before the base pointer, and to improve cache utilization by; // merging equivalent states.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:50,Performance,cache,cache,50,"// FIXME: If this depth limit is hit, then we may cache sub-optimal results; // for recursive queries. For this reason, this limit is chosen to be large; // enough to be very rarely hit, while still being small enough to avoid; // stack overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:221,Safety,avoid,avoid,221,"// FIXME: If this depth limit is hit, then we may cache sub-optimal results; // for recursive queries. For this reason, this limit is chosen to be large; // enough to be very rarely hit, while still being small enough to avoid; // stack overflows.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:13,Performance,cache,cache,13,"// Check the cache before climbing up use-def chains. This also terminates; // otherwise infinitely recursive queries. Include MayBeCrossIteration in the; // cache key, because some cases where MayBeCrossIteration==false returns; // MustAlias or NoAlias may become MayAlias under MayBeCrossIteration==true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:158,Performance,cache,cache,158,"// Check the cache before climbing up use-def chains. This also terminates; // otherwise infinitely recursive queries. Include MayBeCrossIteration in the; // cache key, because some cases where MayBeCrossIteration==false returns; // MustAlias or NoAlias may become MayAlias under MayBeCrossIteration==true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Performance,Cache,Cache,3,"// Cache contains sorted {V1,V2} pairs but we should return original order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:3,Performance,Cache,Cache,3,"// Cache contains sorted {V1,V2} pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:133,Deployability,update,updates,133,"// If the assumption has been disproven, remove any results that may have; // been based on this assumption. Do this after the Entry updates above to; // avoid iterator invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:154,Safety,avoid,avoid,154,"// If the assumption has been disproven, remove any results that may have; // been based on this assumption. Do this after the Entry updates above to; // avoid iterator invalidation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:118,Performance,cache,cache,118,"// The result may still be based on assumptions higher up in the chain.; // Remember it, so it can be purged from the cache later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:74,Security,access,accesses,74,"// If both pointers are pointing into the same object and one of them; // accesses the entire object, then the accesses must overlap in some way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:111,Security,access,accesses,111,"// If both pointers are pointing into the same object and one of them; // accesses the entire object, then the accesses must overlap in some way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:90,Modifiability,variab,variable,90,"// Find V in Dest. This is N^2, but pointer indices almost never have more; // than a few variable indexes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:304,Integrability,wrap,wrapping,304,"// We have a hit - Var0 and Var1 only differ by a constant offset!; // If we've been sext'ed then zext'd the maximum difference between Var0 and; // Var1 is possible to calculate, but we're just interested in the absolute; // minimum difference between the two. The minimum distance may occur due to; // wrapping; consider ""add i3 %i, 5"": if %i == 7 then 7 + 5 mod 8 == 4, and so; // the minimum distance between %i and %i + 5 is 3.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:69,Integrability,wrap,wrapping,69,"// We can't definitely say whether GEP1 is before or after V2 due to wrapping; // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other; // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and; // V2Size can fit in the MinDiffBytes gap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:399,Usability,simpl,simplified,399,"//===- BlockFrequencyInfo.cpp - Block Frequency Analysis ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:258,Availability,avail,available,258,// Explicitly define the default constructor otherwise it would be implicitly; // defined at the first ODR-use which is the BFI member in the; // LazyBlockFrequencyInfo header. The dtor needs the BlockFrequencyInfoImpl; // template instantiated which is not available in the header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:25,Safety,avoid,avoid,25,// Use 128 bits APInt to avoid overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:184,Safety,avoid,avoid,184,"// udiv is an expensive operation in the general case. If this ends up being; // a hot spot, one of the options proposed in; // https://reviews.llvm.org/D28535#650071 could be used to avoid this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:399,Usability,simpl,simplified,399,"//===- BlockFrequencyImplInfo.cpp - Block Frequency Info Implementation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:131,Availability,error,error,131,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:654,Deployability,Update,Update,654,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:179,Integrability,depend,depends,179,"/// Dithering mass distributer.; ///; /// This class splits up a single mass into portions by weight, dithering to; /// spread out error. No mass is lost. The dithering precision depends on the; /// precision of the product of \a BlockMass and \a BranchProbability.; ///; /// The distribution algorithm follows.; ///; /// 1. Initialize by saving the sum of the weights in \a RemWeight and the; /// mass to distribute in \a RemMass.; ///; /// 2. For each portion:; ///; /// 1. Construct a branch probability, P, as the portion's weight divided; /// by the current value of \a RemWeight.; /// 2. Calculate the portion's mass as \a RemMass times P.; /// 3. Update \a RemWeight and \a RemMass at each portion by subtracting; /// the current portion's weight and mass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update the total.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,Security,hash,hash,9,// Use a hash table for many successors to keep this linear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,Availability,down,down,9,"// Scale down below UINT32_MAX. Since Shift is larger than necessary, we; // can round here without concern about overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update the total.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:69,Usability,clear,clear,69,"// Swap with a default-constructed std::vector, since std::vector<>::clear(); // does not actually clear heap storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:99,Usability,clear,clear,99,"// Swap with a default-constructed std::vector, since std::vector<>::clear(); // does not actually clear heap storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:32,Availability,down,downstream,32,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:83,Availability,down,downstream,83,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:54,Deployability,Release,Releases,54,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:4,Usability,Clear,Clear,4,"/// Clear all memory not needed downstream.; ///; /// Releases all memory not used downstream. In particular, saves Freqs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:25,Safety,Abort,Abort,25,// Irreducible backedge. Abort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:143,Availability,down,down,143,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:255,Safety,avoid,avoid,255,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Usability,Clear,Clear,3,// Clear the subloop exits to prevent quadratic memory usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:129,Safety,avoid,avoid,129,// Users often add up multiple BlockFrequency values or multiply them with; // things like instruction costs. Leave some room to avoid saturating; // operations reaching UIN64_MAX too early.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:107,Deployability,update,updated,107,"// Propagate the head scale through the loop. Since members are visited in; // RPO, the head scale will be updated by the loop scale first, and then the; // final head scale will be used for updated the rest of the members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:191,Deployability,update,updated,191,"// Propagate the head scale through the loop. Since members are visited in; // RPO, the head scale will be updated by the loop scale first, and then the; // final head scale will be used for updated the rest of the members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update min/max scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:45,Safety,avoid,avoid,45,// Use 128 bit APInt to do the arithmetic to avoid overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:3,Deployability,Update,Update,3,// Update loop hierarchy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:399,Usability,simpl,simplified,399,"//===- BranchProbabilityInfo.cpp - Branch Probability Analysis ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:161,Safety,predict,predict,161,"// Weights are for internal use only. They are used by heuristics to help to; // estimate edges' probability. Example:; //; // Using ""Loop Branch Heuristics"" we predict weights of edges for the; // block BB2.; // ...; // |; // V; // BB1<-+; // | |; // | | (Weight = 124); // V |; // BB2--+; // |; // | (Weight = 4); // V; // BB3; //; // Probability of the edge BB2->BB1 = 124 / (124 + 4) = 0.96875; // Probability of the edge BB2->BB3 = 4 / (124 + 4) = 0.03125",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:184,Safety,predict,predicted,184,/// Unreachable-terminating branch taken probability.; ///; /// This is the probability for a branch being taken to a block that terminates; /// (eventually) in unreachable. These are predicted as unlikely as possible.; /// All reachable probability will proportionally share the remaining part.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:144,Testability,test,test,144,"/// This is the probability for an unordered floating point comparison, it means; /// one or two of the operands are NaN. Usually it is used to test for an; /// exceptional case, so the result is unlikely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:165,Performance,cache,cache,165,// Record SCC numbers of blocks in the CFG to identify irreducible loops.; // FIXME: We could only calculate this if the CFG is known to be irreducible; // (perhaps cache this info in LoopInfo if we can easily calculate it there?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:57,Performance,cache,cache,57,// Lazily compute the set of headers for a given SCC and cache the results; // in the SccHeaderMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:69,Availability,down,down,69,"// If the sum of weights does not fit in 32 bits, scale every weight down; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:111,Availability,error,error,111,// If all oldBP[i] are zeroes then the proportional distribution results; // in all zero probabilities and the error stays big. In this case we; // evenly spread NewReachableSum over the reachable edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:44,Availability,error,error,44,"// We use uint64_t to avoid double rounding error of the following; // calculation: BP[i] = BP[i] * NewReachableSum / OldReachableSum; // The formula is taken from the private constructor; // BranchProbability(uint32_t Numerator, uint32_t Denominator)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:22,Safety,avoid,avoid,22,"// We use uint64_t to avoid double rounding error of the following; // calculation: BP[i] = BP[i] * NewReachableSum / OldReachableSum; // The formula is taken from the private constructor; // BranchProbability(uint32_t Numerator, uint32_t Denominator)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:54,Safety,Predict,Predict,54,"// Calculate Edge Weights using ""Pointer Heuristics"". Predict a comparison; // between two pointer or pointer and NULL will fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:516,Integrability,depend,depends,516,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:414,Safety,detect,detect,414,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:21,Modifiability,extend,extends,21,// Stop if the chain extends outside of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Deployability,Update,Updates,3,// Updates \p LoopBB's weight and returns true. If \p LoopBB has already; // an associated weight it is unchanged and false is returned.; //; // Please note by the algorithm the weight is not expected to change once set; // thus 'false' status is used to track visited blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:750,Deployability,update,updated,750,"// Starting from \p BB traverse through dominator blocks and assign \p BBWeight; // to all such blocks that are post dominated by \BB. In other words to all; // blocks that the one is executed if and only if another one is executed.; // Importantly, we skip loops here for two reasons. First weights of blocks in; // a loop should be scaled by trip count (yet possibly unknown). Second there is; // no any value in doing that because that doesn't give any additional; // information regarding distribution of probabilities inside the loop.; // Exception is loop 'enter' and 'exit' edges that are handled in a special way; // at calcEstimatedHeuristics.; //; // In addition, \p WorkList is populated with basic blocks if at leas one; // successor has updated estimated weight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:37,Availability,down,down,37,// TODO: Consider propagating weight down the domination line as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:125,Safety,avoid,avoid,125,"// Important note regarding the order of checks. They are ordered by weight; // from lowest to highest. Doing that allows to avoid ""unstable"" results; // when several conditions heuristics can be applied simultaneously.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:188,Availability,down,down,188,"// Does RPO traversal over all blocks in \p F and assigns weights to; // 'unreachable', 'noreturn', 'cold', 'unwind' blocks. In addition it does its; // best to propagate the weight to up/down the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid adjustment of ZERO weight since it should remain unchanged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:9,Availability,down,down,9,// Scale down loop exiting weight by trip count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid adjustment of ZERO weight since it should remain unchanged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:69,Availability,down,down,69,"// If the sum of weights does not fit in 32 bits, scale every weight down; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:23,Availability,error,errors,23,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:254,Availability,error,error,254,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:307,Availability,error,error,307,"// Because of rounding errors the total probability cannot be checked to be; // 1.0 exactly. That is TotalNumerator == BranchProbability::getDenominator.; // Instead, every single probability in Probs must be as accurate as possible.; // This results in error 1/denominator at most, thus the total absolute error; // should be within Probs.size / BranchProbability::getDenominator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:3,Deployability,Update,Update,3,// Update parent CG for all call graph's nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:78,Testability,assert,assertion,78,// Reset all node's use counts to zero before deleting them to prevent an; // assertion from firing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:106,Availability,down,down,106,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:92,Safety,avoid,avoid,92,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:30,Energy Efficiency,schedul,scheduled,30,"/// Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:26,Deployability,update,update,26,// Yep. Emit a remark and update InstrCount.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:129,Deployability,update,updated,129,"// After the CGSCCPass is done, when assertions are enabled, use; // RefreshCallGraph to verify that the callgraph was correctly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:37,Testability,assert,assertions,37,"// After the CGSCCPass is done, when assertions are enabled, use; // RefreshCallGraph to verify that the callgraph was correctly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:262,Deployability,update,updated,262,"/// Scan the functions in the specified CFG and resync the; /// callgraph with the call sites found in it. This is used after; /// FunctionPasses have potentially munged the callgraph, and can be used after; /// CallGraphSCC passes to verify that they correctly updated the callgraph.; ///; /// This function returns true if it devirtualized an existing function call,; /// meaning it turned an indirect call into a direct call. This happens when; /// a function pass like GVN optimizes away stuff feeding the indirect call.; /// This never happens in checking mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:477,Performance,optimiz,optimizes,477,"/// Scan the functions in the specified CFG and resync the; /// callgraph with the call sites found in it. This is used after; /// FunctionPasses have potentially munged the callgraph, and can be used after; /// CallGraphSCC passes to verify that they correctly updated the callgraph.; ///; /// This function returns true if it devirtualized an existing function call,; /// meaning it turned an indirect call into a direct call. This happens when; /// a function pass like GVN optimizes away stuff feeding the indirect call.; /// This never happens in checking mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:3,Deployability,Update,Update,3,// Update the edge target in CGN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:506,Energy Efficiency,reduce,reduced,506,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:321,Performance,optimiz,optimize,321,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:399,Safety,detect,detect,399,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:156,Safety,abort,abort,156,"// After scanning this function, if we still have entries in callsites, then; // they are dangling pointers. WeakTrackingVH should save us for this, so; // abort if; // this happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:31,Usability,clear,clear,31,// Periodically do an explicit clear to remove tombstones when processing; // large scc's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:87,Safety,avoid,avoid,87,"// If we're in -debug-pass=Executions mode, construct the SCC node list,; // otherwise avoid constructing this string as it is expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:30,Energy Efficiency,schedul,scheduled,30,"/// Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:3,Deployability,Update,Update,3,// Update the active scc_iterator so that it doesn't contain dangling; // pointers to the old CallGraphNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:527,Availability,avail,available,527,"//===- CallPrinter.cpp - DOT printer for call graph -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines '-dot-callgraph', which emit a callgraph.<fnname>.dot; // containing the call graph of a module.; //; // There is also a pass available to directly call dotty ('-view-callgraph').; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:113,Availability,avail,available,113,// This option shows static (relative) call counts.; // FIXME:; // Need to show real counts when profile data is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:402,Integrability,rout,routines,402,"//===--- CaptureTracking.cpp - Determine whether a pointer is captured ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; // A pointer value is captured if the function makes a copy of any part of the; // pointer that outlives the call. Not being captured means, more or less, that; // the pointer is only dereferenced and not stored in a global. Returning part; // of the pointer as the function return value may or may not count as capturing; // the pointer, depending on the context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:800,Integrability,depend,depending,800,"//===--- CaptureTracking.cpp - Determine whether a pointer is captured ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help determine which pointers are captured.; // A pointer value is captured if the function makes a copy of any part of the; // pointer that outlives the call. Not being captured means, more or less, that; // the pointer is only dereferenced and not stored in a global. Returning part; // of the pointer as the function return value may or may not count as capturing; // the pointer, depending on the context.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:189,Performance,cache,cached,189,"/// The default value for MaxUsesToExplore argument. It's relatively small to; /// keep the cost of analysis reasonable for clients like BasicAliasAnalysis,; /// where the results can't be cached.; /// TODO: we should probably introduce a caching CaptureTracking analysis and; /// use it where possible. The caching version can use much higher limit or; /// don't have this cap at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:281,Safety,safe,safe,281,"// We want comparisons to null pointers to not be considered capturing,; // but need to guard against cases like gep(p, -ptrtoint(p2)) == null,; // which are equivalent to p == p2 and would capture the pointer.; //; // A dereferenceable pointer is a case where this is known to be safe,; // because the pointer resulting from such a construction would not be; // dereferenceable.; //; // It is not sufficient to check for inbounds GEP here, because GEP with; // zero offset is always inbounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:64,Safety,avoid,avoid,64,// Check isSafeToPrune() here rather than in shouldExplore() to avoid; // an expensive reachability query for every instruction we look at.; // Instead we only do one for actual capturing candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:143,Integrability,rout,routine,143,"/// PointerMayBeCaptured - Return true if this pointer value may be captured; /// by the enclosing function (which is required to exist). This routine can; /// be expensive, so consider caching the results. The boolean ReturnCaptures; /// specifies whether returning the value (or part of it) from the function; /// counts as capturing it or not. The boolean StoreCaptures specified whether; /// storing the value (or part of it) into memory anywhere automatically; /// counts as capturing it or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:182,Deployability,update,updated,182,"// TODO: If StoreCaptures is not true, we could do Fancy analysis; // to determine whether this store is not actually an escape point.; // In that case, BasicAliasAnalysis should be updated as well to; // take advantage of this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:263,Integrability,rout,routine,263,"/// PointerMayBeCapturedBefore - Return true if this pointer value may be; /// captured by the enclosing function (which is required to exist). If a; /// DominatorTree is provided, only captures which happen before the given; /// instruction are considered. This routine can be expensive, so consider; /// caching the results. The boolean ReturnCaptures specifies whether; /// returning the value (or part of it) from the function counts as capturing; /// it or not. The boolean StoreCaptures specified whether storing the value; /// (or part of it) into memory anywhere automatically counts as capturing it; /// or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:184,Integrability,depend,depending,184,"// Not captured if the callee is readonly, doesn't return a copy through; // its return value and doesn't unwind (a readonly function can leak bits; // by throwing an exception or not depending on the input value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:77,Performance,load,load,77,// Volatile operations effectively capture the memory location that they; // load and store to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:221,Performance,load,loading,221,"// Calling a function pointer does not in itself cause the pointer to; // be captured. This is a subtle point considering that (for example); // the callee might return its own address. It is analogous to saying; // that loading a value from a pointer does not cause the pointer to be; // captured, even though the loaded value might be the pointer itself; // (think of self-referential objects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:315,Performance,load,loaded,315,"// Calling a function pointer does not in itself cause the pointer to; // be captured. This is a subtle point considering that (for example); // the callee might return its own address. It is analogous to saying; // that loading a value from a pointer does not cause the pointer to be; // captured, even though the loaded value might be the pointer itself; // (think of self-referential objects).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:12,Performance,load,loads,12,// Volatile loads make the address observable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:42,Performance,load,load,42,"// atomicrmw conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:125,Security,access,accessed,125,"// atomicrmw conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:40,Performance,load,load,40,"// cmpxchg conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:123,Security,access,accessed,123,"// cmpxchg conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:83,Safety,avoid,avoid,83,"// If there are lots of uses, conservatively say that the value; // is captured to avoid taking too much compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:9,Performance,cache,cached,9,"// Found cached result, return it!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:110,Performance,load,load,110,"// Set StoreCaptures to True so that we can assume in our callers that the; // pointer is not the result of a load instruction. Currently; // PointerMayBeCaptured doesn't have any special analysis for the; // StoreCaptures=false case; if it did, our callers could be refined to be; // more precise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:408,Performance,perform,performs,408,"//===-- CFG.cpp - BasicBlock analysis --------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:6,Availability,down,down,6,// Go down one level if there is a unvisited successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:173,Availability,error,error,173,/// GetSuccessorNumber - Search for the specified successor of basic block BB; /// and return its position in the terminator instruction's list of; /// successors. It is an error to call this with a block that is not a; /// successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:125,Usability,simpl,simply,125,"// If we're in a loop with a hole, not all blocks in the loop are; // reachable from all other blocks. That implies we can't simply jump to; // the loop's exit blocks, as that exit might need to pass through an; // excluded block. Clear Outer so we process BB's successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:231,Usability,Clear,Clear,231,"// If we're in a loop with a hole, not all blocks in the loop are; // reachable from all other blocks. That implies we can't simply jump to; // the loop's exit blocks, as that exit might need to pass through an; // excluded block. Clear Outer so we process BB's successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp:215,Integrability,depend,depends,215,"/// viewCFG - This function is meant for use from the debugger. You can just; /// say 'call F->viewCFG()' and a ghostview window should pop up from the; /// program, displaying the CFG of the current function. This depends on there; /// being a 'dot' and 'gv' program in your path.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:80,Deployability,update,updates,80,/// Explicitly specialize the pass manager run method to handle call graph; /// updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:99,Deployability,update,update,99,"// The SCC may be refined while we are running passes over it, so set up; // a pointer that we can update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the SCC if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:11,Deployability,update,updated,11,"// If C is updated, also create a proxy and update FAM inside the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:44,Deployability,update,update,44,"// If C is updated, also create a proxy and update FAM inside the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager as each pass runs and potentially; // invalidates analyses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:292,Deployability,update,update,292,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:362,Performance,cache,cache,362,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:317,Usability,simpl,simplified,317,"// The postorder_ref_sccs range we are walking is lazily constructed, so; // we only push the first one onto the worklist. The worklist allows us; // to capture *new* RefSCCs created during transformations.; //; // We really want to form RefSCCs lazily because that makes them cheaper; // to update as the program is simplified and allows us to have greater; // cache locality as forming a RefSCC touches all the parts of all the; // functions within that RefSCC.; //; // We also eagerly increment the iterator to the next position because; // the CGSCC passes below may delete the current RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:170,Availability,redundant,redundant,170,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:154,Deployability,update,update,154,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:220,Deployability,update,updated,220,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:164,Safety,avoid,avoid,164,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:170,Safety,redund,redundant,170,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:167,Performance,queue,queued,167,"// Due to call graph mutations, we may have invalid SCCs or SCCs from; // other RefSCCs in the worklist. The invalid ones are dead and the; // other RefSCCs should be queued above, so we just need to skip both; // scenarios here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:662,Deployability,update,updates,662,"// We used to also check if the current SCC is part of the current; // RefSCC and bail if it wasn't, since it should be in RCWorklist.; // However, this can cause compile time explosions in some cases on; // modules with a huge RefSCC. If a non-trivial amount of SCCs in the; // huge RefSCC can become their own child RefSCC, we create one child; // RefSCC, bail on the current RefSCC, visit the child RefSCC, revisit; // the huge RefSCC, and repeat. By visiting all SCCs in the original; // RefSCC we create all the child RefSCCs in one pass of the RefSCC,; // rather one pass of the RefSCC creating one child RefSCC at a time.; // Ensure we can proxy analysis updates from the CGSCC analysis manager; // into the Function analysis manager by getting a proxy here.; // This also needs to update the FunctionAnalysisManager, as this may be; // the first time we see this SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:789,Deployability,update,update,789,"// We used to also check if the current SCC is part of the current; // RefSCC and bail if it wasn't, since it should be in RCWorklist.; // However, this can cause compile time explosions in some cases on; // modules with a huge RefSCC. If a non-trivial amount of SCCs in the; // huge RefSCC can become their own child RefSCC, we create one child; // RefSCC, bail on the current RefSCC, visit the child RefSCC, revisit; // the huge RefSCC, and repeat. By visiting all SCCs in the original; // RefSCC we create all the child RefSCCs in one pass of the RefSCC,; // rather one pass of the RefSCC creating one child RefSCC at a time.; // Ensure we can proxy analysis updates from the CGSCC analysis manager; // into the Function analysis manager by getting a proxy here.; // This also needs to update the FunctionAnalysisManager, as this may be; // the first time we see this SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:832,Availability,robust,robustness,832,"// Each time we visit a new SCC pulled off the worklist,; // a transformation of a child SCC may have also modified this parent; // and invalidated analyses. So we invalidate using the update record's; // cross-SCC preserved set. This preserved set is intersected by any; // CGSCC pass that handles invalidation (primarily pass managers) prior; // to marking its SCC as preserved. That lets us track everything that; // might need invalidation across SCCs without excessive invalidations; // on a single SCC.; //; // This essentially allows SCC passes to freely invalidate analyses; // of any ancestor SCC. If this becomes detrimental to successfully; // caching analyses, we could force each SCC pass to manually; // invalidate the analyses for any SCCs other than themselves which; // are mutated. However, that seems to lose the robustness of the; // pass-manager driven invalidation scheme.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:185,Deployability,update,update,185,"// Each time we visit a new SCC pulled off the worklist,; // a transformation of a child SCC may have also modified this parent; // and invalidated analyses. So we invalidate using the update record's; // cross-SCC preserved set. This preserved set is intersected by any; // CGSCC pass that handles invalidation (primarily pass managers) prior; // to marking its SCC as preserved. That lets us track everything that; // might need invalidation across SCCs without excessive invalidations; // on a single SCC.; //; // This essentially allows SCC passes to freely invalidate analyses; // of any ancestor SCC. If this becomes detrimental to successfully; // caching analyses, we could force each SCC pass to manually; // invalidate the analyses for any SCCs other than themselves which; // are mutated. However, that seems to lose the robustness of the; // pass-manager driven invalidation scheme.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the SCC and RefSCC if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:35,Deployability,update,update,35,"// If we're updating the SCC, also update the FAM inside the proxy's; // result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC,; // the current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC,; // the current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Deployability,update,update,33,// Check that we didn't miss any update scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:92,Deployability,update,updated,92,// We handle invalidating the CGSCC analysis manager's information; // for the (potentially updated) SCC here. Note that any other SCCs; // whose structure has changed should have been invalidated by; // whatever was updating the call graph. This SCC gets invalidated; // late as it contains the nodes that were actively being; // processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:312,Availability,avail,available,312,"// The pass may have restructured the call graph and refined the; // current SCC and/or RefSCC. We need to update our current SCC and; // RefSCC pointers to follow these. Also, when the current SCC is; // refined, re-run the SCC pass over the newly refined SCC in order; // to observe the most precise SCC model available. This inherently; // cannot cycle excessively as it only happens when we split SCCs; // apart, at most converging on a DAG of single nodes.; // FIXME: If we ever start having RefSCC passes, we'll want to; // iterate there too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:107,Deployability,update,update,107,"// The pass may have restructured the call graph and refined the; // current SCC and/or RefSCC. We need to update our current SCC and; // RefSCC pointers to follow these. Also, when the current SCC is; // refined, re-run the SCC pass over the newly refined SCC in order; // to observe the most precise SCC model available. This inherently; // cannot cycle excessively as it only happens when we split SCCs; // apart, at most converging on a DAG of single nodes.; // FIXME: If we ever start having RefSCC passes, we'll want to; // iterate there too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:79,Usability,clear,clear,79,"// We only need to keep internal inlined edge information within; // a RefSCC, clear it to save on space and let the next time we visit; // any of these functions have a fresh start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:99,Deployability,update,update,99,"// The SCC may be refined while we are running passes over it, so set up; // a pointer that we can update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:52,Deployability,update,updated,52,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:89,Usability,simpl,simply,89,"// If the CGSCC pass wasn't able to provide a valid updated SCC, the; // current SCC may simply need to be skipped if invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,// Update the analysis manager with each run and intersect the total set; // of preserved analyses so we're ready to iterate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:38,Performance,optimiz,optimizing,38,"// The SCC may get split while we are optimizing functions due to deleting; // edges. If this happens, the current SCC can shift, so keep track of; // a pointer we can overwrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:106,Integrability,contract,contract,106,"// We know that the function pass couldn't have invalidated any other; // function's analyses (that's the contract of a function pass), so; // directly handle the function analysis manager's invalidation here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:44,Deployability,update,update,44,"// If the call graph hasn't been preserved, update it based on this; // function pass. This may also update the current SCC to point to; // a smaller, more refined SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:101,Deployability,update,update,101,"// If the call graph hasn't been preserved, update it based on this; // function pass. This may also update the current SCC to point to; // a smaller, more refined SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:30,Deployability,update,updated,30,// We've also ensured that we updated the call graph along the way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:116,Usability,clear,clear,116,"// This is still a valid proxy.; // If this proxy or the call graph is going to be invalidated, we also need; // to clear all the keys coming from that analysis.; //; // We also directly invalidate the FAM's module proxy if necessary, and if; // that proxy isn't preserved we can't preserve this proxy either. We rely on; // it to handle module -> function analysis invalidation in the face of; // structural changes and so if it's unavailable we conservatively clear the; // entire SCC layer as well rather than trying to do invalidation ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:462,Usability,clear,clear,462,"// This is still a valid proxy.; // If this proxy or the call graph is going to be invalidated, we also need; // to clear all the keys coming from that analysis.; //; // We also directly invalidate the FAM's module proxy if necessary, and if; // that proxy isn't preserved we can't preserve this proxy either. We rely on; // it to handle module -> function analysis invalidation in the face of; // structural changes and so if it's unavailable we conservatively clear the; // entire SCC layer as well rather than trying to do invalidation ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:61,Availability,down,down,61,"// Ok, we have a graph, so we can propagate the invalidation down into it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:50,Availability,avail,available,50,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:82,Security,access,accessed,82,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:214,Testability,assert,assert,214,// Force the Function analysis manager to also be available so that it can; // be accessed in an SCC analysis and proxied onward to function passes.; // FIXME: It is pretty awkward to just drop the result here and assert that; // we can find it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:183,Testability,assert,assertion,183,"// Note: unconditionally getting checking that the proxy exists may get it at; // this point. There are cases when this is being run unnecessarily, but; // it is cheap and having the assertion in place is more valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:59,Deployability,update,updateFAM,59,// We just return an empty result. The caller will use the updateFAM interface; // to correctly register the relevant FunctionAnalysisManager based on the; // context in which this proxy is run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:69,Integrability,interface,interface,69,// We just return an empty result. The caller will use the updateFAM interface; // to correctly register the relevant FunctionAnalysisManager based on the; // context in which this proxy is run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:40,Deployability,update,updates,40,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:251,Deployability,update,updated,251,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:322,Performance,cache,cached,322,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:457,Performance,cache,cached,457,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:388,Usability,clear,cleared,388,"// This is still a valid proxy.; // All updates to preserve valid results are done below, so we don't need to; // invalidate this proxy.; //; // Note that in order to preserve this proxy, a module pass must ensure that; // the FAM has been completely updated to handle the deletion of functions.; // Specifically, any FAM-cached results for those functions need to have been; // forcibly cleared. When preserved, this proxy will only invalidate results; // cached on functions *still in the module* at the end of the module pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:76,Deployability,update,update,76,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:248,Deployability,update,updates,248,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:607,Integrability,depend,dependencies,607,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:632,Integrability,depend,dependencies,632,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:188,Performance,cache,cached,188,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:471,Performance,cache,cached,471,"// end namespace llvm; /// When a new SCC is created for the graph we first update the; /// FunctionAnalysisManager in the Proxy's result.; /// As there might be function analysis results cached for the functions now in; /// that SCC, two forms of updates are required.; ///; /// First, a proxy from the SCC to the FunctionAnalysisManager needs to be; /// created so that any subsequent invalidation events to the SCC are; /// propagated to the function analysis results cached for functions within it.; ///; /// Second, if any of the functions within the SCC have analysis results with; /// outer analysis dependencies, then those dependencies would point to the; /// *wrong* SCC's analysis result. We forcibly invalidate the necessary; /// function analyses so that they don't retain stale handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:109,Integrability,depend,dependencies,109,// Now walk the functions in this SCC and invalidate any function analysis; // results that might have outer dependencies on an SCC analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:48,Integrability,depend,dependencies,48,"// Forcibly abandon all the inner analyses with dependencies, but; // invalidate nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:23,Deployability,update,update,23,"/// Helper function to update both the \c CGSCCAnalysisManager \p AM and the \c; /// CGSCCPassManager's \c CGSCCUpdateResult \p UR based on a range of newly; /// added SCCs.; ///; /// The range of new SCCs must be in postorder already. The SCC they were split; /// out of must be provided as \p C. The current node being mutated and; /// triggering updates must be passed as \p N.; ///; /// This function returns the SCC containing \p N. This will be either \p C if; /// no new SCCs have been split out, or it will be the new SCC containing \p N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:349,Deployability,update,updates,349,"/// Helper function to update both the \c CGSCCAnalysisManager \p AM and the \c; /// CGSCCPassManager's \c CGSCCUpdateResult \p UR based on a range of newly; /// added SCCs.; ///; /// The range of new SCCs must be in postorder already. The SCC they were split; /// out of must be provided as \p C. The current node being mutated and; /// triggering updates must be passed as \p N.; ///; /// This function returns the SCC containing \p N. This will be either \p C if; /// no new SCCs have been split out, or it will be the new SCC containing \p N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:3,Deployability,Update,Update,3,"// Update the current SCC. Note that if we have new SCCs, this must actually; // change the SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:15,Performance,cache,cached,15,"// If we had a cached FAM proxy originally, we will want to create more of; // them for each SCC that was split off.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:216,Deployability,update,updater,216,// We need to propagate an invalidation call to all but the newly current SCC; // because the outer pass manager won't do that for us after splitting them.; // FIXME: We should accept a PreservedAnalysis from the CG updater so that if; // there are preserved analysis we can avoid invalidating them here for; // split-off SCCs.; // We know however that this will preserve any FAM proxy so go ahead and mark; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:275,Safety,avoid,avoid,275,// We need to propagate an invalidation call to all but the newly current SCC; // because the outer pass manager won't do that for us after splitting them.; // FIXME: We should accept a PreservedAnalysis from the CG updater so that if; // there are preserved analysis we can avoid invalidating them here for; // split-off SCCs.; // We know however that this will preserve any FAM proxy so go ahead and mark; // that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:54,Deployability,update,updated,54,// Ensure the now-current SCC's function analyses are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:42,Deployability,update,updated,42,// Ensure new SCCs' function analyses are updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:88,Deployability,update,updateCGAndAnalysisManagerForPass,88,// We can miss devirtualization if an indirect call is created then; // promoted before updateCGAndAnalysisManagerForPass runs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:7,Deployability,update,update,7,// Now update the call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:233,Deployability,Update,Update,233,"// Note that we don't bother to invalidate analyses as ref-edge; // connectivity is not really observable in any way and is intended; // exclusively to be used for ordering of transforms rather than for; // analysis conclusions.; // Update RC to the ""bottom"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:7,Deployability,update,update,7,// Now update the call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:126,Deployability,Update,UpdateResult,126,"// Otherwise we are switching an internal ref edge to a call edge. This; // may merge away some SCCs, and we add those to the UpdateResult. We also; // need to make sure to update the worklist in the event SCCs have moved; // before the current one in the post-order sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:173,Deployability,update,update,173,"// Otherwise we are switching an internal ref edge to a call edge. This; // may merge away some SCCs, and we add those to the UpdateResult. We also; // need to make sure to update the worklist in the event SCCs have moved; // before the current one in the post-order sequence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:57,Deployability,release,release,57,"// FIXME: We should really do a 'clear' here to forcibly release; // memory, but we don't have a good way of doing that and; // preserving the function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:33,Usability,clear,clear,33,"// FIXME: We should really do a 'clear' here to forcibly release; // memory, but we don't have a good way of doing that and; // preserving the function analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:58,Deployability,update,update,58,"// If we formed a cycle by creating this call, we need to update more data; // structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:40,Performance,cache,cached,40,"// If one of the invalidated SCCs had a cached proxy to a function; // analysis manager, we need to create a proxy in the new current SCC as; // the invalidated SCCs had their functions moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:149,Deployability,update,update,149,"// Any analyses cached for this SCC are no longer precise as the shape; // has changed by introducing this cycle. However, we have taken care to; // update the proxies so it remains valide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:16,Performance,cache,cached,16,"// Any analyses cached for this SCC are no longer precise as the shape; // has changed by introducing this cycle. However, we have taken care to; // update the proxies so it remains valide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:220,Performance,optimiz,optimize,220,"// Put our current SCC back onto the worklist as we'll visit other SCCs; // that are now definitively ordered prior to the current one in the; // post-order sequence, and may end up observing more precise context to; // optimize the current SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:91,Deployability,update,updates,91,// Record the current SCC for higher layers of the CGSCC pass manager now that; // all the updates have been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:37,Modifiability,layers,layers,37,// Record the current SCC for higher layers of the CGSCC pass manager now that; // all the updates have been applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp:396,Integrability,rout,routines,396,"//===- CmpInstAnalysis.cpp - Utils to help fold compares ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse compare instructions; // and fold them into constants or other compare instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CmpInstAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:81,Availability,alive,alive,81,"// Note: We don't speculate PHIs here, so we'll miss instruction chains kept; // alive only by ephemeral values.; // Walk the worklist using an index but without caching the size so we can; // append more entries as we process the worklist. This forms a queue without; // quadratic behavior by just leaving processed nodes at the head of the; // worklist forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:254,Performance,queue,queue,254,"// Note: We don't speculate PHIs here, so we'll miss instruction chains kept; // alive only by ephemeral values.; // Walk the worklist using an index but without caching the size so we can; // append more entries as we process the worklist. This forms a queue without; // quadratic behavior by just leaving processed nodes at the head of the; // worklist forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:138,Security,expose,exposed,138,"// If a function is both internal and has a single use, then it is; // extremely likely to get inlined in the future (it was probably; // exposed by an interleaved devirtualization pass).; // When preparing for LTO, liberally consider calls as inline; // candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:406,Safety,safe,safely,406,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this indirect; // jump would jump from the inlined copy of the function into the original; // function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions; // with indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function. And as a QOI issue,; // if someone is using a blockaddress without an indirectbr, and that; // reference somehow ends up in another function or global, we probably; // don't want to inline this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:373,Testability,log,logic,373,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this indirect; // jump would jump from the inlined copy of the function into the original; // function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions; // with indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function. And as a QOI issue,; // if someone is using a blockaddress without an indirectbr, and that; // reference somehow ends up in another function or global, we probably; // don't want to inline this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:401,Integrability,rout,routines,401,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:568,Integrability,rout,routines,568,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:677,Integrability,depend,dependency,677,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:505,Usability,simpl,simplifications,505,"//===-- ConstantFolding.cpp - Fold instructions into constants ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines routines for folding instructions into constants.; //; // Also, to supplement the basic IR ConstantExpr simplifications,; // this file defines some additional folding routines that can make use of; // DataLayout information. These functions cannot go in IR due to library; // dependency issues.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:83,Usability,simpl,simplify,83,"// If the vector is a vector of floating point, convert it to vector of int; // to simplify things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:172,Integrability,depend,depends,172,"// Now we know that the input and output vectors are both integer vectors; // of the same size, and that their #elements is not the same. Do the; // conversion here, which depends on whether the input or output has; // more elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:8,Modifiability,extend,extend,8,// Zero extend the element to the right size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:32,Integrability,depend,depending,32,"// Shift it to the right place, depending on endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:54,Integrability,depend,depending,54,"// Shift the piece of the value into the right place, depending on; // endianness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:72,Availability,down,down,72,"// If this isn't an aggregate type, there is nothing we can do to drill down; // and find a bitcastable constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:118,Availability,down,down,118,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:22,Performance,load,load,22,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:243,Performance,load,load,243,"// We're simulating a load through a pointer that was bitcast to point to; // a different type, so we can try to walk down through the initial; // elements of an aggregate to see if some part of the aggregate is; // castable to implement the ""load"" semantic model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:18,Security,access,access,18,"// If the element access is to the element itself and not to tail padding,; // read the bytes from the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:59,Modifiability,variab,variable,59,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:33,Performance,load,load,33,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:43,Performance,scalab,scalable,43,// Bail out early. Not expect to load from scalable global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:28,Performance,load,load,28,// If this isn't an integer load we can't fold it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:28,Performance,load,load,28,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:66,Performance,load,load,66,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:240,Performance,load,load,240,"// If this is a non-integer load, we can try folding it as an int load and; // then bitcast the result. This can be useful for union cases. Note; // that address spaces don't matter here since we're not going to result in; // an actual new load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:31,Performance,load,load,31,// Be careful not to replace a load of an addrspace value with an inttoptr here,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:16,Security,access,accessing,16,"// If we're not accessing anything in this constant, the result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:38,Performance,scalab,scalable,38,// TODO: We should be able to support scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:16,Security,access,accessing,16,"// If we're not accessing anything in this constant, the result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:12,Performance,load,loading,12,"// If we're loading off the beginning of the global, some bytes may be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:51,Safety,avoid,avoid,51,// Bail for large initializers in excess of 64K to avoid allocating; // too much memory.; // Offset is assumed to be less than or equal than InitSize (this; // is enforced in ReadDataFromGlobal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:38,Security,access,access,38,"// Explicitly check for out-of-bounds access, so we return poison even if the; // constant is a uniform value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:20,Performance,load,loads,20,// Try hard to fold loads from bitcasted strange and non-type-safe things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:62,Safety,safe,safe,62,// Try hard to fold loads from bitcasted strange and non-type-safe things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:20,Performance,load,loads,20,"// We can only fold loads from constant globals with a definitive initializer.; // Check this upfront, to skip expensive offset calculations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:11,Performance,load,load,11,"// If this load comes from anywhere in a uniform constant global, the value; // is always the same, regardless of the loaded offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:118,Performance,load,loaded,118,"// If this load comes from anywhere in a uniform constant global, the value; // is always the same, regardless of the loaded offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:167,Availability,avail,available,167,"/// One of Op0/Op1 is a constant expression.; /// Attempt to symbolically evaluate the result of a binary operator merging; /// these together. If target data info is available, it is provided as DL,; /// otherwise DL is null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:47,Availability,mask,masking,47,// All the bits of Op0 that the 'and' could be masking are already zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:47,Availability,mask,masking,47,// All the bits of Op1 that the 'and' could be masking are already zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:104,Safety,avoid,avoid,104,// Try to add additional zero indices to reach the desired result element; // type.; // TODO: Should we avoid extra zero indices if ResElemTy can't be reached and; // we'll have to insert a bitcast anyway?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:248,Performance,load,loads,248,"/// Attempt to constant fold an instruction with the; /// specified opcode and operands. If successful, the constant result is; /// returned, if not, null is returned. Note that this function can fail when; /// attempting to fold instructions like loads and stores, which have no; /// constant expression form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:26,Performance,perform,perform,26,"// If we have GEP, we can perform the following folds:; // (ptrtoint (gep null, x)) -> x; // (ptrtoint (gep (gep null, x), y) -> x + y, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:68,Integrability,depend,depend,68,// Operations that do not operate floating-point numbers and do not depend on; // FP environment can be folded even in strictfp functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:24,Integrability,depend,depend,24,// The intrinsics below depend on rounding mode in MXCSR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:4,Usability,Clear,Clear,4,/// Clear the floating-point exception state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:4,Testability,Test,Test,4,/// Test if a floating-point exception was raised.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:368,Availability,avail,available,368,"/// Attempt to fold an SSE floating point to integer conversion of a constant; /// floating point. If roundTowardZero is false, the default IEEE rounding is; /// used (toward nearest, ties to even). This matches the behavior of the; /// non-truncating SSE instructions in the default rounding mode. The desired; /// integer type Ty is used to select how many bits are available for the; /// result. Returns null if the conversion cannot be performed, otherwise; /// returns the Constant value resulting from the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:440,Performance,perform,performed,440,"/// Attempt to fold an SSE floating point to integer conversion of a constant; /// floating point. If roundTowardZero is false, the default IEEE rounding is; /// used (toward nearest, ties to even). This matches the behavior of the; /// non-truncating SSE instructions in the default rounding mode. The desired; /// integer type Ty is used to select how many bits are available for the; /// result. Returns null if the conversion cannot be performed, otherwise; /// returns the Constant value resulting from the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:66,Safety,safe,safe,66,"// If the operation does not change exception status flags, it is safe; // to fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:53,Integrability,depend,depend,53,"// If evaluation raised FP exception, the result can depend on rounding; // mode. If the latter is unknown, folding is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:181,Integrability,depend,depend,181,"// Even if the rounding mode is unknown, try evaluating the operation.; // If it does not raise inexact exception, rounding was not applied,; // so the result is exact and does not depend on rounding mode. Whether; // other FP exceptions are raised, it does not depend on rounding mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:262,Integrability,depend,depend,262,"// Even if the rounding mode is unknown, try evaluating the operation.; // If it does not raise inexact exception, rounding was not applied,; // so the result is exact and does not depend on rounding mode. Whether; // other FP exceptions are raised, it does not depend on rounding mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:117,Integrability,depend,depend,117,"// We know we have a ""Constant"" argument. But we want to only; // return true for manifest constants, not those that depend on; // constants with unknowable values, e.g. GlobalValue or BlockAddress.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:127,Availability,avail,available,127,"// If instruction is not yet put in a basic block (e.g. when cloning; // a function during inlining), Call's caller may not be available.; // So check Call's BB first before querying Call->getCaller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:161,Availability,error,errors,161,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:91,Safety,abort,aborted,91,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:60,Usability,clear,clear,60,// Undef operand with no poison min --> 0 (sign bit must be clear),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:13,Performance,perform,performs,13,"// This code performs rounding towards negative infinity in case the result; // cannot be represented exactly for the given scale. Targets that do care; // about rounding should use a target hook for specifying how rounding; // should be done, and provide their own folding to be consistent with; // rounding. This is the same approach as used by; // DAGTypeLegalizer::ExpandIntRes_MULFIX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:101,Safety,avoid,avoid,101,"// The shift amount is interpreted as modulo the bitwidth. If the shift; // amount is effectively 0, avoid UB due to oversized inverse shift below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:37,Usability,simpl,simplify,37,// Use the regular scalar folding to simplify this column.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:70,Safety,avoid,avoid,70,"// The exponent is an ""unspecified value"" for inf/nan. We use zero to avoid; // using undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:10,Modifiability,Refactor,Refactor,10,// FIXME: Refactor this code; this duplicates logic in LibCallsShrinkWrap; // (and to some extent ConstantFoldScalarCall).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:46,Testability,log,logic,46,// FIXME: Refactor this code; this duplicates logic in LibCallsShrinkWrap; // (and to some extent ConstantFoldScalarCall).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:115,Availability,error,error,115,"// Although IEEE-754 says atan2(+/-0.0, +/-0.0) are well-defined, and; // GLIBC and MSVC do not appear to raise an error on those, we; // cannot rely on that behavior. POSIX and C11 say that a domain error; // may occur, so allow for that possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:200,Availability,error,error,200,"// Although IEEE-754 says atan2(+/-0.0, +/-0.0) are well-defined, and; // GLIBC and MSVC do not appear to raise an error on those, we; // cannot rely on that behavior. POSIX and C11 say that a domain error; // may occur, so allow for that possibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:177,Integrability,depend,dependence,177,"// Implementation of Fourier–Motzkin elimination, with some tricks from the; // paper Pugh, William. ""The Omega test: a fast and practical integer; // programming algorithm for dependence; // analysis.""; // Supercomputing'91: Proceedings of the 1991 ACM/; // IEEE conference on Supercomputing. IEEE, 1991.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:112,Testability,test,test,112,"// Implementation of Fourier–Motzkin elimination, with some tricks from the; // paper Pugh, William. ""The Omega test: a fast and practical integer; // programming algorithm for dependence; // analysis.""; // Supercomputing'91: Proceedings of the 1991 ACM/; // IEEE conference on Supercomputing. IEEE, 1991.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:28,Modifiability,variab,variable,28,"// First, either remove the variable in place if it is 0 or add the row to; // RemainingRows and remove it from the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:26,Modifiability,variab,variable,26,// Process rows where the variable is != 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:3,Testability,assert,assert,3,"// assert(!Parts.empty() && ""need to have at least some parts"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp:10,Modifiability,variab,variable,10,"// If all variable coefficients are 0, we have 'C >= 0'. If the constant is >=; // 0, R is always true, regardless of the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstraintSystem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:693,Performance,throughput,throughput,693,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:737,Performance,load,loads,737,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:751,Performance,cache,cache,751,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:779,Safety,predict,predicted,779,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp:245,Integrability,wrap,wrapper,245,//===----------------------------------------------------------------------===//; // CycleInfoWrapperPass Implementation; //===----------------------------------------------------------------------===//; //; // The implementation details of the wrapper pass that holds a CycleInfo; // suitable for use with the legacy pass manager.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CycleAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:22,Integrability,Depend,Dependence,22,"//===- DDG.cpp - Data Dependence Graph -------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the data dependence graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:415,Integrability,depend,dependence,415,"//===- DDG.cpp - Data Dependence Graph -------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The implementation for the data dependence graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:83,Usability,Simpl,SimpleDDGNode,83,//===--------------------------------------------------------------------===//; // SimpleDDGNode implementation; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:53,Integrability,depend,dependence,53,// Put the basic blocks in program order for correct dependence; // directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:53,Integrability,depend,dependence,53,// Put the basic blocks in program order for correct dependence; // directions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:73,Safety,safe,safe,73,"// In general, if the root node is already created and linked, it is not safe; // to add new nodes since they may be unreachable by the root. However,; // pi-block nodes need to be added after the root node is linked, and they are; // always reachable by the root, because they represent components that are; // already reachable by root.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:3,Safety,Avoid,Avoid,3,// Avoid printing nodes that are part of a pi-block twice. They will get; // printed when the pi-block is printed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:41,Usability,simpl,simple,41,// Only merge two nodes if they are both simple nodes and the consecutive; // instructions after merging belong to the same BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp:49,Integrability,depend,dependence,49,"//===- DDGPrinter.cpp - DOT printer for the data dependence graph ----------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; //; // This file defines the `-dot-ddg` analysis pass, which emits DDG in DOT format; // in a file named `ddg.<graph-name>.dot` for each loop in a function.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDGPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:550,Testability,test,testing,550,"//===---- Delinearization.cpp - MultiDimensional Index Delinearization ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements an analysis pass that tries to delinearize all GEP; // instructions in all loops using the SCEV analysis functionality. This pass is; // only used for testing purposes: if your pass needs delinearization, please; // use the on-demand SCEVAddRecExpr::delinearize() function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:409,Modifiability,variab,variable,409,"// Find factors that are multiplied with an expression that (possibly as a; // subexpression) contains an AddRecExpr. In the expression:; //; // 8 * (100 + %p * %q * (%a + {0, +, 1}_loop)); //; // ""%p * %q"" are factors multiplied by the expression ""(%a + {0, +, 1}_loop)""; // that contains the AddRec {0, +, 1}_loop. %p * %q are likely to be array size; // parameters as they form a product with an induction variable.; //; // This collector expects all array size parameters to be in the same MulExpr.; // It might be necessary to later add support for collecting parameters that are; // spread over different nested MulExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:14,Security,access,access,14,// Record the access function for the current subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:85,Security,access,access,85,// Also push in last position the remainder of the last division: it will be; // the access function of the innermost dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1629,Energy Efficiency,allocate,allocated,1629,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2129,Performance,load,loads,2129,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:101,Security,access,access,101,"/// Splits the SCEV into two vectors of SCEVs representing the subscripts and; /// sizes of an array access. Returns the remainder of the delinearization that; /// is the offset start of the array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:572,Security,access,access,572,"/// Splits the SCEV into two vectors of SCEVs representing the subscripts and; /// sizes of an array access. Returns the remainder of the delinearization that; /// is the offset start of the array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1030,Security,access,access,1030," array. The SCEV->delinearize algorithm computes; /// the multiples of SCEV coefficients: that is a pattern matching of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1830,Security,access,access,1830,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2199,Security,access,access,2199,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:1926,Testability,test,testcase,1926,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:2027,Testability,test,testcases,2027,"of sub; /// expressions in the stride and base of a SCEV corresponding to the; /// computation of a GCD (greatest common divisor) of base and stride. When; /// SCEV->delinearize fails, it returns the SCEV unchanged.; ///; /// For example: when analyzing the memory access A[i][j][k] in this loop nest; ///; /// void foo(long n, long m, long o, double A[n][m][o]) {; ///; /// for (long i = 0; i < n; i++); /// for (long j = 0; j < m; j++); /// for (long k = 0; k < o; k++); /// A[i][j][k] = 1.0;; /// }; ///; /// the delinearization input is the following AddRec SCEV:; ///; /// AddRec: {{{%A,+,(8 * %m * %o)}<%for.i>,+,(8 * %o)}<%for.j>,+,8}<%for.k>; ///; /// From this SCEV, we are able to say that the base offset of the access is %A; /// because it appears as an offset that does not divide any of the strides in; /// the loops:; ///; /// CHECK: Base offset: %A; ///; /// and then SCEV->delinearize determines the size of some of the dimensions of; /// the array as these are the multiples by which the strides are happening:; ///; /// CHECK: ArrayDecl[UnknownSize][%m][%o] with elements of sizeof(double); /// bytes.; ///; /// Note that the outermost dimension remains of UnknownSize because there are; /// no strides that would help identifying the size of the last dimension: when; /// the array has been statically allocated, one could compute the size of that; /// dimension by dividing the overall size of the array by the size of the known; /// dimensions: %m * %o * 8.; ///; /// Finally delinearize provides the access functions for the array reference; /// that does correspond to A[i][j][k] of the above C testcase:; ///; /// CHECK: ArrayRef[{0,+,1}<%for.i>][{0,+,1}<%for.j>][{0,+,1}<%for.k>]; ///; /// The testcases are checking the output of a function pass:; /// DelinearizationPass that walks through all loads and stores of a function; /// asking for the SCEV of the memory access with respect to all enclosing; /// loops, calling SCEV->delinearize on that and printing the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:27,Security,access,access,27,// Third step: compute the access functions for each subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:13,Usability,simpl,simple,13,// Check the simple case where the array dimensions are fixed size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:133,Usability,clear,clear,133,"// Check that the two size arrays are non-empty and equal in length and; // value.; // TODO: it would be better to let the caller to clear Subscripts, similar; // to how we handle Sizes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:16,Performance,load,loads,16,// Only analyze loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:26,Security,access,access,26,// Delinearize the memory access as analyzed in all the surrounding loops.; // Do not analyze memory accesses outside loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:101,Security,access,accesses,101,// Delinearize the memory access as analyzed in all the surrounding loops.; // Do not analyze memory accesses outside loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:264,Performance,cache,cache,264,"// We're called once per operand, but for some instructions, we need to; // compute known bits of both operands in order to determine the live bits of; // either (when both operands are instructions themselves). We don't,; // however, want to do this twice, so we cache the result in APInts that live; // in the caller. For the two-relevant-operands case, both operand values are; // provided here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,Availability,alive,alive,7,// The alive bits of the input are the swapped alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:47,Availability,alive,alive,47,// The alive bits of the input are the swapped alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:7,Availability,alive,alive,7,// The alive bits of the input are the reversed alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:48,Availability,alive,alive,48,// The alive bits of the input are the reversed alive bits of; // the output.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:44,Energy Efficiency,power,powers,44,// Shift amount is modulo the bitwidth. For powers of two we have; // SA % BW == SA & (BW - 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:67,Availability,alive,alive,67,"// For integer-valued instructions, set up an initial empty set of alive; // bits and add the instruction to the work list. For other instructions; // add their operands to the work list (for integer values operands, mark; // all bits as live).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:22,Availability,alive,alive,22,"// Compute the set of alive bits for each operand. These are anded into the; // existing set, if any, and if that changes the set of alive bits, the; // operand is added to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:133,Availability,alive,alive,133,"// Compute the set of alive bits for each operand. These are anded into the; // existing set, if any, and if that changes the set of alive bits, the; // operand is added to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:19,Safety,detect,detect,19,"// We also want to detect dead uses of arguments, but will only store; // demanded bits for instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:49,Availability,alive,alive,49,"// Bits of each operand that are used to compute alive bits of the; // output are alive, all others are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:82,Availability,alive,alive,82,"// Bits of each operand that are used to compute alive bits of the; // output are alive, all others are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:32,Availability,alive,alive,32,"// If we've added to the set of alive bits (or the operand has not; // been previously visited), then re-queue the operand to be visited; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:105,Performance,queue,queue,105,"// If we've added to the set of alive bits (or the operand has not; // been previously visited), then re-queue the operand to be visited; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:58,Availability,mask,mask,58,"// We only track integer uses, everything else produces a mask with all bits; // set",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:14,Availability,alive,alive,14,"// First, the alive carry bits are determined from the alive output bits:; // Let demand ripple to the right but only up to any set bit in Bound.; // AOut = -1----; // Bound = ----1-; // ACarry&~AOut = --111-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:55,Availability,alive,alive,55,"// First, the alive carry bits are determined from the alive output bits:; // Let demand ripple to the right but only up to any set bit in Bound.; // AOut = -1----; // Bound = ----1-; // ACarry&~AOut = --111-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:13,Availability,alive,alive,13,"// Then, the alive input bits are determined from the alive carry bits:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:54,Availability,alive,alive,54,"// Then, the alive input bits are determined from the alive carry bits:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:16,Usability,simpl,simplified,16,// The below is simplified from; //; // APInt CarryKnownZero = ~(PossibleSumZero ^ LHS.Zero ^ RHS.Zero);; // APInt CarryKnownOne = PossibleSumOne ^ LHS.One ^ RHS.One;; // APInt CarryUnknown = ~(CarryKnownZero | CarryKnownOne);; //; // APInt NeededToMaintainCarry =; // (CarryKnownZero & NeededToMaintainCarryZero) |; // (CarryKnownOne & NeededToMaintainCarryOne) |; // CarryUnknown;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1219,Availability,recover,recover,1219,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Integrability,Depend,DependenceAnalysis,8,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:383,Integrability,Depend,DependenceAnalysis,383,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependences,432,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,Depend,Dependence,572,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:685,Integrability,depend,dependence,685,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:781,Integrability,depend,dependence,781,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:843,Integrability,depend,dependence,843,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1165,Integrability,depend,dependence,1165,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:2039,Integrability,interface,interface,2039,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1219,Safety,recover,recover,1219,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1283,Safety,avoid,avoid,1283,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:463,Security,access,accesses,463,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1821,Security,expose,expose,1821,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:583,Testability,Test,Testing,583,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1003,Testability,test,test,1003,"//===-- DependenceAnalysis.cpp - DA Implementation --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1329,Testability,test,tests,1329,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1528,Testability,test,tests,1528,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1686,Testability,test,test,1686,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1714,Testability,test,tests,1714,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1810,Testability,test,test,1810,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1855,Usability,simpl,simplification,1855,"--------------------------------------------------------------------===//; //; // DependenceAnalysis is an LLVM pass that analyses dependences between memory; // accesses. Currently, it is an (incomplete) implementation of the approach; // described in; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // There's a single entry point that analyzes the dependence between a pair; // of memory references in a function, returning either NULL, for no dependence,; // or a more-or-less detailed description of the dependence between them.; //; // Currently, the implementation cannot propagate constraints between; // coupled RDIV subscripts and lacks a multi-subscript MIV test.; // Both of these are conservative weaknesses;; // that is, not a source of correctness problems.; //; // Since Clang linearizes some array subscripts, the dependence; // analysis is using SCEV->delinearize to recover the representation of multiple; // subscripts, and thus avoid the more expensive and less precise MIV tests. The; // delinearization is controlled by the flag -da-delinearize.; //; // We should pay some careful attention to the possibility of integer overflow; // in the implementation of the various tests. This could happen with Add,; // Subtract, or Multiply, with both APInt's and SCEV's.; //; // Some non-linear subscript pairs can be handled by the GCD test; // (and perhaps other tests).; // Should explore how often these things occur.; //; // Finally, it seems like certain test cases expose weaknesses in the SCEV; // simplification, especially in the handling of sign and zero extensions.; // It could be useful to spend time exploring these.; //; // Please note that this is work in progress and the interface is subject to; // change.; //; //===----------------------------------------------------------------------===//; // //; // In memory of Ken Kennedy, 1945 - 2007 //; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Integrability,depend,dependence,20,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:127,Integrability,depend,depends,127,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:102,Security,access,access,102,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:11,Testability,test,test,11,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,Dependence,85,//===----------------------------------------------------------------------===//; // Dependence methods; // Returns true if this is an input dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:141,Integrability,depend,dependence,141,//===----------------------------------------------------------------------===//; // Dependence methods; // Returns true if this is an input dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:37,Integrability,depend,dependence,37,// Returns true if this is an output dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,Integrability,depend,dependence,46,// Returns true if this is an flow (aka true) dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:35,Integrability,depend,dependence,35,// Returns true if this is an anti dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:133,Modifiability,variab,variable,133,"// Returns true if a particular level is scalar; that is,; // if no subscript in the source or destination mention the induction; // variable associated with the loop at this level.; // Leave this out of line, so it will serve as a virtual method anchor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:200,Integrability,depend,dependency,200,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:356,Integrability,depend,dependence,356,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:447,Integrability,depend,dependence,447,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:579,Integrability,depend,dependency,579,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:625,Integrability,depend,dependency,625,"// FIXME: in some cases the meaning of a negative direction vector; // may not be straightforward, e.g.,; // for (int i = 0; i < 32; ++i) {; // Src: A[i] = ...;; // Dst: use(A[31 - i]);; // }; // The dependency is; // flow { Src[i] -> Dst[31 - i] : when i >= 16 } and; // anti { Dst[i] -> Src[31 - i] : when i < 16 },; // -- hence a [<>].; // As long as a dependence result contains '>' ('<>', '<=>', ""*""), it; // means that a reversed/normalized dependence needs to be considered; // as well. Nevertheless, current isDirectionNegative() only returns; // true with a '>' or '>=' dependency for ease of canonicalizing the; // dependency vector, since the reverse of '<>', '<=>' and ""*"" is itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:15,Integrability,depend,dependence,15,// Reverse the dependence distance as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:16,Usability,simpl,simple,16,// The rest are simple getters that hide the implementation.; // getDirection - Returns the direction associated with a particular level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:133,Modifiability,variab,variable,133,"// Returns true if a particular level is scalar; that is,; // if no subscript in the source or destination mention the induction; // variable associated with the loop at this level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:82,Integrability,depend,dependence,82,// Returns true if peeling the first iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:81,Integrability,depend,dependence,81,// Returns true if peeling the last iteration from this loop; // will break this dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,depend,dependence,54,// Returns true if splitting this loop will break the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,DependenceInfo,85,"//===----------------------------------------------------------------------===//; // DependenceInfo::Constraint methods; // If constraint is a point <X, Y>, returns X.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:182,Testability,assert,assert,182,"//===----------------------------------------------------------------------===//; // DependenceInfo::Constraint methods; // If constraint is a point <X, Y>, returns X.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:61,Testability,assert,assert,61,"// If constraint is a point <X, Y>, returns Y.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns A.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns B.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,assert,assert,65,"// If constraint is a line AX + BY = C, returns C.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Testability,assert,assert,57,"// If constraint is a distance, returns D.; // Otherwise assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,Update,Updates,3,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:159,Integrability,Depend,Dependence,159,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:170,Testability,Test,Testing,170,"// Updates X with the intersection; // of the Constraints X and Y. Returns true if X has changed.; // Corresponds to Figure 4 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:85,Integrability,Depend,DependenceInfo,85,//===----------------------------------------------------------------------===//; // DependenceInfo methods; // For debugging purposes. Dumps a dependence to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:144,Integrability,depend,dependence,144,//===----------------------------------------------------------------------===//; // DependenceInfo methods; // For debugging purposes. Dumps a dependence to OS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:232,Integrability,depend,dependecy,232,"// Returns NoAlias/MayAliass/MustAlias for two memory locations based upon their; // underlaying objects. If LocA and LocB are known to not alias (for any reason:; // tbaa, non-overlapping regions etc), then it is known there is no dependecy.; // Otherwise the underlying objects are checked to see if they point to; // different identifiable objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:23,Performance,load,load,23,// Returns true if the load or store can be analyzed. Atomic and volatile; // operations have properties which this analysis does not understand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:561,Energy Efficiency,allocate,allocate,561,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:255,Integrability,rout,routine,255,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1503,Integrability,depend,dependence,1503,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:110,Modifiability,variab,variables,110,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:703,Modifiability,variab,variable,703,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1559,Performance,load,load,1559,"// Examines the loop nesting of the Src and Dst; // instructions and establishes their shared loops. Sets the variables; // CommonLevels, SrcLevels, and MaxLevels.; // The source and destination instructions needn't be contained in the same; // loop. The routine establishNestingLevels finds the level of most deeply; // nested loop that contains them both, CommonLevels. An instruction that's; // not contained in a loop is at level = 0. MaxLevels is equal to the level; // of the source plus the level of the destination, minus CommonLevels.; // This lets us allocate vectors MaxLevels in length, with room for every; // distinct loop referenced in both the source and destination subscripts.; // The variable SrcLevels is the nesting depth of the source instruction.; // It's used to help calculate distinct loops referenced by the destination.; // Here's the map from loops to levels:; // 0 - unused; // 1 - outermost common loop; // ... - other common loops; // CommonLevels - innermost common loop; // ... - loops containing Src but not Dst; // SrcLevels - innermost loop containing Src but not Dst; // ... - loops containing Dst but not Src; // MaxLevels - innermost loops containing Dst but not Src; // Consider the follow code fragment:; // for (a = ...) {; // for (b = ...) {; // for (c = ...) {; // for (d = ...) {; // A[] = ...;; // }; // }; // for (e = ...) {; // for (f = ...) {; // for (g = ...) {; // ... = A[];; // }; // }; // }; // }; // }; // If we're looking at the possibility of a dependence between the store; // to A (the Src) and the load from A (the Dst), we'll note that they; // have 2 loops in common, so CommonLevels will equal 2 and the direction; // vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; // A map from loop names to loop numbers would look like; // a - 1; // b - 2 = CommonLevels; // c - 3; // d - 4 = SrcLevels; // e - 5; // f - 6; // g - 7 = MaxLevels",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:92,Security,access,accesses,92,// This tries to make sure that we assign unique numbers to src and dst when; // the memory accesses reside in different loops that have the same depth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Security,access,access,60,"// Unlike ScalarEvolution::isLoopInvariant() we consider an access outside of; // any loop as invariant, because we only consier expression evaluation at a; // specific position (where the array access takes place), and not across the; // entire function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:195,Security,access,access,195,"// Unlike ScalarEvolution::isLoopInvariant() we consider an access outside of; // any loop as invariant, because we only consier expression evaluation at a; // specific position (where the array access takes place), and not across the; // entire function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:72,Modifiability,extend,extend,72,// Go through each pair and find the widest bit to which we need; // to extend all of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:7,Modifiability,extend,extend,7,// Now extend each pair to the widest seen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Modifiability,extend,extend,8,// Sign-extend Src to widestType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:8,Modifiability,extend,extend,8,// Sign-extend Dst to widestType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:126,Modifiability,extend,extended,126,"// removeMatchingExtensions - Examines a subscript pair.; // If the source and destination are identically sign (or zero); // extended, it strips off the extension in an effect to simplify; // the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:180,Usability,simpl,simplify,180,"// removeMatchingExtensions - Examines a subscript pair.; // If the source and destination are identically sign (or zero); // extended, it strips off the extension in an effect to simplify; // the actual analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Integrability,depend,depend,19,"// The AddRec must depend on one of the containing loops. Otherwise,; // mapSrcLoop and mapDstLoop return indices outside the intended range. This; // can happen when a subscript in one loop references an IV from a sibling; // loop that could not be replaced with a concrete exit value by; // getSCEVAtScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:336,Deployability,update,updated,336,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:5,Integrability,wrap,wrapper,5,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:169,Modifiability,extend,extended,169,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:417,Usability,simpl,simple,417,"// A wrapper around SCEV::isKnownPredicate.; // Looks for cases where we're interested in comparing for equality.; // If both X and Y have been identically sign or zero extended,; // it strips off the (confusing) extensions before invoking; // SCEV::isKnownPredicate. Perhaps, someday, the ScalarEvolution package; // will be similarly updated.; //; // If SCEV::isKnownPredicate can't prove the predicate,; // we try simple subtraction, which seems to help in some cases; // involving symbolics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Safety,avoid,avoid,188,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:113,Testability,test,testing,113,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:144,Testability,test,testing,144,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Integrability,wrap,wrap,65,"// We know S is for Ptr, the operand on a load/store, so doesn't wrap.; // If both parts are NonNegative, the end result will be NonNegative",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:42,Performance,load,load,42,"// We know S is for Ptr, the operand on a load/store, so doesn't wrap.; // If both parts are NonNegative, the end result will be NonNegative",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:376,Availability,avail,available,376,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:155,Integrability,rout,routine,155,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:276,Integrability,wrap,wrap,276,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:103,Modifiability,extend,extend,103,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Modifiability,extend,extends,188,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:238,Safety,safe,safe,238,"// All subscripts are all the same type.; // Loop bound may be smaller (e.g., a char).; // Should zero extend loop bound, since it's always >= 0.; // This routine collects upper bound and extends or truncates if needed.; // Truncating is safe when subscripts are known not to wrap. Cases without; // nowrap flags should have been rejected earlier.; // Return null if no bound available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,Integrability,depend,dependence,301,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:359,Integrability,depend,dependence,359,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:427,Integrability,depend,dependence,427,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:462,Integrability,depend,dependence,462,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:126,Security,attack,attack,126,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testZIV,3,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:154,Testability,test,test,154,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:174,Testability,test,test,174,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,Integrability,depend,dependent,12,// provably dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:12,Integrability,depend,dependent,12,// possibly dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:49,Integrability,Depend,Dependence,49,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:484,Integrability,depend,dependence,484,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:537,Integrability,depend,dependence,537,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:603,Integrability,depend,dependence,603,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:706,Integrability,depend,dependence,706,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:729,Integrability,depend,dependence,729,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:858,Integrability,depend,dependence,858,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:192,Modifiability,variab,variable,192,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Testability,Test,Testing,60,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:302,Testability,test,test,302,"// strongSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.1; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the Strong SIV test.; //; // Can prove independence. Failing that, can compute distance (and direction).; // In the presence of symbolic terms, we can sometimes make progress.; //; // If there's a dependence,; //; // c1 + a*i = c2 + a*i'; //; // The dependence distance is; //; // d = i' - i = (c1 - c2)/a; //; // A dependence only exists if d is an integer and abs(d) <= U, where U is the; // loop's upper bound. If a dependence exists, the dependence direction is; // defined as; //; // { < if d > 0; // direction = { = if d = 0; // { > if d < 0; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:41,Integrability,depend,dependence,41,// Distance greater than trip count - no dependence,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:37,Integrability,depend,dependence,37,"// Coeff doesn't divide Distance, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:55,Integrability,Depend,Dependence,55,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:537,Integrability,depend,dependence,537,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:584,Integrability,depend,dependence,584,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:639,Integrability,depend,dependence,639,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:702,Integrability,depend,dependence,702,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:764,Integrability,depend,dependence,764,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:838,Integrability,depend,dependence,838,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:892,Integrability,depend,dependence,892,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1057,Integrability,depend,dependence,1057,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:198,Modifiability,variab,variable,198,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:66,Testability,Test,Testing,66,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:319,Testability,test,test,319,"// weakCrossingSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2 - a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Crossing SIV test.; //; // Given c1 + a*i = c2 - a*i', we can look for the intersection of; // the two lines, where i = i', yielding; //; // c1 + a*i = c2 - a*i; // 2a*i = c2 - c1; // i = (c2 - c1)/2a; //; // If i < 0, there is no dependence.; // If i > upperbound, there is no dependence.; // If i = 0 (i.e., if c1 = c2), there's a dependence with distance = 0.; // If i = upperbound, there's a dependence with distance = 0.; // If i is integral, there's a dependence (all directions).; // If the non-integer part = 1/2, there's a dependence (<> directions).; // Otherwise, there's no dependence.; //; // Can prove independence. Failing that,; // can sometimes refine the directions.; // Can determine iteration for splitting.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,Depend,DependenceInfo,32,// compute SplitIter for use by DependenceInfo::getSplitIteration(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:75,Integrability,depend,dependence,75,"// We're certain that ConstCoeff > 0; therefore,; // if Delta < 0, then no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, Delta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:21,Integrability,depend,dependence,21,"// Delta too big, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:34,Integrability,depend,dependence,34,"// Coeff doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:266,Integrability,depend,dependence,266,"// Kirch's algorithm, from; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; // MIT Press, 1989; //; // Program 2.1, page 29.; // Computes the GCD of AM and BM.; // Also finds a solution to the equation ax - by = gcd(a, b).; // Returns true if dependence disproved; i.e., gcd does not divide Delta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:35,Performance,Optimiz,Optimizing,35,"// Kirch's algorithm, from; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; // MIT Press, 1989; //; // Program 2.1, page 29.; // Computes the GCD of AM and BM.; // Also finds a solution to the equation ax - by = gcd(a, b).; // Returns true if dependence disproved; i.e., gcd does not divide Delta.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:320,Integrability,Depend,Dependence,320,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:657,Integrability,depend,dependence,657,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:791,Integrability,depend,depends,791,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:859,Integrability,depend,dependencies,859,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:125,Modifiability,variab,variable,125,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:822,Modifiability,extend,extends,822,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:456,Testability,test,tests,456,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:605,Testability,test,test,605,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:772,Testability,test,tested,772,"// exactSIVtest -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*i],; // where i is an induction variable, c1 and c2 are loop invariant, and a1; // and a2 are constant, we can solve it exactly using an algorithm developed; // by Banerjee and Wolfe. See Algorithm 6.2.1 (case 2.5) in:; //; // Dependence Analysis for Supercomputing; // Utpal Banerjee; // Kluwer Academic Publishers, 1988; //; // It's slower than the specialized tests (strong SIV, weak-zero SIV, etc),; // so use them if possible. They're also a bit better with symbolics and,; // in the case of the strong SIV test, can compute Distances.; //; // Return true if dependence disproved.; //; // This is a modified version of the original Banerjee algorithm. The original; // only tested whether Dst depends on Src. This algorithm extends that and; // returns all the dependencies that exist between Dst and Src.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,Depend,Dependence,54,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependence,432,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:477,Integrability,depend,dependence,477,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,depend,dependence,572,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:669,Integrability,depend,dependence,669,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:874,Integrability,depend,dependences,874,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:967,Integrability,depend,dependence,967,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:191,Modifiability,variab,variable,191,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,Test,Testing,65,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:308,Testability,test,test,308,"// weakZeroSrcSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1] and [c2 + a*i],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 = c2 + a*i; //; // we get; //; // (c1 - c2)/a = i; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is >= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is <= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroDstSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,test,test,19,"// For the WeakSIV test, it's possible the loop isn't common to; // the Src and Dst loops. If it isn't, then there's no need to; // record a direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by first iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by last iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, newDelta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// if SrcCoeff doesn't divide Delta, then no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:54,Integrability,Depend,Dependence,54,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:432,Integrability,depend,dependence,432,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:477,Integrability,depend,dependence,477,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:572,Integrability,depend,dependence,572,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:669,Integrability,depend,dependence,669,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:874,Integrability,depend,dependences,874,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:967,Integrability,depend,dependence,967,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:191,Modifiability,variab,variable,191,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:65,Testability,Test,Testing,65,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:308,Testability,test,test,308,"// weakZeroDstSIVtest -; // From the paper, Practical Dependence Testing, Section 4.2.2; //; // When we have a pair of subscripts of the form [c1 + a*i] and [c2],; // where i is an induction variable, c1 and c2 are loop invariant,; // and a is a constant, we can solve it exactly using the; // Weak-Zero SIV test.; //; // Given; //; // c1 + a*i = c2; //; // we get; //; // i = (c2 - c1)/a; //; // If i is not an integer, there's no dependence.; // If i < 0 or > UB, there's no dependence.; // If i = 0, the direction is <= and peeling the; // 1st iteration will break the dependence.; // If i = UB, the direction is >= and peeling the; // last iteration will break the dependence.; // Otherwise, the direction is *.; //; // Can prove independence. Failing that, we can sometimes refine; // the directions. Can sometimes show that first or last; // iteration carries all the dependences (so worth peeling).; //; // (see also weakZeroSrcSIVtest); //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,test,test,19,"// For the WeakSIV test, it's possible the loop isn't common to the; // Src and Dst loops. If it isn't, then there's no need to record a direction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by first iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,dependences,3,// dependences caused by last iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:6,Integrability,depend,dependence,6,"// No dependence, newDelta < 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// if SrcCoeff doesn't divide Delta, then no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:53,Integrability,depend,dependence,53,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:251,Integrability,depend,dependence,251,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:147,Modifiability,variab,variable,147,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:19,Testability,Test,Tests,19,"// exactRDIVtest - Tests the RDIV subscript pair for dependence.; // Things of the form [c1 + a*i] and [c2 + b*j],; // where i and j are induction variable, c1 and c2 are loop invariant,; // and a and b are constants.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Works in some cases that symbolicRDIVtest doesn't, and vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:32,Integrability,depend,dependence,32,"// gcd doesn't divide Delta, no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Integrability,Depend,Dependence,58,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Integrability,depend,dependence,316,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:629,Integrability,depend,dependences,629,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:810,Integrability,depend,dependence,810,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1087,Integrability,depend,dependence,1087,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1768,Integrability,depend,dependence,1768,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:533,Modifiability,variab,variables,533,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:719,Modifiability,variab,variable,719,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:69,Testability,Test,Testing,69,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:186,Testability,Test,Test,186,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:412,Testability,test,tests,412,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:606,Testability,test,tests,606,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:679,Testability,test,test,679,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:746,Testability,test,test,746,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:789,Testability,test,tests,789,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1076,Testability,test,test,1076,"// symbolicRDIVtest -; // In Section 4.5 of the Practical Dependence Testing paper,the authors; // introduce a special case of Banerjee's Inequalities (also called the; // Extreme-Value Test) that can handle some of the SIV and RDIV cases,; // particularly cases with symbolics. Since it's only able to disprove; // dependence (not compute distances or directions), we'll use it as a; // fall back for the other tests.; //; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables and c1 and c2 are loop invariants,; // we can use the symbolic tests to disprove some dependences, serving as a; // backup for the RDIV test. Note that i and j can be the same variable,; // letting this test serve as a backup for the various SIV tests.; //; // For a dependence to exist, c1 + a1*i must equal c2 + a2*j for some; // 0 <= i <= N1 and some 0 <= j <= N2, where N1 and N2 are the (normalized); // loop bounds for the i and j loops, respectively. So, ...; //; // c1 + a1*i = c2 + a2*j; // a1*i - a2*j = c2 - c1; //; // To test for a dependence, we compute c2 - c1 and make sure it's in the; // range of the maximum and minimum possible values of a1*i - a2*j.; // Considering the signs of a1 and a2, we have 4 possible cases:; //; // 1) If a1 >= 0 and a2 >= 0, then; // a1*0 - a2*N2 <= c2 - c1 <= a1*N1 - a2*0; // -a2*N2 <= c2 - c1 <= a1*N1; //; // 2) If a1 >= 0 and a2 <= 0, then; // a1*0 - a2*0 <= c2 - c1 <= a1*N1 - a2*N2; // 0 <= c2 - c1 <= a1*N1 - a2*N2; //; // 3) If a1 <= 0 and a2 >= 0, then; // a1*N1 - a2*N2 <= c2 - c1 <= a1*0 - a2*0; // a1*N1 - a2*N2 <= c2 - c1 <= 0; //; // 4) If a1 <= 0 and a2 <= 0, then; // a1*N1 - a2*0 <= c2 - c1 <= a1*0 - a2*N2; // a1*N1 <= c2 - c1 <= -a2*N2; //; // return true if dependence disproved",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:405,Integrability,depend,dependence,405,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:119,Modifiability,variab,variable,119,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:194,Security,attack,attack,194,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testSIV,3,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Testability,test,test,216,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:274,Testability,test,test,274,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:311,Testability,test,tests,311,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:303,Usability,simpl,simpler,303,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Energy Efficiency,adapt,adaptation,234,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:629,Integrability,depend,dependence,629,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:124,Modifiability,variab,variables,124,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Modifiability,adapt,adaptation,234,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:300,Modifiability,Variab,Variable,300,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,testRDIV,3,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:266,Testability,test,test,266,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Testability,test,test,316,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:467,Testability,test,test,467,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:501,Testability,test,test,501,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:540,Testability,test,test,540,"// testRDIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 + a2*j]; // where i and j are induction variables, c1 and c2 are loop invariant,; // and a1 and a2 are constant, we can solve it exactly with an easy adaptation; // of the Exact SIV test, the Restricted Double Index Variable (RDIV) test.; // It doesn't make sense to talk about distance or direction in this case,; // so there's no point in making special versions of the Strong SIV test or; // the Weak-crossing SIV test.; //; // With minor algebra, this test can also be used for things like; // [c1 + a1*i + a2*j][c2].; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Integrability,depend,dependence,57,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:88,Integrability,depend,dependence,88,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Tests,3,// Tests the single-subscript MIV pair (Src and Dst) for dependence.; // Return true if dependence disproved.; // Can sometimes refine direction vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:134,Integrability,depend,dependence,134,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:179,Integrability,depend,dependence,179,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:534,Modifiability,variab,variables,534,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:585,Modifiability,variab,variables,585,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:777,Modifiability,variab,variables,777,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:361,Performance,Perform,Performance,361,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:102,Testability,Test,Tests,102,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:670,Testability,test,test,670,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:710,Testability,test,tests,710,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:817,Testability,test,test,817,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:148,Integrability,depend,dependence,148,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:271,Usability,simpl,simplify,271,"// Try to disprove equal directions.; // For example, given a subscript pair [3*i + 2*j] and [i' + 2*j' - 1],; // the code above can't disprove the dependence because the GCD = 1.; // So we consider what happen if i = i' and what happens if j = j'.; // If i = i', we can simplify the subscript to [2*i + 2*j] and [2*j' - 1],; // which is infeasible, so we can disallow the = direction for the i level.; // Setting j = j' doesn't help matters, so we end up with a direction vector; // of [<>, *]; //; // Given A[5*i + 10*j*M + 9*M*N] and A[15*i + 20*j*M - 21*N*M + 5],; // we need to remember that the constant part is 5 and the RunningGCD should; // be initialized to ExtraGCD = 30.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1460,Integrability,depend,dependence,1460,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,Performance,Optimiz,Optimizing,301,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:138,Testability,test,test,138,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:229,Testability,Test,Test,229,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:410,Usability,simpl,simplified,410,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1000,Usability,simpl,simplify,1000,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1153,Usability,simpl,simplifications,1153,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Test,3,"// Test the *, *, *, ... case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:104,Integrability,depend,dependences,104,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:185,Integrability,depend,dependences,185,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Integrability,depend,dependence,216,"// Hierarchically expands the direction vector; // search space, combining the directions of discovered dependences; // in the DirSet field of Bound. Returns the number of distinct; // dependences discovered. If the dependence is disproved,; // it will return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:109,Safety,avoid,avoid,109,"// This algorithm has worst case complexity of O(3^n), where 'n' is the number; // of common loop levels. To avoid excessive compile-time, pessimize all the; // results and immediately return when the number of common levels is beyond; // the given threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,"// test bounds for <, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,Test,Test,3,"// Test bounds for =, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,"// test bounds for >, *, *, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:290,Usability,simpl,simplify,290,"// Computes the upper and lower bounds for level K; // using the * direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^*_k = (A^-_k - B^+_k)(U_k - L_k) + (A_k - B_k)L_k; // UB^*_k = (A^+_k - B^-_k)(U_k - L_k) + (A_k - B_k)L_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^*_k = (A^-_k - B^+_k)U_k; // UB^*_k = (A^+_k - B^-_k)U_k; //; // We must be careful to handle the case where the upper bound is unknown.; // Note that the lower bound is always <= 0; // and the upper bound is always >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:288,Usability,simpl,simplify,288,"// Computes the upper and lower bounds for level K; // using the = direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^=_k = (A_k - B_k)^- (U_k - L_k) + (A_k - B_k)L_k; // UB^=_k = (A_k - B_k)^+ (U_k - L_k) + (A_k - B_k)L_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^=_k = (A_k - B_k)^- U_k; // UB^=_k = (A_k - B_k)^+ U_k; //; // We must be careful to handle the case where the upper bound is unknown.; // Note that the lower bound is always <= 0; // and the upper bound is always >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:324,Usability,simpl,simplify,324,"// Computes the upper and lower bounds for level K; // using the < direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; // UB^<_k = (A^+_k - B_k)^+ (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 1) - B_k; // UB^<_k = (A^+_k - B_k)^+ (U_k - 1) - B_k; //; // We must be careful to handle the case where the upper bound is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:324,Usability,simpl,simplify,324,"// Computes the upper and lower bounds for level K; // using the > direction. Records them in Bound.; // Wolfe gives the equations; //; // LB^>_k = (A_k - B^+_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k + A_k N_k; // UB^>_k = (A_k - B^-_k)^+ (U_k - L_k - N_k) + (A_k - B_k)L_k + A_k N_k; //; // Since we normalize loops, we can simplify these equations to; //; // LB^>_k = (A_k - B^+_k)^- (U_k - 1) + A_k; // UB^>_k = (A_k - B^-_k)^+ (U_k - 1) + A_k; //; // We must be careful to handle the case where the upper bound is unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:119,Testability,test,test,119,"//===----------------------------------------------------------------------===//; // Constraint manipulation for Delta test.; // Given a linear SCEV,; // return the coefficient (the step); // corresponding to the specified loop.; // If there isn't one, return 0.; // For example, given a*i + b*j + c*k, finding the coefficient; // corresponding to the j loop would yield b.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:234,Integrability,depend,dependence,234,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:333,Integrability,Depend,Dependence,333,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:344,Testability,Test,Testing,344,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Usability,simpl,simplify,60,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:125,Usability,simpl,simplification,125,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:159,Usability,simpl,simplification,159,"// Review the constraints, looking for opportunities; // to simplify a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.; // Corresponds to Figure 5 from the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:220,Integrability,depend,dependence,220,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:111,Usability,simpl,simplification,111,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:145,Usability,simpl,simplification,145,"// Attempt to propagate a distance; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:216,Integrability,depend,dependence,216,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:107,Usability,simpl,simplification,107,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:141,Usability,simpl,simplification,141,"// Attempt to propagate a line; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.; // If the simplification isn't exact (that is, if it is conservative; // in terms of dependence), set consistent to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:108,Usability,simpl,simplification,108,// Attempt to propagate a point; // constraint into a subscript pair (Src and Dst).; // Return true if some simplification occurs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,Update,Update,3,// Update direction vector entry based on the current constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:57,Integrability,depend,dependence,57,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:104,Integrability,depend,dependence,104,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:68,Testability,test,test,68,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:115,Testability,test,test,115,"// The delinearization transforms a single-subscript MIV dependence test into; // a multi-subscript SIV dependence test that is easier to compute. So we; // resize Pair to contain as many pairs of subscripts as the delinearization; // has found, and then initialize the pairs following the delinearization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:87,Security,access,accessed,87,/// Try to delinearize \p SrcAccessFn and \p DstAccessFn if the underlying; /// arrays accessed are fixed-size arrays. Return true if delinearization was; /// successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Availability,recover,recovered,58,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:24,Safety,safe,safely,24,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:58,Safety,recover,recovered,58,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:27,Security,access,access,27,// Third step: compute the access functions for each subscript.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,Security,access,access,60,// Fail when there is only a subscript: that's a linearized access function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:339,Integrability,depend,dependency,339,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:169,Safety,safe,safe,169,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Integrability,depend,dependencies,20,// Check transitive dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Integrability,depend,depends,3,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:45,Integrability,depend,dependence,45,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:81,Integrability,Depend,Dependence,81,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,Integrability,Depend,Dependence,188,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:283,Integrability,rout,routine,283,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:355,Integrability,rout,routine,355,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:199,Testability,Test,Testing,199,"// depends -; // Returns NULL if there is no dependence.; // Otherwise, return a Dependence with as many details as possible.; // Corresponds to Section 3.1 in the paper; //; // Practical Dependence Testing; // Goff, Kennedy, Tseng; // PLDI 1991; //; // Care is required to keep the routine below, getSplitIteration(),; // up to date with respect to this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:59,Integrability,depend,dependence,59,"// if both instructions don't reference memory, there's no dependence",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:27,Performance,load,loads,27,"// can only analyze simple loads and stores, i.e., no calls, invokes, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:20,Usability,simpl,simple,20,"// can only analyze simple loads and stores, i.e., no calls, invokes, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,Security,access,accesses,46,"// If the objects noalias, they are distinct, accesses are independent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:51,Integrability,depend,dependence,51,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:38,Security,access,accesses,38,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:33,Testability,test,test,33,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test separable subscripts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test coupled subscript groups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test & propagate remaining RDIVs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test remaining MIVs; // This code is temporary.; // Better to somehow test all remaining subscripts simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:73,Testability,test,test,73,// test remaining MIVs; // This code is temporary.; // Better to somehow test all remaining subscripts simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Deployability,update,update,3,// update Result.DV from constraint vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:129,Integrability,depend,dependence,129,"// Make sure the LoopIndependent flag is set correctly.; // All directions must include equal, otherwise no; // loop-independent dependence is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:86,Integrability,depend,dependence,86,"// On the other hand, if all directions are equal and there's no; // loop-independent dependence possible, then no dependence exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:115,Integrability,depend,dependence,115,"// On the other hand, if all directions are equal and there's no; // loop-independent dependence possible, then no dependence exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:305,Integrability,depend,dependence,305,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:367,Integrability,depend,dependence,367,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:526,Integrability,rout,routine,526,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:545,Integrability,depend,depends,545,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:579,Integrability,depend,dependence,579,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:627,Integrability,depend,dependence,627,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:701,Integrability,depend,dependences,701,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:881,Integrability,depend,dependences,881,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1028,Integrability,depend,dependences,1028,"---------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1558,Integrability,depend,dependence,1558,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1642,Integrability,depend,dependence,1642,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1695,Integrability,depend,dependence,1695,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1822,Integrability,depend,dependence,1822,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1994,Integrability,depend,dependence,1994,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1591,Performance,load,load,1591,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:212,Testability,test,test,212,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:316,Testability,test,test,316,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:1632,Testability,test,test,1632,"----------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the dependence and allows us to vectorize/parallelize; // both loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:333,Usability,simpl,simplified,333,"//===----------------------------------------------------------------------===//; // getSplitIteration -; // Rather than spend rarely-used space recording the splitting iteration; // during the Weak-Crossing SIV test, we re-compute it on demand.; // The re-computation is basically a repeat of the entire dependence test,; // though simplified since we know that the dependence exists.; // It's tedious, since we must go through all propagations, etc.; //; // Care is required to keep this code up to date with respect to the routine; // above, depends().; //; // Generally, the dependence analyzer will be used to build; // a dependence graph for a function (basically a map from instructions; // to dependences). Looking for cycles in the graph shows us loops; // that cannot be trivially vectorized/parallelized.; //; // We can try to improve the situation by examining all the dependences; // that make up the cycle, looking for ones we can break.; // Sometimes, peeling the first or last iteration of a loop will break; // dependences, and we've got flags for those possibilities.; // Sometimes, splitting a loop at some other iteration will do the trick,; // and we've got a flag for that case. Rather than waste the space to; // record the exact iteration (since we rarely know), we provide; // a method that calculates the iteration. It's a drag that it must work; // from scratch, but wonderful in that it's possible.; //; // Here's an example:; //; // for (i = 0; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // There's a loop-carried flow dependence from the store to the load,; // found by the weak-crossing SIV test. The dependence will have a flag,; // indicating that the dependence can be broken by splitting the loop.; // Calling getSplitIteration will return 5.; // Splitting the loop breaks the dependence, like so:; //; // for (i = 0; i <= 5; i++); // A[i] = ...; // ... = A[11 - i]; // for (i = 6; i < 10; i++); // A[i] = ...; // ... = A[11 - i]; //; // breaks the depende",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test separable subscripts,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:3,Testability,test,test,3,// test coupled subscript groups,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:7,Integrability,Depend,DependenceGraphBuilder,7,"//===- DependenceGraphBuilder.cpp ------------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file implements common steps of the build algorithm for construction; // of dependence graphs such as DDG and PDG.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:460,Integrability,depend,dependence,460,"//===- DependenceGraphBuilder.cpp ------------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file implements common steps of the build algorithm for construction; // of dependence graphs such as DDG and PDG.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,Availability,redundant,redundant,629,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:653,Integrability,depend,depending,653,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:629,Safety,redund,redundant,629,"// Create a root node that connects to every connected component of the graph.; // This is done to allow graph iterators to visit all the disjoint components; // of the graph, in a single walk.; //; // This algorithm works by going through each node of the graph and for each; // node N, do a DFS starting from N. A rooted edge is established between the; // root node and N (if N is not yet visited). All the nodes reachable from N; // are marked as visited and are skipped in the DFS of subsequent nodes.; //; // Note: This algorithm tries to limit the number of edges out of the root; // node to some extent, but there may be redundant edges created depending on; // the iteration order. For example for a graph {A -> B}, an edge from the; // root node is added to both nodes if B is visited before A. While it does; // not result in minimal number of edges, this approach saves compile-time; // while keeping the number of edges in check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:20,Usability,usab,usable,20,// To make the enum usable as an array index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:45,Availability,redundant,redundant,45,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:30,Safety,avoid,avoid,30,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:45,Safety,redund,redundant,45,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:140,Usability,simpl,simply,140,"// In the case of loops, the scope of the subgraph is all the; // basic blocks (and instructions within them) belonging to the loop. We; // simply ignore all the edges coming from (or going into) instructions; // or basic blocks outside of this range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,Availability,redundant,redundant,50,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:8,Integrability,depend,dependencies,8,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,Safety,redund,redundant,50,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:16,Integrability,depend,dependence,16,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:154,Integrability,depend,dependence,154,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:211,Integrability,depend,dependencies,211,"// If we have a dependence with its left-most non-'=' direction; // being '>' we need to reverse the direction of the edge, because; // the source of the dependence cannot occur after the sink. For; // confused dependencies, we will create edges in both directions to; // represent the possibility of a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating duplicate edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:365,Availability,avail,available,365,"// This algorithm works by first collecting a set of candidate nodes that have; // an out-degree of one (in terms of def-use edges), and then ignoring those; // whose targets have an in-degree more than one. Each node in the resulting; // set can then be merged with its corresponding target and put back into the; // worklist until no further merge candidates are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:91,Deployability,update,updated,91,// Insert an element into the in-degree map and initialize to zero. The; // count will get updated in the next step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:50,Performance,load,loadable,50,"//===- DevelopmentModeInlineAdvisor.cpp - runtime-loadable model runner --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner using TFLite, allowing the; // loading of a model from a command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:449,Performance,load,loading,449,"//===- DevelopmentModeInlineAdvisor.cpp - runtime-loadable model runner --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner using TFLite, allowing the; // loading of a model from a command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:156,Testability,log,logged,156,"R""(Path to SavedModel from the previous training iteration.; The directory is also expected to contain a JSON specification of the ; outputs expected to be logged, where the first entry must be the ; inlining decision. The file containing the specification should be ; called output_spec.json. The expected JSON value is an array of ; dictionaries. Each dictionary should have 2 keys: . - ""tensor_spec, followed by the TensorSpec description of the; output; and ; - ""logging_name"", a string indicating the name to use when; logging the output values. . Example:; [; {; ""logging_name"" : ""some_name"", ; ""tensor_spec"" : { ; ""name"" : ""model_name"", ; ""port"" : 0,; ""shape"" : [2, 3],; ""type"" : ""float""; }; }; ]. The first value must always correspond to the decision.)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:524,Testability,log,logging,524,"R""(Path to SavedModel from the previous training iteration.; The directory is also expected to contain a JSON specification of the ; outputs expected to be logged, where the first entry must be the ; inlining decision. The file containing the specification should be ; called output_spec.json. The expected JSON value is an array of ; dictionaries. Each dictionary should have 2 keys: . - ""tensor_spec, followed by the TensorSpec description of the; output; and ; - ""logging_name"", a string indicating the name to use when; logging the output values. . Example:; [; {; ""logging_name"" : ""some_name"", ; ""tensor_spec"" : { ; ""name"" : ""model_name"", ; ""port"" : 0,; ""shape"" : [2, 3],; ""type"" : ""float""; }; }; ]. The first value must always correspond to the decision.)""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:80,Availability,error,error,80,"/// What actually happened. This would be 'false' in the case of an inline; /// error, even if AdvisedDecision were true, otherwise it agrees with; /// AdvisedDecision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:4,Testability,Log,Log,4,/// Log one inlining event.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:16,Usability,clear,clearly,16,"/// Set these 2 clearly OOB, to make sure we set them later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:951,Deployability,release,release,951,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1081,Deployability,release,release,1081,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1124,Deployability,release,release,1124,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1385,Deployability,release,release,1385,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:908,Security,validat,validation,908,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:1144,Security,validat,validate,1144,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:229,Testability,log,logs,229,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:318,Testability,log,logs,318,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:493,Testability,log,logs,493,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:752,Testability,log,logs,752,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:864,Testability,log,logging,864,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:98,Testability,log,logging,98,"/// A variant of MLInlineAdvice that tracks all non-trivial inlining; /// decisions, for training/logging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:4,Testability,Log,Log,4,/// Log one inlining event.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:52,Testability,log,logging,52,// We cannot have the case of neither inference nor logging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:2,Testability,Log,Logger,2,/*Logger=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:2,Testability,Log,Logger,2,/*Logger=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp:277,Usability,clear,clearer,277,"// TODO: This code is very similar to findAffectedValues() in; // AssumptionCache, but currently specialized to just the patterns that; // computeKnownBits() supports, and without the notion of result elem indices; // that are AC specific. Deduplicate this code once we have a clearer picture; // of how much they can be shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomConditionCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:647,Availability,avail,available,647,"//===- DomPrinter.cpp - DOT printer for the dominance trees ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines '-dot-dom' and '-dot-postdom' analysis passes, which emit; // a dom.<fnname>.dot or postdom.<fnname>.dot file for each function in the; // program, with a graph of the dominance/postdominance tree of that; // function.; //; // There are also passes available to directly call dotty ('-view-dom' or; // '-view-postdom'). By appending '-only' like '-dot-dom-only' only the; // names of the bbs are printed, but the content is hidden.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:18,Availability,avail,available,18,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp:155,Performance,optimiz,optimization,155,"// Create methods available outside of this file, to use them; // ""include/llvm/LinkAllPasses.h"". Otherwise the pass would be deleted by; // the link time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:49,Deployability,Update,Updater,49,"//===- DomTreeUpdater.cpp - DomTree/Post DomTree Updater --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DomTreeUpdater class, which provides a uniform way; // to update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:466,Deployability,update,update,466,"//===- DomTreeUpdater.cpp - DomTree/Post DomTree Updater --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DomTreeUpdater class, which provides a uniform way; // to update dominator tree related data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:11,Deployability,update,updates,11,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:185,Deployability,update,update,185,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:217,Deployability,update,updates,217,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:253,Deployability,update,update,253,// Discard updates by inspecting the current state of successors of From.; // Since isUpdateValid() must be called *after* the Terminator of From is; // altered we can determine if the update is unnecessary for batch updates; // or invalid for a single update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:32,Deployability,update,update,32,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:56,Deployability,update,updates,56,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:70,Deployability,update,update,70,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:149,Deployability,update,update,149,"// If the IR does not match the update,; // 1. In batch updates, this update is unnecessary.; // 2. When called by insertEdge*()/deleteEdge*(), this update is invalid.; // Edge does not exist in IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:14,Deployability,update,updates,14,// Only apply updates not are applied by DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:14,Deployability,update,updates,14,// Only apply updates not are applied by PostDomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:57,Deployability,Update,UpdateStrategy,57,"// After calling deleteBB or callbackDeleteBB under Lazy UpdateStrategy,; // validateDeleteBB() removes all instructions of DelBB and adds an; // UnreachableInst as its terminator. So we check whether the BasicBlock to; // delete only has an UnreachableInst inside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:77,Security,validat,validateDeleteBB,77,"// After calling deleteBB or callbackDeleteBB under Lazy UpdateStrategy,; // validateDeleteBB() removes all instructions of DelBB and adds an; // UnreachableInst as its terminator. So we check whether the BasicBlock to; // delete only has an UnreachableInst inside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:113,Availability,avail,available,113,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:80,Deployability,Update,UpdateStrategy,80,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:19,Performance,perform,performance,19,// There is little performance gain if we pend the recalculation under; // Lazy UpdateStrategy so we recalculate available trees immediately.; // Prevent forceFlushDeletedBB() from erasing DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:3,Usability,Resume,Resume,3,// Resume forceFlushDeletedBB() to erase DomTree or PostDomTree nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:47,Deployability,update,updates,47,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:80,Deployability,update,update,80,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:165,Deployability,Update,UpdateStrategy,165,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:198,Deployability,Update,UpdateStrategy,198,"// The DT and PDT require the nodes related to updates; // are not deleted when update functions are called.; // So BasicBlock deletions must be pended when the; // UpdateStrategy is Lazy. When the UpdateStrategy is; // Eager, the BasicBlock will be deleted immediately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:35,Deployability,update,updates,35,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:82,Deployability,update,updates,82,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:194,Deployability,update,update,194,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:236,Deployability,update,update,236,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:323,Deployability,update,update,323,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:520,Deployability,update,updates,520,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:617,Deployability,update,updates,617,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:741,Deployability,update,updates,741,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:997,Deployability,update,update,997,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:1146,Deployability,update,update,1146,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:140,Safety,safe,safe,140,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:720,Safety,safe,safely,720,"// Because it is illegal to submit updates that have already been applied; // and updates to an edge need to be strictly ordered,; // it is safe to infer the existence of an edge from the first update; // to this edge.; // If the first update to an edge is ""Delete"", it means that the edge; // existed before. If the first update to an edge is ""Insert"", it means; // that the edge didn't exist before.; //; // For example, if the user submits {{Delete, A, B}, {Insert, A, B}},; // because; // 1. it is illegal to submit updates that have already been applied,; // i.e., user cannot delete an nonexistent edge,; // 2. updates to an edge need to be strictly ordered,; // So, initially edge A -> B existed.; // We can then safely ignore future updates to this edge and directly; // inspect the current CFG:; // a. If the edge still exists, because the user cannot insert an existent; // edge, so both {Delete, A, B}, {Insert, A, B} actually happened and; // resulted in a no-op. DTU won't submit any update in this case.; // b. If the edge doesn't exist, we can then infer that {Delete, A, B}; // actually happened but {Insert, A, B} was an invalid update which never; // happened. DTU will submit {Delete, A, B} in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:10,Deployability,update,update,10,"// If the update doesn't appear in the CFG, it means that; // either the change isn't made or relevant operations; // result in a no-op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp:12,Deployability,update,updates,12,// Drop all updates applied by both trees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DomTreeUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:179,Deployability,update,updated,179,"// For BBs that are likely to change, we subtract from feature totals their; // contribution. Some features, like max loop counts or depths, are left; // invalid, as they will be updated post-inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:385,Availability,down,down,385,"// Update feature values from the BBs that were copied from the callee, or; // might have been modified because of inlining. The latter have been; // subtracted in the FunctionPropertiesUpdater ctor.; // There could be successors that were reached before but now are only; // reachable from elsewhere in the CFG.; // One example is the following diamond CFG (lines are arrows pointing down):; // A; // / \; // B C; // | |; // | D; // | |; // | E; // \ /; // F; // There's a call site in C that is inlined. Upon doing that, it turns out; // it expands to; // call void @llvm.trap(); // unreachable; // F isn't reachable from C anymore, but we did discount it when we set up; // FunctionPropertiesUpdater, so we need to re-include it here.; // At the same time, D and E were reachable before, but now are not anymore,; // so we need to leave D out (we discounted it at setup), and explicitly; // remove E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:3,Deployability,Update,Update,3,"// Update feature values from the BBs that were copied from the callee, or; // might have been modified because of inlining. The latter have been; // subtracted in the FunctionPropertiesUpdater ctor.; // There could be successors that were reached before but now are only; // reachable from elsewhere in the CFG.; // One example is the following diamond CFG (lines are arrows pointing down):; // A; // / \; // B C; // | |; // | D; // | |; // | E; // \ /; // F; // There's a call site in C that is inlined. Upon doing that, it turns out; // it expands to; // call void @llvm.trap(); // unreachable; // F isn't reachable from C anymore, but we did discount it when we set up; // FunctionPropertiesUpdater, so we need to re-include it here.; // At the same time, D and E were reachable before, but now are not anymore,; // so we need to leave D out (we discounted it at setup), and explicitly; // remove E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp:198,Performance,perform,perform,198,"// For reinclusion, we want to stop at the reachable successors, who are at; // the beginning of the worklist; but, starting from the callsite bb and; // ending at those successors, we also want to perform a traversal.; // IncludeSuccessorsMark is the index after which we include successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/FunctionPropertiesAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:27,Usability,Simpl,Simple,27,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:388,Usability,simpl,simple,388,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:584,Usability,simpl,simple,584,"//===- GlobalsModRef.cpp - Simple Mod/Ref Analysis for Globals ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass provides alias and mod/ref information for global values; // that do not have their address taken, and keeps track of whether functions; // read or write memory (are ""pure""). For this simple (but very common) case,; // we can provide pretty accurate and useful information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:590,Performance,perform,performance,590,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:689,Performance,perform,performance,689,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:23,Safety,unsafe,unsafe,23,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:390,Safety,unsafe,unsafe,390,"// An option to enable unsafe alias results from the GlobalsModRef analysis.; // When enabled, GlobalsModRef will provide no-alias results which in extremely; // rare cases may not be conservatively correct. In particular, in the face of; // transforms which cause asymmetry between how effective getUnderlyingObject; // is for two pointers, it may produce incorrect results.; //; // These unsafe results have been returned by GMR for many years without; // causing significant issues in the wild and so we provide a mechanism to; // re-enable them for users of LLVM that have a particular performance; // sensitivity and no known issues. The option also makes it easy to evaluate; // the performance impact of these results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:12,Integrability,wrap,wrapper,12,"/// Build a wrapper struct that has 8-byte alignment. All heap allocations; /// should provide this much alignment at least, but this makes it clear we; /// specifically rely on this amount of alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:143,Usability,clear,clear,143,"/// Build a wrapper struct that has 8-byte alignment. All heap allocations; /// should provide this much alignment at least, but this makes it clear we; /// specifically rely on this amount of alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:219,Availability,mask,masks,219,/// The bit that flags that this function may read any global. This is; /// chosen to mix together with ModRefInfo bits.; /// FIXME: This assumes ModRefInfo lattice will remain 4 bits!; /// FunctionInfo.getModRefInfo() masks out everything except ModRef so; /// this remains correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:16,Usability,clear,clears,16,/// This method clears MayReadAnyGlobal bit added by GlobalsAAResult to return; /// the corresponding ModRefInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:54,Modifiability,variab,variable,54,"/// Returns whether this function may read any global variable, and we don't; /// know which global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:4,Usability,Clear,Clear,4,/// Clear a global's ModRef info. Should be used when a global is being; /// deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:7,Usability,clear,clear,7,// And clear out the handle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Safety,Detect,Detect,3,// Detect calls to free.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:72,Usability,simpl,simple,72,"// In general, we return true for unknown calls, but there are; // some simple checks that we can do for functions that; // will never call back into the module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:71,Modifiability,variab,variable,71,"/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable; /// which holds a pointer type. See if the global always points to non-aliased; /// heap memory: that is, all initializers of the globals store a value known; /// to be obtained via a noalias return function call which have no other use.; /// Further, all loads out of GV must directly use the memory, not store the; /// pointer somewhere. If this is true, we consider the memory pointed to by; /// GV to be owned by GV and can disambiguate other pointers from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:337,Performance,load,loads,337,"/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable; /// which holds a pointer type. See if the global always points to non-aliased; /// heap memory: that is, all initializers of the globals store a value known; /// to be obtained via a noalias return function call which have no other use.; /// Further, all loads out of GV must directly use the memory, not store the; /// pointer somewhere. If this is true, we consider the memory pointed to by; /// GV to be owned by GV and can disambiguate other pointers from it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:81,Performance,load,load,81,"// Walk the user list of the global. If we find anything other than a direct; // load or store, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:15,Performance,load,loaded,15,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:105,Performance,load,loading,105,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:162,Performance,load,loaded,162,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:58,Usability,simpl,simple,58,// The pointer loaded from the global can only be used in simple ways:; // we allow addressing of it and loading storing to it. We do *not* allow; // storing the loaded pointer somewhere else or passing to a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Performance,Load,Loaded,3,// Loaded pointer escapes.; // TODO: Could try some IP mod/ref of the loaded pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:70,Performance,load,loaded,70,// Loaded pointer escapes.; // TODO: Could try some IP mod/ref of the loaded pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:101,Usability,simpl,simple,101,// Too hard to analyze.; // Analyze all uses of the allocation. If any of them are used in a; // non-simple way (e.g. stored to another global) bail out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Performance,Load,Loaded,3,// Loaded pointer escapes.; // Remember that this allocation is related to the indirect global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:30,Integrability,synchroniz,synchronizing,30,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:326,Security,access,accesses,326,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:41,Performance,load,loads,41,// Scan the function bodies for explicit loads or stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:235,Security,hash,hash,235,"// Finally, now that we know the full effect on this SCC, clone the; // information to each function in the SCC.; // FI is a reference into FunctionInfos, so copy it now so that it doesn't; // get invalidated if DenseMap decides to re-hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:69,Performance,load,loaded,69,"// GV is a non-escaping global. V is a pointer address that has been loaded from.; // If we can prove that V must escape, we can conclude that a load from V cannot; // alias GV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:145,Performance,load,load,145,"// GV is a non-escaping global. V is a pointer address that has been loaded from.; // If we can prove that V must escape, we can conclude that a load from V cannot; // alias GV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:187,Performance,load,loads,187,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:216,Safety,safe,safe,216,"// Arguments to functions or returns from functions are inherently; // escaping, so we can immediately classify those as not aliasing any; // non-addr-taken globals.; //; // (Transitive) loads from a global are also safe - if this aliased; // another global, its address would escape, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:48,Performance,load,loads,48,"// Recurse through a limited number of selects, loads and PHIs. This is an; // arbitrary depth of 4, lower numbers could be used to fix compile time; // issues if needed, but this is generally expected to be only be important; // for small depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1344,Modifiability,variab,variables,1344,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1394,Modifiability,variab,variable,1394,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1570,Modifiability,variab,variables,1570,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:466,Performance,load,loading,466,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1182,Performance,optimiz,optimization,1182,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:558,Safety,safe,safe,558,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1440,Security,expose,expose,1440,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:200,Performance,load,load,200,"// In order to know that the underlying object cannot alias the; // non-addr-taken global, we must know that it would have to be an escape.; // Thus if the underlying object is a function argument, a load from; // a global, or the return of a function, it cannot alias. We can also; // recurse through PHI nodes and select nodes provided all of their inputs; // resolve to one of these known-escaping roots.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:48,Performance,load,loads,48,"// Recurse through a limited number of selects, loads and PHIs. This is an; // arbitrary depth of 4, lower numbers could be used to fix compile time; // issues if needed, but this is generally expected to be only be important; // for small depths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:13,Performance,load,loaded,13,"// A pointer loaded from a global would have been captured, and we know; // that the global is non-escaping, so no alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:7,Performance,load,load,7,// The load does not alias with GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:16,Performance,load,load,16,"// Otherwise, a load could come from anywhere, so bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:89,Usability,clear,clear,89,"// FIXME: It would be good to handle other obvious no-alias cases here, but; // it isn't clear how to do so reasonably without building a small version; // of BasicAA into this code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:106,Performance,perform,performance,106,"// If one is and the other isn't, it isn't strictly safe but we can fake; // this result if necessary for performance. This does not appear to be; // a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:52,Safety,safe,safe,52,"// If one is and the other isn't, it isn't strictly safe but we can fake; // this result if necessary for performance. This does not appear to be; // a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:97,Security,access,accesses,97,"// Otherwise if they are both derived from the same addr-taken global, we; // can't know the two accesses don't overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:171,Performance,load,load,171,"// These pointers may be based on the memory owned by an indirect global. If; // so, we may be able to handle this. First check to see if the base pointer; // is a direct load from an indirect global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:134,Performance,perform,performance,134,"// If one is based on an indirect global and the other isn't, it isn't; // strictly safe but we can fake this result if necessary for performance.; // This does not appear to be a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:84,Safety,safe,safe,84,"// If one is based on an indirect global and the other isn't, it isn't; // strictly safe but we can fake this result if necessary for performance.; // This does not appear to be a common problem in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:3,Deployability,Update,Update,3,// Update the parent for each DeletionCallbackHandle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp:402,Performance,perform,perform,402,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp:12,Safety,avoid,avoid,12,"// We could avoid second lookup, but it would make the code ultra ugly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp:531,Availability,avail,available,531,"//===-- IndirectCallPromotionAnalysis.cpp - Find promotion candidates ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Helper methods for identifying profitable indirect call promotion; // candidates for an instruction when the indirect-call value profile metadata; // is available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IndirectCallPromotionAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:23,Integrability,message,messages,23,/// Flag to add inline messages as callsite attributes 'inline-remark'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:498,Availability,avail,available,498,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:10,Safety,detect,detect,10,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:764,Testability,log,logic,764,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:71,Safety,avoid,avoiding,71,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:258,Safety,avoid,avoid,258,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:307,Safety,avoid,avoid,307,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,Security,expose,exposed,132,// InlineSavingsMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:159,Testability,test,testing,159,// InlineSavingsMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:142,Security,expose,exposed,142,// InlineSavingsProfitableMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:169,Testability,test,testing,169,// InlineSavingsProfitableMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Performance,perform,performance,39,// We introduce this threshold to help performance of instrumentation based; // PGO before we actually hook up inliner with analysis passes such as BPI and; // BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:296,Integrability,wrap,wrapper,296,"/// Carry out call site analysis, in order to evaluate inlinability.; /// NOTE: the type is currently used as implementation detail of functions such; /// as llvm::getInlineCost. Note the function_ref constructor parameters - the; /// expectation is that they come from the outer scope, from the wrapper; /// functions. If we want to support constructing CallAnalyzer objects where; /// lambdas are provided inline at construction, or where the object needs to; /// otherwise survive past the scope of the provided functions, we need to; /// revisit the argument types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Availability,avail,available,28,/// The TargetTransformInfo available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Performance,cache,cache,19,/// Getter for the cache of @llvm.assume intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Performance,Cache,Cache,3,// Cache the DataLayout since we use it a lot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:34,Availability,avail,available,34,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,Performance,Optimiz,OptimizationRemarkEmitter,8,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:158,Performance,cache,cacheable,158,"/// The candidate callsite being analyzed. Please do not use this to do; /// analysis in the caller function; we want the inline cost query to be; /// easily cacheable. Instead, use the cover function paramHasAttr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:42,Performance,load,load,42,/// Called the analysis engine determines load elimination won't happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Performance,load,load,28,/// Called to account for a load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:73,Performance,load,load,73,/// Called to account for the expectation the inlining would result in a load; /// elimination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,Performance,load,load,28,/// Called to account for a load relative intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:20,Energy Efficiency,allocate,allocated,20,/// Number of bytes allocated statically by the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:99,Usability,simpl,simplified,99,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:315,Usability,simpl,simplifications,315,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:402,Usability,simpl,simplifications,402,"/// While we walk the potentially-inlined instructions, we build up and; /// maintain a mapping of simplified values specific to this callsite. The; /// idea is to propagate any special information we have about arguments to; /// this call through the inlinable section of the function, and account for; /// likely simplifications post-inlining. The most important aspect we track; /// is CFG altering simplifications -- when we prove a basic block dead, that; /// can cause dramatic shifts in the cost of inlining a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:124,Usability,simpl,simplified,124,/// Keep track of the values which map back (through function arguments) to; /// allocas on the caller stack which could be simplified through SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:63,Performance,optimiz,optimization,63,/// Keep track of Allocas for which we believe we may get SROA optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:38,Performance,load,loads,38,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:156,Performance,load,loads,156,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:88,Usability,simpl,simplify,88,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Integrability,rout,routines,32,// Custom simplification helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:10,Usability,simpl,simplification,10,// Custom simplification helper routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Integrability,rout,routines,19,// Custom analysis routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:732,Usability,simpl,simple,732,"// Considering forming a binary search, we should find the number of nodes; // which is same as the number of comparisons when lowered. For a given; // number of clusters, n, we can define a recursive function, f(n), to find; // the number of nodes in the tree. The recursion is :; // f(n) = 1 + f(n/2) + f (n - n/2), when n > 3,; // and f(n) = n, when n <= 3.; // This will lead a binary tree where the leaf should be either f(2) or f(3); // when n > 3. So, the number of comparisons from leaves should be n, while; // the number of non-leaf should be :; // 2^(log2(n) - 1) - 1; // = 2^log2(n) * 2^-1 - 1; // = n / 2 - 1.; // Considering comparisons from leaf and non-leaf nodes, we can estimate the; // number of comparisons in a simple closed form :; // n + n / 2 - 1 = n * 3 / 2 - 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:107,Deployability,update,updateThreshold,107,/// Bonus to be applied when percentage of vector instructions in callee is; /// high (see more details in updateThreshold).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Deployability,Update,Update,4,/// Update Threshold based on callsite properties such as callee; /// attributes and callee hotness for PGO builds. The Callee is explicitly; /// passed to support analyzing indirect calls whose target is inferred by; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:13,Usability,simpl,simply,13,// Otherwise simply add the cost for merely making the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:143,Testability,log,logic,143,// buildInlinerPipeline in the pass builder sets HotCallSiteThreshold to 0; // for the prelink phase of the AutoFDO + ThinLTO build. Honor the logic by; // falling back to the cost-based metric.; // TODO: Improve this hacky condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:343,Modifiability,variab,variable,343,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,Safety,avoid,avoid,132,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:312,Safety,avoid,avoid,312,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:452,Safety,avoid,avoid,452,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:862,Safety,avoid,avoid,862,"// Let R be the ratio of CycleSavings to Size. We accept the inlining; // opportunity if R is really high and reject if R is really low. If R is; // somewhere in the middle, we fall back to the cost-based analysis.; //; // Specifically, let R = CycleSavings / Size, we accept the inlining; // opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R > -------------------------------------------------; // getInliningCostBenefitAnalysisSavingsMultiplier(); //; // and reject the inlining opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R <= ----------------------------------------------------; // getInliningCostBenefitAnalysisProfitableMultiplier(); //; // Otherwise, we fall back to the cost-based analysis.; //; // Implementation-wise, use multiplication (CycleSavings * Multiplier,; // HotCountThreshold * Size) rather than division to avoid precision loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:193,Performance,perform,perform,193,"// Loops generally act a lot like calls in that they act like barriers to; // movement, require a certain amount of setup, etc. So when optimising for; // size, we penalise any call sites that perform loops. We do this after all; // other costs here, so will likely only be dealing with relatively small; // functions (and hence DT and LI will hopefully be cheap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:303,Modifiability,evolve,evolved,303,"// Perform some tweaks to the cost and threshold based on the direct; // callsite information.; // We want to more aggressively inline vector-dense kernels, so up the; // threshold, and we'll lower it if the % of vector instructions gets too; // low. Note that these bonuses are some what arbitrary and evolved over; // time by accident as much as because they are principled bonuses.; //; // FIXME: It would be nice to remove all such bonuses. At least it would be; // nice to base the bonus values on something more scientific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Performance,Perform,Perform,3,"// Perform some tweaks to the cost and threshold based on the direct; // callsite information.; // We want to more aggressively inline vector-dense kernels, so up the; // threshold, and we'll lower it if the % of vector instructions gets too; // low. Note that these bonuses are some what arbitrary and evolved over; // time by accident as much as because they are principled bonuses.; //; // FIXME: It would be nice to remove all such bonuses. At least it would be; // nice to base the bonus values on something more scientific.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Deployability,Update,Update,3,// Update the threshold based on callsite properties,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Integrability,depend,depends,19,"// While Threshold depends on commandline options that can take negative; // values, we want to enforce the invariant that the computed threshold and; // bonuses are non-negative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,Integrability,depend,dependent,65,"// Prints the same analysis as dump(), but its definition is not dependent; // on the build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:135,Safety,avoid,avoid,135,// FIXME: These constants are taken from the heuristic-based cost visitor.; // These should be removed entirely in a later revision to avoid reliance on; // heuristics in the ML inliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:128,Safety,avoid,avoid,128,// FIXME: These are taken from the heuristic-based cost visitor: we should; // eventually abstract these to the CallAnalyzer to avoid duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:35,Testability,log,logic,35,"// FIXME: we shouldn't repeat this logic in both the Features and Cost; // analyzer - instead, we should abstract it to a common method in the; // CallAnalyzer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:18,Testability,Test,Test,18,// namespace; /// Test whether the given value is an Alloca-derived function argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:154,Usability,simpl,simplified,154,/// Accumulate a constant GEP offset into an APInt if possible.; ///; /// Returns false if unable to compute the offset for any reason. Respects any; /// simplified values known during the analysis of this callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:67,Usability,simpl,simplified,67,/// Use TTI to check whether a GEP is free.; ///; /// Respects any simplified values known during the analysis of this callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:166,Safety,Avoid,Avoid,166,"// Sometimes a dynamic alloca could be converted into a static alloca; // after this constant prop, and become a huge static alloca on an; // unconditional CFG path. Avoid inlining if this is going to happen above; // a threshold.; // FIXME: If the threshold is removed or lowered too much, we could end up; // being too pessimistic and prevent inlining non-problematic code. This; // could result in unintended perf regressions. A better overall strategy; // is needed to track stack usage during inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:18,Energy Efficiency,allocate,allocated,18,// Accumulate the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:210,Usability,simpl,simply,210,"// FIXME: This is overly conservative. Dynamic allocas are inefficient for; // a variety of reasons, and so we would like to not inline them into; // functions which don't currently have a dynamic alloca. This simply; // disables inlining altogether in the presence of a dynamic alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:12,Testability,log,logic,12,"// The same logic as above, but check pointer with constant offset here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:3,Modifiability,Variab,Variable,3,// Variable GEPs will require math and will disable SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:52,Deployability,update,update,52,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Usability,Simpl,Simplify,4,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:59,Usability,Simpl,SimplifiedValues,59,/// Simplify \p I if its operands are constants and update SimplifiedValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a call to llvm.is.constant.; ///; /// Duplicate the argument checking from CallAnalyzer::simplifyCallSite since; /// we expect calls of this specific intrinsic to be infrequent.; ///; /// FIXME: Given that we know CB's parent (F) caller; /// (CandidateCall->getParent()->getParent()), we might be able to determine; /// whether inlining F into F's caller would change how the call to; /// llvm.is.constant would evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:109,Usability,simpl,simplifyCallSite,109,"/// Try to simplify a call to llvm.is.constant.; ///; /// Duplicate the argument checking from CallAnalyzer::simplifyCallSite since; /// we expect calls of this specific intrinsic to be infrequent.; ///; /// FIXME: Given that we know CB's parent (F) caller; /// (CandidateCall->getParent()->getParent()), we might be able to determine; /// whether inlining F into F's caller would change how the call to; /// llvm.is.constant would evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Integrability,wrap,wrap,39,"// Casts don't change the offset, just wrap it up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:336,Usability,simpl,simplified,336,"// Does the *call site* have the NonNull attribute set on an argument? We; // use the attribute on the call site to memoize any analysis done in the; // caller. This will also trip if the callee function has a non-null; // parameter attribute, but that's a less interesting case because hopefully; // the callee would already have been simplified based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:113,Deployability,update,updated,113,// Is this an alloca in the caller? This is distinct from the attribute case; // above because attributes aren't updated within the inliner itself and we; // always want to catch the alloca derived case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Safety,predict,predict,19,// We can actually predict the result of comparisons between an; // alloca-derived value and null. Note that this fires regardless of; // SROA firing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:635,Deployability,update,updateThreshold,635,"// If the normal destination of the invoke or the parent block of the call; // site is unreachable-terminated, there is little point in inlining this; // unless there is literally zero cost.; // FIXME: Note that it is possible that an unreachable-terminated block has a; // hot entry. For example, in below scenario inlining hot_call_X() may be; // beneficial :; // main() {; // hot_call_1();; // ...; // hot_call_N(); // exit(0);; // }; // For now, we are not handling this corner case here as it is rare in real; // code. In future, we should elaborate this based on BPI and BFI in more; // general threshold adjusting heuristics in updateThreshold().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Availability,avail,available,32,"// If global profile summary is available, then callsite's coldness is; // determined based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,Availability,avail,available,31,// Otherwise we need BFI to be available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:90,Performance,cache,cache,90,"// Determine if the callsite is cold relative to caller's entry. We could; // potentially cache the computation of scaled entry frequency, but the added; // complexity is not worth it unless this scaling shows up high in the; // profiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Availability,avail,available,32,"// If global profile summary is available, then callsite's hotness is; // determined based on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:31,Availability,avail,available,31,// Otherwise we need BFI to be available and to have a locally hot callsite; // threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:89,Performance,cache,cache,89,"// Determine if the callsite is hot relative to caller's entry. We could; // potentially cache the computation of scaled entry frequency, but the added; // complexity is not worth it unless this scaling shows up high in the; // profiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:475,Energy Efficiency,reduce,reduce,475,// Various bonus percentages. These are multiplied by Threshold to get the; // bonus values.; // SingleBBBonus: This bonus is applied if the callee has a single reachable; // basic block at the given callsite context. This is speculatively applied; // and withdrawn if more than one basic block is seen.; //; // LstCallToStaticBonus: This large bonus is applied to ensure the inlining; // of the last call to a static function as inlining such functions is; // guaranteed to reduce code size.; //; // These bonus percentages may be set to 0 based on properties of the caller; // and the callsite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:68,Availability,avail,available,68,// Use the OptMinSizeThreshold or OptSizeThreshold knob if they are available; // and reduce the threshold if the caller has the necessary attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:86,Energy Efficiency,reduce,reduce,86,// Use the OptMinSizeThreshold or OptSizeThreshold knob if they are available; // and reduce the threshold if the caller has the necessary attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:137,Availability,reliab,reliably,137,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:348,Availability,avail,available,348,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:63,Testability,log,logic,63,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:50,Usability,simpl,simplify,50,"// FIXME: After switching to the new passmanager, simplify the logic below; // by checking only the callsite hotness/coldness as we will reliably; // have local profile information.; //; // Callsite hotness and coldness can be determined if sample profile is; // used (which adds hotness metadata to calls) or if caller's; // BlockFrequencyInfo is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:22,Deployability,update,update,22,"// FIXME: This should update the threshold only if it exceeds the; // current threshold, but AutoFDO + ThinLTO currently relies on this; // behavior to prevent inlining of hot callsites during ThinLTO; // compile phase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:142,Deployability,update,update,142,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:161,Deployability,update,updateThreshold,161,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:192,Integrability,depend,depends,192,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:207,Testability,log,logic,207,"// If there is only one call of the function, and it has internal linkage,; // the cost of inlining it drops dramatically. It may seem odd to update; // Cost in updateThreshold, but the bonus depends on the logic in this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:23,Usability,simpl,simplified,23,// First try to handle simplified comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:65,Usability,simpl,simplify,65,"// If the comparison is an equality comparison with null, we can simplify it; // if we know the value (argument) can't be null",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:101,Usability,simpl,simplified,101,// Implicit null checks act as unconditional branches and their comparisons; // should be treated as simplified and free of cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:39,Testability,log,logic,39,"// Otherwise, fall back to the generic logic for simplifying and handling; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:49,Usability,simpl,simplifying,49,"// Otherwise, fall back to the generic logic for simplifying and handling; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Availability,redundant,redundant,131,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:26,Performance,load,loaded,26,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:110,Performance,load,load,110,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Safety,redund,redundant,131,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:37,Performance,load,loads,37,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:64,Performance,load,loads,64,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:167,Performance,load,loads,167,// The store can potentially clobber loads and prevent repeated loads from; // being eliminated.; // FIXME:; // 1. We can probably keep an initial set of eliminatable loads substracted; // from the cost even when we finally see a store. We just need to disable; // *further* accumulation of elimination savings.; // 2. We should probably at some point thread MemorySSA for the callee into; // this and then use that to actually compute *really* precise savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:104,Usability,simpl,simplify,104,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:211,Usability,simpl,simplified,211,"/// Try to simplify a call site.; ///; /// Takes a concrete function and callsite and tries to actually simplify it by; /// analyzing the arguments and call itself with instsimplify. Returns true if; /// it has simplified the callsite to some other entity (a constant), making it; /// free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:173,Performance,perform,performed,173,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:33,Testability,log,logic,33,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:150,Usability,simpl,simplifications,150,"// FIXME: Using the instsimplify logic directly for this is inefficient; // because we have to continually rebuild the argument list even when no; // simplifications can be performed. Until that is fixed with remapping; // inside of instsimplify, directly constant fold calls here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,Safety,abort,aborts,8,// This aborts the entire analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:50,Usability,simpl,simplify,50,"// When we have a concrete function, first try to simplify it directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:24,Safety,abort,abort,24,"// This flag will fully abort the analysis, so don't bother with anything; // else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:171,Safety,predict,predictable,171,"// We model unconditional branches as essentially free -- they really; // shouldn't exist at all, but handling them makes the behavior of the; // inliner more regular and predictable. Interestingly, conditional branches; // which will fold away are also free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:51,Usability,simpl,simplified,51,// Condition is either all 1s or all 0s. SI can be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:653,Performance,optimiz,optimization,653,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:94,Testability,test,test,94,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:305,Testability,test,test,305,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:550,Usability,simpl,simplifycfg,550,"// Assume the most general case where the switch is lowered into; // either a jump table, bit test, or a balanced binary tree consisting of; // case clusters without merging adjacent clusters with the same; // destination. We do not consider the switches that are lowered with a mix; // of jump table/bit test/binary search tree. The cost of the switch is; // proportional to the size of the tree or the size of jump table range.; //; // NB: We convert large switches which are just used to initialize large phi; // nodes to lookup tables instead in simplifycfg, so this shouldn't prevent; // inlining those. It will prevent inlining in cases where the optimization; // does not (yet) fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:406,Safety,safe,safely,406,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this; // indirect jump would jump from the inlined copy of the function into the; // original function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions with; // indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:373,Testability,log,logic,373,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this; // indirect jump would jump from the inlined copy of the function into the; // original function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions with; // indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:101,Usability,resume,resume,101,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a cleanupret instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,Usability,clear,clear,19,// FIXME: It's not clear that a single instruction is an accurate model for; // the inline cost of a catchret instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:231,Safety,abort,aborts,231,"/// Analyze a basic block for its contribution to the inline cost.; ///; /// This method walks the analyzer over every instruction in the given basic; /// block and accounts for their cost during inlining at this callsite. It; /// aborts early if the threshold has been exceeded or an impossible to inline; /// construct has been detected. It returns false if inlining is no longer; /// viable, and true if inlining remains viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:330,Safety,detect,detected,330,"/// Analyze a basic block for its contribution to the inline cost.; ///; /// This method walks the analyzer over every instruction in the given basic; /// block and accounts for their cost during inlining at this callsite. It; /// aborts early if the threshold has been exceeded or an impossible to inline; /// construct has been detected. It returns false if inlining is no longer; /// viable, and true if inlining remains viable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:95,Usability,simpl,simplify,95,"// FIXME: Currently, the number of instructions in a function regardless of; // our ability to simplify them during inline to constants or dead code,; // are actually used by the vector bonus heuristic. As long as that's true,; // we have to special case debug intrinsics here to prevent differences in; // inlining due to debug symbols. Eventually, the number of unsimplified; // instructions shouldn't factor into the cost computation, but until then,; // hack around it here.; // Similarly, skip pseudo-probes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:181,Testability,log,logic,181,"// If the instruction simplified to a constant, there is no cost to this; // instruction. Visit the instructions using our InstVisitor to account for; // all of the per-instruction logic. The visit tree returns true if we; // consumed the instruction in any way, and false if the instruction's base; // cost should count against inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:22,Usability,simpl,simplified,22,"// If the instruction simplified to a constant, there is no cost to this; // instruction. Visit the instructions using our InstVisitor to account for; // all of the per-instruction logic. The visit tree returns true if we; // consumed the instruction in any way, and false if the instruction's base; // cost should count against inlining.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:33,Safety,detect,detected,33,"// If the visit this instruction detected an uninlinable pattern, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:66,Safety,abort,abort,66,"// If the visit this instruction detected an uninlinable pattern, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:90,Energy Efficiency,allocate,allocate,90,// If the caller is a recursive function then we don't want to inline; // functions which allocate a lot of stack space because it would increase; // the caller stack usage dramatically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:388,Integrability,rout,routine,388,"/// Analyze a call site for potential inlining.; ///; /// Returns true if inlining this call is viable, and false if it is not; /// viable. It computes the cost and adjusts the threshold based on numerous; /// factors and heuristics. If this method returns false but the computed cost; /// is below the computed threshold, then inlining was forcibly disabled by; /// some artifact of the routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:16,Usability,simpl,simplified,16,// Populate our simplified values by mapping from function arguments to call; // arguments with known important simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:112,Usability,simpl,simplifications,112,// Populate our simplified values by mapping from function arguments to call; // arguments with known important simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:507,Performance,optimiz,optimized,507,"// The worklist of live basic blocks in the callee *after* inlining. We avoid; // adding basic blocks of the callee which can be proven to be dead for this; // particular call site in order to get more accurate cost estimates. This; // requires a somewhat heavyweight iteration pattern: we need to walk the; // basic blocks in a breadth-first order as we insert live successors. To; // accomplish this, prioritizing for small iterations because we exit after; // crossing our threshold, we use a small-size optimized SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:72,Safety,avoid,avoid,72,"// The worklist of live basic blocks in the callee *after* inlining. We avoid; // adding basic blocks of the callee which can be proven to be dead for this; // particular call site in order to get more accurate cost estimates. This; // requires a somewhat heavyweight iteration pattern: we need to walk the; // basic blocks in a breadth-first order as we insert live successors. To; // accomplish this, prioritizing for small iterations because we exit after; // crossing our threshold, we use a small-size optimized SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:27,Performance,cache,cache,27,"// Note that we *must not* cache the size, this loop grows the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:405,Modifiability,variab,variable,405,"// Disallow inlining a blockaddress with uses other than strictly callbr.; // A blockaddress only has defined behavior for an indirect branch in the; // same function, and we do not currently support inlining indirect; // branches. But, the inliner may not see an indirect branch that ends up; // being dead code at a particular call site. If the blockaddress escapes; // the function, e.g., via a global variable, inlining may lead to an; // invalid cross-function reference.; // FIXME: pr/39560: continue relaxing this overt restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:91,Usability,simpl,simplified,91,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:122,Usability,simpl,simplified,122,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:4,Testability,Test,Test,4,/// Test that there are no attribute conflicts between Caller and Callee; /// that prevent inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:83,Performance,cache,caches,83,"// Note that CalleeTLI must be a copy not a reference. The legacy pass manager; // caches the most recently created TLI in the TargetLibraryInfoWrapperPass; // object, and always returns the same object (which is overwritten on each; // GetTLI call). Therefore we copy the first result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:32,Performance,load,loads,32,// We approximate the number of loads and stores needed by dividing the; // size of the byval type by the target's pointer size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:316,Availability,avail,available,316,"// If it generates more than 8 stores it is likely to be expanded as an; // inline memcpy so we take that as an upper bound. Otherwise we assume; // one load and one store per word copied.; // FIXME: The maxStoresPerMemcpy setting from the target should be used; // here instead of a magic number of 8, but it's not available via; // DataLayout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:153,Performance,load,load,153,"// If it generates more than 8 stores it is likely to be expanded as an; // inline memcpy so we take that as an upper bound. Otherwise we assume; // one load and one store per word copied.; // FIXME: The maxStoresPerMemcpy setting from the target should be used; // here instead of a magic number of 8, but it's not available via; // DataLayout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:44,Usability,simpl,simply,44,"// No details on how the decision was made, simply return always or never.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:24,Security,expose,expose,24,// Disallow calls which expose returns-twice to a function not previously; // attributed as such.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:110,Performance,optimiz,optimization,110,"// This field is the threshold to use for a callee by default. This is; // derived from one or more of:; // * optimization or size-optimization levels,; // * a value passed to createFunctionInliningPass function, or; // * the -inline-threshold flag.; // If the -inline-threshold flag is explicitly specified, that is used; // irrespective of anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,Performance,optimiz,optimization,131,"// This field is the threshold to use for a callee by default. This is; // derived from one or more of:; // * optimization or size-optimization levels,; // * a value passed to createFunctionInliningPass function, or; // * the -inline-threshold flag.; // If the -inline-threshold flag is explicitly specified, that is used; // irrespective of anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:234,Performance,optimiz,optimization,234,"// If the -locally-hot-callsite-threshold is explicitly specified, use it to; // populate LocallyHotCallSiteThreshold. Later, we populate; // Params.LocallyHotCallSiteThreshold from -locally-hot-callsite-threshold if; // we know that optimization level is O3 (in the getInlineParams variant that; // takes the opt and size levels).; // FIXME: Remove this check (and make the assignment unconditional) after; // addressing size regression issues at O2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:134,Energy Efficiency,reduce,reduce,134,"// We prioritize call sites in the dictionary order of the following; // priorities:; //; // 1. Those call sites that are expected to reduce the caller size when; // inlined. Within them, we prioritize those call sites with bigger; // reduction.; //; // 2. Those call sites that have gone through the cost-benefit analysis.; // Currently, they are limited to hot call sites. Within them, we; // prioritize those call sites with higher benefit-to-cost ratios.; //; // 3. Remaining call sites are prioritized according to their costs.; // We add back StaticBonusApplied to determine whether we expect the caller; // to shrink (even if we don't delete the callee).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:10,Energy Efficiency,reduce,reduces,10,"// If one reduces the caller size while the other doesn't, then return; // true iff P1 reduces the caller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:87,Energy Efficiency,reduce,reduces,87,"// If one reduces the caller size while the other doesn't, then return; // true iff P1 reduces the caller size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:16,Energy Efficiency,reduce,reduce,16,"// If they both reduce the caller size, pick the one with the smaller; // cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:158,Deployability,update,update,158,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:353,Deployability,update,updated,353,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp:415,Usability,simpl,simplicity,415,"// A call site could become less desirable for inlining because of the size; // growth from prior inlining into the callee. This method is used to lazily; // update the desirability of a call site if it's decreasing. It is only; // called on pop(), not every time the desirability changes. When the; // desirability of the front call site decreases, an updated one would be; // pushed right back into the heap. For simplicity, those cases where the; // desirability of a call site increases are ignored here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineOrder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:451,Usability,learn,learning,451,"//===- InlineSizeEstimatorAnalysis.cpp - IR to native size from ML model --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements feature and label extraction for offline supervised learning; // of a IR to native size model.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:115,Availability,avail,available,115,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:341,Availability,avail,available,341,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp:176,Performance,perform,performance,176,"// This is a point in time - we determined including these pairs of; // consecutive instructions (in the IR layout available at inline time) as; // features improves the model performance. We want to move away from manual; // feature selection.; // The array is given in opcode pairs rather than labels because 1) labels; // weren't readily available, and 2) the successions were hand - extracted.; //; // This array must be sorted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineSizeEstimatorAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:567,Energy Efficiency,efficient,efficiently,567,"//===-- InstructionPrecedenceTracking.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:965,Performance,cache,cached,965,"//===-- InstructionPrecedenceTracking.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:42,Performance,cache,cache,42,"// If there is a bug connected to invalid cache, turn on ExpensiveAsserts to; // catch this situation as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:34,Performance,cache,cached,34,// Bail if we don't have anything cached for this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:40,Performance,cache,cached,40,// Check that for every known block the cached value is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:33,Usability,clear,clearing,33,// The map should be valid after clearing (at least empty).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:161,Safety,avoid,avoid,161,"// If a block's instruction doesn't always pass the control to its successor; // instruction, mark the block as having implicit control flow. We use them; // to avoid wrong assumptions of sort ""if A is executed and B post-dominates; // A, then B is also executed"". This is not true is there is an implicit; // control flow instruction (e.g. a guard) between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:404,Integrability,rout,routines,404,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:838,Testability,log,logic,838,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:443,Usability,simpl,simpler,443,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:774,Usability,simpl,simplified,774,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:823,Usability,simpl,simplifies,823,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:871,Usability,simpl,simplified,871,"//===- InstructionSimplify.cpp - Fold instruction operands ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements routines for folding instructions into simpler forms; // that do not require creating new instructions. This does constant folding; // (""add i32 1, 1"" -> ""2"") but can also handle non-constant operands, either; // returning a constant (""and i32 %x, 0"" -> ""0"") or an already existing value; // (""and i32 %x, %x"" -> ""%x""). All operands are assumed to have already been; // simplified: This is usually true and assuming it simplifies the logic (if; // they have not been simplified then results are correct but maybe suboptimal).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,"/// Simplify comparison with true or false branch of select:; /// %sel = select i1 %cond, i32 %tv, i32 %fv; /// %cmp = icmp sle i32 %sel, %rhs; /// Compose new comparison by substituting %sel with either %tv or %fv; /// and see if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:234,Usability,simpl,simplifies,234,"/// Simplify comparison with true or false branch of select:; /// %sel = select i1 %cond, i32 %tv, i32 %fv; /// %cmp = icmp sle i32 %sel, %rhs; /// Compose new comparison by substituting %sel with either %tv or %fv; /// and see if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:8,Usability,simpl,simplified,8,// %cmp simplified to the select condition (%cond).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Usability,simpl,simplify,13,"// It didn't simplify. However, if composed comparison is equivalent; // to the select condition (%cond) then we can replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify comparison with true branch of select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify comparison with false branch of select,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:105,Integrability,rout,routine,105,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:126,Testability,log,logical,126,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplified,59,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:134,Usability,simpl,simplifications,134,"/// We know comparison with both branches of select can be simplified, but they; /// are not equal. This routine handles some logical simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:266,Safety,safe,safe,266,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:22,Usability,simpl,simplified,22,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:158,Usability,simpl,simplified,158,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Usability,simpl,simplified,21,"// If the true value simplified to true, then the result of the compare; // is equal to ""Cond || FCmp"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplified,31,"// Finally, if the false value simplified to true and the true value to; // false, then the result of the compare is equal to ""!Cond"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:48,Testability,test,test,48,// If we have a DominatorTree then do a precise test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify a binary operator of form ""V op OtherOp"" where V is; /// ""(B0 opex B1)"" by distributing 'op' across 'opex' as; /// ""(B0 op OtherOp) opex (B1 op OtherOp)"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplify,36,// Does the expanded pair of binops simplify to the existing binop?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Usability,simpl,simplifies,37,"// Otherwise, return ""L op' R"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,"/// Try to simplify binops of form ""A op (B op' C)"" or the commuted variant by; /// distributing op over op'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:12,Usability,simpl,simplifications,12,"/// Generic simplifications for associative binary operations.; /// Returns the simpler value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:80,Usability,simpl,simpler,80,"/// Generic simplifications for associative binary operations.; /// Returns the simpler value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""A op V"" if it simplifies or is already available.; // If V equals B then ""A op V"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""A op V"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""V op C"" if it simplifies or is already available.; // If V equals B then ""V op C"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""V op C"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""V op B"" if it simplifies or is already available.; // If V equals A then ""V op B"" is just the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""V op B"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplifies,56,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if it simplifies completely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,avail,available,59,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// It does! Return ""B op V"" if it simplifies or is already available.; // If V equals C then ""B op V"" is just the RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Usability,simpl,simplifies,35,"// Otherwise return ""B op V"" if it simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:91,Usability,simpl,simplify,91,"/// In the case of a binary operation with a select instruction as an operand,; /// try to simplify the binop by seeing whether evaluating it on both branches; /// of the select results in the same value. Returns the common value if so,; /// otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplified,11,"// If they simplified to the same value, then return the common value.; // If they both failed to simplify then return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:98,Usability,simpl,simplify,98,"// If they simplified to the same value, then return the common value.; // If they both failed to simplify then return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If one branch simplified to undef, return the other one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplified,59,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Usability,simpl,simplified,125,"// If one branch simplified and the other did not, and the simplified; // value is equal to the unsimplified one, return the simplified value.; // For example, select (cond, X, X & Z) & Z -> X & Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:18,Usability,simpl,simplified,18,"// Check that the simplified value has the form ""X op Y"" where ""op"" is the; // same as the original operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Usability,simpl,simplify,25,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:128,Usability,simpl,simplified,128,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:199,Usability,simpl,simplified,199,"// The value that didn't simplify is ""UnsimplifiedLHS op UnsimplifiedRHS"".; // We already know that ""op"" is the same as for the simplified value. See; // if the operands match too. If so, return the simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Usability,simpl,simplify,66,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:345,Usability,simpl,simplify,345,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:525,Usability,simpl,simplified,525,"/// In the case of a comparison with a select instruction, try to simplify the; /// comparison by seeing whether both branches of the select result in the same; /// value. Returns the common value if so, otherwise returns null.; /// For example, if we have:; /// %tmp = select i1 %cmp, i32 1, i32 2; /// %cmp1 = icmp sle i32 %tmp, 3; /// We can simplify %cmp1 to true, because both branches of select are; /// less than 3. We compose new comparison by substituting %tmp with both; /// branches of select and see if it can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:88,Usability,simpl,simplify,88,"// Now that we have ""cmp select(Cond, TV, FV), RHS"", analyse it.; // Does ""cmp TV, RHS"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:22,Usability,simpl,simplify,22,"// Does ""cmp FV, RHS"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Usability,simpl,simplified,17,"// If both sides simplified to the same value, then use it as the result of; // the original comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:93,Usability,simpl,simplify,93,"/// In the case of a binary operation with an operand that is a PHI instruction,; /// try to simplify the binop by seeing whether evaluating it on the incoming; /// phi values yields the same result for every value. If so returns the common; /// value, otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplify,30,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Usability,simpl,simplified,43,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:63,Usability,simpl,simplify,63,"/// In the case of a comparison with a PHI instruction, try to simplify the; /// comparison by seeing whether comparing with all of the incoming phi values; /// yields the same result every time. If so returns the common result,; /// otherwise returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplify,30,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Usability,simpl,simplified,43,"// If the operation failed to simplify, or simplified to a different value; // to previously, then give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:60,Integrability,wrap,wrapping,60,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:156,Usability,clear,clearing,156,"// add nsw/nuw (xor Y, signmask), signmask --> Y; // The no-wrapping add guarantees that the top bit will be set by the add.; // Therefore, the xor must be clearing the already set sign bit of Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Add over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A + select(cond, B, C)"" means evaluating; // ""A+B"" and ""A+C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A+B"" and ""A+C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Add over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A + select(cond, B, C)"" means evaluating; // ""A+B"" and ""A+C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A+B"" and ""A+C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:103,Energy Efficiency,reduce,reduce,103,"/// Test if there is a dominating equivalence condition for the; /// two operands. If there is, try to reduce the binary operation; /// between the two operands.; /// Example: Op0 - Op1 --> 0 when Op0 == Op1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Testability,Test,Test,4,"/// Test if there is a dominating equivalence condition for the; /// two operands. If there is, try to reduce the binary operation; /// between the two operands.; /// Example: Op0 - Op1 --> 0 when Op0 == Op1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplifies,59,"// (X + Y) - Z -> X + (Y - Z) or Y + (X - Z) if everything simplifies.; // For example, (X + Y) - Y -> X; (Y + X) - Y -> X",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// (X + Y) - Z; // See if ""V === Y - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""X + V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""Y + V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Usability,simpl,simplifies,59,"// X - (Y + Z) -> (X - Y) - Z or (X - Z) - Y if everything simplifies.; // For example, X - (X + 1) -> -1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// X - (Y + Z); // See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Z"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:44,Usability,simpl,simplifies,44,"// Z - (X - Y) -> (Z - X) + Y if everything simplifies.; // For example, X - (X - Y) -> Y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:40,Usability,simpl,simplifies,40,"// Z - (X - Y); // See if ""V === Z - X"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// It does! Now see if ""V + Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,Usability,simpl,simplifies,53,// trunc(X) - trunc(Y) -> trunc(X - Y) if everything simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Usability,simpl,simplifies,24,"// See if ""V === X - Y"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:33,Usability,simpl,simplifies,33,"// It does! Now see if ""trunc V"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:23,Usability,simpl,simplified,23,"// It does, return the simplified ""trunc V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Sub over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A - select(cond, B, C)"" means evaluating; // ""A-B"" and ""A-C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A-B"" and ""A-C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Sub over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A - select(cond, B, C)"" means evaluating; // ""A-B"" and ""A-C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A-B"" and ""A-C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:105,Energy Efficiency,reduce,reduce,105,"// mul i1 nsw is a special-case because -1 * -1 is poison (+1 is not; // representable). All other cases reduce to 0, so just return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:46,Usability,simpl,simplifications,46,// Mul distributes over Add. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:113,Usability,simpl,simplification,113,"/// Given a predicate and two operands, return true if the comparison is true.; /// This is a helper for div/rem simplification where we return some other value; /// when we can prove a relationship between the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Energy Efficiency,adapt,adapt,61,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Modifiability,adapt,adapt,61,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Usability,simpl,simplify,26,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:87,Usability,simpl,simplify,87,/// Return true if we can simplify X / Y to 0. Remainder can adapt that answer; /// to simplify X % Y to X.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:89,Modifiability,extend,extended,89,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:107,Modifiability,variab,variables,107,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:58,Usability,simpl,simple,58,// |X| / |Y| --> 0; //; // We require that 1 operand is a simple constant. That could be extended to; // 2 variables if we computed the sign bit for each.; //; // Make sure that a constant is not the minimum signed value because taking; // the abs() of that is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variable,10,// Is the variable divisor magnitude always greater than the constant; // dividend magnitude?; // |Y| > |C| --> Y < -abs(C) or Y > abs(C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variable,10,// Is the variable dividend magnitude always less than the constant; // divisor magnitude?; // |X| < |C| --> X > -abs(C) and X < abs(C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:69,Availability,fault,faults,69,// X / 0 -> poison; // X % 0 -> poison; // We don't need to preserve faults!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:214,Usability,simpl,simplifiable,214,"// X / 0 -> poison; // X % 0 -> poison; // If the divisor is known to be zero, just return poison. This can happen in; // some cases where its provable indirectly the denominator is zero but it's; // not trivially simplifiable (i.e known zero through a phi node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Usability,simpl,simplifications,14,/// These are simplifications common to SDiv and UDiv.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:98,Energy Efficiency,power,power,98,"// udiv exact (mul nsw X, C), C --> X; // sdiv exact (mul nuw X, C), C --> X; // where C is not a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Usability,simpl,simplifications,14,/// These are simplifications common to SRem and URem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:81,Performance,scalab,scalable,81,// Shifting by the bitwidth or more is poison. This covers scalars and; // fixed/scalable vectors with splat constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Modifiability,extend,extended,39,// X shift by 0 -> X; // Shift-by-sign-extended bool must be shift-by-0 because shift-by-all-ones; // would be poison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:211,Performance,optimiz,optimization,211,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:307,Performance,optimiz,optimizers,307,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:155,Usability,Simpl,SimplifyDemandedBits,155,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:334,Usability,simpl,simple,334,// ((X << A) | Y) >> A -> X if effective width of Y is not larger than A.; // We can return X as we do in the above case since OR alters no bits in X.; // SimplifyDemandedBits in InstCombine can do more general optimization for; // bit manipulation. This pattern aims to provide opportunities for other; // optimizers by supporting a simple but common case in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:198,Performance,optimiz,optimizer,198,"// The transforms below here are expected to be handled more generally with; // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's; // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,; // these are candidates for removal.; // X < Y && Y != 0 --> X < Y; // X < Y || Y != 0 --> Y != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:80,Usability,simpl,simplifyAndOrOfICmpsWithLimitConst,80,"// The transforms below here are expected to be handled more generally with; // simplifyAndOrOfICmpsWithLimitConst() or in InstCombine's; // foldAndOrOfICmpsWithConstEq(). If we are looking to trim optimizer overlap,; // these are candidates for removal.; // X < Y && Y != 0 --> X < Y; // X < Y || Y != 0 --> Y != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Testability,Test,Test,4,"/// Test if a pair of compares with a shared operand and 2 constants has an; /// empty set intersection, full set union, or if one compare is a superset of; /// the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify and/or of icmp with ctpop intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Usability,simpl,simplification,61,"// If we looked through casts, we can only handle a constant simplification; // because we are not allowed to create a cast instruction here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:109,Usability,simpl,simplifies,109,"// and (icmp eq a, b), x implies (a==b) inside x.; // or (icmp ne a, b), x implies (a==b) inside x.; // If x simplifies to true/false, we can simplify the and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:142,Usability,simpl,simplify,142,"// and (icmp eq a, b), x implies (a==b) inside x.; // or (icmp ne a, b), x implies (a==b) inside x.; // If x simplifies to true/false, we can simplify the and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Usability,simpl,simplify,56,"// If we have and (icmp ne a, b), x and for a==b we can simplify x to false,; // then we can drop the icmp, as x will already be false in the case where; // the icmp is false. Similar for or and true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Testability,log,logic,20,"/// Given a bitwise logic op, check if the operands are add/sub with a common; /// source value and inverted constant (identity: C - X -> ~(X + ~C)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Energy Efficiency,power,power,24,// -A & A = A if A is a power of two or zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:63,Energy Efficiency,power,power-of-,63,// This is a similar pattern used for checking if a value is a power-of-2:; // (A - 1) & A --> 0 (if A is a power-of-2 or 0),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Energy Efficiency,power,power-of-,108,// This is a similar pattern used for checking if a value is a power-of-2:; // (A - 1) & A --> 0 (if A is a power-of-2 or 0),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Energy Efficiency,power,power,61,"// (x << N) & ((x << M) - 1) --> 0, where x is known to be a power of 2 and; // M <= N.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:5,Availability,mask,mask,5,// A mask that only clears known zeros of a shifted value is a no-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,clear,clears,20,// A mask that only clears known zeros of a shifted value is a no-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Availability,mask,mask,43,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:83,Availability,Mask,Mask,83,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Usability,clear,clear,52,"// If all bits in the inverted and shifted mask are clear:; // and (shl X, ShAmt), Mask --> shl X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Availability,mask,mask,43,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Availability,Mask,Mask,84,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Usability,clear,clear,52,"// If all bits in the inverted and shifted mask are clear:; // and (lshr X, ShAmt), Mask --> lshr X, ShAmt",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:53,Energy Efficiency,power,power,53,// Use getActiveBits() to make use of the additional power of two knowledge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Usability,simpl,simplifications,45,// And distributes over Or. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:46,Usability,simpl,simplifications,46,// And distributes over Xor. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:131,Availability,mask,mask,131,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:276,Availability,Mask,Mask,276,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:294,Availability,Mask,Mask,294,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:357,Availability,Mask,Mask,357,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:380,Availability,Mask,Mask,380,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:471,Performance,optimiz,optimize,471,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:431,Usability,Simpl,SimplifyDemandedBits,431,"// Assuming the effective width of Y is not larger than A, i.e. all bits; // from X and Y are disjoint in (X << A) | Y,; // if the mask of this AND op covers all bits of X or Y, while it covers; // no bits from the other, we can bypass this AND op. E.g.,; // ((X << A) | Y) & Mask -> Y,; // if Mask = ((1 << effective_width_of(Y)) - 1); // ((X << A) | Y) & Mask -> X << A,; // if Mask = ((1 << effective_width_of(X)) - 1) << A; // SimplifyDemandedBits in InstCombine can optimize the general case.; // This pattern aims to help other passes for a common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Availability,mask,mask,10,"// If the mask is extracting all bits from X or Y as is, we can skip; // this AND op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Testability,Log,LogicalAnd,39,// TODO: Many of these folds could use LogicalAnd/LogicalOr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:50,Testability,Log,LogicalOr,50,// TODO: Many of these folds could use LogicalAnd/LogicalOr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:23,Testability,Log,Logical,23,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,log,logic,66,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:123,Testability,Log,LogicalAnd,123,// The same is true of Logical And; // TODO: This could share the logic of the version above if there was a; // version of LogicalAnd that allowed more than just i1 types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:116,Availability,redundant,redundant,116,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:116,Safety,redund,redundant,116,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:50,Usability,simpl,simpler,50,"// A funnel shift (rotate) can be decomposed into simpler shifts. See if we; // are mixing in another shift that is redundant with the funnel shift.; // (fshl X, ?, Y) | (shl X, Y) --> fshl X, ?, Y; // (shl X, Y) | (fshl X, ?, Y) --> fshl X, ?, Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Usability,simpl,simplifications,45,// Or distributes over And. Try some generic simplifications based on this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:174,Safety,safe,safe,174,// (~A | B) ^ (A & B) --> ~A -- There are 8 commuted variants.; // The 'not' op must contain a complete -1 operand (no undef elements for; // vector) for the transform to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:20,Usability,simpl,simplifications,20,// Try some generic simplifications for associative operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:336,Usability,simpl,simplified,336,"// Threading Xor over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A ^ select(cond, B, C)"" means evaluating; // ""A^B"" and ""A^C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A^B"" and ""A^C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:390,Usability,simpl,simplified,390,"// Threading Xor over selects and phi nodes is pointless, so don't bother.; // Threading over the select in ""A ^ select(cond, B, C)"" means evaluating; // ""A^B"" and ""A^C"" and seeing if they are equal; but they are equal if and; // only if B and C are equal. If B and C are equal then (since we assume; // that operands have already been simplified) ""select(cond, B, C)"" should; // have been simplified to the common value of B and C already. Analysing; // ""A^B"" and ""A^C"" thus gains nothing, but costs compile time. Similarly; // for threading over phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:269,Performance,load,loaded,269,"// For allocas, we consider only static ones (dynamic; // allocas might be transformed into calls to malloc not simultaneously; // live with the compared-to allocation). For globals, we exclude symbols; // that might be resolve lazily to symbols in another dynamically-loaded; // library (and, thus, could be malloc'ed by the implementation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:529,Energy Efficiency,reduce,reduce,529,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Modifiability,variab,variables,10,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:117,Modifiability,variab,variables,117,"// Global variables always exist, so they always exist during the lifetime; // of each other and all allocas. Global variables themselves usually have; // non-overlapping storage, but since their addresses are constants, the; // case involving two globals does not reach here and is instead handled in; // constant folding.; //; // Two different allocas usually have different addresses...; //; // However, if there's an @llvm.stackrestore dynamically in between two; // allocas, they may have the same address. It's tempting to reduce the; // scope of the problem by only looking at *static* allocas here. That would; // cover the majority of allocas while significantly reducing the likelihood; // of having an @llvm.stackrestore pop up in the middle. However, it's not; // actually impossible for an @llvm.stackrestore to pop up in the middle of; // an entry block. Also, if we have a block that's not attached to a; // function, we can't tell if it's ""static"" under the current definition.; // Theoretically, this problem could be fixed by creating a new kind of; // instruction kind specifically for static allocas. Such a new instruction; // could be required to be at the top of the entry block, thus preventing it; // from being subject to a @llvm.stackrestore. Instcombine could even; // convert regular allocas into these special allocas. It'd be nifty.; // However, until then, this problem remains open.; //; // So, we'll assume that two non-empty allocas have different addresses; // for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:1375,Deployability,update,update,1375,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:17,Performance,optimiz,optimization,17,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:1434,Performance,optimiz,optimization,1434,"// A significant optimization not implemented here is assuming that alloca; // addresses are not equal to incoming argument values. They don't *alias*,; // as we say, but that doesn't mean they aren't equal, so we take a; // conservative approach.; //; // This is inspired in part by C++11 5.10p1:; // ""Two pointers of the same type compare equal if and only if they are both; // null, both point to the same function, or both represent the same; // address.""; //; // This is pretty permissive.; //; // It's also partly due to C11 6.5.9p6:; // ""Two pointers compare equal if and only if both are null pointers, both are; // pointers to the same object (including a pointer to an object and a; // subobject at its beginning) or function, both are pointers to one past the; // last element of the same array object, or one is a pointer to one past the; // end of one array object and the other is a pointer to the start of a; // different array object that happens to immediately follow the first array; // object in the address space.); //; // C11's version is more restrictive, however there's no reason why an argument; // couldn't be a one-past-the-end value for a stack object in the caller and be; // equal to the beginning of a stack object in the callee.; //; // If the C and C++ standards are ever made sufficiently restrictive in this; // area, it may be possible to update LLVM's semantics accordingly and reinstate; // this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:117,Integrability,wrap,wrapping,117,// We can only handle unsigned relational comparisons because 'inbounds' on; // a GEP only protects against unsigned wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:316,Performance,load,loads,316,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:519,Performance,optimiz,optimize,519,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:239,Safety,hazard,hazards,239,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Performance,optimiz,optimizations,11,// Various optimizations for (in)equality comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:208,Energy Efficiency,allocate,allocated,208,"// If one side of the equality comparison must come from a noalias call; // (meaning a system memory allocation function), and the other side must; // come from a pointer that cannot overlap with dynamically-allocated; // memory within the lifetime of the current function (allocas, byval; // arguments, globals), then determine the comparison result here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:201,Safety,safe,safely,201,"// Is the set of underlying objects all things which must be disjoint from; // noalias calls. We assume that indexing from such disjoint storage; // into the heap is undefined, and thus offsets can be safely ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:45,Modifiability,variab,variable,45,"// Comparison against value stored in global variable. Given the; // pointer does not escape, its value cannot be guessed and stored; // separately in a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:160,Modifiability,variab,variable,160,"// Comparison against value stored in global variable. Given the; // pointer does not escape, its value cannot be guessed and stored; // separately in a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:43,Energy Efficiency,reduce,reduced,43,// A boolean compared to true/false can be reduced in 14 out of the 20; // (10 predicates * 2 constants) possible combinations. The other; // 6 cases require a 'not' of the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Testability,log,logic,25,/// SLE follows the same logic as SGE with the LHS and RHS swapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Performance,optimiz,optimized,26,"// Sign-bit checks can be optimized to true/false after unsigned; // floating-point casts:; // icmp slt (bitcast (uitofp X)), 0 --> false; // icmp sgt (bitcast (uitofp X)), -1 --> true",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:126,Safety,avoid,avoid,126,/// TODO: A large part of this logic is duplicated in InstCombine's; /// foldICmpBinOp(). We should be able to share that and avoid the code; /// duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Testability,log,logic,31,/// TODO: A large part of this logic is duplicated in InstCombine's; /// foldICmpBinOp(). We should be able to share that and avoid the code; /// duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:14,Energy Efficiency,power,power-of-,14,// If C2 is a power-of-2 and C is not:; // (C2 << X) == C --> false; // (C2 << X) != C --> true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:82,Safety,unsafe,unsafe,82,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Safety,safe,safe,125,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:58,Usability,simpl,simplification,58,// C2 << X can equal zero in some circumstances.; // This simplification might be unsafe if C is zero.; //; // We know it is safe if:; // - The shift is nsw. We can't shift out the one bit.; // - The shift is nuw. We can't shift out the one bit.; // - C2 is one.; // - C isn't zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Energy Efficiency,power,power-of-,13,// If C is a power-of-2:; // (C << X) >u 0x8000 --> false; // (C << X) <=u 0x8000 --> true,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Usability,simpl,simplify,4,/// simplify integer comparisons where at least one operand of the compare; /// matches an integer min/max idiom.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,test,tested,66,"// Equivalent to ""A EqP B"". This may be the same as the condition tested; // in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// Otherwise, see if ""A EqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Testability,test,tested,73,"// Equivalent to ""A InvEqP B"". This may be the same as the condition; // tested in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// Otherwise, see if ""A InvEqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:66,Testability,test,tested,66,"// Equivalent to ""A EqP B"". This may be the same as the condition tested; // in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:31,Usability,simpl,simplifies,31,"// Otherwise, see if ""A EqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Testability,test,tested,73,"// Equivalent to ""A InvEqP B"". This may be the same as the condition; // tested in the max/min; if so, we can just return that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:34,Usability,simpl,simplifies,34,"// Otherwise, see if ""A InvEqP B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Usability,simpl,simplify,65,"// If both operands have range metadata, use the metadata; // to simplify the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Modifiability,extend,extended,65,"// Turn icmp (zext X), Cst into a compare of X and Cst if Cst is extended; // too. If not, then try to deduce the result of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Modifiability,extend,extended,13,// If the re-extended constant didn't change any of the elements then; // this is effectively also a case of comparing two zero-extended; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:128,Modifiability,extend,extended,128,// If the re-extended constant didn't change any of the elements then; // this is effectively also a case of comparing two zero-extended; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:65,Modifiability,extend,extended,65,"// Turn icmp (sext X), Cst into a compare of X and Cst if Cst is extended; // too. If not, then try to deduce the result of the comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Modifiability,extend,extended,13,// If the re-extended constant didn't change then this is effectively; // also a case of comparing two sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Modifiability,extend,extended,108,// If the re-extended constant didn't change then this is effectively; // also a case of comparing two sign-extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Availability,avail,available,110,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:52,Energy Efficiency,power,powerful,52,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Usability,Simpl,Simplify,3,"// Simplify comparisons of related pointers using a powerful, recursive; // GEP-walk when we have target data available..",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:97,Modifiability,variab,variable,97,"// Fold (un)ordered comparison if we can determine there are no NaNs.; //; // This catches the 2 variable input case, constants are handled below as a; // class-like compare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:48,Safety,Avoid,Avoid,48,// Lazily compute the possible classes for LHS. Avoid computing it twice if; // RHS is a 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:81,Performance,perform,perform,81,// Fold out compares that express a class test.; //; // FIXME: Should be able to perform folds without context; // instruction. Always pass in the context function?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:42,Testability,test,test,42,// Fold out compares that express a class test.; //; // FIXME: Should be able to perform folds without context; // instruction. Always pass in the context function?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Testability,test,test,110,"// TODO: Need version fcmpToClassTest which returns implied class when the; // compare isn't a complete class test. e.g. > 1.0 implies fcPositive, but; // isn't implementable as a class call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Usability,simpl,simplification,25,"// For vector types, the simplification must hold per-lane, so forbid; // potentially cross-lane operations like shufflevector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:9,Usability,simpl,simplify,9,// Don't simplify freeze.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,Safety,avoid,avoid,125,"// General InstSimplify functions may refine the result, e.g. by returning; // a constant for a potentially poison value. To avoid this, implement only; // a few non-refining but profitable transforms here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:111,Integrability,wrap,wraps,111,"// x - x -> 0, x ^ x -> 0. This is non-refining, because x is non-poison; // by assumption and this case never wraps, so nowrap flags can be; // ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:204,Safety,safe,safe,204,"// If we are substituting an absorber constant into a binop and extra; // poison can't leak if we remove the select -- because both operands of; // the binop are based on the same value -- then it may be safe to replace; // the value with the absorber constant. Examples:; // (Op == 0) ? 0 : (Op & -Op) --> Op & -Op; // (Op == 0) ? 0 : (Op * (binop Op, C)) --> Op * (binop Op, C); // (Op == -1) ? -1 : (Op | (binop C, Op) --> Op | (binop C, Op)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:423,Integrability,contract,contract,423,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Usability,simpl,simplification,7,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:300,Usability,simpl,simplifies,300,"// The simplification queries below may return the original value. Consider:; // %div = udiv i32 %arg, %arg2; // %mul = mul nsw i32 %div, %arg2; // %cmp = icmp eq i32 %mul, %arg; // %sel = select i1 %cmp, i32 %div, i32 undef; // Replacing %arg by %mul, %div becomes ""udiv i32 %mul, %arg2"", which; // simplifies back to %arg. This can only happen because %mul does not; // dominate %div. To ensure a consistent return value contract, we make sure; // that this case returns nullptr as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer comparison where one operand of the compare is a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:309,Energy Efficiency,reduce,reduces,309,"// (X > Y) ? X : max(X, Y) --> max(X, Y); // (X >= Y) ? X : max(X, Y) --> max(X, Y); // (X < Y) ? X : min(X, Y) --> min(X, Y); // (X <= Y) ? X : min(X, Y) --> min(X, Y); //; // The equivalence allows a vector select (shuffle) of max/min and Y. Ex:; // (X > Y) ? X : (Z ? max(X, Y) : Y); // If Z is true, this reduces as above, and if Z is false:; // (X > Y) ? X : Y --> max(X, Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:26,Testability,test,test,26,/// An alternative way to test if a bit is set or not uses sgt/slt instead of; /// eq/ne.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer equality comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is an; /// integer comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,Test,Test,3,// Test for a bogus zero-shift-guard-op around funnel-shift or rotate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:72,Safety,avoid,avoid,72,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:295,Safety,safe,safety,295,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,Test,Test,3,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:49,Testability,test,test,49,// Check for other compares that behave like bit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:157,Usability,simpl,simplifying,157,"// If we have a scalar equality comparison, then we know the value in one of; // the arms of the select. See if substituting this value into the arm and; // simplifying the result yields the same value as the other arm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Usability,simpl,simplify,11,/// Try to simplify a select instruction when its condition operand is a; /// floating-point comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Safety,safe,safe,21,"// This transform is safe if we do not have (do not care about) -0.0 or if; // at least one operand is known to not be -0.0. Otherwise, the select can; // change the sign of a zero operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Testability,log,logical-and,30,// Match patterns that end in logical-and.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Testability,log,logical-or,30,// Match patterns that end in logical-or.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:38,Testability,log,logical-and,38,"// select i1 X, i1 X, i1 false --> X (logical-and)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Testability,log,logical-or,37,"// select i1 X, i1 true, i1 X --> X (logical-or)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:135,Safety,safe,safe,135,"// If the elements match (undef or not), that value is the result. If only; // one element is undef, choose the defined element as the safe result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:38,Performance,perform,performs,38,"// All-zero GEP is a no-op, unless it performs a vector splat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,Safety,safe,safe,37,// The following transforms are only safe if the ptrtoint cast; // doesn't truncate the pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Safety,Avoid,Avoid,3,"// Avoid creating inttoptr of zero here: While LLVMs treatment of; // inttoptr is generally conservative, this particular case is folded to; // a null pointer, which will have incorrect provenance.; // gep (gep V, C), (sub 0, V) -> C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Safety,risk,risk,59,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:113,Usability,simpl,simplify,113,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:69,Modifiability,variab,variable,69,"// extractelt x, (insertelt y, elt, n), n -> elt; // If the possibly-variable indices are trivially known to be equal; // (because they are the same operand) then use the value that was; // inserted directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Performance,perform,perform,61,"// WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE; // here, because the PHI we may succeed simplifying to was not; // def-reachable from the original PHI!; // If all of the PHI's incoming values are the same then replace the PHI node; // with the common value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,Usability,simpl,simplifying,118,"// WARNING: no matter how worthwhile it may seem, we can not perform PHI CSE; // here, because the PHI we may succeed simplifying to was not; // def-reachable from the original PHI!; // If all of the PHI's incoming values are the same then replace the PHI node; // with the common value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,Safety,safe,safely,56,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,Availability,mask,mask,187,"/// For the given destination element of a shuffle, peek through shuffles to; /// match a root vector source operand that contains that element in the same; /// vector lane (ie, the same mask index), so we can eliminate the shuffle(s).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,Availability,mask,mask,19,// Bail out if any mask value is undefined. That kind of shuffle may be; // simplified further based on demanded bits or other folds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:76,Usability,simpl,simplified,76,// Bail out if any mask value is undefined. That kind of shuffle may be; // simplified further based on demanded bits or other folds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Availability,mask,mask,7,// The mask value chooses which source operand we need to look at next.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Availability,mask,mask,24,"// Canonicalization: If mask does not select elements from an input vector,; // replace that input vector with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:112,Availability,mask,mask,112,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Integrability,depend,depends,84,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:160,Performance,scalab,scalable,160,"// If all operands are constant, constant fold the shuffle. This; // transformation depends on the value of the mask which is not known at; // compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:139,Availability,mask,mask,139,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:111,Integrability,depend,depends,111,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:187,Performance,scalab,scalable,187,"// Canonicalization: if only one input vector is constant, it shall be the; // second one. This transformation depends on the value of the mask which; // is not known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:233,Availability,mask,mask,233,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:306,Availability,mask,mask,306,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:195,Deployability,update,updated,195,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:278,Integrability,depend,depends,278,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:354,Performance,scalab,scalable,354,"// A splat of an inserted scalar constant becomes a vector constant:; // shuf (inselt ?, C, IndexC), undef, <IndexC, IndexC...> --> <C, C...>; // NOTE: We may have commuted above, so analyze the updated Indices, not the; // original mask constant.; // NOTE: This transformation depends on the value of the mask which is not; // known at compile time for scalable vectors",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Availability,mask,mask,25,// Match a splat shuffle mask of the insert index allowing undef elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:11,Availability,mask,mask,11,// Shuffle mask poisons become poison constant result elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,Availability,mask,mask,59,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:32,Integrability,depend,depend,32,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:108,Performance,scalab,scalable,108,"// All remaining transformation depend on the value of the mask, which is; // not known at compile time for scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Availability,mask,mask,35,// Don't fold a shuffle with undef mask elements. This may get folded in a; // better way using demanded bits or other analysis.; // TODO: Should we allow this?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:171,Usability,simpl,simple,171,"// Check if every element of this shuffle can be mapped back to the; // corresponding element of a single root vector. If so, we don't need this; // shuffle. This handles simple identity shuffles as well as chains of; // shuffles that may widen/narrow and/or move elements across lanes and back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:118,Usability,simpl,simplify,118,"// Note that recursion is limited for each vector element, so if any element; // exceeds the limit, this will fail to simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:42,Usability,simpl,simple,42,"// If it is not a fixed vector, but not a simple NaN either, return a; // canonical NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:39,Performance,scalab,scalable,39,"// If we known this is a NaN, and it's scalable vector, we must have a splat; // on our hands. Grab that before splatting a QNaN constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Performance,Perform,Perform,4,/// Perform folds that are common to any floating-point operation. This implies; /// transforms based on poison/undef/NaN because the operation itself makes no; /// difference to the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:102,Usability,simpl,simplify,102,"// fadd X, -0 ==> X; // With strict/constrained FP, we have these possible edge cases that do; // not simplify to Op0:; // fadd SNaN, -0.0 --> QNaN; // fadd +0.0, -0.0 --> -0.0 (but only with round toward negative)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:13,Usability,simpl,simplifications,13,// Now apply simplifications that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,Safety,safe,safe,25,"// These cases should be safe, even with strictfp.; // ldexp(0.0, x) -> 0.0; // ldexp(-0.0, x) -> -0.0; // ldexp(inf, x) -> inf; // ldexp(-inf, x) -> -inf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:35,Energy Efficiency,power,power,35,// ctpop(X) -> 1 iff X is non-zero power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:7,Testability,log,log,7,// exp(log(x)) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Testability,log,log,3,// log(exp(x)) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:3,Usability,Simpl,Simple,3,"// Simple case, m(m(X,Y), X) => m(X, Y); // m(m(X,Y), Y) => m(X, Y); // For minimum/maximum, X is NaN => m(NaN, Y) == NaN and m(NaN, NaN) == NaN.; // For minimum/maximum, Y is NaN => m(X, NaN) == NaN and m(NaN, NaN) == NaN.; // For minnum/maxnum, X is NaN => m(NaN, Y) == Y and m(Y, Y) == Y.; // For minnum/maxnum, Y is NaN => m(X, NaN) == X and m(X, NaN) == X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:29,Usability,simpl,simplifications,29,// NOTE: We can't apply this simplifications based on the value of Op1; // because we need to preserve provenance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:19,Availability,mask,mask,19,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:61,Availability,mask,mask,61,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:75,Modifiability,extend,extended,75,// If index-width (mask size) is less than pointer-size then mask is; // 1-extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:18,Availability,mask,masking,18,// See if we only masking off bits we know are already zero due to; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Testability,test,tests,10,"// If all tests are made, it doesn't matter what the value is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:84,Usability,simpl,simplify,84,// Most of the intrinsics with no operands have some kind of side effect.; // Don't simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:10,Availability,mask,mask,10,"// If the mask is all zeros or undef, the ""passthru"" argument is the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:30,Usability,simpl,simplified,30,"// musttail calls can only be simplified if they are also DCEd.; // As we can't guarantee this here, don't simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:107,Usability,simpl,simplify,107,"// musttail calls can only be simplified if they are also DCEd.; // As we can't guarantee this here, don't simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:24,Performance,load,load,24,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:109,Testability,log,logic,109,// We can only fold the load if it is from a constant global with definitive; // initializer. Skip expensive logic if this is not the case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:28,Usability,simpl,simplified,28,"/// See if we can compute a simplified version of this instruction.; /// If not, this returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:6,Usability,simpl,simplifications,6,// No simplifications for Alloca and it can't be constant folded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,Safety,detect,detecting,110,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:157,Safety,safe,safe,157,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:55,Usability,simpl,simplify,55,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:159,Integrability,rout,routines,159,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:585,Integrability,rout,routine,585,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:32,Usability,simpl,simplification,32,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:144,Usability,simpl,simplification,144,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:191,Usability,simpl,simplified,191,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:212,Usability,Simpl,SimpleV,212,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:295,Usability,simpl,simply,295,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:369,Usability,simpl,simplify,369,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:463,Usability,simpl,simplified,463,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:623,Usability,simpl,simplifies,623,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:664,Usability,simpl,simplified,664,"/// Implementation of recursive simplification through an instruction's; /// uses.; ///; /// This is the common implementation of the recursive simplification routines.; /// If we have a pre-simplified value in 'SimpleV', that is forcibly used to; /// replace the instruction 'I'. Otherwise, we simply add 'I' to the list of; /// instructions to process and attempt to simplify it using; /// InstructionSimplify. Recursively visited users which could not be; /// simplified themselves are to the optional UnsimplifiedUsers set for; /// further processing by the caller.; ///; /// This routine returns 'true' only when *it* simplifies something. The passed; /// in simplified value does not count toward this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:73,Usability,simpl,simplification,73,"// If we have an explicit value to collapse to, do that round of the; // simplification loop by hand initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,Testability,test,test,21,"// Note that we must test the size on each iteration, the worklist can grow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:27,Usability,simpl,simplifies,27,// See if this instruction simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:89,Usability,simpl,simplifications,89,// Stash away all the uses of the old instruction so we can check them for; // recursive simplifications after a RAUW. This is cheaper than checking all; // uses of To on the recursive step in most cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp:49,Energy Efficiency,allocate,allocate,49,"// Just like in the no inference case, this will allocate an appropriately; // sized buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InteractiveModelRunner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:204,Deployability,release,releaseMemory,204,//===----------------------------------------------------------------------===//; // IntervalPartition Implementation; //===----------------------------------------------------------------------===//; // releaseMemory - Reset state back to before function was analyzed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:3,Deployability,update,updatePredecessors,3,"// updatePredecessors - Interval generation only sets the successor fields of; // the interval data structures. After interval generation is complete,; // run through all of the intervals and propagate successor info as; // predecessor info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp:36,Energy Efficiency,reduce,reduced,36,// IntervalPartition ctor - Build a reduced interval partition from an; // existing interval graph. This takes an additional boolean parameter to; // distinguish it from a copy constructor. Always pass in false for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:6,Security,hash,hash,6,"// To hash intrinsics, we use the opcode, and types like the other; // instructions, but also, the Intrinsic ID, and the Name of the; // intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:19,Performance,perform,performing,19,// Check if we are performing the same sort of operation on the same types; // but not on the same values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:95,Integrability,interface,interface,95,"// TODO: This is the same as the MachineOutliner, and should be consolidated; // into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:136,Testability,assert,assert,136,"// Setting the first and last instruction data pointers for the candidate. If; // we got through the entire for loop without hitting an assert, we know; // that both of these instructions are not nullptrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:342,Deployability,update,update,342,"// We are given two unsigned integers representing the global values of; // the operands in different IRSimilarityCandidates and a current mapping; // between the two.; //; // Source Operand GVN: 1; // Target Operand GVN: 2; // CurrentMapping: {1: {1, 2}}; //; // Since we have mapping, and the target operand is contained in the set, we; // update it to:; // CurrentMapping: {1: {2}}; // and can return true. But, if the mapping was; // CurrentMapping: {1: {3}}; // we would return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:50,Integrability,bridg,bridge,50,"// We're going to use the larger candidates as a ""bridge"" to create the; // canonical number for the target candidate since we have idetified two; // candidates as subsequences of larger sequences, and therefore must be; // structurally similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:45,Performance,perform,perform,45,"/// From the list of IRSimilarityCandidates, perform a comparison between each; /// IRSimilarityCandidate to determine if there are overlapping; /// IRInstructionData, or if they do not have the same structure.; ///; /// \param [in] CandsForRepSubstring - The vector containing the; /// IRSimilarityCandidates.; /// \param [out] StructuralGroups - the mapping of unsigned integers to vector; /// of IRSimilarityCandidates where each of the IRSimilarityCandidates in the; /// vector are structurally similar to one another.; /// \param [in] IndexToIncludedCand - Mapping of index of the an instruction in; /// a circuit to the IRSimilarityCandidates that include this instruction.; /// \param [in] CandToOverallGroup - Mapping of IRSimilarityCandidate to a; /// number representing the structural group assigned to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:430,Modifiability,variab,variables,430,"//===- llvm/Analysis/IVDescriptors.cpp - IndVar Descriptors -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file ""describes"" induction and recurrence variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:111,Availability,mask,mask,111,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:210,Availability,mask,mask,210,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:140,Deployability,update,updated,140,"/// Determines if Phi may have been type-promoted. If Phi has a single user; /// that ANDs the Phi with a type mask, return the user. RT is updated to; /// account for the narrower bit width represented by the mask, and the AND; /// instruction is added to CI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:65,Deployability,update,update,65,"// Matches either I & 2^x-1 or 2^x-1 & I. If we find a match, we update RT; // with a new integer type of the corresponding bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:130,Energy Efficiency,power,power,130,"// Use the demanded bits analysis to determine the bits that are live out; // of the exit instruction, rounding up to the nearest power of two. If the; // use of demanded bits results in a smaller bit width, we know the value; // must be positive (i.e., IsSigned = false), because if this were not the; // case, the sign bit would have been demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:95,Modifiability,extend,extended,95,"// Make sure at least one sign bit is included in the result, so it; // will get properly sign-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:212,Performance,load,loads,212,// The minimum width used by the recurrence is found by checking for; // casts on its operands. The minimum width is used by the vectorizer; // when finding the widest type for in-loop reductions without any; // loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:125,Safety,unsafe,unsafe,125,// Check if a given Phi node can be recognized as an ordered reduction for; // vectorizing floating point operations without unsafe math.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:13,Modifiability,variab,variables,13,// Reduction variables are only found in the loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:189,Modifiability,variab,variables,189,"// ExitInstruction is the single value which is used outside the loop.; // We only allow for a single reduction value to be used outside the loop.; // This includes users of the reduction, variables (which form a cycle; // which ends in the phi node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:3,Modifiability,Variab,Variable,3,// Variable to keep last visited store instruction. By the end of the; // algorithm this variable will be either empty or having intermediate; // reduction value stored in invariant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:89,Modifiability,variab,variable,89,// Variable to keep last visited store instruction. By the end of the; // algorithm this variable will be either empty or having intermediate; // reduction value stored in invariant address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:150,Modifiability,variab,variables,150,// We start with the PHI node and scan for all of the users of this; // instruction. All users must be instructions that can be used as reduction; // variables (such as ADD). We must have a single out-of-block user. The cycle; // must include the original PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:193,Performance,perform,performed,193,"// Return early if the recurrence kind does not match the type of Phi. If the; // recurrence kind is arithmetic, we attempt to look through AND operations; // resulting from the type promotion performed by InstCombine. Vector; // operations are not limited to the legal integer widths, so we may be able; // to evaluate the reduction in the narrower width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:126,Safety,safe,safe,126,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:176,Safety,safe,safe,176,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:243,Safety,safe,safe,243,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:271,Safety,safe,safe,271,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:320,Safety,safe,safe,320,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:486,Safety,safe,safe,486,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:726,Safety,safe,safe,726,"// A value in the reduction can be used:; // - By the reduction:; // - Reduction operation:; // - One use of reduction value (safe).; // - Multiple use of reduction value (not safe).; // - PHI:; // - All uses of the PHI must be the reduction (safe).; // - Otherwise, not safe.; // - By instructions outside of the loop (safe).; // * One value may have several outside users, but all outside; // uses must be of the same value.; // - By store instructions with a loop invariant address (safe with; // the following restrictions):; // * If there are several stores, all must have the same address.; // * Final value should be stored in that loop invariant address.; // - By an instruction that is not part of the reduction (not safe).; // This is either:; // * An instruction type other than PHI or the reduction operation.; // * A PHI in the header other than the initial PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:106,Modifiability,variab,variable,106,// No Users.; // If the instruction has no users then this is a broken chain and can't be; // a reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:100,Modifiability,variab,variable,100,"// Reductions of instructions such as Div, and Sub is only possible if the; // LHS is the reduction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:3,Deployability,Update,Update,3,// Update this reduction kind if we matched a new instruction.; // TODO: Can we eliminate the need for a 2nd InstDesc by keeping 'Kind'; // state accurate while processing the worklist?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:13,Modifiability,variab,variable,13,// Reduction variable chain can only be stored somewhere but it; // can't be used as an address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:1055,Modifiability,extend,extend,1055,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:1256,Modifiability,rewrite,rewrite,1256,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:875,Performance,perform,perform,875,"// If the starting value is not the same as the phi node, we speculatively; // looked through an 'and' instruction when evaluating a potential; // arithmetic reduction to determine if it may have been type-promoted.; //; // We now compute the minimal bit width that is required to represent the; // reduction. If this is the same width that was indicated by the 'and', we; // can represent the reduction in the smaller type. The 'and' instruction; // will be eliminated since it will essentially be a cast instruction that; // can be ignore in the cost model. If we compute a different type than we; // did when evaluating the 'and', the 'and' will not be eliminated, and we; // will end up with different kinds of operations in the recurrence; // expression (e.g., IntegerAND, IntegerADD). We give up if this is; // the case.; //; // The vectorizer relies on InstCombine to perform the actual; // type-shrinking. It does this by inserting instructions to truncate the; // exit value of the reduction to the width indicated by RecurrenceType and; // then extend this value back to the original width. If IsSigned is false,; // a 'zext' instruction will be generated; otherwise, a 'sext' will be; // used.; //; // TODO: We should not rely on InstCombine to rewrite the reduction in the; // smaller type. We should just generate a correctly typed expression; // to begin with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:809,Usability,simpl,simple,809,"// Collect cast instructions and the minimum width used by the recurrence.; // If the starting value is not the same as the phi node and the computed; // recurrence type is equal to the recurrence type, the recurrence expression; // will be represented in a narrower or wider type. If there are any cast; // instructions that will be unnecessary, collect them in CastsFromRecurTy.; // Note that the 'and' instruction was already included in this list.; //; // TODO: A better way to represent this may be to tag in some way all the; // instructions that are a part of the reduction. The vectorizer cost; // model could then apply the recurrence type to these instructions,; // without needing a white list of instructions to ignore.; // This may also be useful for the inloop reductions, if it can be; // kept simple enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:308,Modifiability,variab,variable,308,// We found a reduction var if we have reached the original phi node and we; // only have a single instruction with out-of-loop users.; // The ExitInstruction(Instruction which is allowed to have out-of-loop users); // is saved as part of the RecurrenceDescriptor.; // Save the description of this reduction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:803,Usability,simpl,simply,803,"// We are looking for loops that do something like this:; // int r = 0;; // for (int i = 0; i < n; i++) {; // if (src[i] > 3); // r = 3;; // }; // where the reduction value (r) only has two states, in this example 0 or 3.; // The generated LLVM IR for this type of loop will be like this:; // for.body:; // %r = phi i32 [ %spec.select, %for.body ], [ 0, %entry ]; // ...; // %cmp = icmp sgt i32 %5, 3; // %spec.select = select i1 %cmp, i32 3, i32 %r; // ...; // In general we can support vectorization of loops where 'r' flips between; // any two non-constants, provided they are loop invariant. The only thing; // we actually care about at the end of the loop is whether or not any lane; // in the selected vector is different from the start value. The final; // across-vector reduction after the loop simply involves choosing the start; // value if nothing changed (0 in the example above) or the other selected; // value (3 in the example above).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:259,Modifiability,extend,extending,259,// Ensure every user of the phi node (recursively) is dominated by the; // previous value. The dominance requirement ensures the loop vectorizer will; // not need to vectorize the initial value prior to the first iteration of the; // loop.; // TODO: Consider extending this sinking to handle memory instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:10,Integrability,depend,dependence,10,// Cyclic dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:10,Availability,down,down,10,"// Search down from the Phi to the LoopExitInstr, looking for instructions; // with a single user of the correct type for the reduction.; // Note that we check that the type of the operand is correct for each item in; // the chain, including the last (the loop exit value). This can come up from; // sub, which would otherwise be treated as an add reduction. MinMax also need; // to check for a pair of icmp/select, for which we use getNextInstruction and; // isCorrectOpcode functions to step the right number of instruction, and; // check the icmp/select pair.; // FIXME: We also do not attempt to look through Select's yet, which might; // be part of the reduction chain, or attempt to looks through And's to find a; // smaller bitwidth. Subs are also currently not allowed (which are usually; // treated as part of a add reduction) as they are expected to generally be; // more expensive than out-of-loop reductions, and need to be costed more; // carefully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:56,Testability,test,test,56,"// The loop exit instruction we check first (as a quick test) but add last. We; // check the opcode is correct (and dont allow them to be Subs) and that they; // have expected to have the expected number of uses. They will have one use; // from the phi and one from a LCSSA value, no matter the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:36,Modifiability,variab,variables,36,// Here we only handle FP induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,Availability,redundant,redundant,142,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:53,Deployability,update,update-chain,53,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:441,Deployability,update,update-chain,441,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:217,Modifiability,rewrite,rewriter,217,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,Safety,redund,redundant,142,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:386,Modifiability,extend,extended,386,"// Find any cast instructions that participate in the def-use chain of; // PhiScev in the loop.; // FORNOW/TODO: We currently expect the def-use chain to include only; // two-operand instructions, where one of the operands is an invariant.; // createAddRecFromPHIWithCasts() currently does not support anything more; // involved than that, so we keep the search simple. This can be; // extended/generalized as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:362,Usability,simpl,simple,362,"// Find any cast instructions that participate in the def-use chain of; // PhiScev in the loop.; // FORNOW/TODO: We currently expect the def-use chain to include only; // two-operand instructions, where one of the operands is an invariant.; // createAddRecFromPHIWithCasts() currently does not support anything more; // involved than that, so we keep the search simple. This can be; // extended/generalized as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:41,Modifiability,variab,variables,41,// Handle integer and pointer inductions variables.; // Now we handle also FP induction but not trying to make a; // recurrent expression from the PHI node in-place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:66,Deployability,update,update,66,// Record any Cast instructions that participate in the induction update,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:49,Modifiability,variab,variables,49,// We only handle integer and pointer inductions variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:137,Testability,assert,assert,137,"// This function assumes that InductionPhi is called only on Phi nodes; // present inside loop headers. Check for the same, and throw an assert if; // the current Phi is not present inside the loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:25,Modifiability,variab,variables,25,// This allows induction variables w/non-constant steps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:31,Modifiability,Variab,Variable,31,"//===- IVUsers.cpp - Induction Variable Users -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:483,Modifiability,variab,variables,483,"//===- IVUsers.cpp - Induction Variable Users -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:20,Testability,Test,Test,20,"/// isInteresting - Test whether the given expression is ""interesting"" when; /// used by the given expression, within the context of analyzing the; /// given loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:15,Usability,simpl,simple,15,// Keep things simple. Don't touch loop-variant strides unless they're; // only used outside the loop and we can simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:113,Usability,simpl,simplify,113,// Keep things simple. Don't touch loop-variant strides unless they're; // only used outside the loop and we can simplify them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:37,Energy Efficiency,reduce,reduced,37,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:117,Safety,safe,safe,117,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:171,Safety,safe,safe,171,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:232,Safety,safe,safe,232,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:79,Safety,avoid,avoid,79,"// LSR is not APInt clean, do not touch integers bigger than 64-bits.; // Also avoid creating IVs of non-native types. For example, we don't want a; // 64-bit IV in 32-bit code just because the loop has one 64-bit cast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:162,Integrability,depend,depend,162,"// Descend recursively, but not into PHI nodes outside the current loop.; // It's important to see the entire expression outside the loop to get; // choices that depend on addressing mode use right, although we won't; // consider references outside the loop in all cases.; // If User is already in Processed, we don't want to recurse into it again,; // but do want to record a second reference in the same instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:40,Energy Efficiency,reduce,reduce,40,"// Okay, we found a user that we cannot reduce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:121,Integrability,wrap,wrapping,121,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:36,Usability,simpl,simplifies,36,// PostIncNormalization effectively simplifies the expression under; // pre-increment assumptions. Those assumptions (no wrapping) might not; // hold for the post-inc value. Catch such cases by making sure the; // transformation is invertible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:30,Modifiability,variab,variables,30,"// Find all uses of induction variables in this loop, and categorize; // them by stride. Start by finding all of the PHI nodes in the header for; // this loop. If they are induction variables, inspect their uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:182,Modifiability,variab,variables,182,"// Find all uses of induction variables in this loop, and categorize; // them by stride. Start by finding all of the PHI nodes in the header for; // this loop. If they are induction variables, inspect their uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBlockFrequencyInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:25,Availability,avail,available,25,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:46,Availability,avail,available,46,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:82,Testability,assert,asserts,82,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp:170,Testability,assert,assert,170,"// We require DT so it's available when LI is available. The LI updating code; // asserts that DT is also present so if we don't make sure that we have DT; // here, that assert will trigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyBranchProbabilityInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:540,Performance,optimiz,optimizations,540,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:994,Performance,optimiz,optimizing,994,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:984,Safety,safe,safety,984,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:848,Testability,test,test,848,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Walk down the graph until we run out of edges or find a path to TargetC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:521,Availability,down,downward,521,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:24,Deployability,update,updates,24,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:370,Deployability,update,updates,370,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:2626,Deployability,Update,Updates,2626,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3093,Deployability,update,update,3093,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:357,Integrability,rout,routine,357,"/// Generic helper that updates a postorder sequence of SCCs for a potentially; /// cycle-introducing edge insertion.; ///; /// A postorder sequence of SCCs of a directed graph has one fundamental; /// property: all deges in the DAG of SCCs point ""up"" the sequence. That is,; /// all edges in the SCC DAG point to prior SCCs in the sequence.; ///; /// This routine both updates a postorder sequence and uses that sequence to; /// compute the set of SCCs connected into a cycle. It should only be called to; /// insert a ""downward"" edge which will require changing the sequence to; /// restore it to a postorder.; ///; /// When inserting an edge from an earlier SCC to a later SCC in some postorder; /// sequence, all of the SCCs which may be impacted are in the closed range of; /// those two within the postorder sequence. The algorithm used here to restore; /// the state is as follows:; ///; /// 1) Starting from the source SCC, construct a set of SCCs which reach the; /// source SCC consisting of just the source SCC. Then scan toward the; /// target SCC in postorder and for each SCC, if it has an edge to an SCC; /// in the set, add it to the set. Otherwise, the source SCC is not; /// a successor, move it in the postorder sequence to immediately before; /// the source SCC, shifting the source SCC and all SCCs in the set one; /// position toward the target SCC. Stop scanning after processing the; /// target SCC.; /// 2) If the source SCC is now past the target SCC in the postorder sequence,; /// and thus the new edge will flow toward the start, we are done.; /// 3) Otherwise, starting from the target SCC, walk all edges which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3015,Integrability,rout,routine,3015,"s which reach an; /// SCC between the source and the target, and add them to the set of; /// connected SCCs, then recurse through them. Once a complete set of the; /// SCCs the target connects to is known, hoist the remaining SCCs between; /// the source and the target to be above the target. Note that there is no; /// need to process the source SCC, it is already known to connect.; /// 4) At this point, all of the SCCs in the closed range between the source; /// SCC and the target SCC in the postorder sequence are connected,; /// including the target SCC and the source SCC. Inserting the edge from; /// the source SCC to the target SCC will form a cycle out of precisely; /// these SCCs. Thus we can merge all of the SCCs in this closed range into; /// a single SCC.; ///; /// This process has various important properties:; /// - Only mutates the SCCs when adding the edge actually changes the SCC; /// structure.; /// - Never mutates SCCs which are unaffected by the change.; /// - Updates the postorder sequence to correctly satisfy the postorder; /// constraint after the edge is inserted.; /// - Only reorders SCCs in the closed postorder sequence from the source to; /// the target, so easy to bound how much has changed even in the ordering.; /// - Big-O is the number of edges in the closed postorder range of SCCs from; /// source to target.; ///; /// This helper routine, in addition to updating the postorder sequence itself; /// will also update a map from SCCs to indices within that sequence.; ///; /// The sequence and the map must operate on pointers to the SCC type.; ///; /// Two callbacks must be provided. The first computes the subset of SCCs in; /// the postorder closed range from the source to the target which connect to; /// the source SCC via some (transitive) set of edges. The second computes the; /// subset of the same range which the target SCC connects to via some; /// (transitive) set of edges. Both callbacks should populate the set argument; /// provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,Safety,detect,detect,59,"// At this point we leverage the postorder list of SCCs to detect when the; // insertion of an edge changes the SCC structure in any way.; //; // First and foremost, we can eliminate the need for any changes when the; // edge is toward the beginning of the postorder sequence because all edges; // flow in that direction already. Thus adding a new one cannot form a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:27,Deployability,update,update,27,// Use a generic helper to update the postorder sequence of SCCs and return; // a range of any SCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:156,Integrability,rout,routine,156,// Use a generic helper to update the postorder sequence of SCCs and return; // a range of any SCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:83,Deployability,update,updates,83,"// Before merging, check that the RefSCC remains valid after all the; // postorder updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:43,Deployability,update,update,43,// Erase the merged SCCs from the list and update the indices of the; // remaining SCCs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:339,Safety,detect,detect,339,"// Force the target node to be in the old SCC. This also enables us to take; // a very significant short-cut in the standard Tarjan walk to re-form SCCs; // below: whenever we build an edge that reaches the target node, we know; // that the target node eventually connects back to all other nodes in our; // walk. As a consequence, we can detect and handle participants in that; // cycle without walking all the edges that form this connection, and instead; // by relying on the fundamental guarantee coming into this operation (all; // nodes are reachable from the target due to previously forming an SCC).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Scan down the stack and DFS across the call edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Cleared,3,"// Cleared the DFS early, start another round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:46,Usability,clear,clear,46,// Form a new SCC out of these nodes and then clear them off our pending; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,"// Update the mapping from SCC* to index to use the new SCC*s, and remove the; // old SCC from the mapping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:27,Deployability,update,update,27,// Use a generic helper to update the postorder sequence of RefSCCs and return; // a range of any RefSCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:162,Integrability,rout,routine,162,// Use a generic helper to update the postorder sequence of RefSCCs and return; // a range of any RefSCCs connected into a cycle by inserting this edge. This; // routine will also take care of updating the indices into the postorder; // sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:34,Testability,test,tests,34,"// Build a set, so we can do fast tests for whether a RefSCC will end up as; // part of the merged RefSCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:26,Deployability,update,update,26,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:80,Deployability,update,update,80,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:146,Safety,avoid,avoid,146,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:91,Deployability,Update,Update,91,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:157,Safety,avoid,avoid,157,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update this node and keep scanning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:219,Energy Efficiency,efficient,efficiently,219,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:202,Integrability,rout,routine,202,"// If we find a cycle containing all nodes originally in this RefSCC then; // the removal hasn't changed the structure at all. This is an important; // special case, and we can directly exit the entire routine more; // efficiently as soon as we discover it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Clear,3,// Clear out the low link field as we won't need it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:80,Usability,clear,clear,80,// We've already marked the nodes internally with the RefSCC number so; // just clear them off the stack and continue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Usability,Clear,Clear,3,// Clear out all the SCC's node's low-link fields now that we're done; // using them as side-storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:53,Usability,clear,clear,53,"// Now that we've moved things into the new RefSCCs, clear out our current; // one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:25,Deployability,update,update,25,"// Already an edge, just update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update various call graph maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:3,Deployability,Update,Update,3,// Update lib functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:152,Security,Validat,Validate,152,"// This node must be the only member of its SCC as it has no callers, and; // that SCC must be the only member of a RefSCC as it has no references.; // Validate these properties first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:59,Availability,down,down,59,"// Finally clear out all the data structures from the node down through the; // components. postorder_ref_scc_iterator will skip empty RefSCCs, so no need; // to adjust LazyCallGraph data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:11,Usability,clear,clear,11,"// Finally clear out all the data structures from the node down through the; // components. postorder_ref_scc_iterator will skip empty RefSCCs, so no need; // to adjust LazyCallGraph data structures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:44,Energy Efficiency,allocate,allocated,44,// Nothing to delete as all the objects are allocated in stable bump pointer; // allocators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:99,Testability,Assert,Asserts,99,// Gets the Edge::Kind from one function to another by looking at the function's; // instructions. Asserts if there is no edge.; // Useful for determining what type of edge should exist between functions when; // the edge hasn't been created yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:6,Deployability,release,release,6,"// In release builds, assume that if there are no direct calls to the new; // function, then there is a ref edge. In debug builds, keep track of; // references to assert that there is actually a ref edge if there is no call; // edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:163,Testability,assert,assert,163,"// In release builds, assume that if there are no direct calls to the new; // function, then there is a ref edge. In debug builds, keep track of; // references to assert that there is actually a ref edge if there is no call; // edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:24,Deployability,update,update,24,"// Walk the node map to update their graph pointers. While this iterates in; // an unstable order, the order has no effect, so it remains correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:8,Availability,down,down,8,// Scan down the stack and DFS across the call edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:47,Availability,down,down,47,// Find the range of the node stack by walking down until we pass the; // root DFS number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:46,Usability,clear,clear,46,// Form a new SCC out of these nodes and then clear them off our pending; // stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:121,Deployability,update,updates,121,/// Build the internal SCCs for a RefSCC from a sequence of nodes.; ///; /// Appends the SCCs to the provided vector and updates the map with their; /// indices. Both the vector and map must be empty when passed into this; /// routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:227,Integrability,rout,routine,227,/// Build the internal SCCs for a RefSCC from a sequence of nodes.; ///; /// Appends the SCCs to the provided vector and updates the map with their; /// indices. Both the vector and map must be empty when passed into this; /// routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:43,Usability,clear,clear,43,"// This node will go into the next RefSCC, clear out its DFS and low link; // as we scan.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:405,Integrability,interface,interface,405,"//===- LazyValueInfo.cpp - Value constraint analysis ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for lazy computation of value constraint; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:900,Modifiability,enhance,enhancement,900,"/// Combine two sets of facts about the same value into a single set of; /// facts. Note that this method is not suitable for merging facts along; /// different paths in a CFG; that's what the mergeIn function is for. This; /// is for merging facts gathered about the same value at the same location; /// through two independent means.; /// Notes:; /// * This method does not promise to return the most precise possible lattice; /// value implied by A and B. It is allowed to return any lattice element; /// which is at least as strong as *either* A or B (unless our facts; /// conflict, see below).; /// * Due to unreachable code, the intersection of two lattice values could be; /// contradictory. If this happens, we return some valid lattice value so as; /// not confuse the rest of LVI. Ideally, we'd always return Undefined, but; /// we do not make this guarantee. TODO: This would be a useful enhancement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:68,Integrability,depend,depending,68,// Note: An empty range is implicitly converted to unknown or undef depending; // on MayIncludeUndef internally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:28,Deployability,update,updates,28,/// A callback value handle updates the cache when values are erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:40,Performance,cache,cache,40,/// A callback value handle updates the cache when values are erased.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Performance,cache,cache,16,/// This is the cache kept by LazyValueInfo which; /// maintains information about queries across the clients' queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:169,Energy Efficiency,reduce,reduce,169,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Performance,cache,cached,23,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:247,Performance,cache,cached,247,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Performance,Cache,Cached,4,/// Cached information per basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// Set of value handles used to erase values from the cache on deletion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:54,Energy Efficiency,reduce,reduce,54,// Insert over-defined values into their own cache to reduce memory; // overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:45,Performance,cache,cache,45,// Insert over-defined values into their own cache to reduce memory; // overhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Performance,cache,cache,22,/// clear - Empty the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Usability,clear,clear,4,/// clear - Empty the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:15,Performance,cache,cache,15,/// Inform the cache that a given value has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Deployability,Update,Updates,4,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Performance,cache,cache,16,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Performance,cache,cache,173,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:200,Deployability,update,update,200,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:266,Performance,cache,cache,266,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:391,Performance,cache,cached,391,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:237,Usability,clear,clear,237,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:367,Usability,simpl,simple,367,"// When an edge in the graph has been threaded, values that we could not; // determine a value for before (i.e. were marked overdefined) may be; // possible to solve now. We do NOT try to proactively update these values.; // Instead, we clear their entries from the cache, and allow lazy updating to; // recompute them when needed.; // The updating process is fairly simple: we need to drop cached info; // for all values that were marked overdefined in OldSucc, and for those same; // values in any successor of OldSucc (except NewSucc) in which they were; // also marked overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:21,Performance,perform,perform,21,"// Use a worklist to perform a depth-first search of OldSucc's successors.; // NOTE: We do not need a visited list since any blocks we have already; // visited will have had their overdefined markers cleared already, and we; // thus won't loop to their successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:200,Usability,clear,cleared,200,"// Use a worklist to perform a depth-first search of OldSucc's successors.; // NOTE: We do not need a visited list since any blocks we have already; // visited will have had their overdefined markers cleared already, and we; // thus won't loop to their successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,Security,access,accessible,20,// Skip blocks only accessible through NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Deployability,update,update,55,"// If we removed anything, then we potentially need to update; // blocks successors too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:68,Deployability,update,update,68,// namespace; // The actual implementation of the lazy analysis and update. Note that the; // inheritance from LazyValueInfoCache is intended to be temporary while; // splitting the code and then transitioning to a has-a relationship.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:94,Modifiability,inherit,inheritance,94,// namespace; // The actual implementation of the lazy analysis and update. Note that the; // inheritance from LazyValueInfoCache is intended to be temporary while; // splitting the code and then transitioning to a has-a relationship.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Performance,Cache,Cached,4,/// Cached results from previous queries,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Performance,cache,cache,22,///< A pointer to the cache of @llvm.assume calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,/// This is the query interface to determine the lattice value for the; /// specified Value* at the context instruction (if specified) or at the; /// start of the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,"/// This is the query interface to determine the lattice value for the; /// specified Value* at the specified instruction using only information; /// from assumes/guards and range metadata. Unlike getValueInBlock(), no; /// recursive query is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:243,Performance,perform,performed,243,"/// This is the query interface to determine the lattice value for the; /// specified Value* at the specified instruction using only information; /// from assumes/guards and range metadata. Unlike getValueInBlock(), no; /// recursive query is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,Integrability,interface,interface,22,/// This is the query interface to determine the lattice; /// value for the specified Value* that is true on the specified edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:99,Performance,cache,cache,99,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:24,Deployability,update,update,24,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:31,Integrability,interface,interface,31,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Performance,cache,cache,55,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,Deployability,update,update,16,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Integrability,interface,interface,23,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:47,Performance,cache,cache,47,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:122,Performance,cache,cache,122,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:313,Performance,cache,cached,313,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:538,Performance,cache,cache,538,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:568,Performance,throttle,throttle,568,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:3,Safety,Abort,Abort,3,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:161,Safety,avoid,avoid,161,"// Abort if we have to process too many values to get a result for this one.; // Because of the design of the overdefined cache currently being per-block; // to avoid naming-related issues (IE it wants to try to give different; // results for the same name in different blocks), overdefined results don't; // get cached globally, which in turn means we will often try to rediscover; // the same overdefined result again and again. Once something like; // PredicateInfo is used in LVI or CVP, we should be able to make the; // overdefined cache global, and remove this throttle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:42,Performance,Cache,Cache,42,// Hold off inserting this value into the Cache in case we have to return; // false and come back later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:183,Modifiability,extend,extend,183,"// If this value is a nonnull pointer, record it's range and bailout. Note; // that for all other pointer typed values, we terminate the search at the; // definition. We could easily extend this to look through geps, bitcasts,; // and the like to prove non-nullness, but it's not clear that's worth it; // compile time wise. The context-insensitive value walk done inside; // isKnownNonZero gets most of the profitable cases at much less expense.; // This does mean that we have a sensitivity to where the defining; // instruction is placed, even if it could legally be hoisted much higher.; // That is unfortunate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:280,Usability,clear,clear,280,"// If this value is a nonnull pointer, record it's range and bailout. Note; // that for all other pointer typed values, we terminate the search at the; // definition. We could easily extend this to look through geps, bitcasts,; // and the like to prove non-nullness, but it's not clear that's worth it; // compile time wise. The context-insensitive value walk done inside; // isKnownNonZero gets most of the profitable cases at much less expense.; // This does mean that we have a sensitivity to where the defining; // instruction is placed, even if it could legally be hoisted much higher.; // That is unfortunate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:105,Performance,cache,cached,105,"// Note that we can provide PN as the context value to getEdgeValue, even; // though the results will be cached, because PN is the value being used as; // the cache key in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:159,Performance,cache,cache,159,"// Note that we can provide PN as the context value to getEdgeValue, even; // though the results will be cached, because PN is the value being used as; // the cache key in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:50,Safety,Avoid,Avoid,50,// Is this a min specifically of our two inputs? (Avoid the risk of; // ValueTracking getting smarter looking back past our immediate inputs.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:60,Safety,risk,risk,60,// Is this a min specifically of our two inputs? (Avoid the risk of; // ValueTracking getting smarter looking back past our immediate inputs.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,Usability,simpl,simplification,55,// Handle extractvalue of insertvalue to allow further simplification; // based on replaced with.overflow intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Availability,Mask,Mask,13,// If (Val & Mask) == C then all the masked bits are known and we can; // compute a value range based on that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:37,Availability,mask,masked,37,// If (Val & Mask) == C then all the masked bits are known and we can; // compute a value range based on that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:13,Availability,Mask,Mask,13,// If (Val & Mask) != 0 then the value must be larger than the lowest set; // bit of Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:85,Availability,Mask,Mask,85,// If (Val & Mask) != 0 then the value must be larger than the lowest set; // bit of Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Usability,simpl,simplified,23,"// Check if Usr can be simplified to an integer constant when the value of one; // of its operands Op is an integer constant OpConstVal. If so, return it as an; // lattice value range with a single element or otherwise return an overdefined; // lattice value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,Usability,simpl,simplified,23,// Check if Usr can be simplified to a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:45,Safety,avoid,avoid,45,// Check with isOperationFoldable() first to avoid linearly iterating; // over the operands unnecessarily which can be expensive for; // instructions with many operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,Integrability,inject,injective,376,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:95,Performance,perform,perform,95,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,Security,inject,injective,376,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:183,Performance,cache,cached,183,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:242,Performance,cache,cached,242,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:560,Performance,cache,cached,560,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:110,Usability,simpl,simplify,110,"// We can use the context instruction (generically the ultimate instruction; // the calling pass is trying to simplify) here, even though the result of; // this function is generally cached when called from the solve* functions; // (and that cached result might be used with queries using a different; // context instruction), because when this function is called from the solve*; // functions, the context instruction is not provided. When called from; // LazyValueInfoImpl::getValueOnEdge, the context instruction is provided,; // but then the result is not cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,Energy Efficiency,allocate,allocated,20,"// If the cache was allocated, free it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:10,Performance,cache,cache,10,"// If the cache was allocated, free it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:113,Integrability,depend,dependencies,113,// We need to invalidate if we have either failed to preserve this analyses; // result directly or if any of its dependencies have been invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:364,Safety,avoid,avoiding,364,"/// Returns true if we can statically tell that this value will never be a; /// ""useful"" constant. In practice, this means we've got something like an; /// alloca or a malloc call for which a comparison against a constant can; /// only be guarding dead code. Note that we are potentially giving up some; /// precision in dead code (a constant result) in favour of avoiding a; /// expensive search for a easily answered common query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:927,Modifiability,extend,extending,927,"// Note: The following bit of code is somewhat distinct from the rest of LVI;; // LVI as a whole tries to compute a lattice value which is conservatively; // correct at a given location. In this case, we have a predicate which we; // weren't able to prove about the merged result, and we're pushing that; // predicate back along each incoming edge to see if we can prove it; // separately for each input. As a motivating example, consider:; // bb1:; // %v1 = ... ; constantrange<1, 5>; // br label %merge; // bb2:; // %v2 = ... ; constantrange<10, 20>; // br label %merge; // merge:; // %phi = phi [%v1, %v2] ; constantrange<1,20>; // %pred = icmp eq i32 %phi, 8; // We can't tell from the lattice value for '%phi' that '%pred' is false; // along each path, but by checking the predicate over each input separately,; // we can.; // We limit the search to one step backwards from the current BB and value.; // We could consider extending this to search further backwards through the; // CFG and/or value graph, but there are non-obvious compile time vs quality; // tradeoffs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:51,Safety,avoid,avoid,51,// Function entry or an unreachable block. Bail to avoid confusing; // analysis below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:209,Performance,cache,cached,209,"// This function prints the LVI analysis for the instruction I at the beginning; // of various basic blocks. It relies on calculated values that are stored in; // the LazyValueInfoCache, and in the absence of cached values, recalculate the; // LazyValueInfo for `I`, and print that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Availability,redundant,redundant,173,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:108,Safety,avoid,avoid,108,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:173,Safety,redund,redundant,173,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:36,Availability,error,errors,36,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1251,Performance,Optimiz,Optimization,1251,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1349,Performance,optimiz,optimization,1349,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1427,Performance,optimiz,optimization,1427,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:58,Integrability,message,message,58,"/// A check failed, so printout out the condition and the message.; ///; /// This provides a nice place to put a breakpoint if you want to see why; /// something is not correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:68,Integrability,Message,Message-only,68,/// A check failed (with values to print).; ///; /// This calls the Message-only version so that the above is easier to set; /// a breakpoint on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:89,Availability,error,error,89,"// end anonymous namespace; // Check - We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:95,Integrability,message,message,95,"// end anonymous namespace; // Check - We know that cond should be true, if not print an error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:48,Integrability,depend,dependence,48,"// If both arguments are readonly, they have no dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:159,Modifiability,variab,variable,159,// Check for buffer overflows and misalignment.; // Only handles memory references that read/write something simple like an; // alloca instruction or a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:109,Usability,simpl,simple,109,// Check for buffer overflows and misalignment.; // Only handles memory references that read/write something simple like an; // alloca instruction or a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:14,Security,access,access,14,"// OK, so the access is to a constant offset from Ptr. Check that Ptr is; // something we can handle and if so extract the size of this base object; // along with its alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:111,Security,access,accesses,111,// If the global may be defined differently in another compilation unit; // then don't warn about funky memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Security,Access,Accesses,3,// Accesses from before the start or after the end of the object are not; // defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Security,Access,Accesses,3,// Accesses that say that the memory is more aligned than it is are not; // defined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:413,Performance,optimiz,optimized,413,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:267,Testability,log,logic,267,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:42,Usability,simpl,simple,42,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:304,Usability,simpl,simplify,304,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:3,Safety,Detect,Detect,3,// Detect self-referential values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:25,Usability,Simpl,SimplifyInstruction,25,"// As a last resort, try SimplifyInstruction or constant folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:256,Availability,error,errors,256,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:106,Integrability,interface,interfaces,106,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:273,Integrability,message,messages,273,"//===----------------------------------------------------------------------===//; // Implement the public interfaces to this file...; //===----------------------------------------------------------------------===//; /// lintFunction - Check a function for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:36,Availability,error,errors,36,"/// lintModule - Check a module for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:53,Integrability,message,messages,53,"/// lintModule - Check a module for errors, printing messages on stderr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:7,Performance,Load,Loads,7,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:25,Performance,load,load,25,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:427,Performance,load,load,427,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:401,Usability,simpl,simple,401,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:37,Energy Efficiency,allocate,allocated,37,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:93,Performance,load,load,93,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:4,Testability,Test,Test,4,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:86,Usability,simpl,simple,86,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:157,Energy Efficiency,allocate,allocated,157,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp
