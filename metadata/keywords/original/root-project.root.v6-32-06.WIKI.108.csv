id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/rf506__msgservice_8C.html:1942,Deployability,configurat,configuration,1942,") + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2596,Deployability,configurat,configuration,2596,"rint streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2965,Deployability,configurat,configuration,2965,"uration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefini",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:3513,Deployability,configurat,configuration,3513,"e tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRo",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5017,Deployability,configurat,configuration,5017,"rgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe n",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7665,Deployability,integrat,integration,7665,"n rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopic newTopic)Definition RooMsgService.h:118; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandli",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7739,Deployability,integrat,integrated,7739,"FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimizat",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7851,Deployability,integrat,integrated,7851,"FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimizat",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:296,Integrability,message,message,296,". ROOT: tutorials/roofit/rf506_msgservice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf506_msgservice.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:1827,Integrability,message,message,1827," m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_de",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2321,Integrability,message,message,2321,"--------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2505,Integrability,message,messages,2505,"s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Pri",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2562,Integrability,message,message,2562,"rint streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2669,Integrability,message,message,2669,"O stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; Roo",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2874,Integrability,message,messages,2874,"ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle Ge",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2931,Integrability,message,message,2931,"uration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefini",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:3180,Integrability,message,messages,3180,"moveTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:3479,Integrability,message,message,3479,"e tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRo",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5034,Integrability,message,message,5034,"rgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe n",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5309,Integrability,message,message,5309," RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopi",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5336,Integrability,message,message,5336," RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopi",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7665,Integrability,integrat,integration,7665,"n rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopic newTopic)Definition RooMsgService.h:118; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandli",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7739,Integrability,integrat,integrated,7739,"FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimizat",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:7851,Integrability,integrat,integrated,7851,"FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimizat",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:8838,Integrability,synchroniz,synchronize,8838,"istFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; pr",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:8963,Integrability,synchroniz,synchronize,8963,"ation LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:9086,Integrability,synchroniz,synchronize,9086,"ation LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:9214,Integrability,synchroniz,synchronize,9214,"andling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:1317,Modifiability,config,configuration,1317,"d simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // ----------------",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:1592,Modifiability,config,configuration,1592,"#include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:1942,Modifiability,config,configuration,1942,") + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2596,Modifiability,config,configuration,2596,"rint streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2965,Modifiability,config,configuration,2965,"uration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefini",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:3513,Modifiability,config,configuration,3513,"e tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRo",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5017,Modifiability,config,configuration,5017,"rgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe n",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:8775,Performance,optimiz,optimization,8775,"istFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; pr",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:24939,Performance,optimiz,optimization,24939," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:25286,Performance,optimiz,optimization,25286," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:28688,Performance,optimiz,optimization,28688,"2.259, p0=6.404e-10, ; prevFCN = 26.37493074 p0=6.286e-10, ; prevFCN = 26.37493074 p0=1.367e-14, s=0.2103, ; prevFCN = 26.3749307 s=0.2103, ; prevFCN = 26.37493077 f=0.2654, m=2.259, s=0.2103, ; prevFCN = 26.37493101 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493123 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493103 f=0.2652, m=2.259, p0=1.589e-08, s=0.2103, ; prevFCN = 26.37493099 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493085 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493105 p0=1.367e-14, s=0.2103, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; All Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [3] MinLevel = DEBUG Topic = LinkStateMgmt ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server x(0x7fff8734d4f0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server m(0x7fff8734b8d8) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server s(0x7fff8734bcc0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server x(0x7fff8734d4f0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server m(0x7fff8734b8d8) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x5588a5f9db10,g): adding server s(0x7fff8734bcc0) for value ; RooGaussian::g[ x=x mean=m sigma=s ] = 8.804e-26; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf506_msgservice.C. tutorialsroofitrf506_msgservice.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:6530,Safety,safe,safe,6530,"Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopic newTopic)Definition RooMsgService.h:118; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:304,Testability,log,logging,304,". ROOT: tutorials/roofit/rf506_msgservice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf506_msgservice.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organisation and simultaneous fits: tuning and customizing the RooFit message logging facility ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooAddPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooMsgService.h""; ; using namespace RooFit;; ; void rf506_msgservice(); {; // C r e a t e p d f; // --------------------; ; // Construct gauss(x,m,s); RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 1, -10, 10);; RooGaussian gauss(""g"", ""g"", x, m, s);; ; // Construct poly(x,p0); RooRealVar p0(""p0"", ""p0"", 0.01, 0., 1.);; RooPolynomial poly(""p"", ""p"", x, p0);; ; // Construct model = f*gauss(x) + (1-f)*poly(x); RooRealVar f(""f"", ""f"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgSet(gauss, poly), f);; ; std::unique_ptr<RooDataSet> data{model.generate(x, 10)};; ; // P r i n t c o n f i g u r a t i o n o f m e s s a g e s e r v i c e; // ---------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // A d d i n g I n t e g r a t i o n t o p i c t o e x i s t i n g I N F O s t r e a m; // -----------------------------------------------------------------------------------------------; ; // Print streams configuration; RooMsgService::instance().Print();; cout << endl;; ; // Add Integration topic to existing INFO stream; RooMsgService::instance().getStream(1).addTopic(Integration);; ; // Construct integral over gauss to demonstrate new message stream; std::unique_ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:2821,Testability,log,log,2821,"ptr<RooAbsReal> igauss{gauss.createIntegral(x)};; igauss->Print();; ; // Print streams configuration in verbose, which also shows inactive streams; cout << endl;; RooMsgService::instance().Print();; cout << endl;; ; // Remove stream; RooMsgService::instance().getStream(1).removeTopic(Integration);; ; // E x a m p l e s o f p d f v a l u e t r a c i n g s t r e a m; // -----------------------------------------------------------------------; ; // Show DEBUG level message on function tracing, trace RooGaussian only; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), ClassName(""RooGaussian""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // Show DEBUG level message on function tracing on all objects, redirect output to file; RooMsgService::instance().addStream(DEBUG, Topic(Tracing), OutputFile(""rf506_debug.log""));; ; // Perform a fit to generate some tracing messages; model.fitTo(*data, Verbose(true));; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; ; // E x a m p l e o f a n o t h e r d e b u g g i n g s t r e a m; // ---------------------------------------------------------------------; ; // Show DEBUG level messages on client/server link state management; RooMsgService::instance().addStream(DEBUG, Topic(LinkStateMgmt));; RooMsgService::instance().Print(""v"");; ; // Clone composite pdf g to trigger some link state management activity; RooAbsArg *gprime = gauss.cloneTree();; gprime->Print();; ; // Reset message service to default stream configuration; RooMsgService::instance().reset();; }; DEBUG#define DEBUGDefinition Polynomial.cxx:40; f#define f(i)Definition RSha256.hxx:104; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle Ge",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:5317,Testability,log,logging,5317," RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopi",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:11964,Testability,log,log,11964,"revFCN = 28.97257031 p0=0.000388, s=1.279, ; prevFCN = 28.97432524 s=1.273, ; prevFCN = 28.97145596 s=1.282, ; prevFCN = 28.97575564 s=1.269, ; prevFCN = 28.97003607 f=0.2452, m=1.663, p0=5.498e-07, s=0.9876, ; prevFCN = 28.8608997 f=0.2274, m=1.628, p0=0.0001029, s=0.8218, ; prevFCN = 28.87647974 f=0.241, m=1.655, p0=3.204e-06, s=0.9491, ; prevFCN = 28.85685477 f=0.2418, ; prevFCN = 28.85692699 f=0.2403, ; prevFCN = 28.85679737 f=0.241, m=1.659, ; prevFCN = 28.85436009 m=1.651, ; prevFCN = 28.8593705 m=1.655, p0=1.215e-06, ; prevFCN = 28.85682558 p0=6.138e-06, ; prevFCN = 28.85689784 p0=3.204e-06, s=0.9556, ; prevFCN = 28.85804684 s=0.9426, ; prevFCN = 28.85571545 s=0.9524, ; prevFCN = 28.85746237 s=0.9458, ; prevFCN = 28.85626117 f=0.2171, m=1.753, p0=0.0002379, s=0.6877, ; prevFCN = 28.6750677 f=0.1311, m=2.143, p0=0.004887, s=-0.3611, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.131146 m=2.14309 p0=0.00488743 s=-0.361096; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] =",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8C.html:15055,Testability,log,log,15055,"ero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; ; ; prevFCN = 122.3539561 f=0.2285, m=1.706, p0=7.868e-05, s=0.8134, ; prevFCN = 28.78647388 f=0.1125, m=2.24, p0=0.006973, s=-0.6231, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.112499 m=2.24008 p0=0.00697315 s=-0.623113; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] =",MatchSource.WIKI,doc/master/rf506__msgservice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5441,Availability,error,error,5441," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5631,Availability,error,error,5631," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5646,Availability,avail,available,5646," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5756,Availability,error,error,5756,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5771,Availability,avail,available,5771,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5879,Availability,error,error,5879,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5894,Availability,avail,available,5894,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:6007,Availability,error,error,6007,"tHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:6022,Availability,avail,available,6022,"tHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:8620,Availability,error,error,8620,"7, ; prevFCN = 28.97321652 m=1.722, ; prevFCN = 28.97256819 m=1.724, p0=0.0004103, ; prevFCN = 28.97321664 p0=0.0003662, ; prevFCN = 28.97257031 p0=0.000388, s=1.279, ; prevFCN = 28.97432524 s=1.273, ; prevFCN = 28.97145596 s=1.282, ; prevFCN = 28.97575564 s=1.269, ; prevFCN = 28.97003607 f=0.2452, m=1.663, p0=5.498e-07, s=0.9876, ; prevFCN = 28.8608997 f=0.2274, m=1.628, p0=0.0001029, s=0.8218, ; prevFCN = 28.87647974 f=0.241, m=1.655, p0=3.204e-06, s=0.9491, ; prevFCN = 28.85685477 f=0.2418, ; prevFCN = 28.85692699 f=0.2403, ; prevFCN = 28.85679737 f=0.241, m=1.659, ; prevFCN = 28.85436009 m=1.651, ; prevFCN = 28.8593705 m=1.655, p0=1.215e-06, ; prevFCN = 28.85682558 p0=6.138e-06, ; prevFCN = 28.85689784 p0=3.204e-06, s=0.9556, ; prevFCN = 28.85804684 s=0.9426, ; prevFCN = 28.85571545 s=0.9524, ; prevFCN = 28.85746237 s=0.9458, ; prevFCN = 28.85626117 f=0.2171, m=1.753, p0=0.0002379, s=0.6877, ; prevFCN = 28.6750677 f=0.1311, m=2.143, p0=0.004887, s=-0.3611, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.131146 m=2.14309 p0=0.00488743 s=-0.361096; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05)",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:11711,Availability,error,error,11711,"ion integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; ; ; prevFCN = 122.3539561 f=0.2285, m=1.706, p0=7.868e-05, s=0.8134, ; prevFCN = 28.78647388 f=0.1125, m=2.24, p0=0.006973, s=-0.6231, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.112499 m=2.24008 p0=0.00697315 s=-0.623113; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05)",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:21952,Availability,error,error,21952," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:911,Deployability,configurat,configuration,911,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1009,Deployability,configurat,configuration,1009,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1074,Deployability,integrat,integration,1074," Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream confi",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1190,Deployability,configurat,configuration,1190," Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream confi",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1508,Deployability,configurat,configuration,1508,"lVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2127,Deployability,configurat,configuration,2127,"ng INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); P",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2512,Deployability,configurat,configuration,2512,"(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching O",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:3047,Deployability,configurat,configuration,3047,"e tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4429,Deployability,integrat,integration,4429," pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling N",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4503,Deployability,integrat,integrated,4503,"ion FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4615,Deployability,integrat,integrated,4615,"ion FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:316,Integrability,message,message,316,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:928,Integrability,message,message,928,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1074,Integrability,integrat,integration,1074," Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream confi",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1422,Integrability,message,message,1422,"truct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to gen",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1833,Integrability,message,message,1833,"r(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance(",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2040,Integrability,message,messages,2040,"configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Re",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2093,Integrability,message,message,2093,"ng INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); P",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2202,Integrability,message,message,2202,"ce.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2425,Integrability,message,messages,2425,"o demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Ge",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2478,Integrability,message,message,2478,"(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching O",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2701,Integrability,message,messages,2701,"ream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Ev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:3013,Integrability,message,message,3013,"e tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4429,Integrability,integrat,integration,4429," pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling N",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4503,Integrability,integrat,integrated,4503,"ion FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:4615,Integrability,integrat,integrated,4615,"ion FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5598,Integrability,synchroniz,synchronize,5598," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5723,Integrability,synchroniz,synchronize,5723,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5846,Integrability,synchroniz,synchronize,5846,"gration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5974,Integrability,synchroniz,synchronize,5974,"tHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:911,Modifiability,config,configuration,911,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1009,Modifiability,config,configuration,1009,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1190,Modifiability,config,configuration,1190," Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream confi",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:1508,Modifiability,config,configuration,1508,"lVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2127,Modifiability,config,configuration,2127,"ng INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); P",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2512,Modifiability,config,configuration,2512,"(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching O",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:3047,Modifiability,config,configuration,3047,"e tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:5535,Performance,optimiz,optimization,5535," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:21699,Performance,optimiz,optimization,21699," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:22046,Performance,optimiz,optimization,22046," p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499245 s=0.2107, ; prevFCN = 26.37498621 f=0.2652, s=0.2107, ; prevFCN = 26.37498903 f=0.2652, ; prevFCN = 26.37498915 f=0.2652, m=2.259, ; prevFCN = 26.37498949 m=2.259, ; prevFCN = 26.37498869 m=2.259, p0=2.905e-06, ; prevFCN = 26.37499046 p0=2.736e-06, ; prevFCN = 26.37498772 p0=2.82e-06, s=0.2107, ; prevFCN = 26.37498971 s=0.2107, ; prevFCN = 26.37498846 f=0.2653, m=2.259, s=0.2107, ; prevFCN = 26.37499134 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499614 p0=2.82e-06, s=0.2108, ; prevFCN = 26.3749924 f=0.2652, m=2.259, p0=3.259e-06, s=0.2107, ; prevFCN = 26.37499844 p0=2.82e-06, s=0.2108, ; prevFCN = 26.37499475 m=2.259, p0=3.259e-06, ; prevFCN = 26.37499954 p0=2.82e-06, s=0.2107, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; ; prevFCN = 26.37498908 f=0.2667, ; prevFCN = 26.37503727 f=0.2636, ; prevFCN = 26.37504545 f=0.2657, ; prevFCN = 26.37499405 f=0.2646, ; prevFCN = 26.37499692 f=0.2652, m=2.261, ; prevFCN = 26.37506777 m=2.258, ; prevFCN = 26.37501136 m=2.26, ; prevFCN = 26.37500554 m=2.259, ; prevFCN = 26.37498543 m=2.259, p0=6.522e-06, ; prevFCN = 26.3750489 p0=6.471e-07, ; prevFCN = 26.37495398 p0=5.331e-06, ; prevFCN = 26.37502965 p0=1.101e-06, ; prevFCN = 26.37496132 p0=2.82e-06, s=0.2117, ; prevFCN = 26.37508362 s=0.2098, ; prevFCN = 26.37499532 s=0.2111, ; prevFCN = 26.37501134 s=0.2104, ; prevFCN = 26.37497963 f=0.2652, m=2.259, p0=1.367e-14, s=0.2103, ; prevFCN = 26.37493072 f=0.2658, ; prevFCN = 26.37493708 f=0.2647, ; prevFCN = 26.37493",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:25448,Performance,optimiz,optimization,25448,"prevFCN = 26.37493079 m=2.259, p0=6.404e-10, ; prevFCN = 26.37493074 p0=6.286e-10, ; prevFCN = 26.37493074 p0=1.367e-14, s=0.2103, ; prevFCN = 26.3749307 s=0.2103, ; prevFCN = 26.37493077 f=0.2654, m=2.259, s=0.2103, ; prevFCN = 26.37493101 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493123 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493103 f=0.2652, m=2.259, p0=1.589e-08, s=0.2103, ; prevFCN = 26.37493099 p0=1.367e-14, s=0.2104, ; prevFCN = 26.37493085 m=2.259, p0=1.589e-08, ; prevFCN = 26.37493105 p0=1.367e-14, s=0.2103, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; All Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [3] MinLevel = DEBUG Topic = LinkStateMgmt ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server x(0x7032410) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server m(0x6fa8f30) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server s(0x6c756e0) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server x(0x7032410) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server m(0x6fa8f30) for value ; [#3] DEBUG:LinkStateMgmt -- RooAbsArg::addServer(0x7fc9cc0,g): adding server s(0x6c756e0) for value ; RooGaussian::g[ x=x mean=m sigma=s ] = 8.804e-26; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf506_msgservice.py. tutorialsroofitrf506_msgservice.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:3298,Safety,safe,safe,3298,"o; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) C",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:324,Testability,log,logging,324,". ROOT: tutorials/roofit/rf506_msgservice.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # ",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:2375,Testability,log,log,2375,"o demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Show DEBUG level message on function tracing on all objects, output to; # file; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, OutputFile=""rf506_debug.log""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); ; # Example of another debugging stream; # ---------------------------------------------------------------------; ; # Show DEBUG level messages on client/server link state management; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.LinkStateMgmt); ROOT.RooMsgService.instance().Print(""v""); ; # Clone composite pdf g to trigger some link state management activity; gprime = gauss.cloneTree(); gprime.Print(); ; # Reset message service to default stream configuration; ROOT.RooMsgService.instance().reset(); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 's' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; Active Message streams; [0] MinLevel = PROGRESS Topic = Ge",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:8724,Testability,log,log,8724,"revFCN = 28.97257031 p0=0.000388, s=1.279, ; prevFCN = 28.97432524 s=1.273, ; prevFCN = 28.97145596 s=1.282, ; prevFCN = 28.97575564 s=1.269, ; prevFCN = 28.97003607 f=0.2452, m=1.663, p0=5.498e-07, s=0.9876, ; prevFCN = 28.8608997 f=0.2274, m=1.628, p0=0.0001029, s=0.8218, ; prevFCN = 28.87647974 f=0.241, m=1.655, p0=3.204e-06, s=0.9491, ; prevFCN = 28.85685477 f=0.2418, ; prevFCN = 28.85692699 f=0.2403, ; prevFCN = 28.85679737 f=0.241, m=1.659, ; prevFCN = 28.85436009 m=1.651, ; prevFCN = 28.8593705 m=1.655, p0=1.215e-06, ; prevFCN = 28.85682558 p0=6.138e-06, ; prevFCN = 28.85689784 p0=3.204e-06, s=0.9556, ; prevFCN = 28.85804684 s=0.9426, ; prevFCN = 28.85571545 s=0.9524, ; prevFCN = 28.85746237 s=0.9458, ; prevFCN = 28.85626117 f=0.2171, m=1.753, p0=0.0002379, s=0.6877, ; prevFCN = 28.6750677 f=0.1311, m=2.143, p0=0.004887, s=-0.3611, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.131146 m=2.14309 p0=0.00488743 s=-0.361096; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.131146); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] =",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf506__msgservice_8py.html:11815,Testability,log,log,11815,"ero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; p.d.f normalization integral is zero or negative @ numerator=g=2.2451e-08, denominator=g_Int[x]=-0.905133; ; ; prevFCN = 122.3539561 f=0.2285, m=1.706, p0=7.868e-05, s=0.8134, ; prevFCN = 28.78647388 f=0.1125, m=2.24, p0=0.006973, s=-0.6231, RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (31.8407) to force MIGRAD to back out of this region. Error log follows.; Parameter values: f=0.112499 m=2.24008 p0=0.00697315 s=-0.623113; RooAddPdf::model[ f * g_over_g_Int[x] + [%] * p_over_p_Int[x] ]; getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] = nan,p_over_p_Int[x] = 0.05), !coefficients=(f = 0.112499); getLogVal() top-level p.d.f evaluates to NaN @ !refCoefNorm=(x = 0), !pdfs=(g_over_g_Int[x] =",MatchSource.WIKI,doc/master/rf506__msgservice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:2463,Availability,error,error,2463,"nitial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByAttrib(""Constant"", true);; ; // Construct the subset of overlapping contents with another set; RooArgSet s1(a, b, c);; RooArgSet s2(c, d, e);; RooArgSet *subset3 = (RooArgSet *)s1.selectCommon(s2);; ; // O w n i n g R o o A r g S e t s; // ---------------------------------; ; // Create a RooArgSet that owns its components; // A set either owns all of its components or none,; // so once addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:2469,Integrability,message,message,2469,"nitial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByAttrib(""Constant"", true);; ; // Construct the subset of overlapping contents with another set; RooArgSet s1(a, b, c);; RooArgSet s2(c, d, e);; RooArgSet *subset3 = (RooArgSet *)s1.selectCommon(s2);; ; // O w n i n g R o o A r g S e t s; // ---------------------------------; ; // Create a RooArgSet that owns its components; // A set either owns all of its components or none,; // so once addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:3386,Integrability,depend,dependencies,3386,"nce addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and all their clone (recursive) server; // dependencies, that together form a self-consistent; // set that is free of external dependencies; ; RooArgSet *sclone3 = (RooArgSet *)s3.snapshot(true);; ; // S e t p r i n t i n g; // ------------------------; ; // Inline printing only show list of names of contained objects; cout << ""sclone = "" << (*sclone) << endl;; ; // Plain print shows the same, prefixed by name of the set; sclone->Print();; ; // Standard printing shows one line for each item with the items name, class name and value; sclone->Print(""s"");; ; // Verbose printing adds each items arguments, address and 'extras' as defined by the object; sclone->Print(""v"");; ; // U s i n g R o o A r g L i s t s; // ---------------------------------; ; // List constructors exists with up to 9 initial arguments; RooArgList l(a, b, c, d);; ; // Lists have an explicit order and allow multiple arguments with the same name; l.add(RooArgList(a, b, c, d));; ; // Access by index is provided; RooAbsArg *arg4 = l.at(4);; }; d#define d(i)Definit",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:3470,Integrability,depend,dependencies,3470,"nce addOwned() is used, add() can no longer be; // used and will result in an error message; ; RooRealVar *ac = (RooRealVar *)a.clone(""a"");; RooRealVar *bc = (RooRealVar *)b.clone(""b"");; RooRealVar *cc = (RooRealVar *)c.clone(""c"");; ; RooArgSet s3;; s3.addOwned(RooArgSet(*ac, *bc, *cc));; ; // Another possibility is to add an owned clone; // of an object instead of the original; s3.addClone(RooArgSet(d, e, g));; ; // A clone of a owning set is non-owning and its; // contents is owned by the originating owning set; RooArgSet *sclone = (RooArgSet *)s3.Clone(""sclone"");; ; // To make a clone of a set and its contents use; // the snapshot method; RooArgSet *sclone2 = (RooArgSet *)s3.snapshot();; ; // If a set contains function objects, only the head node; // is cloned in a snapshot. To make a snapshot of all; // servers of a function object do as follows. The result; // of a RooArgSet snapshot with deepCloning option is a set; // of cloned objects, and all their clone (recursive) server; // dependencies, that together form a self-consistent; // set that is free of external dependencies; ; RooArgSet *sclone3 = (RooArgSet *)s3.snapshot(true);; ; // S e t p r i n t i n g; // ------------------------; ; // Inline printing only show list of names of contained objects; cout << ""sclone = "" << (*sclone) << endl;; ; // Plain print shows the same, prefixed by name of the set; sclone->Print();; ; // Standard printing shows one line for each item with the items name, class name and value; sclone->Print(""s"");; ; // Verbose printing adds each items arguments, address and 'extras' as defined by the object; sclone->Print(""v"");; ; // U s i n g R o o A r g L i s t s; // ---------------------------------; ; // List constructors exists with up to 9 initial arguments; RooArgList l(a, b, c, d);; ; // Lists have an explicit order and allow multiple arguments with the same name; l.add(RooArgList(a, b, c, d));; ; // Access by index is provided; RooAbsArg *arg4 = l.at(4);; }; d#define d(i)Definit",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:687,Modifiability,variab,variables,687,". ROOT: tutorials/roofit/rf508_listsetmanip.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf508_listsetmanip.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooArgSet and RooArgList tools and tricks ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooArgSet.h""; #include ""RooArgList.h""; #include ""RooCategory.h""; using namespace RooFit;; ; void rf508_listsetmanip(); {; ; // C r e a t e d u m m y o b j e c t s; // ---------------------------------------; ; // Create some variables; RooRealVar a(""a"", ""a"", 1, -10, 10);; RooRealVar b(""b"", ""b"", 2, -10, 10);; RooRealVar c(""c"", ""c"", 3, -10, 10);; RooRealVar d(""d"", ""d"", 4, -10, 10);; RooRealVar x(""x"", ""x"", 0, -10, 10);; c.setError(0.5);; a.setConstant();; b.setConstant();; ; // Create a category; RooCategory e(""e"", ""e"");; e.defineType(""sig"");; e.defineType(""bkg"");; ; // Create a pdf; RooGaussian g(""g"", ""g"", x, a, b);; ; // C r e a t i n g , f i l l i n g R o o A r g S e t s; // -------------------------------------------------------; ; // A RooArgSet is a set of RooAbsArg objects. Each object in the set must have; // a unique name; ; // Set constructors exists with up to 9 initial arguments; RooArgSet s(a, b);; ; // At any time objects can be added with add(); s.add(e);; ; // Add up to 9 additional arguments in one call; s.add(RooArgSet(c, d));; ; // Sets can contain any type of RooAbsArg, also pdf and functions; s.add(g);; ; // Remove element d; s.remove(d);; ; // A c c e s s i n g R o o A r g S e t c o n t e n t s; // -------------------------------------------------------; ; // You can look up objects by name; RooAbsArg *aptr = s.find(""a"");; ; // Construct a subset by name; RooArgSet *subset1 = (RooArgSet *)s.selectByName(""a,b,c"");; ; // Construct asubset by attribute; RooArgSet *subset2 = (RooArgSet *)s.selectByA",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8C.html:7253,Safety,safe,safe,7253,"y=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooArgSet::selectByNameRooArgSet * selectByName(const char *nameList, bool verbose=false) constUse RooAbsCollection::selectByName(), but return as RooArgSet.Definition RooArgSet.h:144; RooArgSet::selectCommonRooArgSet * selectCommon(const RooAbsCollection &refColl) constUse RooAbsCollection::selecCommon(), but return as RooArgSet.Definition RooArgSet.h:149; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::cloneTObject * clone(const char *newname) const overrideDefinition RooRealVar.h:48; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf508_listsetmanipDefinition rf508_listsetmanip.py:1; lTLine lDefinition textangle.C:4; ; [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; sclone = (a,b,c,d,e,g); RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x5569466c3940 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x556948df5f70 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x556946cacdc0 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x5569492af150 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x5569468860e0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x5569458db0b0 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf508_listsetmanip.C. tutorialsroofitrf508_listsetmanip.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8C.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:2238,Availability,error,error,2238," s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standar",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:2244,Integrability,message,message,2244," s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standar",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:2842,Integrability,depend,dependencies,2842,"ts with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standard printing shows one line for each item with the items name, name; # and value; sclone.Print(""s""); ; # Verbose printing adds each items arguments, and 'extras' as defined by; # the object; sclone.Print(""v""); ; # Using RooArgLists; # ---------------------------------; ; # List constructors exists with up to 9 initial arguments; l = ROOT.RooArgList(a, b, c, d); ; # Lists have an explicit order and allow multiple arguments with the same; # name; l.add(ROOT.RooArgList(a, b, c, d)); ; # Access by index is provided; arg4 = l.at(4); [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe rang",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:2920,Integrability,depend,dependencies,2920,"ts with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ; # You can create a RooArgSet that owns copies of the objects instead of; # referencing the originals. A set either owns all of its components or none,; # so once addClone() is used, add() can no longer be used and will result in an; # error message; s3 = ROOT.RooArgSet(); for arg in [a, b, c, d, e, g]:; s3.addClone(arg); ; # A clone of a owning set is non-owning and its; # contents is owned by the originating owning set; sclone = s3.Clone(""sclone""); ; # To make a clone of a set and its contents use; # the snapshot method; sclone2 = s3.snapshot(); ; # If a set contains function objects, the head node; # is cloned in a snapshot. To make a snapshot of all; # servers of a function object do as follows. The result; # of a RooArgSet snapshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standard printing shows one line for each item with the items name, name; # and value; sclone.Print(""s""); ; # Verbose printing adds each items arguments, and 'extras' as defined by; # the object; sclone.Print(""v""); ; # Using RooArgLists; # ---------------------------------; ; # List constructors exists with up to 9 initial arguments; l = ROOT.RooArgList(a, b, c, d); ; # Lists have an explicit order and allow multiple arguments with the same; # name; l.add(ROOT.RooArgList(a, b, c, d)); ; # Access by index is provided; arg4 = l.at(4); [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe rang",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:495,Modifiability,variab,variables,495,". ROOT: tutorials/roofit/rf508_listsetmanip.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf508_listsetmanip.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #508 ; RooArgSet and RooArgList tools and tricks; ; from __future__ import print_function; import ROOT; ; ; # Create dummy objects; # ---------------------------------------; ; # Create some variables; a = ROOT.RooRealVar(""a"", ""a"", 1, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 2, -10, 10); c = ROOT.RooRealVar(""c"", ""c"", 3, -10, 10); d = ROOT.RooRealVar(""d"", ""d"", 4, -10, 10); x = ROOT.RooRealVar(""x"", ""x"", 0, -10, 10); c.setError(0.5); a.setConstant(); b.setConstant(); ; # Create a category; e = ROOT.RooCategory(""e"", ""e""); e.defineType(""sig""); e.defineType(""bkg""); ; # Create a pdf; g = ROOT.RooGaussian(""g"", ""g"", x, a, b); ; # Creating, killing RooArgSets; # -------------------------------------------------------; ; # A ROOT.RooArgSet is a set of RooAbsArg objects. Each object in the set must have; # a unique name; ; # Set constructors exists with up to 9 initial arguments; s = ROOT.RooArgSet(a, b); ; # At any time objects can be added with add(); s.add(e); ; # Add up to 9 additional arguments in one call; # s.add(ROOT.RooArgSet(c, d)); s.add(c); s.add(d); ; # Sets can contain any type of RooAbsArg, pdf and functions; s.add(g); ; # Remove element d; s.remove(d); ; # Accessing RooArgSet contents; # -------------------------------------------------------; ; # You can look up objects by name; aptr = s.find(""a""); ; # Construct a subset by name; subset1 = s.selectByName(""a,b,c""); ; # Construct asubset by attribute; subset2 = s.selectByAttrib(""Constant"", ROOT.kTRUE); ; # Construct the subset of overlapping contents with another set; s1 = ROOT.RooArgSet(a, b, c); s2 = ROOT.RooArgSet(c, d, e); subset3 = s1.selectCommon(s2); ; # Owning RooArgSets; # ---------------------------------; ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf508__listsetmanip_8py.html:3821,Safety,safe,safe,3821,"apshot with deepCloning option is a set; # of cloned objects, all their clone (recursive) server; # dependencies, together form a self-consistent; # set that is free of external dependencies; ; sclone3 = s3.snapshot(True); ; # Set printing; # ------------------------; ; # Inline printing only show list of names of contained objects; print(""sclone = "", sclone); ; # Plain print shows the same, by name of the set; sclone.Print(); ; # Standard printing shows one line for each item with the items name, name; # and value; sclone.Print(""s""); ; # Verbose printing adds each items arguments, and 'extras' as defined by; # the object; sclone.Print(""v""); ; # Using RooArgLists; # ---------------------------------; ; # List constructors exists with up to 9 initial arguments; l = ROOT.RooArgList(a, b, c, d); ; # Lists have an explicit order and allow multiple arguments with the same; # name; l.add(ROOT.RooArgList(a, b, c, d)); ; # Access by index is provided; arg4 = l.at(4); [#0] WARNING:InputArguments -- The parameter 'b' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; RooArgSet::sclone = (a,b,c,d,e,g); 1) RooRealVar:: a = 1; 2) RooRealVar:: b = 2; 3) RooRealVar:: c = 3 +/- 0.5; 4) RooRealVar:: d = 4; 5) RooCategory:: e = sig(idx = 0); ; 6) RooGaussian:: g = 0.882497; 1) 0x7b39df0 RooRealVar:: a = 1 C L(-10 - 10) ""a""; 2) 0x7b3a1e0 RooRealVar:: b = 2 C L(-10 - 10) ""b""; 3) 0x7b13900 RooRealVar:: c = 3 +/- 0.5 L(-10 - 10) ""c""; 4) 0x7aa7d60 RooRealVar:: d = 4 L(-10 - 10) ""d""; 5) 0x7e8fbd0 RooCategory:: e = sig(idx = 0); ""e""; 6) 0x7ea8d00 RooGaussian:: g[ x=x mean=a sigma=b ] = 0.882497 ""g""; sclone = { @0x7eaa940, @0x7eaa948, @0x7eaa950, @0x7eaa958, @0x7eaa960, @0x7eaa968 }; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf508_listsetmanip.py. tutorialsroofitrf508_listsetmanip.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf508__listsetmanip_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf508__listsetmanip_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:9031,Availability,error,error,9031,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:3762,Integrability,interface,interface,3762,""", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; w.import(model);; }; d#define d(i)Definition RSha256.hxx:102; kDashed@ kDashedDefinition TAttLine.h:48; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAddPdfEfficient imple",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:1413,Modifiability,variab,variable,1413,"rence Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:5424,Modifiability,variab,variable,5424,"ven dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooWorkspace::Printvoid Print(Option_t *opts=nullptr) const overridePrint contents of the workspace.Definition RooWorkspace.cxx:2095; RooWorkspace::pdfRooAbsPdf * pdf(RooStringView name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitl",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:6231,Modifiability,variab,variable,6231,"ame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooWorkspace::Printvoid Print(Option_t *opts=nullptr) const overridePrint contents of the workspace.Definition RooWorkspace.cxx:2095; RooWorkspace::pdfRooAbsPdf * pdf(RooStringView name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the R",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:8364,Modifiability,variab,variables,8364,"or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:9125,Performance,optimiz,optimization,9125,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:9222,Performance,optimiz,optimization,9222,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:7068,Safety,safe,safe,7068,"iew name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:7235,Safety,safe,safe,7235,"StringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf509_wsinteractiveDefinition rf509_wsinteractive.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:285,Security,access,access,285,". ROOT: tutorials/roofit/rf509_wsinteractive.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"",",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8C.html:1402,Security,access,access,1402,"rence Guide ; .  . Loading...; Searching...; No Matches. rf509_wsinteractive.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf509_wsinteractive(); {; // C r e a t e a n d f i l l w o r k s p a c e; // ------------------------------------------------; ; // Create a workspace named 'w'; // With CINT w could exports its contents to; // a same-name C++ namespace in CINT 'namespace w'.; // but this does not work anymore in CLING.; // so this tutorial is an example on how to; // change the code; RooWorkspace *w1 = new RooWorkspace(""w"", true);; ; // Fill workspace with pdf and data in a separate function; fillWorkspace(*w1);; ; // Print workspace contents; w1->Print();; ; // this does not work anymore with CLING; // use normal workspace functionality; ; // U s e w o r k s p a c e c o n t e n t s; // ----------------------------------------------; ; // use normal workspace methods; RooAbsPdf *model = w1->pdf(""model"");; RooRealVar *x = w1->var(""x"");; ; std::unique_ptr<RooDataSet> d{ model->generate(*x, 1000)};; std::unique_ptr<RooFitResult> r{model->fitTo(*d, PrintLevel(-1))};; ; // old syntax to access the variable x; // RooPlot* frame = w::x.frame() ;; ; RooPlot *frame = x->frame();; d->plotOn(frame);; ; // OLD syntax to omit x::; // NB: The 'w::' prefix can be omitted if namespace w is imported in local namespace; // in the usual C++ way; //; // using namespace w;; // model.plotOn(frame) ;; // model.plotOn(frame,Components(bkg),LineStyle(kDashed)) ;; ; // new correct syntax; RooAbsPdf *bkg = w1->pdf(""bkg"");; model->plotOn(frame);; model->plotOn(frame, Components(*bkg), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame",MatchSource.WIKI,doc/master/rf509__wsinteractive_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:5282,Availability,error,error,5282,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:2558,Modifiability,variab,variable,2558,"f(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:4619,Modifiability,variab,variables,4619," frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- u",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:5376,Performance,optimiz,optimization,5376,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:5473,Performance,optimiz,optimization,5473,"oRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 1/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf509_wsinteractive.py. tutorialsroofitrf509_wsinteractive.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:3323,Safety,safe,safe,3323,"ame space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Object",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:3490,Safety,safe,safe,3490,"el""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:300,Security,access,access,300,". ROOT: tutorials/roofit/rf509_wsinteractive.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf509_wsinteractive.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: easy interactive access to workspace contents - CINT to CLING code migration . ; import ROOT; ; ; def fillWorkspace(w):; # Create pdf and fill workspace; # --------------------------------------------------------; ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", 0, 10); ; # Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,mean2,sigma) and; # their parameters; mean = ROOT.RooRealVar(""mean"", ""mean of gaussians"", 5, 0, 10); sigma1 = ROOT.RooRealVar(""sigma1"", ""width of gaussians"", 0.5); sigma2 = ROOT.RooRealVar(""sigma2"", ""width of gaussians"", 1); ; sig1 = ROOT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial pdf; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and da",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:2302,Security,access,access,2302," into a composite signal pdf; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf509__wsinteractive_8py.html:2547,Security,access,access,2547,"f(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; w.Import(model); ; ; # Create and fill workspace; # ------------------------------------------------; ; ; # Create a workspace named 'w'; # With CINT w could exports its contents to; # a same-name C++ namespace in CINT 'namespace w'.; # but self does not work anymore in CLING.; # so self tutorial is an example on how to; # change the code; w = ROOT.RooWorkspace(""w"", True); ; # Fill workspace with pdf and data in a separate function; fillWorkspace(w); ; # Print workspace contents; w.Print(); ; # self does not work anymore with CLING; # use normal workspace functionality; ; # Use workspace contents; # ----------------------------------------------; ; # Old syntax to use the name space prefix operator to access the workspace contents; #; # d = w.model.generate(w.x,1000); # r = w.model.fitTo(*d); ; # use normal workspace methods; model = w[""model""]; x = w[""x""]; ; d = model.generate({x}, 1000); r = model.fitTo(d, PrintLevel=-1); ; # old syntax to access the variable x; # frame = w.x.frame(); ; frame = x.frame(); d.plotOn(frame); ; # OLD syntax to omit x.; # NB: The 'w.' prefix can be omitted if namespace w is imported in local namespace; # in the usual C++ way; #; # using namespace w; # model.plotOn(frame); # model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # correct syntax; bkg = w[""bkg""]; model.plotOn(frame); model.plotOn(frame, Components=bkg, LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf509_wsinteractive"", ""rf509_wsinteractive"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf509_wsinteractive.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [",MatchSource.WIKI,doc/master/rf509__wsinteractive_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4487,Availability,error,errors,4487,"ve in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:10288,Availability,error,error,10288,"port(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] IN",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:10732,Availability,error,error,10732,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:11271,Availability,error,error,11271,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:6188,Integrability,interface,interface,6188,"onstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starting with ourself as top node that don't match any of...Definition RooAbsArg.cxx:541; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAddPdfEfficient impl",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:3401,Modifiability,variab,variables,3401,", 1);; ; RooGaussian sig1(""sig1"", ""Signal component 1"", x, mean, sigma1);; RooGaussian sig2(""sig2"", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Import model into pdf; w.import(model);; ; // E n c o d e d e f i n i t i o n o f p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------; ; // Define named sets ""parameters"" and ""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using t",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:3695,Modifiability,variab,variables,3695,"ts into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // Import model into pdf; w.import(model);; ; // E n c o d e d e f i n i t i o n o f p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------; ; // Define named sets ""parameters"" and ""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snap",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4275,Modifiability,variab,variables,4275,"frac);; ; // Import model into pdf; w.import(model);; ; // E n c o d e d e f i n i t i o n o f p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------; ; // Define named sets ""parameters"" and ""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the sig",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4364,Modifiability,variab,variable,4364,"""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; R",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4473,Modifiability,variab,variable,4473,"ve in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:11508,Modifiability,variab,variables,11508,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:1491,Performance,load,loadSnapshot,1491,"oFit Tutorials. Detailed Description; Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf510_wsnamedsets(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; RooWorkspace *w = new RooWorkspace(""w"");; fillWorkspace(*w);; ; // Exploit convention encoded in named set ""parameters"" and ""observables""; // to use workspace contents w/o need for introspected; RooAbsPdf *model = w->pdf(""model"");; ; // Generate data from pdf in given observables; std::unique_ptr<RooDataSet> data{model->generate(*w->set(""observables""), 1000)};; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot fitted model and data on frame of first (only) observable; RooPlot *frame = ((RooRealVar *)w->set(""observables"")->first())->frame();; data->plotOn(frame);; model->plotOn(frame);; ; // Overlay plot with model with reference parameters as stored in snapshots; w->loadSnapshot(""reference_fit"");; model->plotOn(frame, LineColor(kRed));; w->loadSnapshot(""reference_fit_bkgonly"");; model->plotOn(frame, LineColor(kRed), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; // Print workspace contents; w->Print();; ; // Workspace will remain in memory after macro finishes; gDirectory->Add(w);; }; ; void fillWorkspace(RooWorkspace &w); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:1566,Performance,load,loadSnapshot,1566,"oFit Tutorials. Detailed Description; Organization and simultaneous fits: working with named parameter sets and parameter snapshots in workspaces . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; void fillWorkspace(RooWorkspace &w);; ; void rf510_wsnamedsets(); {; // C r e a t e m o d e l a n d d a t a s e t; // -----------------------------------------------; ; RooWorkspace *w = new RooWorkspace(""w"");; fillWorkspace(*w);; ; // Exploit convention encoded in named set ""parameters"" and ""observables""; // to use workspace contents w/o need for introspected; RooAbsPdf *model = w->pdf(""model"");; ; // Generate data from pdf in given observables; std::unique_ptr<RooDataSet> data{model->generate(*w->set(""observables""), 1000)};; ; // Fit model to data; model->fitTo(*data, PrintLevel(-1));; ; // Plot fitted model and data on frame of first (only) observable; RooPlot *frame = ((RooRealVar *)w->set(""observables"")->first())->frame();; data->plotOn(frame);; model->plotOn(frame);; ; // Overlay plot with model with reference parameters as stored in snapshots; w->loadSnapshot(""reference_fit"");; model->plotOn(frame, LineColor(kRed));; w->loadSnapshot(""reference_fit_bkgonly"");; model->plotOn(frame, LineColor(kRed), LineStyle(kDashed));; ; // Draw the frame on the canvas; new TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; ; // Print workspace contents; w->Print();; ; // Workspace will remain in memory after macro finishes; gDirectory->Add(w);; }; ; void fillWorkspace(RooWorkspace &w); {; // C r e a t e m o d e l; // -----------------------; ; // Declare observable x; RooRealVar x(""x"", ""x"", 0, 10);; ; // Create two Gaussian PDFs g1(x,mean1,sigma) anf g2(x,",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:4391,Performance,load,loadSnapshot,4391,"""observables"", which list which variables should be considered; // parameters and observables by the users convention; //; // Variables appearing in sets _must_ live in the workspace already, or the autoImport flag; // of defineSet must be set to import them on the fly. Named sets contain only references; // to the original variables, therefore the value of observables in named sets already; // reflect their 'current' value; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; w.defineSet(""parameters"", *params);; w.defineSet(""observables"", x);; ; // E n c o d e r e f e r e n c e v a l u e f o r p a r a m e t e r s i n w o r k s p a c e; // ---------------------------------------------------------------------------------------------------; ; // Define a parameter 'snapshot' in the pdf; // Unlike a named set, a parameter snapshot stores an independent set of values for; // a given set of variables in the workspace. The values can be stored and reloaded; // into the workspace variable objects using the loadSnapshot() and saveSnapshot(); // methods. A snapshot saves the value of each variable, any errors that are stored; // with it as well as the 'Constant' flag that is used in fits to determine if a; // parameter is kept fixed or not.; ; // Do a dummy fit to a (supposedly) reference dataset here and store the results; // of that fit into a snapshot; std::unique_ptr<RooDataSet> refData{model.generate(x, 10000)};; model.fitTo(*refData, PrintLevel(-1));; ; // The true flag imports the values of the objects in (*params) into the workspace; // If not set, the present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", *params, true);; ; // Make another fit with the signal component forced to zero; // and save those parameters too; ; bkgfrac.setVal(1);; bkgfrac.setConstant(true);; bkgfrac.removeError();; model.fitTo(*refData, PrintLevel(-1));; ; w.saveSnapshot(""reference_fit_bkgonly"", *params, true);; }; RooAddPdf.h; RooChebychev.h; R",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:10382,Performance,optimiz,optimization,10382,"ooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:10479,Performance,optimiz,optimization,10479," [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorks",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:10826,Performance,optimiz,optimization,10826,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:11018,Performance,optimiz,optimization,11018,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:11365,Performance,optimiz,optimization,11365,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:11462,Performance,optimiz,optimization,11462,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:8712,Safety,safe,safe,8712,"s objects within that frame.Definition RooPlot.h:45; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf510_wsnamedsetsDefinition rf510_wsnamedsets.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8C.html:8879,Safety,safe,safe,8879,"r) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf510_wsnamedsetsDefinition rf510_wsnamedsets.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8C.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2814,Availability,error,errors,2814,"ters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:6490,Availability,error,error,6490,"port(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] IN",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:6934,Availability,error,error,6934,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7473,Availability,error,error,7473,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:1820,Modifiability,variab,variables,1820,"OT.RooGaussian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Import model into p.d.f.; w.Import(model); ; # Encode definition of parameters in workspace; # ---------------------------------------------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2106,Modifiability,variab,variables,2106,"ckground"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Import model into p.d.f.; w.Import(model); ; # Encode definition of parameters in workspace; # ---------------------------------------------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, Print",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2608,Modifiability,variab,variables,2608,"Import model into p.d.f.; w.Import(model); ; # Encode definition of parameters in workspace; # ---------------------------------------------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapsho",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2696,Modifiability,variab,variable,2696,"----------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2804,Modifiability,variab,variable,2804,"ters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7710,Modifiability,variab,variables,7710,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:2723,Performance,load,loadSnapshot,2723,"----------------------------------------------------; ; # Define named sets ""parameters"" and ""observables"", list which variables should be considered; # parameters and observables by the users convention; #; # Variables appearing in sets _must_ live in the workspace already, the autoImport flag; # of defineSet must be set to import them on the fly. Named sets contain only references; # to the original variables, the value of observables in named sets already; # reflect their 'current' value; params = model.getParameters({x}); w.defineSet(""parameters"", params); w.defineSet(""observables"", {x}); ; # Encode reference value for parameters in workspace; # ---------------------------------------------------------------------------------------------------; ; # Define a parameter 'snapshot' in the p.d.f.; # Unlike a named set, parameter snapshot stores an independent set of values for; # a given set of variables in the workspace. The values can be stored and reloaded; # into the workspace variable objects using the loadSnapshot() and saveSnapshot(); # methods. A snapshot saves the value of each variable, errors that are stored; # with it as well as the 'Constant' flag that is used in fits to determine if a; # parameter is kept fixed or not.; ; # Do a dummy fit to a (supposedly) reference dataset here and store the results; # of that fit into a snapshot; refData = model.generate({x}, 10000); model.fitTo(refData, PrintLevel=-1); ; # The kTRUE flag imports the values of the objects in (*params) into the workspace; # If not set, present values of the workspace parameters objects are stored; w.saveSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4292,Performance,load,loadSnapshot,4292,"veSnapshot(""reference_fit"", params, True); ; # Make another fit with the signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for introspected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectH",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4361,Performance,load,loadSnapshot,4361,"signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for introspected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:Obj",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:6584,Performance,optimiz,optimization,6584,"ooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:6681,Performance,optimiz,optimization,6681," [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorks",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7028,Performance,optimiz,optimization,7028,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7220,Performance,optimiz,optimization,7220,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7567,Performance,optimiz,optimization,7567,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:7664,Performance,optimiz,optimization,7664,"ectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4914,Safety,safe,safe,4914,"rospected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:Objec",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf510__wsnamedsets_8py.html:5081,Safety,safe,safe,5081,"ata, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a0; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHan",MatchSource.WIKI,doc/master/rf510__wsnamedsets_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html
https://root.cern/doc/master/rf511__wsfactory__basic_8C.html:2253,Integrability,depend,depending,2253,"ac[0.5,0.,1.]*bkg,sig)"");; ; } else {; ; // Use object factory to build pdf of tutorial rs502_wspacewrite but; // - Contracted to a single line recursive expression,; // - Omitting explicit names for components that are not referred to explicitly later; ; w->factory(""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[0.2,0.,1.]}),""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))"");; }; ; // A d v a n c e d p . d . f . c o n s t r u c t o r a r g u m e n t s; // ----------------------------------------------------------------; //; // P.d.f. constructor arguments may by any type of RooAbsArg, but also; //; // double --> converted to RooConst(...); // {a,b,c} --> converted to RooArgSet() or RooArgList() depending on required ctor arg; // dataset name --> converted to RooAbsData reference for any dataset residing in the workspace; // enum --> Any enum label that belongs to an enum defined in the (base) class; ; // Make a dummy dataset pdf 'model' and import it in the workspace; std::unique_ptr<RooDataSet> data{w->pdf(""model"")->generate(*w->var(""x""), 1000)};; w->import(*data, Rename(""data""));; ; // Construct a KEYS pdf passing a dataset name and an enum type defining the; // mirroring strategy; w->factory(""KeysPdf::k(x,data,NoMirror,0.2)"");; ; // Print workspace contents; w->Print();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFit::RenameRooCmdArg Rename(const char *suffix)Definition RooGlobalFunc.cxx:1055; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or o",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html
https://root.cern/doc/master/rf511__wsfactory__basic_8C.html:3800,Modifiability,variab,variables,3800,"ake a dummy dataset pdf 'model' and import it in the workspace; std::unique_ptr<RooDataSet> data{w->pdf(""model"")->generate(*w->var(""x""), 1000)};; w->import(*data, Rename(""data""));; ; // Construct a KEYS pdf passing a dataset name and an enum type defining the; // mirroring strategy; w->factory(""KeysPdf::k(x,data,NoMirror,0.2)"");; ; // Print workspace contents; w->Print();; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFit::RenameRooCmdArg Rename(const char *suffix)Definition RooGlobalFunc.cxx:1055; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf511_wsfactory_basicDefinition rf511_wsfactory_basic.py:1; ; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooKeysPdf::k[ x=x ] = 0.0210129; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.4/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 7.45331e-07/1; RooGaussian::sig1[ x=x mean=mean sigma=0.5 ] = 1.92875e-22; RooGaussian::sig2[ x=x mean=mean sigma=1 ] = 3.72665e-06; ; datasets; --------; RooDataSet::data(x); ; DateJuly 2009 ; AuthorWouter Verkerke ; Definition in file rf511_wsfactory_basic.C. tutorialsroofitrf511_wsfactory_basic.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8C.html
https://root.cern/doc/master/rf511__wsfactory__basic_8py.html:1912,Integrability,depend,depending,1912,"wspacewrite; w.factory(""Gaussian::sig1(x[-10,10],mean[5,0,10],0.5)""); w.factory(""Gaussian::sig2(x,mean,1)""); w.factory(""Chebychev::bkg(x,{a0[0.5,0.,1],a1[-0.2,0.,1.]})""); w.factory(""SUM::sig(sig1frac[0.8,0.,1.]*sig1,sig2)""); w.factory(""SUM::model(bkgfrac[0.5,0.,1.]*bkg,sig)""); ; else:; ; # Use object factory to build pdf of tutorial rs502_wspacewrite but; # - Contracted to a single line recursive expression,; # - Omitting explicit names for components that are not referred to explicitly later; ; w.factory(; ""SUM::model(bkgfrac[0.5,0.,1.]*Chebychev::bkg(x[-10,10],{a0[0.5,0.,1],a1[-0.2,0.,1.]}), ""; ""SUM(sig1frac[0.8,0.,1.]*Gaussian(x,mean[5,0,10],0.5), Gaussian(x,mean,1)))""; ); ; # Advanced pdf constructor arguments; # ----------------------------------------------------------------; #; # P.d.f. constructor arguments may by any type of ROOT.RooAbsArg, also; #; # Double_t -. converted to ROOT.RooConst(...); # {a,b,c} -. converted to ROOT.RooArgSet() or ROOT.RooArgList() depending on required ctor arg; # dataset name -. converted to ROOT.RooAbsData reference for any dataset residing in the workspace; # enum -. Any enum label that belongs to an enum defined in the (base); # class; ; # Make a dummy dataset pdf 'model' and import it in the workspace; data = w[""model""].generate({w[""x""]}, 1000); # Cannot call 'import' directly because this is a python keyword:; w.Import(data, Rename=""data""); ; # Construct a KEYS pdf passing a dataset name and an enum type defining the; # mirroring strategy; # w.factory(""KeysPdf::k(x,data,NoMirror,0.2)""); # Workaround for pyROOT; x = w[""x""]; k = ROOT.RooKeysPdf(""k"", ""k"", x, data, ROOT.RooKeysPdf.NoMirror, 0.2); w.Import(k, RenameAllNodes=""workspace""); ; # Print workspace contents; w.Print(); [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) Resolving name confli",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html
https://root.cern/doc/master/rf511__wsfactory__basic_8py.html:3117,Modifiability,variab,variables,3117,"OOT.RooConst(...); # {a,b,c} -. converted to ROOT.RooArgSet() or ROOT.RooArgList() depending on required ctor arg; # dataset name -. converted to ROOT.RooAbsData reference for any dataset residing in the workspace; # enum -. Any enum label that belongs to an enum defined in the (base); # class; ; # Make a dummy dataset pdf 'model' and import it in the workspace; data = w[""model""].generate({w[""x""]}, 1000); # Cannot call 'import' directly because this is a python keyword:; w.Import(data, Rename=""data""); ; # Construct a KEYS pdf passing a dataset name and an enum type defining the; # mirroring strategy; # w.factory(""KeysPdf::k(x,data,NoMirror,0.2)""); # Workaround for pyROOT; x = w[""x""]; k = ROOT.RooKeysPdf(""k"", ""k"", x, data, ROOT.RooKeysPdf.NoMirror, 0.2); w.Import(k, RenameAllNodes=""workspace""); ; # Print workspace contents; w.Print(); [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset modelData; [#1] INFO:ObjectHandling -- RooWorkSpace::import(w) changing name of dataset from modelData to data; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) Resolving name conflict in workspace by changing name of imported node k to k_workspace; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooKeysPdf::k_workspace; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 1; RooKeysPdf::k_workspace[ x=x ] = 0.0139016; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.5/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 7.45331e-07/1; RooGaussian::sig1[ x=x mean=mean sigma=0.5 ] = 1.92875e-22; RooGaussian::sig2[ x=x mean=mean sigma=1 ] = 3.72665e-06; ; datasets; --------; RooDataSet::data(x); ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf511_wsfactory_basic.py. tutorialsroofitrf511_wsfactory_basic.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf511__wsfactory__basic_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf511__wsfactory__basic_8py.html
https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:2443,Modifiability,coupling,couplings,2443,"gy( y[-10,10], x, 1.0 )"");; w->factory(""PROD::gxycond( gy|x, gx )"");; ; // Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w->factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )"");; ; // Simultaneous pdfs are constructed with SIMUL( index, state1=pdf1, state2=pdf2,...); w->factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )"");; ; // O p e r a t o r f u n c t i o n e x a m p l e s; // ---------------------------------------------------; ; // Function multiplication is done with prod (func1, func2,...); w->factory(""prod::uv(u[10],v[10])"");; ; // Function addition is done with sum(func1,func2); w->factory(""sum::uv2(u,v)"");; ; // Lagrangian morphing function for the example shown in rf711_lagrangianmorph; std::string infilename = std::string(gROOT->GetTutorialDir()) + ""/roofit/input_histos_rf_lagrangianmorph.root"";; w->factory((""lagrangianmorph::morph($fileName('""+infilename+""'),$observableName('pTV'),$couplings({cHq3[0,1],SM[1]}),$NewPhysics(cHq3=1,SM=0),$folders({'SM_NPsq0','cHq3_NPsq1','cHq3_NPsq2'}))"").c_str());; ; ; // Taylor expansion is done with taylorexpand(func,{var1,var2,...},val,order); w->factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)"");; ; ; // I n t e r p r e t e d a n d c o m p i l e d e x p r e s s i o n b a s e d p . d . f . s .; // ---------------------------------------------------------------------------------------------------; ; // Create a RooGenericPdf interpreted pdf You can use single quotes to pass the expression string argument; w->factory(""EXPR::G('x*x+1',x)"");; ; // Create a custom compiled pdf similar to the above interpreted pdf; // The code required to make this pdf is automatically embedded in the workspace; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make works",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:4097,Modifiability,variab,variable,4097,"to the above interpreted pdf; // The code required to make this pdf is automatically embedded in the workspace; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make workspace visible on command line; gDirectory->Add(w);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; gROOT#define gROOTDefinition TROOT.h:406; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf512_wsfactory_operDefinition rf512_wsfactory_oper.py:1; ; [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:5042,Modifiability,variab,variables,5042,"iable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf::G[ actualVars=(x) formula=""x[0]*x[0]+1"" ] = 1; RooCFAuto000Pdf::GC[ x=x a=a ] = 1; RooChebychev::ch[ x=x coefList=(0.1,0.2,-0.3) ] = 0.8; RooAddPdf::extsummodel[ Nsig * gx + Nbkg * ch ] = 0.9/1; RooGaussian::g[ x=x mean=mg sigma=1 ] = 1; RooGaussian::gs[ x=x mean=m sigma=s ] = 1; RooGaussian::gx[ x=x mean=m sigma=1 ] = 1; RooProdPdf::gxycond[ gx * gy|x ] = 1; RooProdPdf::gxz[ gx * gz ] = 1; RooGaussian::gy[ x=y mean=x sigma=1 ] = 1; RooGaussian::gz[ x=z mean=0 sigma=1 ] = 1; RooLandau::lc[ x=x mean=0 sigma=1 ] = 0.178854; RooLandau::ls[ x=x mean=0 sigma=1 ] = 0.178854; RooFFTConvPdf::lxg[ g(x) (*) lc(x) ] = 375639; RooSimultaneous::smodel[ indexCat=c A=gs B=ls ] = 1; RooAddPdf::summodel[ f * gx + [%] * ch ] = 0.9/1; ; functions; --------; RooLagrangianMorphFunc::morph[ physics=(phys_SM_NPsq0_morph,phys_cHq3_NPsq1_morph,phys_cHq3_NPsq2_morph) operators=(cHq3,SM) ob",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
https://root.cern/doc/master/rf512__wsfactory__oper_8C.html:4252,Performance,cache,cache,4252,"; w->factory(""CEXPR::GC('x*x+a',{x,a[1]})"");; ; // Compiled and interpreted functions (rather than pdfs) can be made with the lower case; // 'expr' and 'cexpr' types; ; // Print workspace contents; w->Print();; ; // Make workspace visible on command line; gDirectory->Add(w);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; gROOT#define gROOTDefinition TROOT.h:406; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf512_wsfactory_operDefinition rf512_wsfactory_oper.py:1; ; [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8C.html
https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:2154,Modifiability,coupling,couplings,2154,"ssian::gy( y[-10,10], x, 1.0 )""); w.factory(""PROD::gxycond( gy|x, gx )""); ; # Convolution (numeric/ fft) is done with NCONV/FCONV (obs,pdf1,pdf2); w.factory(""FCONV::lxg( x, Gaussian::g(x,mg[0],1), Landau::lc(x,0,1) )""); ; # Simultaneous p.d.f.s are constructed with SIMUL( index, state1=pdf1,; # state2=pdf2,...); w.factory(""SIMUL::smodel( c[A=0,B=1], A=Gaussian::gs(x,m,s[1.0, 0.01, 10.0]), B=Landau::ls(x,0,1) )""); ; # Operator function examples; # ---------------------------------------------------; ; # Function multiplication is done with prod (func1, func2,...); w.factory(""prod::uv(u[10],v[10])""); ; # Function addition is done with sum(func1,func2); w.factory(""sum::uv2(u,v)""); ; # Lagrangian morphing function for the example shown in rf711_lagrangianmorph; infilename = ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/input_histos_rf_lagrangianmorph.root""; w.factory(; ""lagrangianmorph::morph($observableName('pTV'),$fileName('""; + infilename; + ""'),$couplings({cHq3[0,1],SM[1]}),$NewPhysics(cHq3=1,SM=0),$folders({'SM_NPsq0','cHq3_NPsq1','cHq3_NPsq2'}))""; ); ; # Taylor expansion is done with taylorexpand(func,{var1,var2,...},val,order); w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changin",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:3217,Modifiability,variab,variable,3217,"q3_NPsq1','cHq3_NPsq2'}))""; ); ; # Taylor expansion is done with taylorexpand(func,{var1,var2,...},val,order); w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:4162,Modifiability,variab,variables,4162,"iable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf::G[ actualVars=(x) formula=""x[0]*x[0]+1"" ] = 1; RooCFAuto000Pdf::GC[ x=x a=a ] = 1; RooChebychev::ch[ x=x coefList=(0.1,0.2,-0.3) ] = 0.8; RooAddPdf::extsummodel[ Nsig * gx + Nbkg * ch ] = 0.9/1; RooGaussian::g[ x=x mean=mg sigma=1 ] = 1; RooGaussian::gs[ x=x mean=m sigma=s ] = 1; RooGaussian::gx[ x=x mean=m sigma=1 ] = 1; RooProdPdf::gxycond[ gx * gy|x ] = 1; RooProdPdf::gxz[ gx * gz ] = 1; RooGaussian::gy[ x=y mean=x sigma=1 ] = 1; RooGaussian::gz[ x=z mean=0 sigma=1 ] = 1; RooLandau::lc[ x=x mean=0 sigma=1 ] = 0.178854; RooLandau::ls[ x=x mean=0 sigma=1 ] = 0.178854; RooFFTConvPdf::lxg[ g(x) (*) lc(x) ] = 375639; RooSimultaneous::smodel[ indexCat=c A=gs B=ls ] = 1; RooAddPdf::summodel[ f * gx + [%] * ch ] = 0.9/1; ; functions; --------; RooLagrangianMorphFunc::morph[ physics=(phys_SM_NPsq0_morph,phys_cHq3_NPsq1_morph,phys_cHq3_NPsq2_morph) operators=(cHq3,SM) ob",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
https://root.cern/doc/master/rf512__wsfactory__oper_8py.html:3372,Performance,cache,cache,3372," w.factory(""taylorexpand::te(expr::poly('x^4+5*x^3+2*x^2+x+1',x),{x},0.0,2)""); ; ; # Interpreted and compiled expression based pdfs; # ---------------------------------------------------------------------------------------------------; ; # Create a ROOT.RooGenericPdf interpreted p.d.f. You can use single quotes; # to pass the expression string argument; w.factory(""EXPR::G('x*x+1',x)""); ; # Create a custom compiled p.d.f similar to the above interpreted p.d.f.; # The code required to make self p.d.f. is automatically embedded in; # the workspace; w.factory(""CEXPR::GC('x*x+a',{x,a[1]})""); ; # Compiled and interpreted functions (rather than p.d.f.s) can be made with the lower case; # 'expr' and 'cexpr' types; ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); [#1] INFO:Caching -- Changing internal binning of variable 'x' in FFT 'lxg' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#0] PROGRESS:InputArguments -- initializing physics inputs from file /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/roofit/input_histos_rf_lagrangianmorph.root with object name(s) 'pTV'; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_SM_NPsq0_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq1_morph; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing dataset dh_cHq3_NPsq2_morph; [#1] INFO:ObjectHandling -- RooWorkspace::autoImportClass(w) importing code of class RooCFAuto000Pdf from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/documentation/doxygen/RooCFAuto000Pdf.cxx and RooCFAuto000Pdf.h; ; RooWorkspace(w) w contents; ; variables; ---------; (Nbkg,Nsig,SM,a,binWidth_pTV,c,cHq3,f,m,mg,nNP0,nNP1,nNP2,nNP3,nNP4,pTV,s,te_c0,te_c1,te_c2,te_x^0,te_x^1,te_x^2,u,v,x,y,z); ; p.d.f.s; -------; RooGenericPdf",MatchSource.WIKI,doc/master/rf512__wsfactory__oper_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf512__wsfactory__oper_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:303,Integrability,interface,interface,303,". ROOT: tutorials/roofit/rf513_wsfactory_tools.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf513_wsfactory_tools.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: RooCustomizer and RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooChebychev.h""; #include ""RooAddPdf.h""; #include ""RooWorkspace.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf513_wsfactory_tools(); {; RooWorkspace *w = new RooWorkspace(""w"");; ; // B u i l d a c o m p l e x e x a m p l e p . d . f .; // -----------------------------------------------------------; ; // Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:2450,Integrability,interface,interfaced,2450,",0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications (branch of leaf node replacements); //; // Here we take our model (the original before RooSimWSTool modifications); // and request that the parameter w (the mistag rate) is replaced with; // an expression-based function that calculates w in terms of the Dilution; // parameter D that is defined as D = 1-2*w; ; // Make a clone model_D of original 'model' replacing 'w' with 'expr('0.5-D/2',D[0,1])'; w->factory(""EDIT::model_D(model, w=expr('0.5-D/2'",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:2085,Modifiability,parameteriz,parameterizations,2085,"odel); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:4051,Modifiability,variab,variables,4051,"sed function that calculates w in terms of the Dilution; // parameter D that is defined as D = 1-2*w; ; // Make a clone model_D of original 'model' replacing 'w' with 'expr('0.5-D/2',D[0,1])'; w->factory(""EDIT::model_D(model, w=expr('0.5-D/2',D[0,1]) )"");; ; // Print workspace contents; w->Print();; ; // Make workspace visible on command line; gDirectory->Add(w);; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorkspace.h; TAxis.h; TCanvas.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf513_wsfactory_toolsDefinition rf513_wsfactory_tools.py:1; ; ; RooWorkspace(w) w contents; ; variables; ---------; (D,NBkg,Nsig,biasC,biasC_Kao,biasC_Lep,biasC_NT1,biasC_NT2,dm,dt,dterr,dw,dw_Kao,dw_Lep,dw_NT1,dw_NT2,fracC,fracT,k,mB0,mes,mixState,sigmB0,sigmaC,sigmaT,tagCat,tagFlav,tau,w,w_Kao,w_Lep,w_NT1,w_NT2); ; p.d.f.s; -------; RooProdPdf::bkg[ bkg_t * bkg_m ] = 0.307193; RooProdPdf::bkg_Kao[ bkg_t_Kao * bkg_m ] = 0.307193; RooProdPdf::bkg_Lep[ bkg_t_Lep * bkg_m ] = 0.307193; RooProdPdf::bkg_NT1[ bkg_t_NT1 * bkg_m ] = 0.307193; RooProdPdf::bkg_NT2[ bkg_t_NT2 * bkg_m ] = 0.307193; RooArgusBG::bkg_m[ m=mes m0=5.291 c=k p=0.5 ] = 0.279062; RooDecay::bkg_t[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_Kao[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_Lep[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_NT1[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_NT2[ t=dt tau=tau ] = 1.10081; RooAddPdf::model[ Nsig * sig + NBkg * bkg ] = 1.88229/1; RooAddPdf::model_D[ Nsig * sig_model_D + NBkg * bkg ] = 1.5029/1; RooAddPdf::model_Kao[ Nsig * sig_Kao + NBkg * bkg_Kao ] = 1.88229/1; RooAddPdf::model_Lep[ Nsig * sig_Lep + NBkg * bkg_Lep ] = 1.88229/1; RooAddPdf::model_NT1[ Nsig * sig_NT1 + NBkg ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
https://root.cern/doc/master/rf513__wsfactory__tools_8C.html:2046,Performance,perform,performance,2046,"odel); // times a Gaussian function the reconstructed mass; w->factory(""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0],""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]),""; ""GaussModel(dt,0,sigmaT[3,10]),""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}),""; ""DoubleSided ),""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))"");; ; // Make background component: A plain decay function in t times an Argus function in the reconstructed mass; w->factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided),""; ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))"");; ; // Make composite model from the signal and background component; w->factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )"");; ; // E x a m p l e o f R o o S i m W S T o o l i n t e r f a c e; // ------------------------------------------------------------------; ; // Introduce a flavour tagging category tagCat as observable with 4 states corresponding; // to 4 flavour tagging techniques with different performance that require different; // parameterizations of the fit model; //; // RooSimWSTool operation:; // - Make 4 clones of model (for each tagCat) state, that will gain an individual; // copy of parameters w,dw and biasC. The other parameters remain common; // - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; // state of the tagCat index category; ; // RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); // argument maps to the SplitParam() named argument in the RooSimWSTool constructor; w->factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))"");; ; // E x a m p l e o f R o o C u s t o m i z e r i n t e r f a c e; // -------------------------------------------------------------------; //; // Class RooCustomizer makes clones of existing pdfs with certain prescribed; // modifications ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8C.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:348,Integrability,interface,interface,348,". ROOT: tutorials/roofit/rf513_wsfactory_tools.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf513_wsfactory_tools.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: illustration use of ROOT.RooCustomizer and ROOT.RooSimWSTool interface in factory workspace tool in a complex standalone B physics example ; ; import ROOT; ; ; w = ROOT.RooWorkspace(""w""); ; # Build a complex example pdf; # -----------------------------------------------------------; ; # Make signal model for CPV: A bmixing decay function in t (convoluted with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other paramete",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:1541,Integrability,interface,interface,1541," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:2161,Integrability,interface,interfaced,2161,": A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf node replacements); #; # Here we take our model (the original before ROOT.RooSimWSTool modifications); # and request that the parameter w (the mistag rate) is replaced with; # an expression-based function that calculates w in terms of the Dilution; # parameter D that is defined D = 1-2*w; ; # Make a clone model_D of original 'model' replacing 'w' with; # 'expr('0.5-D/2',D[0,1])'; w.factory(""EDIT::model_D(model, w=expr('0.5-D/2',D[0,1]) )""); ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:2443,Integrability,interface,interface,2443,"onent; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf node replacements); #; # Here we take our model (the original before ROOT.RooSimWSTool modifications); # and request that the parameter w (the mistag rate) is replaced with; # an expression-based function that calculates w in terms of the Dilution; # parameter D that is defined D = 1-2*w; ; # Make a clone model_D of original 'model' replacing 'w' with; # 'expr('0.5-D/2',D[0,1])'; w.factory(""EDIT::model_D(model, w=expr('0.5-D/2',D[0,1]) )""); ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); ; RooWorkspace(w) w contents; ; variables; ---------; (D,NBkg,Nsig,biasC,biasC_Kao,biasC_Lep,biasC_NT1,biasC_NT2,dm,dt,dterr,dw,dw_Kao,dw_Lep,dw_NT1,dw_NT2,fracC,fracT,k,mB0,mes,mixState,sigmB0,sigmaC,sigmaT,tagCat,tagFlav,tau,w,w_Kao,w",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:1800,Modifiability,parameteriz,parameterizations,1800," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:3228,Modifiability,variab,variables,3228,"w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf node replacements); #; # Here we take our model (the original before ROOT.RooSimWSTool modifications); # and request that the parameter w (the mistag rate) is replaced with; # an expression-based function that calculates w in terms of the Dilution; # parameter D that is defined D = 1-2*w; ; # Make a clone model_D of original 'model' replacing 'w' with; # 'expr('0.5-D/2',D[0,1])'; w.factory(""EDIT::model_D(model, w=expr('0.5-D/2',D[0,1]) )""); ; # Print workspace contents; w.Print(); ; # Make workspace visible on command line; ROOT.gDirectory.Add(w); ; RooWorkspace(w) w contents; ; variables; ---------; (D,NBkg,Nsig,biasC,biasC_Kao,biasC_Lep,biasC_NT1,biasC_NT2,dm,dt,dterr,dw,dw_Kao,dw_Lep,dw_NT1,dw_NT2,fracC,fracT,k,mB0,mes,mixState,sigmB0,sigmaC,sigmaT,tagCat,tagFlav,tau,w,w_Kao,w_Lep,w_NT1,w_NT2); ; p.d.f.s; -------; RooProdPdf::bkg[ bkg_t * bkg_m ] = 0.307193; RooProdPdf::bkg_Kao[ bkg_t_Kao * bkg_m ] = 0.307193; RooProdPdf::bkg_Lep[ bkg_t_Lep * bkg_m ] = 0.307193; RooProdPdf::bkg_NT1[ bkg_t_NT1 * bkg_m ] = 0.307193; RooProdPdf::bkg_NT2[ bkg_t_NT2 * bkg_m ] = 0.307193; RooArgusBG::bkg_m[ m=mes m0=5.291 c=k p=0.5 ] = 0.279062; RooDecay::bkg_t[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_Kao[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_Lep[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_NT1[ t=dt tau=tau ] = 1.10081; RooDecay::bkg_t_NT2[ t=dt tau=tau ] = 1.10081; RooAddPdf::model[ Nsig * sig + NBkg * bkg ] = 1.88229/1; RooAddPdf::model_D[ Nsig * sig_model_D + NBkg * bkg ] = 1.5029/1; RooAddPdf::model_Kao[ Nsig * sig_Kao + NBkg * bkg_Kao ] = 1.88229/1; RooAddPdf::model_Lep[ Nsig * sig_Lep + NBkg * bkg_Lep ] = 1.88229/1; RooAddPdf::model_NT1[ Nsig * sig_NT1 + NBkg ",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf513__wsfactory__tools_8py.html:1762,Performance,perform,performance,1762," with a triple Gaussian resolution model); # times a Gaussian function the reconstructed mass; w.factory(; ""PROD::sig( BMixDecay::sig_t( dt[-20,20], mixState[mixed=1,unmix=-1], tagFlav[B0=1,B0bar=-1], ""; ""tau[1.54], dm[0.472], w[0.05], dw[0], ""; ""AddModel::gm({GaussModel(dt,biasC[-10,10],sigmaC[0.1,3],dterr[0.01,0.2]), ""; ""GaussModel(dt,0,sigmaT[3,10]), ""; ""GaussModel(dt,0,20)},{fracC[0,1],fracT[0,1]}), ""; ""DoubleSided ), ""; ""Gaussian::sig_m( mes[5.20,5.30], mB0[5.20,5.30], sigmB0[0.01,0.05] ))""; ); ; # Make background component: A plain decay function in t times an Argus; # function in the reconstructed mass; w.factory(""PROD::bkg( Decay::bkg_t( dt, tau, gm, DoubleSided), "" ""ArgusBG::bkg_m( mes, 5.291, k[-100,-10]))""); ; # Make composite model from the signal and background component; w.factory(""SUM::model( Nsig[5000,0,10000]*sig, NBkg[500,0,10000]*bkg )""); ; # Example of RooSimWSTool interface; # ------------------------------------------------------------------; ; # Introduce a flavour tagging category tagCat as observable with 4 states corresponding; # to 4 flavour tagging techniques with different performance that require different; # parameterizations of the fit model; #; # ROOT.RooSimWSTool operation:; # - Make 4 clones of model (for each tagCat) state, will gain an individual; # copy of parameters w, and biasC. The other parameters remain common; # - Make a simultaneous pdf of the 4 clones assigning each to the appropriate; # state of the tagCat index category; ; # ROOT.RooSimWSTool is interfaced as meta-type SIMCLONE in the factory. The $SplitParam(); # argument maps to the SplitParam() named argument in the; # ROOT.RooSimWSTool constructor; w.factory(""SIMCLONE::model_sim( model, $SplitParam({w,dw,biasC},tagCat[Lep,Kao,NT1,NT2]))""); ; # Example of RooCustomizer interface; # -------------------------------------------------------------------; #; # Class ROOT.RooCustomizer makes clones of existing pdfs with certain prescribed; # modifications (branch of leaf no",MatchSource.WIKI,doc/master/rf513__wsfactory__tools_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf513__wsfactory__tools_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:3562,Integrability,depend,depending,3562," register them in the set of customiser nodes.; // The customiser will pick them up instead of creating new ones.; // If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; RooRealVar mass(""M"", ""M"", 1, 0, 12000);; RooFormulaVar yield1(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass);; RooFormulaVar yield2(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass);; allCustomiserNodes.add(yield1);; allCustomiserNodes.add(yield2);; ; // Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample);; ; ; // Now we can start building the PDFs for all categories:; auto pdf1 = cust.build(""Sample1"");; auto pdf2 = cust.build(""Sample2"");; auto pdf3 = cust.build(""Sample3"");; ; // And we inspect the two PDFs; std::cout << ""\nPDF 1 with a yield depending on M:"" << std::endl;; pdf1->Print(""T"");; std::cout << ""\nPDF 2 with a yield depending on M:"" << std::endl;; pdf2->Print(""T"");; std::cout << ""\nPDF 3 with a free yield:"" << std::endl;; pdf3->Print(""T"");; ; std::cout << ""\nThe following leaves have been created automatically while customising:"" << std::endl;; newLeaves.Print(""V"");; ; ; // If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; auto& meanG1 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample1""]);; meanG1.setVal(200);; auto& meanG2 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample2""]);; meanG2.setVal(300);; ; std::cout << ""\nThe following leaves have been used while customising""; << ""\n\t(partial overlap with the set of automatically created leaves.""; << ""\n\ta new customiser for a different PDF could reuse them if necessary.):"" << std::endl;; allCustomiserNodes.Print(""V"");; ; ; }; RooAddPdf.h; RooCategory.h; RooCustomizer.h; RooFormulaVar.h; RooGaussian.h; RooPolynomial.h; RooRealVar.h; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:3648,Integrability,depend,depending,3648," register them in the set of customiser nodes.; // The customiser will pick them up instead of creating new ones.; // If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; RooRealVar mass(""M"", ""M"", 1, 0, 12000);; RooFormulaVar yield1(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass);; RooFormulaVar yield2(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass);; allCustomiserNodes.add(yield1);; allCustomiserNodes.add(yield2);; ; // Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample);; ; ; // Now we can start building the PDFs for all categories:; auto pdf1 = cust.build(""Sample1"");; auto pdf2 = cust.build(""Sample2"");; auto pdf3 = cust.build(""Sample3"");; ; // And we inspect the two PDFs; std::cout << ""\nPDF 1 with a yield depending on M:"" << std::endl;; pdf1->Print(""T"");; std::cout << ""\nPDF 2 with a yield depending on M:"" << std::endl;; pdf2->Print(""T"");; std::cout << ""\nPDF 3 with a free yield:"" << std::endl;; pdf3->Print(""T"");; ; std::cout << ""\nThe following leaves have been created automatically while customising:"" << std::endl;; newLeaves.Print(""V"");; ; ; // If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; auto& meanG1 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample1""]);; meanG1.setVal(200);; auto& meanG2 = static_cast<RooRealVar&>(allCustomiserNodes[""meanG_Sample2""]);; meanG2.setVal(300);; ; std::cout << ""\nThe following leaves have been used while customising""; << ""\n\t(partial overlap with the set of automatically created leaves.""; << ""\n\ta new customiser for a different PDF could reuse them if necessary.):"" << std::endl;; allCustomiserNodes.Print(""V"");; ; ; }; RooAddPdf.h; RooCategory.h; RooCustomizer.h; RooFormulaVar.h; RooGaussian.h; RooPolynomial.h; RooRealVar.h; RooAbsCollection::addvirtual bool add(const RooAbsArg &var, bool silent=false)Add ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:6735,Integrability,depend,depending,6735,"object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; rf514_RooCustomizerDefinition rf514_RooCustomizer.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; The proto model before customisation:; 0x7ffc956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x557340631bf0/V- RooRealVar::meanG_Sample1 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b71f0/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; 0x7ffc956b66a0/V- RooRealVar::M = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 2 with a yield depending on M:; 0x55734057d9d0 RooAddPdf::model_Sample2 = 1000.67/1 [Auto,Clean] ; 0x55734180e980/V- RooGaussian::gauss_Sample2 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:7344,Integrability,depend,depending,7344,"c956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x557340631bf0/V- RooRealVar::meanG_Sample1 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b71f0/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; 0x7ffc956b66a0/V- RooRealVar::M = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 2 with a yield depending on M:; 0x55734057d9d0 RooAddPdf::model_Sample2 = 1000.67/1 [Auto,Clean] ; 0x55734180e980/V- RooGaussian::gauss_Sample2 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x55734182e1b0/V- RooRealVar::meanG_Sample2 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b7628/V- RooFormulaVar::yieldSig_Sample2 = 0.5 [Auto,Clean] ; 0x7ffc956b66a0/V- RooRealVar::M = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 3 with a free yield:; 0x5573405818d0 RooAddPdf::model_Sample3 = 750.5/1 [Auto,Clean] ; 0x557340560070/V- RooGaussian::gauss_Sample3 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x55734055f270/V- RooRealVar::meanG_Sample3 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x55734063c570/V-",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:2506,Modifiability,variab,variable,2506,"ation:"" << std::endl;; model.Print(""T""); // ""T"" prints the model as a tree; ; ; // Build the categories; RooCategory sample(""sample"",""sample"");; sample[""Sample1""] = 1;; sample[""Sample2""] = 2;; sample[""Sample3""] = 3;; ; ; // Start to customise the proto model that was defined above.; // ---------------------------------------------------------------------------; ; // We need two sets for bookkeeping of PDF nodes:; RooArgSet newLeaves; // This set collects leaves that are created in the process.; RooArgSet allCustomiserNodes; // This set lists leaves that have been used in a replacement operation.; ; ; // 1. Each sample should have its own mean for the gaussian; // The customiser will make copies of `meanG` for each category.; // These will all appear in the set `newLeaves`, which will own the new nodes.; RooCustomizer cust(model, sample, newLeaves, &allCustomiserNodes);; cust.splitArg(meanG, sample);; ; ; // 2. Each sample should have its own signal yield, but there is an extra complication:; // We need the yields 1 and 2 to be a function of the variable ""mass"".; // For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; // that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; // The customiser will pick them up instead of creating new ones.; // If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; RooRealVar mass(""M"", ""M"", 1, 0, 12000);; RooFormulaVar yield1(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass);; RooFormulaVar yield2(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass);; allCustomiserNodes.add(yield1);; allCustomiserNodes.add(yield2);; ; // Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample);; ; ; // Now we can start building the PDFs for all categories:; auto pdf1 = cust.build(""Sample1"");; auto pdf2 = cust.build(""",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:5920,Modifiability,variab,variable,5920,"finition RooAbsCollection.h:315; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; rf514_RooCustomizerDefinition rf514_RooCustomizer.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; The proto model before customisation:; 0x7ffc956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8C.html:6145,Safety,safe,safe,6145,"bjects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooCustomizerRooCustomizer is a factory class to produce clones of a prototype composite PDF object with the same ...Definition RooCustomizer.h:36; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setValvoid setVal(double value) overrideSet value of variable to 'value'.Definition RooRealVar.cxx:242; rf514_RooCustomizerDefinition rf514_RooCustomizer.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; The proto model before customisation:; 0x7ffc956b53c8 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7ffc956b3d70/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b5ed0/V- RooRealVar::meanG = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b62b8/V- RooRealVar::yieldSig = 1; 0x7ffc956b42c8/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x7ffc956b4bf8/V- RooRealVar::pol1 = 1; 0x7ffc956b4fe0/V- RooRealVar::yieldBkg = 1; ; PDF 1 with a yield depending on M:; 0x55734032a0f0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x5573405e0390/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x7ffc956b5ae8/V- RooRealVar::Energy = 1500; 0x557340631bf0/V- RooRealVar::meanG_Sample1 = 100; 0x7ffc956b4810/V- RooRealVar::sigmaG = 3; 0x7ffc956b71f0/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8C.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:3054,Integrability,depend,depending,3054,"ss"".; # For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; # that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; # The customiser will pick them up instead of creating new ones.; # If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; mass = ROOT.RooRealVar(""M"", ""M"", 1, 0, 12000); yield1 = ROOT.RooFormulaVar(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass); yield2 = ROOT.RooFormulaVar(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass); allCustomiserNodes.add(yield1); allCustomiserNodes.add(yield2); ; # Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample); ; ; # Now we can start building the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x70",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:3120,Integrability,depend,depending,3120," have created automatically,; # that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; # The customiser will pick them up instead of creating new ones.; # If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; mass = ROOT.RooRealVar(""M"", ""M"", 1, 0, 12000); yield1 = ROOT.RooFormulaVar(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass); yield2 = ROOT.RooFormulaVar(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass); allCustomiserNodes.add(yield1); allCustomiserNodes.add(yield2); ; # Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample); ; ; # Now we can start building the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7075f00/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:6339,Integrability,depend,depending,6339,"00.67/1 [Auto,Clean] ; 0x76835f0/V- RooGaussian::gauss_Sample2 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6f8f320/V- RooRealVar::meanG_Sample2 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x76ba770/V- RooFormulaVar::yieldSig_Sample2 = 0.5 [Auto,Clean] ; 0x74a38c0/V- RooRealVar::M = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 0x77151e0 RooAddPdf::model_Sample3 = 750.5/1 [Auto,Clean] ; 0x76aa830/V- RooGaussian::gauss_Sample3 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x2ad1e30/V- RooRealVar::meanG_Sample3 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x2ad2220/V- RooRealVar::yieldSig_Sample3 = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 1) RooRealVar:: meanG_Sample1 = 100; 2) RooRealVar:: meanG_Sample2 = 100; 3) RooRealVar:: meanG_Sample3 = 100; 4) RooRealVar:: yieldSig_Sample3 = 1; 1) RooFormulaVar:: yieldSig_Sample1 = 0.29755; 2) RooFormulaVar:: yieldSig_Sample2 = 0.5; 3) RooRealVar:: meanG_Sample1 = 200; 4) RooRealVar:: meanG_Sample2 = 300; 5) RooRealVar:: meanG_Sample3 = 100; 6) RooRealVar:: yieldSig_Sample3 = 1; The proto model before customisation:; ; ; PDF 1 with a yield depending on M:; ; ; PDF 2 with a yield depending on M:; ; ; PDF 3 with a free yield:; ; ; The following leaves have been created automatically while customising:; ; ; The following leaves have been used while customising; (partial overlap with the set of automatically created leaves.; a new customiser for a different PDF could reuse them if necessary.):; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf514_RooCustomizer.py. tutorialsroofitrf514_RooCustomizer.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:6379,Integrability,depend,depending,6379,"00.67/1 [Auto,Clean] ; 0x76835f0/V- RooGaussian::gauss_Sample2 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6f8f320/V- RooRealVar::meanG_Sample2 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x76ba770/V- RooFormulaVar::yieldSig_Sample2 = 0.5 [Auto,Clean] ; 0x74a38c0/V- RooRealVar::M = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 0x77151e0 RooAddPdf::model_Sample3 = 750.5/1 [Auto,Clean] ; 0x76aa830/V- RooGaussian::gauss_Sample3 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x2ad1e30/V- RooRealVar::meanG_Sample3 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x2ad2220/V- RooRealVar::yieldSig_Sample3 = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 1) RooRealVar:: meanG_Sample1 = 100; 2) RooRealVar:: meanG_Sample2 = 100; 3) RooRealVar:: meanG_Sample3 = 100; 4) RooRealVar:: yieldSig_Sample3 = 1; 1) RooFormulaVar:: yieldSig_Sample1 = 0.29755; 2) RooFormulaVar:: yieldSig_Sample2 = 0.5; 3) RooRealVar:: meanG_Sample1 = 200; 4) RooRealVar:: meanG_Sample2 = 300; 5) RooRealVar:: meanG_Sample3 = 100; 6) RooRealVar:: yieldSig_Sample3 = 1; The proto model before customisation:; ; ; PDF 1 with a yield depending on M:; ; ; PDF 2 with a yield depending on M:; ; ; PDF 3 with a free yield:; ; ; The following leaves have been created automatically while customising:; ; ; The following leaves have been used while customising; (partial overlap with the set of automatically created leaves.; a new customiser for a different PDF could reuse them if necessary.):; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf514_RooCustomizer.py. tutorialsroofitrf514_RooCustomizer.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:2015,Modifiability,variab,variable,2015,", ""yieldBkg"", 1, 0, 1.0e4); ; model = ROOT.RooAddPdf(""model"", ""S + B model"", [gauss, linear], [yieldSig, yieldBkg]); ; print(""The proto model before customisation:\n""); model.Print(""T"") # ""T"" prints the model as a tree; ; ; # Build the categories; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ; ; # Start to customise the proto model that was defined above.; # ---------------------------------------------------------------------------; ; # We need two sets for bookkeeping of PDF nodes:; newLeaves = ROOT.RooArgSet(); allCustomiserNodes = ROOT.RooArgSet(); ; ; # 1. Each sample should have its own mean for the gaussian; # The customiser will make copies of `meanG` for each category.; # These will all appear in the set `newLeaves`, which will own the new nodes.; cust = ROOT.RooCustomizer(model, sample, newLeaves, allCustomiserNodes); cust.splitArg(meanG, sample); ; ; # 2. Each sample should have its own signal yield, but there is an extra complication:; # We need the yields 1 and 2 to be a function of the variable ""mass"".; # For this, we pre-define nodes with exactly the names that the customiser would have created automatically,; # that is, ""<nodeName>_<categoryName>"", and we register them in the set of customiser nodes.; # The customiser will pick them up instead of creating new ones.; # If we don't provide one (e.g. for ""yieldSig_Sample3""), it will be created automatically by cloning `yieldSig`.; mass = ROOT.RooRealVar(""M"", ""M"", 1, 0, 12000); yield1 = ROOT.RooFormulaVar(""yieldSig_Sample1"", ""Signal yield in the first sample"", ""M/3.360779"", mass); yield2 = ROOT.RooFormulaVar(""yieldSig_Sample2"", ""Signal yield in the second sample"", ""M/2"", mass); allCustomiserNodes.add(yield1); allCustomiserNodes.add(yield2); ; # Instruct the customiser to replace all yieldSig nodes for each sample:; cust.splitArg(yieldSig, sample); ; ; # Now we can start building the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sam",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf514__RooCustomizer_8py.html:3920,Safety,safe,safe,3920,"lding the PDFs for all categories:; pdf1 = cust.build(""Sample1""); pdf2 = cust.build(""Sample2""); pdf3 = cust.build(""Sample3""); ; # And we inspect the two PDFs; print(""\nPDF 1 with a yield depending on M:\n""); pdf1.Print(""T""); print(""\nPDF 2 with a yield depending on M:\n""); pdf2.Print(""T""); print(""\nPDF 3 with a free yield:\n""); pdf3.Print(""T""); ; print(""\nThe following leaves have been created automatically while customising:\n""); newLeaves.Print(""V""); ; # If we needed to set reasonable values for the means of the gaussians, this could be done as follows:; meanG1 = allCustomiserNodes[""meanG_Sample1""]; meanG1.setVal(200); meanG2 = allCustomiserNodes[""meanG_Sample2""]; meanG2.setVal(300); ; print(; ""\nThe following leaves have been used while customising\n\t(partial overlap with the set of automatically created leaves.\n\ta new customiser for a different PDF could reuse them if necessary.):""; ); allCustomiserNodes.Print(""V""); [#0] WARNING:InputArguments -- The parameter 'sigmaG' with range [-inf, inf] of the RooGaussian 'gauss' exceeds the safe range of (0, inf). Advise to limit its range.; 0x7448c10 RooAddPdf::model = 750.5/1 [Auto,Clean] ; 0x7075f00/V- RooGaussian::gauss = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x69b2ac0/V- RooRealVar::meanG = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x7002610/V- RooRealVar::yieldSig = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::pol1 = 1; 0x70456d0/V- RooRealVar::yieldBkg = 1; 0x76dd3d0 RooAddPdf::model_Sample1 = 1156.8/1 [Auto,Clean] ; 0x733d770/V- RooGaussian::gauss_Sample1 = 0 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x71a3180/V- RooRealVar::meanG_Sample1 = 100; 0x37bfa10/V- RooRealVar::sigmaG = 3; 0x769f520/V- RooFormulaVar::yieldSig_Sample1 = 0.29755 [Auto,Clean] ; 0x74a38c0/V- RooRealVar::M = 1; 0x720a750/V- RooPolynomial::linear = 1501 [Auto,Dirty] ; 0x6d30aa0/V- RooRealVar::Energy = 1500; 0x6fbfd00/V- RooRealVar::p",MatchSource.WIKI,doc/master/rf514__RooCustomizer_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf514__RooCustomizer_8py.html
https://root.cern/doc/master/rf515__hfJSON_8py.html:966,Modifiability,config,config,966,". ROOT: tutorials/roofit/rf515_hfJSON.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf515_hfJSON.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Code HistFactory Models in JSON. ; With the HS3 standard, it is possible to code RooFit-Models of any kind as JSON files. In this tutorial, you can see how to code up a (simple) HistFactory-based model in JSON and import it into a RooWorkspace.; ; import ROOT; ; # start by creating an empty workspace; ws = ROOT.RooWorkspace(""workspace""); ; # the RooJSONFactoryWSTool is responsible for importing and exporting things to and from your workspace; tool = ROOT.RooJSONFactoryWSTool(ws); ; # use it to import the information from your JSON file; tool.importJSON(ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf515_hfJSON.json""); ws.Print(); ; # now, you can easily use your workspace to run your fit (as you usually would); # the model config is named after your pdf, i.e. <the pdf name>_modelConfig; model = ws[""ModelConfig""]; ; # for resetting the parameters after the fit; params = model.GetPdf().getParameters(ws[""observed""]); ROOT.SetOwnership(params, True); params_initial = params.snapshot(); ROOT.SetOwnership(params_initial, True); ; # we are fitting a clone of the model now,; result = model.fitTo(ws[""observed""], ROOT.RooFit.Save(), ROOT.RooFit.PrintLevel(-1)); ROOT.SetOwnership(result, True); result.Print(); # reset parameters, such that we are not double-fitting the model in the; # closure check.; params.assign(params_initial); ; # in the end, you can again write to json; # the result will be not completely identical to the JSON file you used as an input, but it will work just the same; tool.exportJSON(""myWorkspace.json""); ; # You can again import it if you want and check for closure; ws_2 = ROOT.RooWorkspace(""workspace""); tool_2 = ROOT.RooJSONFactoryWSTool(ws_2); tool_2.importJSON(""myWorkspace.json""); ws_2.Print(); model_2 = ws_2[""ModelConfig""];",MatchSource.WIKI,doc/master/rf515__hfJSON_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf515__hfJSON_8py.html
https://root.cern/doc/master/rf515__hfJSON_8py.html:403,Usability,simpl,simple,403,". ROOT: tutorials/roofit/rf515_hfJSON.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf515_hfJSON.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Code HistFactory Models in JSON. ; With the HS3 standard, it is possible to code RooFit-Models of any kind as JSON files. In this tutorial, you can see how to code up a (simple) HistFactory-based model in JSON and import it into a RooWorkspace.; ; import ROOT; ; # start by creating an empty workspace; ws = ROOT.RooWorkspace(""workspace""); ; # the RooJSONFactoryWSTool is responsible for importing and exporting things to and from your workspace; tool = ROOT.RooJSONFactoryWSTool(ws); ; # use it to import the information from your JSON file; tool.importJSON(ROOT.gROOT.GetTutorialDir().Data() + ""/roofit/rf515_hfJSON.json""); ws.Print(); ; # now, you can easily use your workspace to run your fit (as you usually would); # the model config is named after your pdf, i.e. <the pdf name>_modelConfig; model = ws[""ModelConfig""]; ; # for resetting the parameters after the fit; params = model.GetPdf().getParameters(ws[""observed""]); ROOT.SetOwnership(params, True); params_initial = params.snapshot(); ROOT.SetOwnership(params_initial, True); ; # we are fitting a clone of the model now,; result = model.fitTo(ws[""observed""], ROOT.RooFit.Save(), ROOT.RooFit.PrintLevel(-1)); ROOT.SetOwnership(result, True); result.Print(); # reset parameters, such that we are not double-fitting the model in the; # closure check.; params.assign(params_initial); ; # in the end, you can again write to json; # the result will be not completely identical to the JSON file you used as an input, but it will work just the same; tool.exportJSON(""myWorkspace.json""); ; # You can again import it if you want and check for closure; ws_2 = ROOT.RooWorkspace(""workspace""); tool_2 = ROOT.RooJSONFactoryWSTool(ws_2); tool_2.importJSON(""myWorkspace.json""); ws_2.Print(); model_2 = ws_2[""ModelConfig""];",MatchSource.WIKI,doc/master/rf515__hfJSON_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf515__hfJSON_8py.html
https://root.cern/doc/master/rf601__intminuit_8C.html:1812,Availability,error,error,1812,"mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero proba",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:2016,Availability,error,errors,2016,"4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:2071,Availability,error,error,2071,".0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult-",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:2129,Availability,error,error,2129,".0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult-",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:2268,Availability,error,error,2268,"d of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult->Print(""v"");; ; // C h a n g e p a r a m e t e r v a l u e s , f l o a t i n g; // -----------------------------------------------------------------; ; // At any moment you can manually change ",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:2326,Availability,error,error,2326,"d of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult->Print(""v"");; ; // C h a n g e p a r a m e t e r v a l u e s , f l o a t i n g; // -----------------------------------------------------------------; ; // At any moment you can manually change ",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6062,Availability,error,error,6062,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6157,Availability,error,error,6157,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6172,Availability,avail,available,6172,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6285,Availability,error,error,6285,"is marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6300,Availability,avail,available,6300,"is marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8614,Availability,error,error,8614," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8670,Availability,toler,tolerance,8670," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8837,Availability,error,error,8837," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8893,Availability,toler,tolerance,8893," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8919,Availability,error,error,8919," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:8972,Availability,error,error,8972,"FCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2663.35774508719987; Edm = 9.56369873007578491e-05; Nfcn = 38; frac = 0.5655 +/- 0.1961 (limited); sigma_g2 = 4.005 +/- 0.3917 (limited); RooRealVar::frac = 0.5655 +/- 0.1961 L(0 - 1) ; Minuit2Minimizer: Minimize with max",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:1564,Integrability,interface,interface,1564,"#include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf601_intminuit(); {; // S e t u p p d f a n d l i k e l i h o o d; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snaps",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:4422,Integrability,interface,interface,4422,"se();; frac.Print();; ; // Now fix sigma_g2; sigma_g2.setConstant(true);; ; // Rerun MIGRAD,HESSE; m.migrad();; m.hesse();; frac.Print();; ; new TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooMinimizer.h; RooPlot.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::SetTitlevoid SetTitle(const char *name) overrideSet the title of the RooPlot to 'title'.Definition RooPlot.cxx:1243; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contai",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6124,Integrability,synchroniz,synchronize,6124,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:6252,Integrability,synchroniz,synchronize,6252,"is marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:5698,Safety,safe,safe,5698,"he title of the RooPlot to 'title'.Definition RooPlot.cxx:1243; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:1627,Testability,log,logging,1627,"#include ""TAxis.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf601_intminuit(); {; // S e t u p p d f a n d l i k e l i h o o d; // -----------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Model (intentional strong correlations); RooRealVar mean(""mean"", ""mean of g1 and g2"", 0);; RooRealVar sigma_g1(""sigma_g1"", ""width of g1"", 3);; RooGaussian g1(""g1"", ""g1"", x, mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snaps",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8C.html:1957,Testability,log,logging,1957,"mean, sigma_g1);; ; RooRealVar sigma_g2(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot",MatchSource.WIKI,doc/master/rf601__intminuit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1121,Availability,error,error,1121,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1481,Availability,error,error,1481,", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot o",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1653,Availability,error,errors,1653," g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change ",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1706,Availability,error,error,1706,"a_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1758,Availability,error,error,1758,"a_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1895,Availability,error,error,1895,"l"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; s",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1947,Availability,error,error,1947,"l"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; s",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3768,Availability,error,error,3768,"---------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3863,Availability,error,error,3863,"---------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3878,Availability,avail,available,3878,"---------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3991,Availability,error,error,3991,"; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:4006,Availability,avail,available,4006,"; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6320,Availability,error,error,6320," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6376,Availability,toler,tolerance,6376," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6543,Availability,error,error,6543," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6599,Availability,toler,tolerance,6599," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6625,Availability,error,error,6625," prevFCN = 2659.738491 frac=0.6236, sigma_g2=4.121, ; prevFCN = 2659.738401 sigma_g2=4.108, ; prevFCN = 2659.738723 frac=0.6241, sigma_g2=4.115, ; prevFCN = 2659.737961 frac=0.6231, ; prevFCN = 2659.737935 frac=0.6236, sigma_g2=4.116, ; prevFCN = 2659.737916 sigma_g2=4.113, ; prevFCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strateg",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:6678,Availability,error,error,6678,"FCN = 2659.737981 frac=0.6262, sigma_g2=4.121, ; prevFCN = 2659.737949 Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73792283928833; Edm = 2.4027910430005747e-05; Nfcn = 37; frac = 0.6236 +/- 0.164 (limited); sigma_g2 = 4.115 +/- 0.405 (limited); frac=0.6236, sigma_g2=4.115, 1) RooRealVar:: frac = 0.6236 +/- 0.164; 2) RooRealVar:: mean = 0; 3) RooRealVar:: sigma_g1 = 3; 4) RooRealVar:: sigma_g2 = 4.115 +/- 0.405; RooRealVar::sigma_g2 = 4.115 +/- 0.4057 L(3 - 6) ; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS LOWER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; ******************************************************************************************************; Minuit2Minimizer::GetMinosError - Run MINOS UPPER error for parameter #1 : sigma_g2 using max-calls 1000, tolerance 1; Minos: Lower error for parameter sigma_g2 : -0.3794; Minos: Upper error for parameter sigma_g2 : 0.4574; RooRealVar::sigma_g2 = 4.115 +/- (-0.3794,0.4574) L(3 - 6) ; ; RooFitResult: minimized FCN value: 2660, estimated distance to minimum: 2.409e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MIGRAD=0 HESSE=0 MINOS=0 ; ; Constant Parameter Value ; -------------------- ------------; mean 0.0000e+00; sigma_g1 3.0000e+00; ; Floating Parameter InitialValue FinalValue (+HiError,-LoError) GblCorr.; -------------------- ------------ ---------------------------------- --------; frac 5.0000e-01 6.2360e-01 +/- 1.64e-01 <none>; sigma_g2 4.0000e+00 4.1146e+00 (+4.57e-01,-3.79e-01) <none>; ; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2663.35774508719987; Edm = 9.56369873007578491e-05; Nfcn = 38; frac = 0.5655 +/- 0.1961 (limited); sigma_g2 = 4.005 +/- 0.3917 (limited); RooRealVar::frac = 0.5655 +/- 0.1961 L(0 - 1) ; Minuit2Minimizer: Minimize with max",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1238,Integrability,interface,interface,1238,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3830,Integrability,synchroniz,synchronize,3830,"---------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3958,Integrability,synchroniz,synchronize,3958,"; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sigma_g2=3.955, ; prevFCN = 2659.823248 frac=0.5767, sigma_g2=4.011, ; prevFCN = 2659.774616 frac=0.6314, sigma_g2=4.128, ; prevFCN = 2659.73914 frac=0.6266, sigma_g2=4.117, ; prevFCN = 2659.738319 frac=0.6296, ; prevFCN = 2659.740343 frac=0.6237, ; prevFCN = 2659.737969 frac=0.6266, sigma_g2=4",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:3404,Safety,safe,safe,3404,"ndicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ; # At any moment you can manually change the value of a (constant); # parameter; mean.setVal(0.3); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; # Now fix sigma_g2; sigma_g2.setConstant(True); ; # Rerun MIGRAD,HESSE; m.migrad(); m.hesse(); frac.Print(); ; c = ROOT.TCanvas(""rf601_intminuit"", ""rf601_intminuit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf601_intminuit.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sig",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1305,Testability,log,logging,1305,"e minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf601__intminuit_8py.html:1596,Testability,log,logging,1596,"2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # ",MatchSource.WIKI,doc/master/rf601__intminuit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:2368,Availability,error,error,2368,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:2426,Energy Efficiency,reduce,reduce,2426,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:2378,Integrability,message,messages,2378,"RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constRet",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:2027,Modifiability,extend,extended,2027,""", ""Signal component 2"", x, mean, sigma2);; ; // Build Chebychev polynomial pdf; RooRealVar a0(""a0"", ""a0"", 0.5, 0., 1.);; RooRealVar a1(""a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg(""bkg"", ""Background"", x, RooArgSet(a0, a1));; ; // Sum the signal components into a composite signal pdf; RooRealVar sig1frac(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0., 1.);; RooAddPdf sig(""sig"", ""Signal"", RooArgList(sig1, sig2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // C r e a t e b i n n e d d a t a s e t; // -----------------------------------------; ; std::unique_ptr<RooDataSet> d{model.generate(x, 10000)};; std::unique_ptr<RooDataHist> dh{d->binnedClone()};; ; // Construct a chi^2 of the data and the model.; // When a pdf is used in a chi^2 fit, the probability density scaled; // by the number of events in the dataset to obtain the fit function; // If model is an extended pdf, the expected number events is used; // instead of the observed number of events.; model.chi2FitTo(*dh, {PrintLevel(-1)});; ; // NB: It is also possible to fit a RooAbsReal function to a RooDataHist; // using chi2FitTo().; ; // Note that entries with zero bins are _not_ allowed; // for a proper chi^2 calculation and will give error; // messages; std::unique_ptr<RooAbsData> dsmall{d->reduce(EventRange(1, 100))};; std::unique_ptr<RooDataHist> dhsmall{static_cast<RooDataSet&>(*dsmall).binnedClone()};; std::unique_ptr<RooAbsReal> chi2_lowstat{model.createChi2(*dhsmall)};; cout << chi2_lowstat->getVal() << endl;; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooRealVar.h; TAxis.h; TCanvas.h; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArg",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4420,Performance,optimiz,optimization,4420,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4549,Performance,cache,cached,4549,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4643,Performance,cache,cache-and-track,4643,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4755,Performance,optimiz,optimization,4755,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4120,Safety,safe,safe,4120,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8C.html:4287,Safety,safe,safe,4287,"ooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooChebychevChebychev polynomial p.d.f.Definition RooChebychev.h:25; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooDataSet::binnedCloneRooFit::OwningPtr< RooDataHist > binnedClone(const char *newName=nullptr, const char *newTitle=nullptr) constReturn binned clone of this dataset.Definition RooDataSet.cxx:736; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::EventRangeRooCmdArg EventRange(Int_t nStart, Int_t nStop)Definition RooGlobalFunc.cxx:567; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf602_chi2fitDefinition rf602_chi2fit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.865; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf602_chi2fit.C. tutorialsroofitrf602_chi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8C.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2214,Availability,error,error,2214,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2244,Energy Efficiency,reduce,reduce,2244,"al"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn =",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2223,Integrability,message,messages,2223,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:1859,Modifiability,extend,extended,1859,"ssian(""sig1"", ""Signal component 1"", x, mean, sigma1); sig2 = ROOT.RooGaussian(""sig2"", ""Signal component 2"", x, mean, sigma2); ; # Build Chebychev polynomial p.d.f.; a0 = ROOT.RooRealVar(""a0"", ""a0"", 0.5, 0.0, 1.0); a1 = ROOT.RooRealVar(""a1"", ""a1"", 0.2, 0.0, 1.0); bkg = ROOT.RooChebychev(""bkg"", ""Background"", x, [a0, a1]); ; # Sum the signal components into a composite signal p.d.f.; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activatin",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2803,Performance,optimiz,optimization,2803,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2932,Performance,cache,cached,2932,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:3026,Performance,cache,cache-and-track,3026,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:3504,Performance,optimiz,optimization,3504,"umber of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf602_chi2fit.py. tutorialsroofitrf602_chi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2503,Safety,safe,safe,2503,"0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAb",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf602__chi2fit_8py.html:2670,Safety,safe,safe,2670,", 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 104.639633447510988; Edm = 0.000778057047730882148; Nfcn = 70; a0 = 0.501526 +/- 0.0229096 (limited); a1 = 0.158456 +/- 0.0368354 (limited); bkgfrac = 0.506609 +/- 0.011349 (limited); sig1frac = 0.815448 +/- 0.0373695 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; 90.86495991394004; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in ",MatchSource.WIKI,doc/master/rf602__chi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html
https://root.cern/doc/master/rf603__multicpu_8C.html:6506,Availability,error,error,6506,"on RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Do",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:2692,Deployability,integrat,integration,2692,"split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density function",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:3845,Deployability,integrat,integrated,3845,"d calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of th",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:2474,Energy Efficiency,reduce,reduce,2474,"g(""fsig"", ""signal fraction"", 0.1, 0., 1.);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Generate large dataset; std::unique_ptr<RooDataSet> data{model.generate({x, y, z}, 200000)};; ; // P a r a l l e l f i t t i n g; // -------------------------------; ; // In parallel mode the likelihood calculation is split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxi",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:2692,Integrability,integrat,integration,2692,"split in N pieces,; // that are calculated in parallel and added a posteriori before passing; // it back to MINUIT.; ; // Use four processes and time results both in wall time and CPU time; model.fitTo(*data, NumCPU(4), Timer(true), PrintLevel(-1));; ; // P a r a l l e l M C p r o j e c t i o n s; // ----------------------------------------------; ; // Construct signal, total likelihood projection on (y,z) observables and likelihood ratio; RooAbsPdf *sigyz = sig.createProjection(x);; RooAbsPdf *totyz = model.createProjection(x);; RooFormulaVar llratio_func(""llratio"", ""log10(@0)-log10(@1)"", RooArgList(*sigyz, *totyz));; ; // Calculate likelihood ratio for each event, define subset of events with high signal likelihood; data->addColumn(llratio_func);; std::unique_ptr<RooAbsData> dataSel{data->reduce(Cut(""llratio>0.7""))};; ; // Make plot frame and plot data; RooPlot *frame = x.frame(Title(""Projection on X with LLratio(y,z)>0.7""), Bins(40));; dataSel->plotOn(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density function",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:3627,Integrability,interface,interface,3627,"On(frame);; ; // Perform parallel projection using MC integration of pdf using given input dataSet.; // In this mode the data-weighted average of the pdf is calculated by splitting the; // input dataset in N equal pieces and calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create ",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:3845,Integrability,integrat,integrated,3845,"d calculating in parallel the weighted average; // one each subset. The N results of those calculations are then weighted into the; // final result; ; // Use four processes; model.plotOn(frame, ProjWData(*dataSel), NumCPU(4));; ; new TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.6);; frame->Draw();; }; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of th",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:4663,Modifiability,variab,variable,4663,"ad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interle",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:7099,Modifiability,variab,variables,7099,"xx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:6600,Performance,optimiz,optimization,6600,"on RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Do",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8C.html:7007,Performance,optimiz,optimization,7007,"xx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::NumCPURooCmdArg NumCPU(Int_t nCPU, Int_t interleave=0)Definition RooGlobalFunc.cxx:474; RooFit::ProjWDataRooCmdArg ProjWData(const RooAbsData &projData, bool binData=false)Definition RooGlobalFunc.cxx:179; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf603_multicpuDefinition rf603_multicpu.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.150, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf603_multicpu.C. tutorialsroofitrf603_multicpu.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf603__multicpu_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8C.html
https://root.cern/doc/master/rf603__multicpu_8py.html:3196,Availability,error,error,3196,"""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:2313,Deployability,integrat,integration,2313,"l fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1]",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:2114,Energy Efficiency,reduce,reduce,2114,"g"", ""signal fraction"", 0.1, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Generate large dataset; data = model.generate({x, y, z}, 200000); ; # Parallel fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErr",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:2313,Integrability,integrat,integration,2313,"l fitting; # -------------------------------; ; # In parallel mode the likelihood calculation is split in N pieces,; # that are calculated in parallel and added a posteriori before passing; # it back to MINUIT.; ; # Use four processes and time results both in wall time and CPU time; model.fitTo(data, NumCPU=4, Timer=True, PrintLevel=-1); ; # Parallel MC projections; # ----------------------------------------------; ; # Construct signal, likelihood projection on (y,z) observables and; # likelihood ratio; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Calculate likelihood ratio for each event, subset of events with high; # signal likelihood; data.addColumn(llratio_func); dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1]",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:3789,Modifiability,variab,variables,3789,"ame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:3290,Performance,optimiz,optimization,3290,"""llratio>0.7""); ; # Make plot frame and plot data; frame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf603__multicpu_8py.html:3697,Performance,optimiz,optimization,3697,"ame = x.frame(Title=""Projection on X with LLratio(y,z)>0.7"", Bins=40); dataSel.plotOn(frame); ; # Perform parallel projection using MC integration of pdf using given input dataSet.; # In self mode the data-weighted average of the pdf is calculated by splitting the; # input dataset in N equal pieces and calculating in parallel the weighted average; # one each subset. The N results of those calculations are then weighted into the; # final result; ; # Use four processes; model.plotOn(frame, ProjWData=dataSel, NumCPU=4); ; c = ROOT.TCanvas(""rf603_multicpu"", ""rf603_multicpu"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf603_multicpu.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.130; [#1] INFO:Minimization -- Command timer: Real time 0:00:00, CP time 0.010; [#1] INFO:Minimization -- Session timer: Real time 0:00:00, CP time 0.140, 2 slices; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf603_multicpu.py. tutorialsroofitrf603_multicpu.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf603__multicpu_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf603__multicpu_8py.html
https://root.cern/doc/master/rf604__constraints_8C.html:4798,Availability,error,error,4798,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:5468,Availability,error,error,5468,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:6138,Availability,error,error,6138,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:4892,Performance,optimiz,optimization,4892,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:4989,Performance,optimiz,optimization,4989,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:5562,Performance,optimiz,optimization,5562,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:5659,Performance,optimiz,optimization,5659,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:6232,Performance,optimiz,optimization,6232,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8C.html:6329,Performance,optimiz,optimization,6329,"ints.py:1; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; fit result without constraint (data generated at f=0.5); ; RooFitResult: minimized FCN value: 1",MatchSource.WIKI,doc/master/rf604__constraints_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8C.html
https://root.cern/doc/master/rf604__constraints_8py.html:2889,Availability,error,error,2889,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:3559,Availability,error,error,3559,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:4229,Availability,error,error,4229,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:2983,Performance,optimiz,optimization,2983,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:3080,Performance,optimiz,optimization,3080,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:3653,Performance,optimiz,optimization,3653,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:3750,Performance,optimiz,optimization,3750,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:4323,Performance,optimiz,optimization,4323,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf604__constraints_8py.html:4420,Performance,optimiz,optimization,4420,"ta generated at f=0.5, is f=0.2+/-0.1)""); r3.Print(""v""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstraint); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelc) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelc_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (fconstext); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (f,m,s); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 134.849, estimated distance to minimum: 2.11658e-",MatchSource.WIKI,doc/master/rf604__constraints_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf604__constraints_8py.html
https://root.cern/doc/master/rf605__profilell_8C.html:6193,Availability,error,error,6193,":547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..............................................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:6758,Availability,error,error,6758," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:7368,Availability,error,error,7368,"tion to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf605_profilell.C. tutorialsroofitrf605_profilell.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:6898,Deployability,configurat,configurations,6898," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:7512,Deployability,configurat,configurations,7512,"tion to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf605_profilell.C. tutorialsroofitrf605_profilell.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:4065,Integrability,interface,interface,4065,"ilell"", ""rf605_profilell"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataSet.h; RooGaussian.h; RooMinimizer.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooMinimizer::migradint migrad()Execute MIGRAD.Definition RooMinimizer.cxx:318; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanva",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:4444,Modifiability,variab,variable,4444,"nimizer.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooMinimizer::migradint migrad()Execute MIGRAD.Definition RooMinimizer.cxx:318; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double we",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:6898,Modifiability,config,configurations,6898," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:7512,Modifiability,config,configurations,7512,"tion to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf605_profilell.C. tutorialsroofitrf605_profilell.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8C.html:5829,Safety,safe,safe,5829,"); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf605_profilellDefinition rf605_profilell.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error l",MatchSource.WIKI,doc/master/rf605__profilell_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8C.html
https://root.cern/doc/master/rf605__profilell_8py.html:3384,Availability,error,error,3384,"except sigma_g2 for each evaluation; pll_sigmag2 = nll.createProfile({sigma_g2}); ; # Plot the profile likelihood in sigma_g2; pll_sigmag2.plotOn(frame2, LineColor=""r""); ; # Adjust frame maximum for visual clarity; frame2.SetMinimum(0); frame2.SetMaximum(3); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf605_profilell"", ""rf605_profilell"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf605_profilell.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..............................................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:3949,Availability,error,error,3949," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:4559,Availability,error,error,4559,"INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf605_profilell.py. tutorialsroofitrf605_profilell.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:4089,Deployability,configurat,configurations,4089," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:4703,Deployability,configurat,configurations,4703,"INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf605_profilell.py. tutorialsroofitrf605_profilell.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:4089,Modifiability,config,configurations,4089," [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ........................................",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:4703,Modifiability,config,configurations,4703,"INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) minimum found at (frac=0.62104); ..................................................................................; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) determining minimum likelihood for current configurations w.r.t all observable; [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[sigma_g2]) minimum found at (sigma_g2=4.11258); ....................................................................................; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf605_profilell.py. tutorialsroofitrf605_profilell.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf605__profilell_8py.html:3020,Safety,safe,safe,3020,"r=""r""); ; # Adjust frame maximum for visual clarity; frame1.SetMinimum(0); frame1.SetMaximum(3); ; # Construct profile likelihood in sigma_g2; # -------------------------------------------------------------------------------; ; # The profile likelihood estimator on nll for sigma_g2 will minimize nll; # w.r.t all floating parameters except sigma_g2 for each evaluation; pll_sigmag2 = nll.createProfile({sigma_g2}); ; # Plot the profile likelihood in sigma_g2; pll_sigmag2.plotOn(frame2, LineColor=""r""); ; # Adjust frame maximum for visual clarity; frame2.SetMinimum(0); frame2.SetMaximum(3); ; # Make canvas and draw ROOT.RooPlots; c = ROOT.TCanvas(""rf605_profilell"", ""rf605_profilell"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf605_profilell.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; Minuit2Minimizer: Minimize with max-calls 1500 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = 2659.73712858695399; Edm = 0.000190395763129910388; Nfcn = 60; frac = 0.62118 +/- 0.165788 (limited); mean = 0.00442366 +/- 0.109372 (limited); sigma_g2 = 4.10789 +/- 0.405468 (limited); [#1] INFO:Minimization -- RooProfileLL::evaluate(RooEvaluatorWrapper_Profile[frac]) Creating instance of MINUIT; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO",MatchSource.WIKI,doc/master/rf605__profilell_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf605__profilell_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:297,Availability,error,error,297,". ROOT: tutorials/roofit/rf606_nllerrorhandling.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf606_nllerrorhandling.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: understanding and customizing error handling in likelihood evaluations . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooArgusBG.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf606_nllerrorhandling(); {; // C r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disabl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1325,Availability,error,errors,1325,"hood evaluations . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooArgusBG.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf606_nllerrorhandling(); {; // C r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1522,Availability,error,error,1522," r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1600,Availability,error,error,1600,"0, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of m",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1690,Availability,error,errors,1690,"0, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of m",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1881,Availability,error,errors,1881,"d::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluat",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2016,Availability,error,error,2016," *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErro",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2901,Availability,error,errors,2901," likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2955,Availability,error,error,2955," likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:3153,Availability,mask,masked,3153,"ending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape.Definition RooArgusBG.h:22; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6131,Availability,error,error,6131,":725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6365,Availability,error,error,6365,":725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6764,Availability,error,error,6764,"; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::s",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:7684,Availability,error,error,7684,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:7918,Availability,error,error,7918,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8074,Availability,error,errors,8074,"us=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8127,Availability,error,error,8127,"us=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8282,Availability,error,errors,8282," m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8335,Availability,error,error,8335," m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8490,Availability,error,errors,8490,"ormalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8543,Availability,error,error,8543,"ormalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8698,Availability,error,errors,8698,r level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denomi,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8751,Availability,error,error,8751,r level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denomi,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8906,Availability,error,errors,8906,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:8959,Availability,error,error,8959,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9109,Availability,error,errors,9109,bsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9162,Availability,error,error,9162,bsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9312,Availability,error,errors,9312, RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9365,Availability,error,error,9365, RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9515,Availability,error,errors,9515,rs; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9568,Availability,error,error,9568,rs; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9718,Availability,error,errors,9718, errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9771,Availability,error,error,9771, errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9921,Availability,error,errors,9921, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:9974,Availability,error,error,9974, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10124,Availability,error,errors,10124, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10177,Availability,error,error,10177, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10327,Availability,error,errors,10327, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10380,Availability,error,error,10380, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10530,Availability,error,errors,10530, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerat,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10583,Availability,error,error,10583, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerat,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10733,Availability,error,errors,10733, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m],MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10786,Availability,error,error,10786, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m],MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10936,Availability,error,errors,10936, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:10989,Availability,error,error,10989, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11139,Availability,error,errors,11139, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11192,Availability,error,error,11192, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11347,Availability,error,errors,11347,RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11400,Availability,error,error,11400,RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11555,Availability,error,errors,11555,sMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11608,Availability,error,error,11608,sMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11766,Availability,error,errors,11766,cn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11819,Availability,error,error,11819,cn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:11975,Availability,error,errors,11975,imized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12028,Availability,error,error,12028,imized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12183,Availability,error,errors,12183,mized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error statu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12325,Availability,error,error,12325,=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_I,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12480,Availability,error,errors,12480,f::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_a,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12533,Availability,error,error,12533,f::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_a,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12690,Availability,error,errors,12690,sPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhan,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12743,Availability,error,error,12743,sPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhan,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12901,Availability,error,errors,12901,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:12954,Availability,error,error,12954,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:13110,Availability,error,errors,13110,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:13163,Availability,error,error,13163,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:13318,Availability,error,errors,13318,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1848,Deployability,configurat,configuration,1848,"d::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluat",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2837,Deployability,configurat,configuration,2837," likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1528,Integrability,message,messages,1528," r e a t e m o d e l a n d d a t a s e t; // ----------------------------------------------; ; // Observable; RooRealVar m(""m"", ""m"", 5.20, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2854,Integrability,message,messages,2854," likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1848,Modifiability,config,configuration,1848,"d::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluat",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2837,Modifiability,config,configuration,2837," likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyl",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:4381,Modifiability,variab,variable,4381,"um(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape.Definition RooArgusBG.h:22; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMaximumSetMaximum(ymax); RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::PrintEvalErrorsRooCmdArg PrintEvalErrors(Int_t numErrors)Definition RooGlobalFunc.cxx:725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition Roo",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6225,Performance,optimiz,optimization,6225,":725; RooFit::EvalErrorValueRooCmdArg EvalErrorValue(double value)Definition RooGlobalFunc.cxx:284; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::Detail::MathFuncs::nlldouble nll(double pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:7395,Performance,optimiz,optimization,7395,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:7778,Performance,optimiz,optimization,7778,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:13411,Performance,optimiz,optimization,13411,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf606_nllerrorhandling.C. tutorialsroofitrf606_nllerrorhandling.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2217,Testability,log,log,2217,"--; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), E",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:3114,Testability,log,log,3114,"ending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooArgusBG.h; RooDataSet.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape.Definition RooArgusBG.h:22; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6470,Testability,log,log,6470," namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf606_nllerrorhandlingDefinition rf606_nllerrorhandling.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; RangeTa Range(0, 0, 1, 1); mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) f",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:6869,Testability,log,log,6869,"for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:2383,Usability,clear,clearly,2383," lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of model and data; std::unique_ptr<RooAbsReal> nll{argus.createNLL(*data)};; ; // Plot likelihood in m0 in range that includes problematic values; // In this configuration no messages are printed for likelihood evaluation errors,; // but if an likelihood value evaluates with error, the corresponding value; // on the curve will be set to the value given in EvalErrorValue().; ; RooPlot *frame2 = m0.frame(Range(5.288, 5.293), Title(""-log(L) scan vs m0, problematic regions masked""));; nll->plotOn(frame2, PrintEvalErrors(-1), ShiftToZero(), EvalErrorValue(nll->getVal() + 10), LineColor(kRed));; frame2->SetMaximum(15);; frame2->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"",",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:342,Availability,error,error,342,". ROOT: tutorials/roofit/rf606_nllerrorhandling.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf606_nllerrorhandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #606 ; Understanding and customizing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1120,Availability,error,errors,1120,"Searching...; No Matches. Namespaces ; rf606_nllerrorhandling.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #606 ; Understanding and customizing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1314,Availability,error,error,1314,"ing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # -------",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1391,Availability,error,error,1391,"---------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1480,Availability,error,errors,1480,"---------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1666,Availability,error,errors,1666,"ooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with err",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1797,Availability,error,error,1797,"---------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-lo",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2624,Availability,error,errors,2624,"er fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_o",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2677,Availability,error,error,2677,"er fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_o",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2850,Availability,mask,masked,2850,"se the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:3688,Availability,error,error,3688," but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:3922,Availability,error,error,3922," but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:4321,Availability,error,error,4321,"c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::s",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5241,Availability,error,error,5241,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5475,Availability,error,error,5475,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5631,Availability,error,errors,5631,"us=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5684,Availability,error,error,5684,"us=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5839,Availability,error,errors,5839," m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5892,Availability,error,error,5892," m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6047,Availability,error,errors,6047,"ormalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6100,Availability,error,error,6100,"ormalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6255,Availability,error,errors,6255,r level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denomi,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6308,Availability,error,error,6308,r level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denomi,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6463,Availability,error,errors,6463,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6516,Availability,error,error,6516,inimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6666,Availability,error,errors,6666,bsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6719,Availability,error,error,6719,bsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6869,Availability,error,errors,6869, RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:6922,Availability,error,error,6922, RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7072,Availability,error,errors,7072,rs; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7125,Availability,error,error,7125,rs; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7275,Availability,error,errors,7275, errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7328,Availability,error,error,7328, errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7478,Availability,error,errors,7478, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7531,Availability,error,error,7531, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7681,Availability,error,errors,7681, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7734,Availability,error,error,7734, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus d,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7884,Availability,error,errors,7884, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:7937,Availability,error,error,7937, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=ar,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8087,Availability,error,errors,8087, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerat,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8140,Availability,error,error,8140, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerat,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8290,Availability,error,errors,8290, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m],MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8343,Availability,error,error,8343, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m],MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8493,Availability,error,errors,8493, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8546,Availability,error,error,8546, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8696,Availability,error,errors,8696, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8749,Availability,error,error,8749, 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8904,Availability,error,errors,8904,RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:8957,Availability,error,error,8957,RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9112,Availability,error,errors,9112,sMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9165,Availability,error,error,9165,sMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9323,Availability,error,errors,9323,cn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9376,Availability,error,error,9376,cn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but ,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9532,Availability,error,errors,9532,imized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9585,Availability,error,error,9585,imized function has error status but is ignored.; Parameter values: k=nan m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9740,Availability,error,errors,9740,mized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error statu,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:9882,Availability,error,error,9882,=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_I,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10037,Availability,error,errors,10037,f::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_a,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10090,Availability,error,error,10090,f::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_a,MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10247,Availability,error,errors,10247,"sPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py.",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10300,Availability,error,error,10300,"sPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py.",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10458,Availability,error,errors,10458," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10511,Availability,error,error,10511," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10667,Availability,error,errors,10667," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10720,Availability,error,error,10720," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10875,Availability,error,errors,10875," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1633,Deployability,configurat,configuration,1633,"ooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with err",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2560,Deployability,configurat,configuration,2560,"er fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_o",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1320,Integrability,message,messages,1320,"ing error handling in likelihood evaluations. ; ; import ROOT; ; ; # Create model and dataset; # ----------------------------------------------; ; # Observable; m = ROOT.RooRealVar(""m"", ""m"", 5.20, 5.30); ; # Parameters; m0 = ROOT.RooRealVar(""m0"", ""m0"", 5.291, 5.20, 5.30); k = ROOT.RooRealVar(""k"", ""k"", -30, -50, -10); ; # Pdf; argus = ROOT.RooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # -------",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2577,Integrability,message,messages,2577,"er fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_o",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1633,Modifiability,config,configuration,1633,"ooArgusBG(""argus"", ""argus"", m, m0, k); ; # Sample 1000 events in m from argus; data = argus.generate({m}, 1000); ; # Plot model and data; # --------------------------------------; ; frame1 = m.frame(Bins=40, Title=""Argus model and data""); data.plotOn(frame1); argus.plotOn(frame1); ; # Fit model to data; # ---------------------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with err",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2560,Modifiability,config,configuration,2560,"er fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_o",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:3782,Performance,optimiz,optimization,3782," but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.3706",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:4952,Performance,optimiz,optimization,4952,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:5335,Performance,optimiz,optimization,5335,"op-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28877; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 4 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 2000 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=nan; RooAbsPdf",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:10968,Performance,optimiz,optimization,10968," but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; Minuit2Minimizer : Invalid minimum - status = 3; FVAL = -2419.31; Edm = -nan; Nfcn = 34; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28374; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 44 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.27133; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 166 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.28726; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 9 errors; ; RooAbsMinimizerFcn: Minimized function has error status but is ignored.; Parameter values: k=-35.3713 m0=5.2898; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ] has 1 errors; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf606_nllerrorhandling.py. tutorialsroofitrf606_nllerrorhandling.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:1994,Testability,log,log,1994,"---------------------; ; # The ARGUS background shape has a sharp kinematic cutoff at m=m0; # and is prone to evaluation errors if the cutoff parameter m0; # is floated: when the pdf cutoff value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2823,Testability,log,log,2823,"se the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:4027,Testability,log,log,4027,"vas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf606_nllerrorhandling.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) f",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:4426,Testability,log,log,4426,"for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-33.8075 m0=5.29014; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.387202, denominator=argus_Int[m]=0.0305662; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-2417.08) to force MIGRAD to back out of this region. Error log follows.; Parameter values: k=-36.7074 m0=5.2901; RooAbsPdf::argus_over_argus_Int[m][ numerator=argus denominator=argus_Int[m] ]; getLogVal() top-level p.d.f not greater than zero @ numerator=argus=0.370612, denominator=argus_Int[m]=0.0290505; ; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2419.30692128725559; Edm = 2.90497786168460102e-06; Nfcn = 47; k = -35.3713 +/- 3.51942 (limited); m0 = 5.2904 +/- 0.000261877 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Fitting -- RooAbsPdf::fitTo(argus_over_argus_Int[m]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_argus_over_argus_Int[m]_argusData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy ",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf606__nllerrorhandling_8py.html:2168,Usability,clear,clearly,2168," value is lower than that in data; # events with m>m0 will have zero probability; ; # Perform unbinned ML fit. Print detailed error messages for up to; # 10 events per likelihood evaluation. The default error handling strategy; # is to return a very high value of the likelihood to MINUIT if errors occur,; # which will force MINUIT to retreat from the problematic area; ; argus.fitTo(data, PrintEvalErrors=10); ; # Perform another fit. In self configuration only the number of errors per; # likelihood evaluation is shown, it is greater than zero. The; # EvalErrorWall(kFALSE) arguments disables the default error handling strategy; # and will cause the actual (problematic) value of the likelihood to be passed; # to MINUIT.; #; # NB: Use of self option is NOT recommended as default strategt as broken -log(L) values; # can often be lower than 'good' ones because offending events are removed.; # ROOT.This may effectively create a False minimum in problem areas. ROOT.This is clearly; # illustrated in the second plot; ; m0.setError(0.1); argus.fitTo(data, PrintEvalErrors=0, EvalErrorWall=False); ; # Plot likelihood as function of m0; # ------------------------------------------------------------------; ; # Construct likelihood function of model and data; nll = argus.createNLL(data); ; # Plot likelihood in m0 in range that includes problematic values; # In self configuration no messages are printed for likelihood evaluation errors,; # but if an likelihood value evaluates with error, corresponding value; # on the curve will be set to the value given in EvalErrorValue().; ; frame2 = m0.frame(Range=(5.288, 5.293), Title=""-log(L) scan vs m0, regions masked""); nll.plotOn(frame2, ShiftToZero=True, PrintEvalErrors=-1, EvalErrorValue=(nll.getVal() + 10), LineColor=""r""); frame2.SetMaximum(15); frame2.SetMinimum(0); ; c = ROOT.TCanvas(""rf606_nllerrorhandling"", ""rf606_nllerrorhandling"", 1200, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4);",MatchSource.WIKI,doc/master/rf606__nllerrorhandling_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8py.html
https://root.cern/doc/master/rf607__fitresult_8C.html:7684,Availability,error,error,7684,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
https://root.cern/doc/master/rf607__fitresult_8C.html:7778,Performance,optimiz,optimization,7778,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
https://root.cern/doc/master/rf607__fitresult_8C.html:7875,Performance,optimiz,optimization,7875,"wvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TMatrixTBase::Printvoid Print(Option_t *name="""") const overridePrint the matrix as a table of elements.Definition TMatrixTBase.cxx:636; TMatrixTSym< Double_t >; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf607_fitresultDefinition rf607_fitresult.py:1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
https://root.cern/doc/master/rf607__fitresult_8C.html:3114,Testability,log,log,3114,"<RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // P r i n t f i t r e s u l t s; // ---------------------------------; ; // Summary printing: Basic info plus final values of floating fit parameters; r->Print();; ; // Verbose printing: Basic info, values of constant parameters, initial and; // final values of floating parameters, global correlations; r->Print(""v"");; ; // V i s u a l i z e c o r r e l a t i o n m a t r i x; // -------------------------------------------------------; ; // Construct 2D color plot of correlation matrix; gStyle->SetOptStat(0);; TH2 *hcorr = r->correlationHist();; ; // Visualize ellipse corresponding to single correlation matrix element; RooPlot *frame = new RooPlot(sigma1, sig1frac, 0.45, 0.60, 0.65, 0.90);; frame->SetTitle(""Covariance between sigma1 and sig1frac"");; r->plotOn(frame, sigma1, sig1frac, ""ME12ABHV"");; ; // A c c e s s f i t r e s u l t i n f o r m a t i o n; // ---------------------------------------------------------; ; // Access basic information; cout << ""EDM = "" << r->edm() << endl;; cout << ""-log(L) at minimum = "" << r->minNll() << endl;; ; // Access list of final fit parameter values; cout << ""final value of floating parameters"" << endl;; r->floatParsFinal().Print(""s"");; ; // Access correlation matrix elements; cout << ""correlation between sig1frac and a0 is "" << r->correlation(sig1frac, a0) << endl;; cout << ""correlation between bkgfrac and mean is "" << r->correlation(""bkgfrac"", ""mean"") << endl;; ; // Extract covariance and correlation matrix as TMatrixDSym; const TMatrixDSym &cor = r->correlationMatrix();; const TMatrixDSym &cov = r->covarianceMatrix();; ; // Print correlation, covariance matrix; cout << ""correlation matrix"" << endl;; cor.Print();; cout << ""covariance matrix"" << endl;; cov.Print();; ; // P e r s i s t f i t r e s u l t i n r o o t f i l e; // -------------------------------------------------------------; ; // Open new ROOT file save save result; TFile f(""rf607_fitresult.root"", ""RECRE",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
https://root.cern/doc/master/rf607__fitresult_8C.html:9070,Testability,log,log,9070,"ting Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue FinalValue +/- Error GblCorr.; -------------------- ------------ -------------------------- --------; a0 5.0000e-01 7.2873e-01 +/- 1.13e-01 <none>; bkgfrac 5.0000e-01 4.3445e-01 +/- 8.57e-02 <none>; mean 5.0000e+00 5.0345e+00 +/- 3.36e-02 <none>; sig1frac 8.0000e-01 7.7758e-01 +/- 9.71e-02 <none>; sigma1 5.0000e-01 5.2318e-01 +/- 4.55e-02 <none>; sigma2 1.0000e+00 1.7671e+00 +/- 1.18e+00 <none>; ; EDM = 0.000381082; -log(L) at minimum = 1885.34; final value of floating parameters; 1) RooRealVar:: a0 = 0.72873 +/- 0.112573; 2) RooRealVar:: bkgfrac = 0.43445 +/- 0.085744; 3) RooRealVar:: mean = 5.03451 +/- 0.0336279; 4) RooRealVar:: sig1frac = 0.777578 +/- 0.0971233; 5) RooRealVar:: sigma1 = 0.523178 +/- 0.0455077; 6) RooRealVar:: sigma2 = 1.76714 +/- 1.18159; correlation between sig1frac and a0 is -0.383713; correlation between bkgfrac and mean is -0.0516125; correlation matrix; ; 6x6 matrix is as follows; ; | 0 | 1 | 2 | 3 | 4 |; ----------------------------------------------------------------------; 0 | 1 -0.8038 -0.02304 -0.3837 0.4249 ; 1 | -0.8038 1 -0.05161 0.6011 -0.4042 ; 2 | -0.02304 -0.05161 1 -0.08752 -0.04055 ; 3 | -0.3837 0.6011 -0.08752 1 0.2836 ; 4 | 0.4249 -0.4042 -0.04055 0.2836 1 ; 5 | 0.8347 -0.8794 0.0146 -0.2731 0.5878 ; ; ; | 5 |; ----------------------------------------------------------------------; 0 | 0.8347 ; 1 | -0.8794 ; 2 | 0.0146 ; 3 | -0.2731 ; 4 | 0.5878 ; 5 | 1 ; ; covaria",MatchSource.WIKI,doc/master/rf607__fitresult_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8C.html
https://root.cern/doc/master/rf607__fitresult_8py.html:4326,Availability,error,error,4326,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
https://root.cern/doc/master/rf607__fitresult_8py.html:4420,Performance,optimiz,optimization,4420,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
https://root.cern/doc/master/rf607__fitresult_8py.html:4517,Performance,optimiz,optimization,4517,"; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); hcorr.GetYaxis().SetTitleOffset(1.4); hcorr.Draw(""colz""); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.6); frame.Draw(); ; c.SaveAs(""rf607_fitresult.png""); Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 7.2873e-01 +/- 1.13e-01; bkgfrac 4.3445e-01 +/- 8.57e-02; mean 5.0345e+00 +/- 3.36e-02; sig1frac 7.7758e-01 +/- 9.71e-02; sigma1 5.2318e-01 +/- 4.55e-02; sigma2 1.7671e+00 +/- 1.18e+00; ; ; RooFitResult: minimized FCN value: 1885.34, estimated distance to minimum: 0.000381082; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Constant Parameter Value ; -------------------- ------------; a1 -2.0000e-01; ; Floating Parameter InitialValue ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
https://root.cern/doc/master/rf607__fitresult_8py.html:2692,Testability,log,log,2692,"---; ; # Perform fit and save result; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Print fit results; # ---------------------------------; ; # Summary printing: Basic info plus final values of floating fit parameters; r.Print(); ; # Verbose printing: Basic info, of constant parameters, and; # final values of floating parameters, correlations; r.Print(""v""); ; # Visualize correlation matrix; # -------------------------------------------------------; ; # Construct 2D color plot of correlation matrix; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetPalette(1); hcorr = r.correlationHist(); ; # Visualize ellipse corresponding to single correlation matrix element; frame = ROOT.RooPlot(sigma1, sig1frac, 0.45, 0.60, 0.65, 0.90); frame.SetTitle(""Covariance between sigma1 and sig1frac""); r.plotOn(frame, sigma1, sig1frac, ""ME12ABHV""); ; # Access fit result information; # ---------------------------------------------------------; ; # Access basic information; print(""EDM = "", r.edm()); print(""-log(L) minimum = "", r.minNll()); ; # Access list of final fit parameter values; print(""final value of floating parameters""); r.floatParsFinal().Print(""s""); ; # Access correlation matrix elements; print(""correlation between sig1frac and a0 is "", r.correlation(sig1frac, a0)); print(""correlation between bkgfrac and mean is "", r.correlation(""bkgfrac"", ""mean"")); ; # Extract covariance and correlation matrix as ROOT.TMatrixDSym; cor = r.correlationMatrix(); cov = r.covarianceMatrix(); ; # Print correlation, matrix; print(""correlation matrix""); cor.Print(); print(""covariance matrix""); cov.Print(); ; # Persist fit result in root file; # -------------------------------------------------------------; ; # Open ROOT file save save result; f = ROOT.TFile(""rf607_fitresult.root"", ""RECREATE""); r.Write(""rf607""); f.Close(); ; # In a clean ROOT session retrieve the persisted fit result as follows:; # r = gDirectory.Get(""rf607""); ; c = ROOT.TCanvas(""rf607_fitresult"", ""rf607_fitresult"", 800, 400); c.Divide(2)",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
https://root.cern/doc/master/rf607__fitresult_8py.html:7152,Testability,log,log,7152,">; sigma2 1.0000e+00 1.7671e+00 +/- 1.18e+00 <none>; ; 1) RooRealVar:: a0 = 0.72873 +/- 0.112573; 2) RooRealVar:: bkgfrac = 0.43445 +/- 0.085744; 3) RooRealVar:: mean = 5.03451 +/- 0.0336279; 4) RooRealVar:: sig1frac = 0.777578 +/- 0.0971233; 5) RooRealVar:: sigma1 = 0.523178 +/- 0.0455077; 6) RooRealVar:: sigma2 = 1.76714 +/- 1.18159; ; 6x6 matrix is as follows; ; | 0 | 1 | 2 | 3 | 4 |; ----------------------------------------------------------------------; 0 | 1 -0.8038 -0.02304 -0.3837 0.4249 ; 1 | -0.8038 1 -0.05161 0.6011 -0.4042 ; 2 | -0.02304 -0.05161 1 -0.08752 -0.04055 ; 3 | -0.3837 0.6011 -0.08752 1 0.2836 ; 4 | 0.4249 -0.4042 -0.04055 0.2836 1 ; 5 | 0.8347 -0.8794 0.0146 -0.2731 0.5878 ; ; ; | 5 |; ----------------------------------------------------------------------; 0 | 0.8347 ; 1 | -0.8794 ; 2 | 0.0146 ; 3 | -0.2731 ; 4 | 0.5878 ; 5 | 1 ; ; ; 6x6 matrix is as follows; ; | 0 | 1 | 2 | 3 | 4 |; ----------------------------------------------------------------------; 0 | 0.01295 -0.007884 -8.818e-05 -0.004281 0.002201 ; 1 | -0.007884 0.007427 -0.0001496 0.005078 -0.001585 ; 2 | -8.818e-05 -0.0001496 0.001131 -0.0002885 -6.206e-05 ; 3 | -0.004281 0.005078 -0.0002885 0.00961 0.001265 ; 4 | 0.002201 -0.001585 -6.206e-05 0.001265 0.002071 ; 5 | 0.1142 -0.09113 0.0005905 -0.0322 0.03217 ; ; ; | 5 |; ----------------------------------------------------------------------; 0 | 0.1142 ; 1 | -0.09113 ; 2 | 0.0005905 ; 3 | -0.0322 ; 4 | 0.03217 ; 5 | 1.446 ; ; EDM = 0.0003810824372158841; -log(L) minimum = 1885.344093393465; final value of floating parameters; correlation between sig1frac and a0 is -0.3837127139109296; correlation between bkgfrac and mean is -0.05161247508597615; correlation matrix; covariance matrix; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf607_fitresult.py. tutorialsroofitrf607_fitresult.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf607__fitresult_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf607__fitresult_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2187,Availability,error,error,2187,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2373,Availability,down,down,2373,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:8163,Availability,error,error,8163,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2428,Deployability,integrat,integrations,2428,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:5728,Deployability,integrat,integrated,5728," GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2428,Integrability,integrat,integrations,2428,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:5160,Integrability,interface,interface,5160,"t(1.4);; tmp1->Draw(""lego3"");; c2->cd(5);; gPad->SetLeftMargin(0.15);; tmp2->GetZaxis()->SetTitleOffset(1.4);; tmp2->Draw(""lego3"");; c2->cd(6);; gPad->SetLeftMargin(0.15);; tmp3->GetZaxis()->SetTitleOffset(1.4);; tmp3->Draw(""lego3"");; }; d#define d(i)Definition RSha256.hxx:102; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; TFile.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a c",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:5728,Integrability,integrat,integrated,5728," GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:6009,Modifiability,variab,variables,6009,"olor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:2480,Performance,perform,performed,2480,"RooFitResult> r{model.fitTo(*data, Save(), PrintLevel(-1))};; ; // C r e a t e M V G a u s s i a n p d f o f f i t t e d p a r a m e t e r s; // ------------------------------------------------------------------------------------; ; RooAbsPdf *parabPdf = r->createHessePdf(RooArgSet(frac, mean, sigma_g2));; ; // S o m e e x e c e r c i s e s w i t h t h e p a r a m e t e r p d f; // -----------------------------------------------------------------------------; ; // Generate 100K points in the parameter space, sampled from the MVGaussian pdf; std::unique_ptr<RooDataSet> d{parabPdf->generate({mean, sigma_g2, frac}, 100000)};; ; // Sample a 3-D histogram of the pdf to be visualized as an error ellipsoid using the GLISO draw option; TH3 *hh_3d = (TH3 *)parabPdf->createHistogram(""mean,sigma_g2,frac"", 25, 25, 25);; hh_3d->SetFillColor(kBlue);; ; // Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; // The integrations corresponding to these projections are performed analytically; // by the MV Gaussian pdf; RooAbsPdf *pdf_sigmag2_frac = parabPdf->createProjection(mean);; RooAbsPdf *pdf_mean_frac = parabPdf->createProjection(sigma_g2);; RooAbsPdf *pdf_mean_sigmag2 = parabPdf->createProjection(frac);; ; // Make 2D plots of the 3 two-dimensional pdf projections; TH2 *hh_sigmag2_frac = (TH2 *)pdf_sigmag2_frac->createHistogram(""sigma_g2,frac"", 50, 50);; TH2 *hh_mean_frac = (TH2 *)pdf_mean_frac->createHistogram(""mean,frac"", 50, 50);; TH2 *hh_mean_sigmag2 = (TH2 *)pdf_mean_sigmag2->createHistogram(""mean,sigma_g2"", 50, 50);; hh_mean_frac->SetLineColor(kBlue);; hh_sigmag2_frac->SetLineColor(kBlue);; hh_mean_sigmag2->SetLineColor(kBlue);; ; // Draw the 'sigar'; new TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600);; hh_3d->Draw(""iso"");; ; // Draw the 2D projections of the 3D pdf; TCanvas *c2 = new TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600);; c2->Divide(3, 2);; c2->cd(1);; gPad->SetLeftMargin(0.15);; hh_mean_sigmag2-",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:8257,Performance,optimiz,optimization,8257,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:8354,Performance,optimiz,optimization,8354,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:7799,Safety,safe,safe,7799,"etween the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf608_fitresultaspdfDefinition rf608_fitresultaspdf.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf608_fitresultaspdf.C. tutorialsroofitrf608_fitresultaspdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1689,Availability,error,error,1689,"OOT.RooRealVar(""sigma_g1"", ""width of g1"", 2); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 5.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1866,Availability,down,down,1866," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:4348,Availability,error,error,4348,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1920,Deployability,integrat,integrations,1920," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1920,Integrability,integrat,integrations,1920," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1972,Performance,perform,performed,1972," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:4442,Performance,optimiz,optimization,4442,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:4539,Performance,optimiz,optimization,4539,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:3984,Safety,safe,safe,3984,"g""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 600); c2.Divide(3, 2); c2.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_mean_sigmag2.GetZaxis().SetTitleOffset(1.4); hh_mean_sigmag2.Draw(""surf3""); c2.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_sigmag2_frac.GetZaxis().SetTitleOffset(1.4); hh_sigmag2_frac.Draw(""surf3""); c2.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_mean_frac.GetZaxis().SetTitleOffset(1.4); hh_mean_frac.Draw(""surf3""); ; # Draw the distributions of parameter points sampled from the pdf; tmp1 = d.createHistogram(mean, sigma_g2, 50, 50); tmp2 = d.createHistogram(sigma_g2, frac, 50, 50); tmp3 = d.createHistogram(mean, frac, 50, 50); ; c2.cd(4); ROOT.gPad.SetLeftMargin(0.15); tmp1.GetZaxis().SetTitleOffset(1.4); tmp1.Draw(""lego3""); c2.cd(5); ROOT.gPad.SetLeftMargin(0.15); tmp2.GetZaxis().SetTitleOffset(1.4); tmp2.Draw(""lego3""); c2.cd(6); ROOT.gPad.SetLeftMargin(0.15); tmp3.GetZaxis().SetTitleOffset(1.4); tmp3.Draw(""lego3""); ; c2.SaveAs(""rf608_fitresultaspdf_2.png""); [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf608_fitresultaspdf.py. tutorialsroofitrf608_fitresultaspdf.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf608__fitresultaspdf_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:752,Availability,error,errors,752,". ROOT: tutorials/roofit/rf609_xychi2fit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:847,Availability,error,error,847,". ROOT: tutorials/roofit/rf609_xychi2fit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:906,Availability,error,errors,906,"ading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YV",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:989,Availability,error,error,989,"ading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YV",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:1280,Availability,error,error,1280,"ading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YV",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:1368,Availability,error,error,1368,"ude ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:2043,Availability,error,errors,2043," RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRand",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:2273,Availability,error,errors,2273,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:2231,Deployability,integrat,integrating,2231,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:2231,Integrability,integrat,integrating,2231,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:3570,Modifiability,variab,variable,3570,"yle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; RooFit::YVarRooCmdArg YVar(const RooAbsRealLValue &var, const RooCmdArg &arg={})Defi",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:5666,Performance,optimiz,optimization,5666,"ooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf609_xychi2fitDefinition rf609_xychi2fit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.17354, estimated distance to minimum: 3.83787e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -6.4539e-02 +/- 5.85e-01; b 2.9760e-01 +/- 4.74e-01; c 1.0442e+00 +/- 9.06e-02; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.81819, estimated distance to minimum: 5.77434e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -5.5529e-02 +/- 3.37e-01; b 3.6741e-02 +/- 4.64e-01; c 1.0407e+00 +/- 4.98e-02; ; DateJuly 20",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:5763,Performance,optimiz,optimization,5763,"ooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf609_xychi2fitDefinition rf609_xychi2fit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.17354, estimated distance to minimum: 3.83787e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -6.4539e-02 +/- 5.85e-01; b 2.9760e-01 +/- 4.74e-01; c 1.0442e+00 +/- 9.06e-02; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.81819, estimated distance to minimum: 5.77434e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -5.5529e-02 +/- 3.37e-01; b 3.6741e-02 +/- 4.64e-01; c 1.0407e+00 +/- 4.98e-02; ; DateJuly 20",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:6216,Performance,optimiz,optimization,6216,"tyle_t style)Definition RooGlobalFunc.cxx:240; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf609_xychi2fitDefinition rf609_xychi2fit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.17354, estimated distance to minimum: 3.83787e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -6.4539e-02 +/- 5.85e-01; b 2.9760e-01 +/- 4.74e-01; c 1.0442e+00 +/- 9.06e-02; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.81819, estimated distance to minimum: 5.77434e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -5.5529e-02 +/- 3.37e-01; b 3.6741e-02 +/- 4.64e-01; c 1.0407e+00 +/- 4.98e-02; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf609_xychi2fit.C. tutorialsroofitrf609_xychi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8C.html:6313,Performance,optimiz,optimization,6313,"tyle_t style)Definition RooGlobalFunc.cxx:240; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf609_xychi2fitDefinition rf609_xychi2fit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.17354, estimated distance to minimum: 3.83787e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -6.4539e-02 +/- 5.85e-01; b 2.9760e-01 +/- 4.74e-01; c 1.0442e+00 +/- 9.06e-02; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.81819, estimated distance to minimum: 5.77434e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -5.5529e-02 +/- 3.37e-01; b 3.6741e-02 +/- 4.64e-01; c 1.0407e+00 +/- 4.98e-02; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf609_xychi2fit.C. tutorialsroofitrf609_xychi2fit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:556,Availability,error,errors,556,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:649,Availability,error,error,649,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:707,Availability,error,errors,707,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:785,Availability,error,error,785,". ROOT: tutorials/roofit/rf609_xychi2fit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:1154,Availability,error,error,1154,"paces ; rf609_xychi2fit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; import ROOT; import math; ; ; # Create dataset with X and Y values; # -------------------------------------------------------------------; ; # Make weighted XY dataset with asymmetric errors stored; # The StoreError() argument is essential as it makes; # the dataset store the error in addition to the values; # of the observables. If errors on one or more observables; # are asymmetric, can store the asymmetric error; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print();",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:1808,Availability,error,errors,1808,"; # using the StoreAsymError() argument; ; x = ROOT.RooRealVar(""x"", ""x"", -11, 11); y = ROOT.RooRealVar(""y"", ""y"", -10, 200); dxy = ROOT.RooDataSet(""dxy"", ""dxy"", {x, y}, StoreError={x, y}); ; # Fill an example dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Sta",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:2004,Availability,error,errors,2004,"mple dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:1962,Deployability,integrat,integrating,1962,"mple dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:1962,Integrability,integrat,integrating,1962,"mple dataset with X,err(X),Y,err(Y) values; for i in range(10):; x.setVal(-10 + 2 * i); x.setError((0.5 / 1.0) if (i < 5) else (1.0 / 1.0)); ; # Set Y value and error; y.setVal(x.getVal() * x.getVal() + 4 * abs(ROOT.gRandom.Gaus())); y.setError(math.sqrt(y.getVal())); ; dxy.add({x, y}); ; # Perform chi2 fit to X +/- dX and Y +/- dY values; # ---------------------------------------------------------------------------------------; ; # Make fit function; a = ROOT.RooRealVar(""a"", ""a"", 0.0, -10, 10); b = ROOT.RooRealVar(""b"", ""b"", 0.0, -100, 100); c = ROOT.RooRealVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:2525,Performance,optimiz,optimization,2525,"lVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:2622,Performance,optimiz,optimization,2622,"lVar(""c"", ""c"", 0.0, -100, 100); f = ROOT.RooPolyVar(""f"", ""f"", x, [b, a, c]); ; # Plot dataset in X-Y interpretation; frame = x.frame(Title=""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""); dxy.plotOnXY(frame, YVar=y); ; # Fit chi^2 using X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:3075,Performance,optimiz,optimization,3075,"ing X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf609_xychi2fit.py. tutorialsroofitrf609_xychi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf609__xychi2fit_8py.html:3172,Performance,optimiz,optimization,3172,"ing X and Y errors; fit1 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1); fit1.Print(); ; # Overlay fitted function; f.plotOn(frame); ; # Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; # than taking point at center of bin; fit2 = f.chi2FitTo(dxy, YVar=y, Save=True, PrintLevel=-1, Integrate=True); fit2.Print(); ; # Overlay alternate fit result; f.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Draw the plot on a canvas; c = ROOT.TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf609_xychi2fit.png""); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 1.16828, estimated distance to minimum: 3.27623e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.5827e-02 +/- 6.43e-01; b 2.9994e-01 +/- 4.78e-01; c 1.0408e+00 +/- 1.04e-01; ; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 2.77875, estimated distance to minimum: 0.000387499; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -8.9593e-02 +/- 3.62e-01; b 4.5829e-02 +/- 4.65e-01; c 1.0343e+00 +/- 5.76e-02; ; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf609_xychi2fit.py. tutorialsroofitrf609_xychi2fit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf609__xychi2fit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8py.html
https://root.cern/doc/master/rf610__visualerror_8C.html:274,Availability,error,errors,274,". ROOT: tutorials/roofit/rf610_visualerror.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf610_visualerror.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; #include ""RooRealVar.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""RooAddPdf.h""; #include ""RooPlot.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TAxis.h""; using namespace RooFit;; ; void rf610_visualerror(); {; // S e t u p e x a m p l e f i t; // ---------------------------------------; ; // Create sum of two Gaussians pdf with factory; RooRealVar x(""x"", ""x"", -10, 10);; ; RooRealVar m(""m"", ""m"", 0, -10, 10);; RooRealVar s(""s"", ""s"", 2, 1, 50);; RooGaussian sig(""sig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; //",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1461,Availability,error,error,1461,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1519,Availability,error,error,1519,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1579,Availability,error,error,1579,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1620,Availability,error,error,1620,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1684,Availability,error,error,1684,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1711,Availability,error,error,1711,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:1856,Availability,error,error,1856,"ig"", ""sig"", x, m, s);; ; RooRealVar m2(""m2"", ""m2"", -1, -10, 10);; RooRealVar s2(""s2"", ""s2"", 6, 1, 50);; RooGaussian bkg(""bkg"", ""bkg"", x, m2, s2);; ; RooRealVar fsig(""fsig"", ""fsig"", 0.33, 0, 1);; RooAddPdf model(""model"", ""model"", RooArgList(sig, bkg), fsig);; ; // Create binned dataset; x.setBins(25);; std::unique_ptr<RooAbsData> d{model.generateBinned(x, 1000)};; ; // Perform fit and save fit result; std::unique_ptr<RooFitResult> r{model.fitTo(*d, Save(), PrintLevel(-1))};; ; // V i s u a l i z e f i t e r r o r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // i",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:2328,Availability,error,error,2328," r; // -------------------------------------; ; // Make plot frame; RooPlot *frame = x.frame(Bins(40), Title(""P.d.f with visualized 1-sigma error band""));; d->plotOn(frame);; ; // Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; // This results in an error band that is by construction symmetric; //; // The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // is chosen to be such that at least 100 curves are expected to be outside the N% interval, and is minimally; // 100 (e.g. Z=1->Ncurve=356, Z=2->Ncurve=2156)) Intervals from the sampling method can be asymmetric,; // and may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The Visua",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:2604,Availability,error,error,2604,"The linear error is calculated as; // error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); //; // where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; //; // with f(x) = the plotted curve; // 'da' = error taken from the fit result; // Corr(a,a') = the correlation matrix from the fit result; // Z = requested significance 'Z sigma band'; //; // The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // is chosen to be such that at least 100 curves are expected to be outside the N% interval, and is minimally; // 100 (e.g. Z=1->Ncurve=356, Z=2->Ncurve=2156)) Intervals from the sampling method can be asymmetric,; // and may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay ",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:3255,Availability,error,error,3255,"ian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // is chosen to be such that at least 100 curves are expected to be outside the N% interval, and is minimally; // 100 (e.g. Z=1->Ncurve=356, Z=2->Ncurve=2156)) Intervals from the sampling method can be asymmetric,; // and may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Whe",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4024,Availability,error,error,4024,"nd may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma ",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4070,Availability,error,error,4070,"nd may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma ",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4089,Availability,error,error,4089,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4567,Availability,error,error,4567,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:5030,Availability,error,error,5030,"ze partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotOn(frame3, Components(""bkg""), LineStyle(kDashed));; frame3->SetMinimum(0);; ; // Make plot frame; RooPlot *frame4 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from fsig""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame4, VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; model.plotOn(frame4, Components(""bkg""), VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; ; model.plotOn(frame4);; model.plotOn(frame4, Components(""bkg""), LineStyle(kDashed));; frame4->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLef",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:5076,Availability,error,error,5076,"ze partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotOn(frame3, Components(""bkg""), LineStyle(kDashed));; frame3->SetMinimum(0);; ; // Make plot frame; RooPlot *frame4 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from fsig""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame4, VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; model.plotOn(frame4, Components(""bkg""), VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; ; model.plotOn(frame4);; model.plotOn(frame4, Components(""bkg""), LineStyle(kDashed));; frame4->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLef",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:5533,Availability,error,error,5533,"rtial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotOn(frame3, Components(""bkg""), LineStyle(kDashed));; frame3->SetMinimum(0);; ; // Make plot frame; RooPlot *frame4 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from fsig""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame4, VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; model.plotOn(frame4, Components(""bkg""), VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; ; model.plotOn(frame4);; model.plotOn(frame4, Components(""bkg""), LineStyle(kDashed));; frame4->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.6);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame4->GetYaxis()->SetTitleOffset(1.6);; frame4->Draw();; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataHist.h; RooGaussian.h; RooPlot",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:5577,Availability,error,error,5577,"rtial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotOn(frame3, Components(""bkg""), LineStyle(kDashed));; frame3->SetMinimum(0);; ; // Make plot frame; RooPlot *frame4 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from fsig""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame4, VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; model.plotOn(frame4, Components(""bkg""), VisualizeError(*r, RooArgSet(fsig), 2), FillColor(kMagenta));; ; model.plotOn(frame4);; model.plotOn(frame4, Components(""bkg""), LineStyle(kDashed));; frame4->SetMinimum(0);; ; TCanvas *c = new TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.6);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.6);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame4->GetYaxis()->SetTitleOffset(1.6);; frame4->Draw();; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; RooAddPdf.h; RooDataHist.h; RooGaussian.h; RooPlot",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:9652,Availability,error,error,9652,"h_t width)Definition RooGlobalFunc.cxx:248; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf610_visualerrorDefinition rf610_visualerror.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4140,Energy Efficiency,reduce,reduced,4140,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:7735,Modifiability,variab,variable,7735,"inition Rtypes.h:66; kMagenta@ kMagentaDefinition Rtypes.h:66; kCyan@ kCyanDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gPad#define gPadDefinition TVirtualPad.h:308; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPlot::SetMinimumSetMinimum(ymin); RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::ComponentsRooCmdArg Components(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:128; RooFit::DrawOptionRooCmdArg DrawOption(const char *opt)Definition RooGlobalFunc.cxx:130; RooFit::FillColorRooCmdArg FillColor(Color_t color)Definition RooGlobalFunc.cxx:252; RooFit::LineWidthRooCmdArg L",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:3029,Performance,perform,perform,3029,"(required 2*N evaluations of the curve, where N is the number of parameters),; // but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; // Gaussian approximations made; //; model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange));; ; // Calculate error using sampling method and visualize as dashed red line.; //; // In this method a number of curves is calculated with variations of the parameter values, as sampled; // from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; // The error(x) is determined by calculating a central interval that capture N% of the variations; // for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; // is chosen to be such that at least 100 curves are expected to be outside the N% interval, and is minimally; // 100 (e.g. Z=1->Ncurve=356, Z=2->Ncurve=2156)) Intervals from the sampling method can be asymmetric,; // and may perform better in the presence of strong correlations, but may take (much) longer to calculate; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed));; ; // Perform the same type of error visualization on the background component only.; // The VisualizeError() option can generally applied to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:9746,Performance,optimiz,optimization,9746,"h_t width)Definition RooGlobalFunc.cxx:248; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf610_visualerrorDefinition rf610_visualerror.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:9843,Performance,optimiz,optimization,9843,"h_t width)Definition RooGlobalFunc.cxx:248; RooFit::VisualizeErrorRooCmdArg VisualizeError(const RooDataSet &paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::LineStyleRooCmdArg LineStyle(Style_t style)Definition RooGlobalFunc.cxx:240; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf610_visualerrorDefinition rf610_visualerror.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; mTMarker mDefinition textangle.C:8; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8C.html:4519,Usability,simpl,simple,4519,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,doc/master/rf610__visualerror_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html
https://root.cern/doc/master/rf610__visualerror_8py.html:289,Availability,error,errors,289,". ROOT: tutorials/roofit/rf610_visualerror.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf610_visualerror.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r,",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1067,Availability,error,error,1067,"r. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf610_visualerror.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visual",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1198,Availability,error,error,1198,"torials » RooFit Tutorials. Detailed Description; Likelihood and minimization: visualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter va",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1251,Availability,error,error,1251,"ualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1311,Availability,error,error,1311,"ualization of errors from a covariance matrix . ; import ROOT; ; ; # Setup example fit; # ---------------------------------------; ; # Create sum of two Gaussians pdf with factory; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 2, 1, 50); sig = ROOT.RooGaussian(""sig"", ""sig"", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1356,Availability,error,error,1356,""", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1418,Availability,error,error,1418,""", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1444,Availability,error,error,1444,""", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:1584,Availability,error,error,1584,""", x, m, s); ; m2 = ROOT.RooRealVar(""m2"", ""m2"", -1, -10, 10); s2 = ROOT.RooRealVar(""s2"", ""s2"", 6, 1, 50); bkg = ROOT.RooGaussian(""bkg"", ""bkg"", x, m2, s2); ; fsig = ROOT.RooRealVar(""fsig"", ""fsig"", 0.33, 0, 1); model = ROOT.RooAddPdf(""model"", ""model"", [sig, bkg], [fsig]); ; # Create binned dataset; x.setBins(25); d = model.generateBinned({x}, 1000); ; # Perform fit and save fit result; r = model.fitTo(d, Save=True, PrintLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:2042,Availability,error,error,2042,"ntLevel=-1); ; # Visualize fit error; # -------------------------------------; ; # Make plot frame; frame = x.frame(Bins=40, Title=""P.d.f with visualized 1-sigma error band""); d.plotOn(frame); ; # Visualize 1-sigma error encoded in fit result 'r' as orange band using linear error propagation; # ROOT.This results in an error band that is by construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generall",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:2311,Availability,error,error,2311," construction symmetric; #; # The linear error is calculated as; # error(x) = Z* F_a(x) * Corr(a,a') F_a'(x); #; # where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2,; #; # with f(x) = the plotted curve; # 'da' = error taken from the fit result; # Corr(a,a') = the correlation matrix from the fit result; # Z = requested significance 'Z sigma band'; #; # The linear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); m",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:2939,Availability,error,error,2939,">2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matri",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:3495,Availability,error,error,3495,"ch that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:3647,Availability,error,error,3647,"rve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield par",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:3690,Availability,error,error,3690,"rve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield par",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:3709,Availability,error,error,3709,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:4160,Availability,error,error,4160,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:4579,Availability,error,error,4579,"tle=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; frame4 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from fsig""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame4, VisualizeError=(r, {fsig}, 2), FillColor=""m""); model.plotOn(frame4, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:4622,Availability,error,error,4622,"tle=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; frame4 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from fsig""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame4, VisualizeError=(r, {fsig}, 2), FillColor=""m""); model.plotOn(frame4, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:5032,Availability,error,error,5032,"22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; frame4 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from fsig""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame4, VisualizeError=(r, {fsig}, 2), FillColor=""m""); model.plotOn(frame4, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation ",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:5073,Availability,error,error,5073,"22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; frame4 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from fsig""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame4, VisualizeError=(r, {fsig}, 2), FillColor=""m""); model.plotOn(frame4, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation ",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:6204,Availability,error,error,6204,"s=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:3760,Energy Efficiency,reduce,reduced,3760,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:2720,Performance,perform,perform,2720,"inear method is fast (required 2*N evaluations of the curve, N is the number of parameters),; # but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and; # Gaussian approximations made; #; model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange""); ; # Calculate error using sampling method and visualize as dashed red line.; #; # In self method a number of curves is calculated with variations of the parameter values, sampled; # from a multi-variate Gaussian pdf that is constructed from the fit results covariance matrix.; # The error(x) is determined by calculating a central interval that capture N% of the variations; # for each value of x, N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves; # is chosen to be such that at least 100 curves are expected to be outside the N% interval, is minimally; # 100 (e.g. Z=1.Ncurve=356, Z=2.Ncurve=2156)) Intervals from the sampling method can be asymmetric,; # and may perform better in the presence of strong correlations, may take; # (much) longer to calculate; model.plotOn(frame, VisualizeError=(r, 1, False), DrawOption=""L"", LineWidth=2, LineColor=""r""); ; # Perform the same type of error visualization on the background component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization th",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:6298,Performance,optimiz,optimization,6298,"s=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:6395,Performance,optimiz,optimization,6395,"s=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf610__visualerror_8py.html:4113,Usability,simpl,simple,4113,"ckground component only.; # The VisualizeError() option can generally applied to _any_ kind of; # plot (components, asymmetries, etc..); model.plotOn(frame, VisualizeError=(r, 1), FillColor=""kOrange"", Components=""bkg""); model.plotOn(; frame,; VisualizeError=(r, 1, False),; DrawOption=""L"",; LineWidth=2,; LineColor=""r"",; Components=""bkg"",; LineStyle=""--"",; ); ; # Overlay central value; model.plotOn(frame); model.plotOn(frame, Components=""bkg"", LineStyle=""--""); d.plotOn(frame); frame.SetMinimum(0); ; # Visualize partial fit error; # ------------------------------------------------------; ; # Make plot frame; frame2 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (m,m2)""); ; # Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; # ___ -1; # Vred = V22 = V11 - V12 * V22 * V21; #; # Where V11,V12,V21, represent a block decomposition of the covariance matrix into observables that; # are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), V22bar; # is the Shur complement of V22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; fr",MatchSource.WIKI,doc/master/rf610__visualerror_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:13282,Availability,error,error,13282," M.Definition TRandom3.h:27; TRandom3::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom3.cxx:99; TRandom3::SetSeedvoid SetSeed(ULong_t seed=0) overrideSet the random generator sequence if seed is 0 (default value) a TUUID is generated and used to fill ...Definition TRandom3.cxx:206; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TStyle::SetPadTopMarginvoid SetPadTopMargin(Float_t margin=0.1)Definition TStyle.h:359; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPadBottomMarginvoid SetPadBottomMargin(Float_t margin=0.1)Definition TStyle.h:358; TStyle::SetPaintTextFormatvoid SetPaintTextFormat(const char *format=""g"")Definition TStyle.h:386; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::SetPadRightMarginvoid SetPadRightMargin(Float_t margin=0.1)Definition TStyle.h:361; TStyle::SetTitleOffsetvoid SetTitleOffset(Float_t offset=1, Option_t *axis=""X"")Specify a parameter offset to control the distance between the axis and the axis title.Definition TStyle.cxx:1798; TStyle::SetPadLeftMarginvoid SetPadLeftMargin(Float_t margin=0.1)Definition TStyle.h:360; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::SetTitleSizevoid SetTitleSize(Float_t size=0.02, Option_t *axis=""X"")Definition TStyle.cxx:1817; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TStyle::SetLabelSizevoid SetLabelSize(Float_t size=0.04, Option_t *axis=""X"")Set size of axis labels.Definition TStyle.cxx:1444; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the hist",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:5601,Integrability,message,messages,5601,"g const &iLabel = std::to_string(i);; // using the inverse Hessian matrix; std::string hc0XLabel = methodLabels[i] + "";"" + makePullXLabel(""c_{0}"") + "";"";; std::string hc1XLabel = methodLabels[i] + "";"" + makePullXLabel(""c_{1}"") + "";"";; std::string hntotXLabel = methodLabels[i] + "";"" + makePullXLabel(""N_{tot}"") + "";"";; hc0pull[i] = new TH1D((""hc0pull"" + iLabel).c_str(), hc0XLabel.c_str(), 20, -5.0, 5.0);; // using the correction with the Hessian matrix with squared weights; hc1pull[i] = new TH1D((""hc1pull"" + iLabel).c_str(), hc1XLabel.c_str(), 20, -5.0, 5.0);; // asymptotically correct approach; hntotpull[i] = new TH1D((""hntotpull"" + iLabel).c_str(), hntotXLabel.c_str(), 20, -5.0, 5.0);; }; ; // number of pseudoexperiments (toys) and number of events per pseudoexperiment; constexpr std::size_t ntoys = 500;; constexpr std::size_t nstats = 500;; // parameters used in the generation; constexpr double c0gen = 0.0;; constexpr double c1gen = 0.0;; ; // Silence fitting and minimisation messages; auto &msgSv = RooMsgService::instance();; msgSv.getStream(1).removeTopic(RooFit::Minimization);; msgSv.getStream(1).removeTopic(RooFit::Fitting);; ; std::cout << ""Running "" << ntoys * 3 << "" toy fits ..."" << std::endl;; ; // M a i n l o o p : r u n p s e u d o e x p e r i m e n t s; //----------------------------------------------------------------; for (std::size_t i = 0; i < ntoys; i++) {; // S e t u p p a r a m e t e r s a n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:10310,Integrability,wrap,wrapper,10310,"->Update();; ; // plot pull distributions; TCanvas *cpull = new TCanvas(""cpull"", ""cpull"", 1200, 800);; cpull->Divide(3, 3);; ; std::vector<TH1 *> pullHistos{hc0pull[0], hc0pull[1], hc0pull[2], hc1pull[0], hc1pull[1],; hc1pull[2], hntotpull[0], hntotpull[1], hntotpull[2]};; ; gStyle->SetOptStat(1100);; gStyle->SetOptFit(11);; ; for (std::size_t i = 0; i < pullHistos.size(); ++i) {; cpull->cd(i + 1);; pullHistos[i]->Fit(""gaus"");; pullHistos[i]->Draw(""ep"");; }; ; cpull->Update();; }; RooDataSet.h; RooFitResult.h; RooPolynomial.h; RooRealVar.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1D.h; TLegend.h; TROOT.h; TRandom3.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooExtendPdfRooExtendPdf is a wrapper around an existing PDF that adds a parameteric extended likelihood term to ...Definition RooExtendPdf.h:22; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCa",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:6805,Modifiability,extend,extended,6805,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:6815,Modifiability,extend,extended,6815,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:6827,Modifiability,extend,extended,6827,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:8405,Modifiability,extend,extended,8405,"imple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen) / ntot.getError());; };; ; // F i t t o y u s i n g t h e t h r e e d i f f e r e n t a p p r o a c h e s t o u n c e r t a i; // n t y d e t e r m i n a t i o n; //-------------------------------------------------------------------------------------------------------------------------------------------------; // this uses the inverse weighted Hessian matrix; extended.fitTo(data, SumW2Error(false), PrintLevel(-1));; fillPulls(0);; ; // this uses the correction with the Hesse matrix with squared weights; extended.fitTo(data, SumW2Error(true), PrintLevel(-1));; fillPulls(1);; ; // this uses the asymptotically correct approach; extended.fitTo(data, AsymptoticError(true), PrintLevel(-1));; fillPulls(2);; }; ; std::cout << ""... done."" << std::endl;; ; // P l o t o u t p u t d i s t r i b u t i o n s; //--------------------------------------------------; ; // plot accepted (weighted) events; gStyle->SetOptStat(0);; gStyle->SetOptFit(0);; TCanvas *cevents = new TCanvas(""cevents"", ""cevents"", 800, 600);; cevents->cd(1);; hweighted->SetMinimum(0.0);; hweighted->SetLineColor(2);; hweighted->Draw(""hist"");; haccepted->Draw(""same hist"");; TLegend *leg = new TLegend(0.6, 0.8, 0.9, 0.9)",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:8552,Modifiability,extend,extended,8552," eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen) / ntot.getError());; };; ; // F i t t o y u s i n g t h e t h r e e d i f f e r e n t a p p r o a c h e s t o u n c e r t a i; // n t y d e t e r m i n a t i o n; //-------------------------------------------------------------------------------------------------------------------------------------------------; // this uses the inverse weighted Hessian matrix; extended.fitTo(data, SumW2Error(false), PrintLevel(-1));; fillPulls(0);; ; // this uses the correction with the Hesse matrix with squared weights; extended.fitTo(data, SumW2Error(true), PrintLevel(-1));; fillPulls(1);; ; // this uses the asymptotically correct approach; extended.fitTo(data, AsymptoticError(true), PrintLevel(-1));; fillPulls(2);; }; ; std::cout << ""... done."" << std::endl;; ; // P l o t o u t p u t d i s t r i b u t i o n s; //--------------------------------------------------; ; // plot accepted (weighted) events; gStyle->SetOptStat(0);; gStyle->SetOptFit(0);; TCanvas *cevents = new TCanvas(""cevents"", ""cevents"", 800, 600);; cevents->cd(1);; hweighted->SetMinimum(0.0);; hweighted->SetLineColor(2);; hweighted->Draw(""hist"");; haccepted->Draw(""same hist"");; TLegend *leg = new TLegend(0.6, 0.8, 0.9, 0.9);; leg->AddEntry(haccepted, ""Accepted"");; leg->AddEntry(hweighted, ""Weighted"");; leg->Draw();; cevents->Update();; ; // plot pull distributions; TCanvas *cpull = new TCanvas(""cpull"", ""cpull"", 1200, 800);; cpull->Divide(3, 3);; ; std::vector<TH1 *> pullHist",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:8676,Modifiability,extend,extended,8676,"ept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen) / ntot.getError());; };; ; // F i t t o y u s i n g t h e t h r e e d i f f e r e n t a p p r o a c h e s t o u n c e r t a i; // n t y d e t e r m i n a t i o n; //-------------------------------------------------------------------------------------------------------------------------------------------------; // this uses the inverse weighted Hessian matrix; extended.fitTo(data, SumW2Error(false), PrintLevel(-1));; fillPulls(0);; ; // this uses the correction with the Hesse matrix with squared weights; extended.fitTo(data, SumW2Error(true), PrintLevel(-1));; fillPulls(1);; ; // this uses the asymptotically correct approach; extended.fitTo(data, AsymptoticError(true), PrintLevel(-1));; fillPulls(2);; }; ; std::cout << ""... done."" << std::endl;; ; // P l o t o u t p u t d i s t r i b u t i o n s; //--------------------------------------------------; ; // plot accepted (weighted) events; gStyle->SetOptStat(0);; gStyle->SetOptFit(0);; TCanvas *cevents = new TCanvas(""cevents"", ""cevents"", 800, 600);; cevents->cd(1);; hweighted->SetMinimum(0.0);; hweighted->SetLineColor(2);; hweighted->Draw(""hist"");; haccepted->Draw(""same hist"");; TLegend *leg = new TLegend(0.6, 0.8, 0.9, 0.9);; leg->AddEntry(haccepted, ""Accepted"");; leg->AddEntry(hweighted, ""Weighted"");; leg->Draw();; cevents->Update();; ; // plot pull distributions; TCanvas *cpull = new TCanvas(""cpull"", ""cpull"", 1200, 800);; cpull->Divide(3, 3);; ; std::vector<TH1 *> pullHistos{hc0pull[0], hc0pull[1], hc0pull[2], hc1pull[0], hc1pull[1],; hc1pull[2], hntotpull[0], hntotpull[1], hntotpull[2]};; ; gStyle->SetOp",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:10365,Modifiability,extend,extended,10365,"->Update();; ; // plot pull distributions; TCanvas *cpull = new TCanvas(""cpull"", ""cpull"", 1200, 800);; cpull->Divide(3, 3);; ; std::vector<TH1 *> pullHistos{hc0pull[0], hc0pull[1], hc0pull[2], hc1pull[0], hc1pull[1],; hc1pull[2], hntotpull[0], hntotpull[1], hntotpull[2]};; ; gStyle->SetOptStat(1100);; gStyle->SetOptFit(11);; ; for (std::size_t i = 0; i < pullHistos.size(); ++i) {; cpull->cd(i + 1);; pullHistos[i]->Fit(""gaus"");; pullHistos[i]->Draw(""ep"");; }; ; cpull->Update();; }; RooDataSet.h; RooFitResult.h; RooPolynomial.h; RooRealVar.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1D.h; TLegend.h; TROOT.h; TRandom3.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooExtendPdfRooExtendPdf is a wrapper around an existing PDF that adds a parameteric extended likelihood term to ...Definition RooExtendPdf.h:22; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCa",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:1616,Performance,perform,performs,1616,"d to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:2300,Performance,perform,performance,2300,"{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If the fit is unbiased and the parameter uncertainties are estimated correctly, the pull distribution should be a Gaussian centered around zero with a width of one. ; #include ""TH1D.h""; #include ""TCanvas.h""; #include ""TROOT.h""; #include ""TStyle.h""; #include ""TRandom3.h""; #include ""TLegend.h""; #include ""RooRealVar.h""; #include ""RooFitResult.h""; #include ""RooDataSet.h""; #include ""RooPolynomial.h""; ; using namespace RooFit;; ; void rf611_weightedfits(int acceptancemodel = 2); {; // I n i t i a l i s a t i o n a n d S e t u p; //------------------------------------------------; ; // plotting options; gStyle->SetPaintTextFormat("".1f"");; gStyle->SetEndErrorSize(6.0);; gStyle->SetTitleSize(0.05, ""XY"");; gStyle->SetLa",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:1496,Testability,log,log,1496,"ning parameter uncertainties in weighted unbinned maximum likelihood fits. Performing a weighted unbinned maximum likelihood fits can be useful to account for acceptance effects and to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:1539,Testability,log,log,1539,"ning parameter uncertainties in weighted unbinned maximum likelihood fits. Performing a weighted unbinned maximum likelihood fits can be useful to account for acceptance effects and to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:6496,Usability,simpl,simple,6496,"ting and minimisation messages; auto &msgSv = RooMsgService::instance();; msgSv.getStream(1).removeTopic(RooFit::Minimization);; msgSv.getStream(1).removeTopic(RooFit::Fitting);; ; std::cout << ""Running "" << ntoys * 3 << "" toy fits ..."" << std::endl;; ; // M a i n l o o p : r u n p s e u d o e x p e r i m e n t s; //----------------------------------------------------------------; for (std::size_t i = 0; i < ntoys; i++) {; // S e t u p p a r a m e t e r s a n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account ",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf611__weightedfits_8C.html:7231,Usability,simpl,simple,7231,"n d P D F; //-----------------------------------------------; // angle theta and the weight to account for the acceptance effect; RooRealVar costheta(""costheta"", ""costheta"", -1.0, 1.0);; RooRealVar weight(""weight"", ""weight"", 0.0, 1000.0);; ; // initialise parameters to fit; RooRealVar c0(""c0"", ""0th-order coefficient"", c0gen, -1.0, 1.0);; RooRealVar c1(""c1"", ""1st-order coefficient"", c1gen, -1.0, 1.0);; c0.setError(0.01);; c1.setError(0.01);; // create simple second-order polynomial as probability density function; RooPolynomial pol(""pol"", ""pol"", costheta, {c0, c1}, 1);; ; double ngen = nstats;; if (acceptancemodel == 1); ngen *= 2.0 / (23.0 / 15.0);; else; ngen *= 2.0 / (16.0 / 15.0);; RooRealVar ntot(""ntot"", ""ntot"", ngen, 0.0, 2.0 * ngen);; RooExtendPdf extended(""extended"", ""extended pdf"", pol, ntot);; int npoisson = rnd->Poisson(nstats);; ; // G e n e r a t e d a t a s e t f o r p s e u d o e x p e r i m e n t i; //-------------------------------------------------------------------------------; RooDataSet data(""data"", ""data"", {costheta, weight}, WeightVar(""weight""));; // generate nstats events; for (std::size_t j = 0; j < npoisson; j++) {; bool finished = false;; // use simple accept/reject for generation; while (!finished) {; costheta = 2.0 * rnd->Rndm() - 1.0;; // efficiency for the specific value of cos(theta); double eff = 1.0;; if (acceptancemodel == 1); eff = 1.0 - 0.7 * costheta.getVal() * costheta.getVal();; else; eff = 0.3 + 0.7 * costheta.getVal() * costheta.getVal();; // use 1/eff as weight to account for acceptance; weight = 1.0 / eff;; // accept/reject; if (10.0 * rnd->Rndm() < eff * pol.getVal()); finished = true;; }; haccepted->Fill(costheta.getVal());; hweighted->Fill(costheta.getVal(), weight.getVal());; data.add({costheta, weight}, weight.getVal());; }; ; auto fillPulls = [&](std::size_t i) {; hc0pull[i]->Fill((c0.getVal() - c0gen) / c0.getError());; hc1pull[i]->Fill((c1.getVal() - c1gen) / c1.getError());; hntotpull[i]->Fill((ntot.getVal() - ngen",MatchSource.WIKI,doc/master/rf611__weightedfits_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:373,Availability,recover,recovery,373,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:756,Availability,error,error,756,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:799,Availability,recover,recover,799,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1119,Availability,recover,recover,1119,"erence Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriousl",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1655,Availability,recover,recovery,1655,"carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:2947,Availability,error,error,2947,"vice.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""n",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3286,Availability,recover,recover,3286,"1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::end",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3821,Availability,error,errors,3821,";; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintL",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4417,Availability,recover,recovery,4417,"eters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid fu",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4602,Availability,recover,recovery,4602,"fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillSty",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4682,Availability,recover,recovery,4682,"t::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->Ad",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4765,Availability,error,errors,4765," prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"")",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4860,Availability,recover,recovery,4860,"ooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Defini",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5041,Availability,recover,recovery,5041,"tion about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCa",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5162,Availability,recover,recovery,5162,"eter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle Get",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5361,Availability,recover,recovery,5361,"// Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; Roo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5697,Availability,recover,recovery,5697,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5753,Availability,recover,recovery,5753,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5770,Availability,recover,recovery,5770,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9199,Availability,error,error,9199,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9772,Availability,error,error,9772,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:10316,Availability,error,error,10316,"t: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distan",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:11119,Availability,recover,recovery,11119,": -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:11549,Availability,recover,recovery,11549,": -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:2953,Integrability,message,messages,2953,"vice.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""n",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:2998,Integrability,message,messages,2998,"ecoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // -------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3019,Integrability,message,message,3019,"ecoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // -------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9838,Integrability,message,message,9838,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:6844,Modifiability,variab,variable,6844," ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TCanvasThe Canvas class.Definition TCanvas.h:23; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TPave::SetB",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9293,Performance,optimiz,optimization,9293,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9697,Performance,optimiz,optimization,9697,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:10410,Performance,optimiz,optimization,10410,"t: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distan",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:10788,Performance,optimiz,optimization,10788,"egral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) u",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:373,Safety,recover,recovery,373,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:799,Safety,recover,recover,799,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1119,Safety,recover,recover,1119,"erence Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriousl",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1655,Safety,recover,recovery,1655,"carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; void rf612_recoverFromInvalidParameters() {; ; // Create a fit model:; // The polynomial is notoriously unstable, because it can quickly go negative.; // Since PDFs need to be positive, one often ends up with an unstable fit model.; RooRealVar x(""x"", ""x"", -15, 15);; RooRealVar a1(""a1"", ""a1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3286,Safety,recover,recover,3286,"1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::end",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4417,Safety,recover,recovery,4417,"eters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid fu",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4602,Safety,recover,recovery,4602,"fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillSty",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4682,Safety,recover,recovery,4682,"t::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->Ad",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:4860,Safety,recover,recovery,4860,"ooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Defini",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5041,Safety,recover,recovery,5041,"tion about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCa",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5162,Safety,recover,recovery,5162,"eter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::endl;; ; // Reset the parameters such that the PDF is again undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle Get",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5361,Safety,recover,recovery,5361,"// Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; Roo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5697,Safety,recover,recovery,5697,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5753,Safety,recover,recovery,5753,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5770,Safety,recover,recovery,5770,"rs(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlo",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:11119,Safety,recover,recovery,11119,": -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:11549,Safety,recover,recovery,11549,": -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; With recovery, the fitter encountered 76 invalid function values, but the parameters are fitted.; Date10/2020 ; AuthorStephan Hageboeck ; Definition in file rf612_recoverFromInvalidParameters.C. tutorialsroofitrf612_recoverFromInvalidParameters.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:1013,Testability,test,test,1013,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf612_recoverFromInvalidParameters.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; Before ROOT 6.24, RooFit always passed the highest function value that was encountered during the minimisation to the minimiser. If a parameter is far in a disallowed region, the minimiser has to blindly test various values of the parameters. It might find the correct values by chance, but often be unable to recover from bad starting values. Here, we use a model with such bad values.; Starting with ROOT 6.24, the minimiser receives more information. For example, when a PDF is negative, the magnitude of the ""undershoot"" is passed to the minimiser. The minimiser can use this to compute a gradient, which will eventually lead it out of the disallowed region. The steepness of this gradient can be chosen using RooFit::RecoverFromUndefinedRegions(double). A value of zero is equivalent to RooFit before ROOT 6.24. Positive values activate the recovery. Values between 1. and 10. were found to be a good default. If no argument is passed, RooFit uses 10.; ; #include <RooRealVar.h>; #include <RooPolynomial.h>; #include <RooPlot.h>; #include <RooDataSet.h>; #include <RooGlobalFunc.h>; #include <RooFitResult.h>; #include <RooMsgService.h>; ; #include <TCanvas.h>; #include <TLegend.h>; ; v",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:9742,Testability,log,logEvalError,9742,"w to leav...Definition RooGlobalFunc.cxx:773; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::NameRooCmdArg Name(const char *name)Definition RooGlobalFunc.cxx:272; xDouble_t x[n]Definition legend1.C:17; RooFit::Plotting@ PlottingDefinition RooGlobalFunc.h:62; rf612_recoverFromInvalidParametersDefinition rf612_recoverFromInvalidParameters.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); ; ; ; -------------- Starting second fit ---------------; ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimizati",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:388,Availability,recover,recovery,388,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:771,Availability,error,error,771,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:814,Availability,recover,recover,814,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:1702,Availability,error,error,1702,"e, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # ------------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2051,Availability,recover,recover,2051,", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # F",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2533,Availability,error,errors,2533,"o we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3073,Availability,recover,recovery,3073,"nimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3218,Availability,recover,recovery,3218," the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""W",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3297,Availability,recover,recovery,3297,"d.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEnt",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3370,Availability,error,errors,3370,"itWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.D",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3438,Availability,recover,recovery,3438,"Fit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoin",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3611,Availability,recover,recovery,3611,"noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3725,Availability,recover,recovery,3725,"nformation about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t Get",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3913,Availability,recover,recovery,3913,"ond fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4232,Availability,recover,recovery,4232," can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4286,Availability,recover,recovery,4286,"very.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_I",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4303,Availability,recover,recovery,4303,"very.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_I",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:5590,Availability,error,error,5590,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6163,Availability,error,error,6163,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6645,Availability,error,error,6645,"bsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating P",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7843,Availability,recover,recovery,7843,"coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromInvalidParameters.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7942,Availability,recover,recovery,7942,"coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromInvalidParameters.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:1708,Integrability,message,messages,1708,"e, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # ------------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:1752,Integrability,message,messages,1752,"oFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badne",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:1773,Integrability,message,message,1773,"oFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badne",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6229,Integrability,message,message,6229,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:5684,Performance,optimiz,optimization,5684,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6088,Performance,optimiz,optimization,6088,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6739,Performance,optimiz,optimization,6739,"bsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating P",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7117,Performance,optimiz,optimization,7117,"[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromI",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:388,Safety,recover,recovery,388,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:814,Safety,recover,recover,814,". ROOT: tutorials/roofit/rf612_recoverFromInvalidParameters.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf612_recoverFromInvalidParameters.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: Recover from regions where the function is not defined. ; We demonstrate improved recovery from disallowed parameters. For this, we use a polynomial PDF of the form ; \[; \mathrm{Pol2} = \mathcal{N} \left( c + a_1 \cdot x + a_2 \cdot x^2 + 0.01 \cdot x^3 \right),; \]. where \( \mathcal{N} \) is a normalisation factor. Unless the parameters are chosen carefully, this function can be negative, and hence, it cannot be used as a PDF. In this case, RooFit passes an error to the minimiser, which might try to recover.; ; import ROOT; ; ; # Create a fit model:; # The polynomial is notoriously unstable, because it can quickly go negative.; # Since PDFs need to be positive, one often ends up with an unstable fit model.; x = ROOT.RooRealVar(""x"", ""x"", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # ---------------------",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:2051,Safety,recover,recover,2051,", -15, 15); a1 = ROOT.RooRealVar(""a1"", ""a1"", -0.5, -10.0, 20.0); a2 = ROOT.RooRealVar(""a2"", ""a2"", 0.2, -10.0, 20.0); a3 = ROOT.RooRealVar(""a3"", ""a3"", 0.01); pdf = ROOT.RooPolynomial(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, [a1, a2, a3]); ; # Create toy data with all-positive coefficients:; data = pdf.generate(x, 10000); ; # For plotting.; # We create pointers to the plotted objects. We want these objects to leak out of the function,; # so we can still see them after it returns.; c = ROOT.TCanvas(); frame = x.frame(); data.plotOn(frame, Name=""data""); ; # Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; # Therefore, we disable plotting messages in RooFit's message streams:; ROOT.RooMsgService.instance().getStream(0).removeTopic(ROOT.RooFit.Plotting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Plotting); ; ; # RooFit before ROOT 6.24; # --------------------------------; # Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # F",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3073,Safety,recover,recovery,3073,"nimiser just errs around; # the starting values of the parameters without finding any improvement.; ; # Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3218,Safety,recover,recovery,3218," the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""W",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3297,Safety,recover,recovery,3297,"d.; a1.setVal(10.0); a2.setVal(-1.0); ; # Perform a fit:; fitWithoutRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=0.0, # This is how RooFit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEnt",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3438,Safety,recover,recovery,3438,"Fit behaved prior to ROOT 6.24; PrintEvalErrors=-1, # We are expecting a lot of evaluation errors. -1 switches off printing.; PrintLevel=-1,; ); ; pdf.plotOn(frame, LineColor=""r"", Name=""noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoin",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3611,Safety,recover,recovery,3611,"noRecovery""); ; ; # RooFit since ROOT 6.24; # --------------------------------; # The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3725,Safety,recover,recovery,3725,"nformation about the ""badness"" of the violation of the function definition. It uses this; # to find its way out of the disallowed parameter regions.; print(""\n\n\n-------------- Starting second fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t Get",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:3913,Safety,recover,recovery,3913,"ond fit ---------------\n\n""); ; # Reset the parameters such that the PDF is again undefined.; a1.setVal(10.0); a2.setVal(-1.0); ; # Fit again, but pass recovery information to the minimiser:; fitWithRecovery = pdf.fitTo(; data,; Save=True,; RecoverFromUndefinedRegions=1.0, # The magnitude of the recovery information can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4232,Safety,recover,recovery,4232," can be chosen here.; # Higher values mean more aggressive recovery.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4286,Safety,recover,recovery,4286,"very.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_I",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:4303,Safety,recover,recovery,4303,"very.; PrintEvalErrors=-1, # We are still expecting a few evaluation errors.; PrintLevel=0,; ); ; pdf.plotOn(frame, LineColor=""b"", Name=""recovery""); ; ; # Collect results and plot.; # --------------------------------; # We print the two fit results, and plot the fitted curves.; # The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery.Print(); print(; ""Without recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values. The parameters are unchanged.\n""; ); ; fitWithRecovery.Print(); print(; ""With recovery, the fitter encountered {}"".format(fitWithoutRecovery.numInvalidNLL()); + "" invalid function values, but the parameters are fitted.\n""; ); ; legend = ROOT.TLegend(0.5, 0.7, 0.9, 0.9); legend.SetBorderSize(0); legend.SetFillStyle(0); legend.AddEntry(""data"", ""Data"", ""P""); legend.AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L""); legend.AddEntry(""recovery"", ""With recovery"", ""L""); frame.Draw(); legend.Draw(); c.Draw(); ; c.SaveAs(""rf612_recoverFromInvalidParameters.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_I",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7843,Safety,recover,recovery,7843,"coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromInvalidParameters.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:7942,Safety,recover,recovery,7942,"coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 -4.9816e-01 +/- 2.27e-02; a2 1.9832e-01 +/- 5.65e-03; ; ; ; ; -------------- Starting second fit ---------------; ; ; Without recovery, the fitter encountered 23 invalid function values. The parameters are unchanged.; ; With recovery, the fitter encountered 23 invalid function values, but the parameters are fitted.; ; DateJune 2021 ; AuthorHarshal Shende, Stephan Hageboeck (C++ version) ; Definition in file rf612_recoverFromInvalidParameters.py. tutorialsroofitrf612_recoverFromInvalidParameters.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6133,Testability,log,logEvalError,6133,"electionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const o",MatchSource.WIKI,doc/master/rf612__recoverFromInvalidParameters_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html
https://root.cern/doc/master/rf613__global__observables_8C.html:932,Integrability,depend,depend,932,". ROOT: tutorials/roofit/rf613_global_observables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
https://root.cern/doc/master/rf613__global__observables_8C.html:1035,Integrability,depend,depend,1035,".C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a Poissonian is not symmetric under exchange of t",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
https://root.cern/doc/master/rf613__global__observables_8C.html:722,Performance,optimiz,optimize,722,". ROOT: tutorials/roofit/rf613_global_observables.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf613_global_observables.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
https://root.cern/doc/master/rf613__global__observables_8C.html:7463,Performance,cache,cache,7463,"ers);; ; // If you want to explicitly ignore the global observables in the dataset,; // you can do that by specifying GlobalObservablesSource(""model""). Keep in; // mind that now it's also again your responsibility to define the set of; // global observables.; std::cout << ""3. model.fitTo(*data, GlobalObservables(mu_obs), GlobalObservablesSource(\""model\""))\n"";; std::cout << ""------------------------------------------------\n"";; FitRes res3{model.fitTo(*data, GlobalObservables(mu_obs), GlobalObservablesSource(""model""), PrintLevel(-1), Save())};; res3->Print();; modelParameters.assign(origParameters);; }; RooArgSet.h; RooConstVar.h; RooDataSet.h; RooFitResult.h; RooGaussian.h; RooProdPdf.h; RooRealVar.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooAbsCollection::assignvoid assign(const RooAbsCollection &other) constSets the value, cache and constant attribute of any argument in our set that also appears in the othe...Definition RooAbsCollection.cxx:283; RooAbsCollection::Printvoid Print(Option_t *options=nullptr) const overrideThis method must be overridden when a class wants to print itself.Definition RooAbsCollection.h:315; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooArgSet::snapshotRooArgSet * snapshot(bool deepCopy=true) constUse RooAbsCollection::snapshot(), but return as RooArgSet.Definition RooArgSet.h:154; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instance",MatchSource.WIKI,doc/master/rf613__global__observables_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8C.html
https://root.cern/doc/master/rf613__global__observables_8py.html:947,Integrability,depend,depend,947,". ROOT: tutorials/roofit/rf613_global_observables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlik",MatchSource.WIKI,doc/master/rf613__global__observables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html
https://root.cern/doc/master/rf613__global__observables_8py.html:1050,Integrability,depend,depend,1050,"nce. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlike a Gaussian, a Poissonian is not symmetric under exchange of t",MatchSource.WIKI,doc/master/rf613__global__observables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html
https://root.cern/doc/master/rf613__global__observables_8py.html:737,Performance,optimiz,optimize,737,". ROOT: tutorials/roofit/rf613_global_observables.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf613_global_observables.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This tutorial explains the concept of global observables in RooFit, and showcases how their values can be stored either in the model or in the dataset. . Introduction; Note: in this tutorial, we are multiplying the likelihood with an additional likelihood to constrain the parameters with auxiliary measurements. This is different from the rf604_constraints tutorial, where the likelihood is multiplied with a Bayesian prior to constrain the parameters.; With RooFit, you usually optimize some model parameters p to maximize the likelihood L given the per-event or per-bin observations x:. \[ L( x | p ) \]. Often, the parameters are constrained with some prior likelihood C, which doesn't depend on the observables x:. \[ L'( x | p ) = L( x | p ) * C( p ) \]. Usually, these constraint terms depend on some auxiliary measurements of other observables g. The constraint term is then the likelihood of the so-called global observables:. \[ L'( x | p ) = L( x | p ) * C( g | p ) \]. For example, think of a model where the true luminosity lumi is a nuisance parameter that is constrained by an auxiliary measurement lumi_obs with uncertainty lumi_obs_sigma:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi_obs | lumi, lumi_obs_sigma) \]. As a Gaussian is symmetric under exchange of the observable and the mean parameter, you can also sometimes find this equivalent but less conventional formulation for Gaussian constraints:. \[ L'(data | mu, lumi) = L(data | mu, lumi) * \text{Gauss}(lumi | lumi_obs, lumi_obs_sigma) \]. If you wanted to constrain a parameter that represents event counts, you would use a Poissonian constraint, e.g.:. \[ L'(data | mu, count) = L(data | mu, count) * \text{Poisson}(count_obs | count) \]. Unlik",MatchSource.WIKI,doc/master/rf613__global__observables_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf613__global__observables_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:568,Deployability,integrat,integrating,568,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:779,Deployability,continuous,continuous,779,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:1599,Deployability,integrat,integration,1599,"ing the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -----------------",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:1631,Deployability,integrat,integration,1631,"ing the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -----------------",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:2070,Deployability,integrat,integrator,2070,"> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -------------------; ; // Set up the observable; RooRealVar x{""x"", ""x"", 0.1, 5.1};; x.setBins(10); // fewer bins so we have larger binning effects for this demo; ; // Let's first look at the example of an exponential function; RooRealVar c{""c"", ""c"", -1.8, -5, 5};; RooExponential expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x,",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:3194,Deployability,continuous,continuous,3194,"alse);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -------------------; ; // Set up the observable; RooRealVar x{""x"", ""x"", 0.1, 5.1};; x.setBins(10); // fewer bins so we have larger binning effects for this demo; ; // Let's first look at the example of an exponential function; RooRealVar c{""c"", ""c"", -1.8, -5, 5};; RooExponential expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x, 10000)};; ; // If you do the fit the usual was in RooFit, you will get a bias in the; // result. This is because the continuous, normalized pdf is evaluated only; // at the bin centers.; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:3838,Deployability,integrat,integrated,3838,"ntial expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x, 10000)};; ; // If you do the fit the usual was in RooFit, you will get a bias in the; // result. This is because the continuous, normalized pdf is evaluated only; // at the bin centers.; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this met",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4910,Deployability,integrat,integrating,4910,"ig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // --",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5456,Deployability,integrat,integrated,5456,"unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10284,Deployability,integrat,integration,10284,"g &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrat",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10296,Deployability,configurat,configuration,10296,"g &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrat",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10563,Deployability,integrat,integration,10563,"at represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(I",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10575,Deployability,configurat,configuration,10575,"at represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(I",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11208,Deployability,configurat,configuration,11208,"tIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmd",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11256,Deployability,integrat,integrators,11256,"tIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmd",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:13490,Deployability,integrat,integrator,13490,"const Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf614_binned_fit_problemsDefinition rf614_binned_fit_problems.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:14396,Deployability,integrat,integrator,14396,"G: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:431,Energy Efficiency,reduce,reduce,431,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4171,Energy Efficiency,power,power,4171,"};; ; // If you do the fit the usual was in RooFit, you will get a bias in the; // result. This is because the continuous, normalized pdf is evaluated only; // at the bin centers.; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4247,Energy Efficiency,power,powerlaw,4247,"; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(po",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4257,Energy Efficiency,power,powerlaw,4257,"; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(po",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4269,Energy Efficiency,power,powerlaw,4269,"; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(po",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4331,Energy Efficiency,power,powerlawData,4331,"the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4365,Energy Efficiency,power,powerlaw,4365,"the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4479,Energy Efficiency,power,powerlaw,4479,"the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4495,Energy Efficiency,power,powerlawData,4495,"he normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is c",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5087,Energy Efficiency,power,powerlaw,5087," ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is num",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5147,Energy Efficiency,power,powerlaw,5147,"; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly diffe",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5163,Energy Efficiency,power,powerlawData,5163,"owerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5260,Energy Efficiency,power,powerlaw,5260,"owerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5726,Energy Efficiency,power,powerlaw,5726,"l out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5742,Energy Efficiency,power,powerlawData,5742,"g the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11361,Energy Efficiency,power,power,11361,"bsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::RangeRooCmdArg Range(const char *rangeName, bool ad",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:568,Integrability,integrat,integrating,568,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:1599,Integrability,integrat,integration,1599,"ing the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -----------------",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:1631,Integrability,integrat,integration,1631,"ing the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -----------------",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:2070,Integrability,integrat,integrator,2070,"> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -------------------; ; // Set up the observable; RooRealVar x{""x"", ""x"", 0.1, 5.1};; x.setBins(10); // fewer bins so we have larger binning effects for this demo; ; // Let's first look at the example of an exponential function; RooRealVar c{""c"", ""c"", -1.8, -5, 5};; RooExponential expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x,",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:3838,Integrability,integrat,integrated,3838,"ntial expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x, 10000)};; ; // If you do the fit the usual was in RooFit, you will get a bias in the; // result. This is because the continuous, normalized pdf is evaluated only; // at the bin centers.; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this met",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4910,Integrability,integrat,integrating,4910,"ig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // --",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5456,Integrability,integrat,integrated,5456,"unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:9027,Integrability,interface,interface,9027,"f[n\log(n/N)\f], we get terms for each; // bin that are closer to each other in order of magnitude as long as the; // initial model is not extremely off. Proving this mathematically is left; // as an exercise to the reader.; ; // This counterterms can be enabled by passing the Offset(""bin"") option to; // RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; std::unique_ptr<RooFitResult> fit7{; model.fitTo(*modelData, Offset(""bin""), Save(), PrintLevel(-1), SumW2Error(false))};; fit7->Print();; ; // You should now see in the last fit result that the fit has converged.; }; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsBinningAbstract base class for RooRealVar binning definitions.Definition RooAbsBinning.h:25; RooAbsBinning::setRangevirtual void setRange(double xlo, double xhi)=0; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10284,Integrability,integrat,integration,10284,"g &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrat",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10563,Integrability,integrat,integration,10563,"at represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(I",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11256,Integrability,integrat,integrators,11256,"tIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmd",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:13490,Integrability,integrat,integrator,13490,"const Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; fit1Definition fit1.py:1; rf614_binned_fit_problemsDefinition rf614_binned_fit_problems.py:1; RooMsgService::StreamConfig::removeTopicvoid removeTopic(RooFit::MsgTopic oldTopic)Definition RooMsgService.h:122; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:14396,Integrability,integrat,integrator,14396,"G: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:2081,Modifiability,config,config,2081,"> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegratorConfig(customConfig);; func.forceNumInt(true);; }; ; // Reset the integrator config to disable the RooBinIntegrator.; void disableBinIntegrator(RooAbsReal &func); {; func.setIntegratorConfig();; func.forceNumInt(false);; }; ; void rf614_binned_fit_problems(); {; using namespace RooFit;; ; // Silence info output for this tutorial; RooMsgService::instance().getStream(1).removeTopic(Minimization);; RooMsgService::instance().getStream(1).removeTopic(Fitting);; RooMsgService::instance().getStream(1).removeTopic(Generation);; ; // Exponential example; // -------------------; ; // Set up the observable; RooRealVar x{""x"", ""x"", 0.1, 5.1};; x.setBins(10); // fewer bins so we have larger binning effects for this demo; ; // Let's first look at the example of an exponential function; RooRealVar c{""c"", ""c"", -1.8, -5, 5};; RooExponential expo{""expo"", ""expo"", x, c};; ; // Generate an Asimov dataset such that the only difference between the fit; // result and the true parameters comes from binning effects.; std::unique_ptr<RooAbsData> expoData{generateBinnedAsimov(expo, x,",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10296,Modifiability,config,configuration,10296,"g &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAbsPdf.h:110; RooAbsRealAbstract base class for objects that represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrat",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:10575,Modifiability,config,configuration,10575,"at represent a real value and implements functionality common to al...Definition RooAbsReal.h:59; RooAbsReal::createIntegralRooFit::OwningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) constCreate an object that represents the integral of the function over one or more observables listed in ...Definition RooAbsReal.cxx:514; RooAbsReal::getValdouble getVal(const RooArgSet *normalisationSet=nullptr) constEvaluate object.Definition RooAbsReal.h:103; RooAbsReal::setIntegratorConfigvoid setIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(I",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11208,Modifiability,config,configuration,11208,"tIntegratorConfig()Remove the specialized numeric integration configuration associated with this object.Definition RooAbsReal.cxx:3346; RooAbsReal::forceNumIntvirtual void forceNumInt(bool flag=true)Definition RooAbsReal.h:169; RooAbsReal::getIntegratorConfigconst RooNumIntConfig * getIntegratorConfig() constReturn the numeric integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmd",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:11622,Modifiability,variab,variable,11622," integration configuration used for this object.Definition RooAbsReal.cxx:3309; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooExponentialExponential PDF.Definition RooExponential.h:22; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooNumIntConfigHolds the configuration parameters of the various numeric integrators used by RooRealIntegral.Definition RooNumIntConfig.h:25; RooPowerSumRooPowerSum implements a power law PDF of the form.Definition RooPowerSum.h:20; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::NormSetRooCmdArg NormSet(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:371; RooFit::IntegrateBinsRooCmdArg IntegrateBins(double precision)Integrate the PDF over bins.Definition RooGlobalFunc.cxx:507; RooFit::OffsetRooCmdArg Offset(std::string const &mode)Definition RooGlobalFunc.cxx:756; RooFit::SaveRooCmdArg Save(bool flag=true)Definition RooGlobalFunc.cxx:649; RooFit::SumW2ErrorRooCmdArg SumW2Error(bool flag)Definition RooGlobalFunc.cxx:733; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::RangeRooCmdArg Range(const char *rangeName, bool adjustNorm=true)Definition RooGlobalFunc.cxx:199; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:15184,Modifiability,extend,extended,15184,"::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162058; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=-1 HESSE=3 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.7972e+00 +/- 7.39e-04; mu 2.9756e+00 +/- 3.90e-02; nbkg 1.0001e+07 +/- 3.25e+03; nsig 9.4264e+03 +/- 7.36e+02; sigma 4.6849e-01 +/- 2.75e-02; ; ; RooFitResult: minimized FCN value: 3416.14, estimated distance to minimum: 0.000238265; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.7971e+00 +/- 7.26e-04; mu 2.9939e+00 +/- 3.63e-02; nbkg 1.0001e+07 +/- 3.24e+03; nsig 9.2425e+03 +/- 6.92e+02; sigma 4.5747e-01 +/- 2.59e-02; ; DateJanuary 2023 ; AuthorJonas Rembser ; Definition in file rf614_binned_fit_problems.C. tutorialsroofitrf614_binned",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:5004,Performance,perform,performance,5004,"ntLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins());; std::unique_ptr<RooFitResult> fit4{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit4->Print();; disableBinIntegrator(powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects beca",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6304,Safety,predict,predicted,6304,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6202,Testability,log,log,6202,"powerlaw);; ; // To get rid of the binning effects in the general case, one can use the; // IntegrateBins() command argument. Now, the pdf is not evaluated at the; // bin centers, but numerically integrated over each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:6382,Testability,log,logarithms,6382,"r each bin and divided by the; // bin width. The parameter for IntegrateBins() is the required precision; // for the numeric integrals. This is computationally expensive, but the; // bias is now not a problem anymore.; std::unique_ptr<RooFitResult> fit5{; powerlaw.fitTo(*powerlawData, IntegrateBins(1e-3), Save(), PrintLevel(-1), SumW2Error(false))};; fit5->Print();; ; // Improving numerical stability; // -----------------------------; ; // There is one more problem with binned fits that is related to the binning; // effects because often, a binned fit is affected by both problems.; //; // The issue is numerical stability for fits with a greatly different number; // of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; // the NLL, where \f[n\f] is the number of observations in the bin, and; // \f[p\f] the predicted probability to have an event in that bin. The; // difference in the logarithms for each bin is small, but the difference in; // \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; // lots of numerical precision is lost for the bins with less events.; ; // We can study this with the example of an exponential plus a Gaussian. The; // Gaussian is only a faint signal in the tail of the exponential where; // there are not so many events. And we can't afford any precision loss for; // these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100); // It's not about binning effects anymore, so reset the number of bins.; ; RooRealVar mu{""mu"", ""mu"", 3.0, 0.1, 5.1};; RooRealVar sigma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0};; ; RooAddPdf model{""model"", ""model"", {gauss, expo}, {nsig, nbkg}};; ; std::unique_ptr<RooAbsData> modelData{model.generateBinned(x)};; ; // Set the starting values ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:8007,Testability,log,log,8007,"gma{""sigma"", ""sigma"", 0.5, 0.01, 5.0};; RooGaussian gauss{""gauss"", ""gauss"", x, mu, sigma};; ; RooRealVar nsig{""nsig"", ""nsig"", 10000, 0, 1e9};; RooRealVar nbkg{""nbkg"", ""nbkg"", 10000000, 0, 1e9};; RooRealVar frac{""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0};; ; RooAddPdf model{""model"", ""model"", {gauss, expo}, {nsig, nbkg}};; ; std::unique_ptr<RooAbsData> modelData{model.generateBinned(x)};; ; // Set the starting values for the Gaussian parameters away from the true; // value such that the fit is not trivial.; mu.setVal(2.0);; sigma.setVal(1.0);; ; std::unique_ptr<RooFitResult> fit6{model.fitTo(*modelData, Save(), PrintLevel(-1), SumW2Error(false))};; fit6->Print();; ; // You should see in the previous fit result that the fit did not converge:; // the `MINIMIZE` return code should be -1 (a successful fit has status code zero).; ; // To improve the situation, we can apply a numeric trick: if we subtract in; // each bin a constant counterterm \f[n\log(n/N)\f], we get terms for each; // bin that are closer to each other in order of magnitude as long as the; // initial model is not extremely off. Proving this mathematically is left; // as an exercise to the reader.; ; // This counterterms can be enabled by passing the Offset(""bin"") option to; // RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; std::unique_ptr<RooFitResult> fit7{; model.fitTo(*modelData, Offset(""bin""), Save(), PrintLevel(-1), SumW2Error(false))};; fit7->Print();; ; // You should now see in the last fit result that the fit has converged.; }; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsBinningAbstract base class for RooRealVar binning definitions.Definition RooAbsBinning.h:25; RooAbsBinning::setRangevirtual void setRange(double xlo, double xhi)=0; RooAbsPdfAbs",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:399,Usability,learn,learn,399,". ROOT: tutorials/roofit/rf614_binned_fit_problems.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf614_binned_fit_problems.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; // Generate binned Asimov dataset for a continuous pdf.; // One should in principle be able to use; // pdf.generateBinned(x, nEvents, RooFit::ExpectedData()).; // Unfortunately it has a problem: it also has the bin bias that this tutorial; // demonstrates, to if we would use it, the biases would cancel out.; std::unique_ptr<RooDataHist> generateBinnedAsimov(RooAbsPdf const &pdf, RooRealVar &x, int nEvents); {; auto dataH = std::make_unique<RooDataHist>(""dataH"", ""dataH"", RooArgSet{x});; RooAbsBinning &xBinning = x.getBinning();; for (int iBin = 0; iBin < x.numBins(); ++iBin) {; x.setRange(""bin"", xBinning.binLow(iBin), xBinning.binHigh(iBin));; std::unique_ptr<RooAbsReal> integ{pdf.createIntegral(x, RooFit::NormSet(x), RooFit::Range(""bin""))};; integ->getVal();; dataH->set(iBin, nEvents * integ->getVal(), -1);; }; return dataH;; }; ; // Force numeric integration and do this numeric integration with the; // RooBinIntegrator, which sums the function values at the bin centers.; void enableBinIntegrator(RooAbsReal &func, int numBins); {; RooNumIntConfig customConfig(*func.getIntegratorConfig());; customConfig.method1D().setLabel(""RooBinIntegrator"");; customConfig.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", numBins);; func.setIntegra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:583,Deployability,integrat,integrating,583,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:858,Deployability,continuous,continuous,858,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1541,Deployability,integrat,integration,1541,"get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binn",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1573,Deployability,integrat,integration,1573,"get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binn",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1994,Deployability,integrat,integrator,1994,"ely it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binning effects for this demo; ; # Let's first look at the example of an exponential function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:3034,Deployability,continuous,continuous,3034,"etIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binning effects for this demo; ; # Let's first look at the example of an exponential function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will get a bias in the; # result. This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"",",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:3639,Deployability,integrat,integrated,3639," function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will get a bias in the; # result. This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4635,Deployability,integrat,integrating,4635,"omizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5143,Deployability,integrat,integrated,5143,"w, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when sum",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:8787,Deployability,integrat,integrator,8787,"itude as long as the; # initial model is not extremely off. Proving this mathematically is left; # as an exercise to the reader.; ; # This counterterms can be enabled by passing the Offset(""bin"") option to; # RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; fit7 = model.fitTo(model_data, Offset=""bin"", Save=True, PrintLevel=-1, SumW2Error=False); fit7.Print(); ; # You should now see in the last fit result that the fit has converged.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:9693,Deployability,integrat,integrator,9693,"G: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:446,Energy Efficiency,reduce,reduce,446,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:3936,Energy Efficiency,power,power,3936,"ata = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will get a bias in the; # result. This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, Pri",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4006,Energy Efficiency,power,powerlaw,4006,". This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the gener",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4035,Energy Efficiency,power,powerlaw,4035,", normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # Inte",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4047,Energy Efficiency,power,powerlaw,4047,", normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # Inte",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4129,Energy Efficiency,power,powerlaw,4129,"l=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4212,Energy Efficiency,power,powerlaw,4212,"l=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4810,Energy Efficiency,power,powerlaw,4810,"e); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4841,Energy Efficiency,power,powerlaw,4841,"egrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4951,Energy Efficiency,power,powerlaw,4951,"0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5380,Energy Efficiency,power,powerlaw,5380,"rick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:583,Integrability,integrat,integrating,583,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1541,Integrability,integrat,integration,1541,"get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binn",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1573,Integrability,integrat,integration,1573,"get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binn",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:1994,Integrability,integrat,integrator,1994,"ely it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binning effects for this demo; ; # Let's first look at the example of an exponential function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:3639,Integrability,integrat,integrated,3639," function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will get a bias in the; # result. This is because the continuous, normalized pdf is evaluated only; # at the bin centers.; fit1 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit1.Print(); ; # In the case of an exponential function, the bias that you get by; # evaluating the pdf only at the bin centers is a constant scale factor in; # each bin. Here, we can do a trick to get rid of the bias: we also; # evaluate the normalization integral for the pdf the same way, i.e.,; # summing the values of the unnormalized pdf at the bin centers. Like this; # the bias cancels out. You can achieve this by customizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4635,Integrability,integrat,integrating,4635,"omizing the way how the; # pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits t",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5143,Integrability,integrat,integrated,5143,"w, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when sum",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:8787,Integrability,integrat,integrator,8787,"itude as long as the; # initial model is not extremely off. Proving this mathematically is left; # as an exercise to the reader.; ; # This counterterms can be enabled by passing the Offset(""bin"") option to; # RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; fit7 = model.fitTo(model_data, Offset=""bin"", Save=True, PrintLevel=-1, SumW2Error=False); fit7.Print(); ; # You should now see in the last fit result that the fit has converged.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:9693,Integrability,integrat,integrator,9693,"G: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(expo_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 4440.6, estimated distance to minimum: 5.599e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.8000e+00 +/- 1.87e-02; ; ; RooFitResult: minimized FCN value: 15816.4, estimated distance to minimum: 4.97037e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -2.6106e-01 +/- 1.06e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:2005,Modifiability,config,config,2005,"ely it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integrator config to disable the RooBinIntegrator.; """"""; func.setIntegratorConfig(); func.forceNumInt(False); ; ; # Silence info output for this tutorial; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Minimization); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Fitting); ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Generation); ; # Exponential example; # -------------------; ; # Set up the observable; x = ROOT.RooRealVar(""x"", ""x"", 0.1, 5.1); x.setBins(10); # fewer bins so we have larger binning effects for this demo; ; # Let's first look at the example of an exponential function; c = ROOT.RooRealVar(""c"", ""c"", -1.8, -5, 5); expo = ROOT.RooExponential(""expo"", ""expo"", x, c); ; # Generate an Asimov dataset such that the only difference between the fit; # result and the true parameters comes from binning effects.; expo_data = generateBinnedAsimov(expo, x, 10000); ; # If you do the fit the usual was in RooFit, you will",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:10481,Modifiability,extend,extended,10481,"::RooBinIntegrator WARNING: integrand provide no binning definition observable #0 substituting default binning of 10 bins; [#1] INFO:NumericIntegration -- RooRealIntegral::init(powerlaw_Int[x]) using numeric integrator RooBinIntegrator to calculate Int(x); ; RooFitResult: minimized FCN value: 15739.9, estimated distance to minimum: 4.99474e-07; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.1481e-01 +/- 1.15e-02; ; ; RooFitResult: minimized FCN value: 15739.6, estimated distance to minimum: 3.92419e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a -3.0010e-01 +/- 1.07e-02; ; [#0] PROGRESS:Generation -- RooAbsPdf::generateBinned(model) Performing costly accept/reject sampling. If this takes too long, use extended mode to speed up the process.; ; RooFitResult: minimized FCN value: -1.47174e+08, estimated distance to minimum: 0.162058; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=-1 HESSE=3 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.7972e+00 +/- 7.39e-04; mu 2.9756e+00 +/- 3.90e-02; nbkg 1.0001e+07 +/- 3.25e+03; nsig 9.4264e+03 +/- 7.36e+02; sigma 4.6849e-01 +/- 2.75e-02; ; ; RooFitResult: minimized FCN value: 3416.14, estimated distance to minimum: 0.000238265; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.7971e+00 +/- 7.26e-04; mu 2.9939e+00 +/- 3.63e-02; nbkg 1.0001e+07 +/- 3.24e+03; nsig 9.2425e+03 +/- 6.92e+02; sigma 4.5747e-01 +/- 2.59e-02; ; DateJanuary 2023 ; AuthorJonas Rembser ; Definition in file rf614_binned_fit_problems.py. tutorialsroofitrf614_binne",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:4728,Performance,perform,performance,4728,"ins()); fit2 = expo.fitTo(expo_data, Save=True, PrintLevel=-1, SumW2Error=False); fit2.Print(); disableBinIntegrator(expo); ; # Power law example; # -----------------; ; # Let's not look at another example: a power law \f[x^a\f].; a = ROOT.RooRealVar(""a"", ""a"", -0.3, -5.0, 5.0); powerlaw = ROOT.RooPowerSum(""powerlaw"", ""powerlaw"", x, ROOT.RooFit.RooConst(1.0), a); powerlaw_data = generateBinnedAsimov(powerlaw, x, 10000); ; # Again, if you do a vanilla fit, you'll get a bias; fit3 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit3.Print(); ; # This time, the bias is not the same factor in each bin! This means our; # trick by sampling the integral in the same way doesn't cancel out the; # bias completely. The average bias is canceled, but there are per-bin; # biases that remain. Still, this method has some value: it is cheaper than; # rigurously correcting the bias by integrating the pdf in each bin. So if; # you know your per-bin bias variations are small or performance is an; # issue, this approach can be sufficient.; enableBinIntegrator(powerlaw, x.numBins()); fit4 = powerlaw.fitTo(powerlaw_data, Save=True, PrintLevel=-1, SumW2Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numer",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5945,Safety,predict,predicted,5945,"Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""fr",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:5845,Testability,log,log,5845,"Error=False); fit4.Print(); disableBinIntegrator(powerlaw); ; # To get rid of the binning effects in the general case, one can use the; # IntegrateBins() command argument. Now, the pdf is not evaluated at the; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""fr",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:6022,Testability,log,logarithms,6022,"; # bin centers, but numerically integrated over each bin and divided by the; # bin width. The parameter for IntegrateBins() is the required precision; # for the numeric integrals. This is computationally expensive, but the; # bias is now not a problem anymore.; fit5 = powerlaw.fitTo(powerlaw_data, IntegrateBins=1e-3, Save=True, PrintLevel=-1, SumW2Error=False); fit5.Print(); ; # Improving numerical stability; # -----------------------------; ; # There is one more problem with binned fits that is related to the binning; # effects because often, a binned fit is affected by both problems.; #; # The issue is numerical stability for fits with a greatly different number; # of events in each bin. For each bin, you have a term \f[n\log(p)\f] in; # the NLL, where \f[n\f] is the number of observations in the bin, and; # \f[p\f] the predicted probability to have an event in that bin. The; # difference in the logarithms for each bin is small, but the difference in; # \f[n\f] can be orders of magnitudes! Therefore, when summing these terms,; # lots of numerical precision is lost for the bins with less events.; ; # We can study this with the example of an exponential plus a Gaussian. The; # Gaussian is only a faint signal in the tail of the exponential where; # there are not so many events. And we can't afford any precision loss for; # these bins, otherwise we can't fit the Gaussian.; ; x.setBins(100) # It's not about binning effects anymore, so reset the number of bins.; ; mu = ROOT.RooRealVar(""mu"", ""mu"", 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0); ; model = ROOT.RooAddPdf(""model"", ""model"", [gauss, expo], [nsig, nbkg]); ; model_data = model.generateBinned(x); ; # Set the starting ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:7615,Testability,log,log,7615," 3.0, 0.1, 5.1); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.01, 5.0); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mu, sigma); ; nsig = ROOT.RooRealVar(""nsig"", ""nsig"", 10000, 0, 1e9); nbkg = ROOT.RooRealVar(""nbkg"", ""nbkg"", 10000000, 0, 1e9); frac = ROOT.RooRealVar(""frac"", ""frac"", nsig.getVal() / (nsig.getVal() + nbkg.getVal()), 0.0, 1.0); ; model = ROOT.RooAddPdf(""model"", ""model"", [gauss, expo], [nsig, nbkg]); ; model_data = model.generateBinned(x); ; # Set the starting values for the Gaussian parameters away from the true; # value such that the fit is not trivial.; mu.setVal(2.0); sigma.setVal(1.0); ; fit6 = model.fitTo(model_data, Save=True, PrintLevel=-1, SumW2Error=False); fit6.Print(); ; # You should see in the previous fit result that the fit did not converge:; # the `MINIMIZE` return code should be -1 (a successful fit has status code zero).; ; # To improve the situation, we can apply a numeric trick: if we subtract in; # each bin a constant counterterm \f[n\log(n/N)\f], we get terms for each; # bin that are closer to each other in order of magnitude as long as the; # initial model is not extremely off. Proving this mathematically is left; # as an exercise to the reader.; ; # This counterterms can be enabled by passing the Offset(""bin"") option to; # RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; ; fit7 = model.fitTo(model_data, Offset=""bin"", Save=True, PrintLevel=-1, SumW2Error=False); fit7.Print(); ; # You should now see in the last fit result that the fit has converged.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'bin' created with bounds [0.1,0.6]; ; RooFitResult: minimized FCN value: 4754.37, estimated distance to minimum: 3.09852e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; c -1.6862e+00 +/- 1.70e-02; ; [#0] WARNING:Integration -- RooBinIntegrator::RooBinIntegrator WARNING: integrand provide ",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf614__binned__fit__problems_8py.html:414,Usability,learn,learn,414,". ROOT: tutorials/roofit/rf614_binned_fit_problems.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf614_binned_fit_problems.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; A tutorial that explains you how to solve problems with binning effects and numerical stability in binned fits. . Introduction; In this tutorial, you will learn three new things:. How to reduce the bias in binned fits by changing the definition of the normalization integral; How to completely get rid of binning effects by integrating the pdf over each bin; How to improve the numeric stability of fits with a greatly different number of events per bin, using a constant per-bin counterterm. ; import ROOT; ; ; def generateBinnedAsimov(pdf, x, n_events):; """"""; Generate binned Asimov dataset for a continuous pdf.; One should in principle be able to use; pdf.generateBinned(x, n_events, RooFit::ExpectedData()).; Unfortunately it has a problem: it also has the bin bias that this tutorial; demonstrates, to if we would use it, the biases would cancel out.; """"""; data_h = ROOT.RooDataHist(""dataH"", ""dataH"", {x}); x_binning = x.getBinning(); ; for i_bin in range(x.numBins()):; x.setRange(""bin"", x_binning.binLow(i_bin), x_binning.binHigh(i_bin)); integ = pdf.createIntegral(x, NormSet=x, Range=""bin""); ROOT.SetOwnership(integ, True); integ.getVal(); data_h.set(i_bin, n_events * integ.getVal(), -1); ; return data_h; ; ; def enableBinIntegrator(func, num_bins):; """"""; Force numeric integration and do this numeric integration with the; RooBinIntegrator, which sums the function values at the bin centers.; """"""; custom_config = ROOT.RooNumIntConfig(func.getIntegratorConfig()); custom_config.method1D().setLabel(""RooBinIntegrator""); custom_config.getConfigSection(""RooBinIntegrator"").setRealValue(""numBins"", num_bins); func.setIntegratorConfig(custom_config); func.forceNumInt(True); ; ; def disableBinIntegrator(func):; """"""; Reset the integra",MatchSource.WIKI,doc/master/rf614__binned__fit__problems_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:9435,Availability,error,error,9435,", 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, True); result.Print(); ; del nll_morph; del nllr_learned; del nll_gauss; del workspace; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:1798,Integrability,message,messages,1798,"trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Grid(ROOT.RooBinning(4, 0.0, 4.0)); x_var.setBins(50); ; # Number of 'sampled' gaussians, if you change it, adjust the binning properly; n_grid = 5; ; for i in range(n_grid):; # Define the sampled gausians; mu_help = ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", i); help = ROOT.RooGaussian(f""g{i}"", f""g{i}"", x_var, mu_help, sigma); workspace.Import(help, Silence=True); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples); ; # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, 1), Silence=True",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:4142,Modifiability,extend,extend,4142,"# f1 = x_var.frame(Title=""linear morphing;x;pdf"", Range=(-4, 8)); # for i in range(n_grid):; # workspace[f""histpdf{i}""].plotOn(f1); # workspace[""morph""].plotOn(f1, LineColor=""r""); # c0 = ROOT.TCanvas(); # f1.Draw(); # input() # Wait for user input to proceed; ; ; # Class used in this case to demonstrate the use of SBI in Root; class SBI:; # Initializing the class SBI; def __init__(self, workspace):; # Choose the hyperparameters for training the neural network; self.classifier = MLPClassifier(hidden_layer_sizes=(20, 20), max_iter=1000, random_state=42); self.data_model = None; self.data_ref = None; self.X_train = None; self.y_train = None; self.workspace = workspace; ; # Defining the target / training data for different values of mean value mu; def model_data(self, model, x, mu, n_samples):; ws = self.workspace; data_test_model = []; samples_gaussian = ws[model].generate([ws[x], ws[mu]], n_samples).to_numpy(); self._training_mus = samples_gaussian[mu]; data_test_model.extend(samples_gaussian[x]); ; self.data_model = np.array(data_test_model).reshape(-1, 1); ; # Generating samples for the reference distribution; def reference_data(self, model, x, n_samples):; ws = self.workspace; # Ensuring the normalization with generating as many reference data as target data; samples_uniform = ws[model].generate(ws[x], n_samples); data_reference_model = np.array(; [samples_uniform.get(i).getRealValue(""x"") for i in range(samples_uniform.numEntries())]; ); self.data_ref = data_reference_model.reshape(-1, 1); ; # Bringing the data in the right format for training; def preprocessing(self):; thetas_model = self._training_mus.reshape(-1, 1); thetas_reference = self._training_mus.reshape(-1, 1); thetas = np.concatenate((thetas_model, thetas_reference), axis=0); X = np.concatenate([self.data_model, self.data_ref]); self.y_train = np.concatenate([np.ones(len(self.data_model)), np.zeros(len(self.data_ref))]); self.X_train = np.concatenate([X, thetas], axis=1); ; # Train the classifier; def t",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:10657,Modifiability,variab,variables,10657,"learned; del nll_gauss; del workspace; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; ; RooWorkspace() contents; ; variables; ---------; (mu,x); ; p.d.f.s; -------; RooGaussian::gauss[ x=x mean=mu sigma=1.5 ] = 0.249352; RooUniform::uniform[ x=(x) ] = 1; ; ; RooFitResult: minimized FCN value: 1862.97, estimated distance to minimum: 2.32702e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; mu 2.5399e+00 +/- 4.74e-02; ; ; RooFitResult: minimized FCN value: -1126.14, estimated distance to minimum: 4.23342e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; mu 2.5511e+00 +/- 7.15e-02; ; ; RooFitResult: minimized FCN value: 1864.58, estimated distance to minimum: 1.67611e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- -------------------------",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:1480,Testability,log,logarithmic,1480,"The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Grid(ROOT.RooBinning(4, 0.0, 4.0)); x_var.setBins(50); ; # Number of 'sampled' gaussians, if you change it, adjust the binning properly; n_grid = 5; ; for i in range(n_grid):; # Define the sampled gausians; mu_help = ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", i); help = ROOT.RooGaussian(f""g{i}"", f""g{i}"", x_var, mu_help, sigma); workspace.Import(help, Silence=True); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples); ; # Make sure that every bin is filled and we don't get zero prob",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6829,Testability,log,log,6829,"""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace[""gauss""]; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:7383,Testability,log,logarithmic,7383,"(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.G",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:405,Usability,simpl,simple,405,". ROOT: tutorials/roofit/rf615_simulation_based_inference.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf615_simulation_based_inference.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in RooFit. ; This tutorial shows how to use SBI in ROOT. As reference distribution we choose a simple uniform distribution. The target distribution is chosen to be gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Gr",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:906,Usability,learn,learn,906,". ROOT: tutorials/roofit/rf615_simulation_based_inference.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf615_simulation_based_inference.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in RooFit. ; This tutorial shows how to use SBI in ROOT. As reference distribution we choose a simple uniform distribution. The target distribution is chosen to be gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Gr",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:1511,Usability,learn,learned,1511,"The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; We compare the approach of using the likelihood ratio trick to morphing.; An introduction of SBI can be found in https://arxiv.org/pdf/2010.06439.; A short recap: The idea of SBI is to fit a surrogate model to the data, in order to really learn the likelihood function instead of calculating it. Therefore, a classifier is trained to discriminate between samples from a target distribution (here the Gaussian) $$x\sim p(x|\theta)$$ and a reference distribution (here the Uniform) $$x\sim p_{ref}(x|\theta)$$.; The output of the classifier $$\hat{s}(\theta)$$ is a monotonic function of the likelihood ration and can be turned into an estimate of the likelihood ratio via $$\hat{r}(\theta)=\frac{1-\hat{s}(\theta)}{\hat{s}(\theta)}.$$ This is called the likelihood ratio trick.; In the end we compare the negative logarithmic likelihoods of the learned, morphed and analytical likelihood with minuit and as a plot. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; ; # The samples used for training the classifier in this tutorial / rescale for more accuracy; n_samples = 10000; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # Morphing as a baseline; def morphing(setting):; ; # Define binning for morphing; grid = ROOT.RooMomentMorphFuncND.Grid(ROOT.RooBinning(4, 0.0, 4.0)); x_var.setBins(50); ; # Number of 'sampled' gaussians, if you change it, adjust the binning properly; n_grid = 5; ; for i in range(n_grid):; # Define the sampled gausians; mu_help = ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", i); help = ROOT.RooGaussian(f""g{i}"", f""g{i}"", x_var, mu_help, sigma); workspace.Import(help, Silence=True); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples); ; # Make sure that every bin is filled and we don't get zero prob",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6561,Usability,learn,learned,6561,"f""Gaussian::gauss(x[-5,15], mu[0,4], {sigma})""); ws.factory(""Uniform::uniform(x)""); ws[""mu""].setVal(mu_observed); ws.Print(""v""); obs_data = ws[""gauss""].generate(ws[""x""], 1000); obs_data.SetName(""obs_data""); ws.Import(obs_data, Silence=True); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace[""gauss""]; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftT",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6964,Usability,learn,learned,6964,"; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:7001,Usability,learn,learned,7001,"; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:7568,Usability,learn,learned,7568," Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); nll_gauss.plotOn(frame1, LineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); lege",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:8590,Usability,learn,learned,8590,"ineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, ",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:8601,Usability,learn,learned,8601,"ineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, ",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:9108,Usability,learn,learned,9108,"+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, True); result.Print(); ; del nll_morph; del nllr_learned; del nll_gauss; del workspace; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPri",MatchSource.WIKI,doc/master/rf615__simulation__based__inference_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html
https://root.cern/doc/master/rf616__morphing_8C.html:1093,Integrability,rout,routine,1093,"orphing.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/b67830e46d53d5f7cf2d. ; #include ""RooRealVar.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooMomentMorphFuncND.h""; #include ""RooAbsPdf.h""; ; using namespace RooFit;; ; // Number of samples to fill the histograms; const int n_samples = 1000;; ; // Kills warning massages; RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);; ; // Define the morphing routine; RooPlot *perform_morphing(RooWorkspace &ws, RooMomentMorphFuncND::Setting setting, double sigma); {; // Get Variables from the workspace; RooRealVar *x_var = ws.var(""x"");; RooRealVar *mu_var = ws.var(""mu"");; RooAbsPdf *gauss = ws.pdf(""gauss"");; ; // Initialize a plot; RooPlot *frame1 = x_var->frame();; ; // Define binning for morphing; RooMomentMorphFuncND::Grid grid(RooBinning(4, 0.0, 4.0));; ; // Set binning of histograms, has to be customized for optimal results; x_var->setBins(50);; ; std::vector<int> parampoints = {0, 1, 2, 3, 4};; ; for (auto i : parampoints) {; // Define the sampled gaussians; RooRealVar mu_help(Form(""mu%d"", i), Form(""mu%d"", i), i);; // Use * because RooGaussian expects objects no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory leaks; std::unique_ptr<RooDataHist> hist1{; dynamic_cast<RooDataHist *>(ws.pdf(Form(""g%d"", i))->generateBinned(*x_var, 100 * n_samples))};; ; // Add ",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:2906,Integrability,message,messages,2906,"s no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory leaks; std::unique_ptr<RooDataHist> hist1{; dynamic_cast<RooDataHist *>(ws.pdf(Form(""g%d"", i))->generateBinned(*x_var, 100 * n_samples))};; ; // Add the value 1 to each bin; for (int i_bin = 0; i_bin < hist1->numEntries(); ++i_bin) {; const RooArgSet *binContent = hist1->get(i_bin);; hist1->add(*binContent, 1.0);; }; ; // Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; // Adjust it to 0 to see binning; ws.import(RooHistPdf(Form(""histpdf%d"", i), Form(""histpdf%d"", i), *x_var, *hist1, 1), Silence(true));; ; // Plot and add the pdf to the grid; RooAbsPdf *pdf = ws.pdf(Form(""histpdf%d"", i));; pdf->plotOn(frame1);; grid.addPdf(*pdf, i);; }; ; // Create the morphing; RooMomentMorphFuncND morph_func(""morpf_func"", ""morph_func"", RooArgList(*mu_var), RooArgList(*x_var), grid, setting);; ; // Normalizing the morphed object to be a pdf, set it false to prevent warning messages and gain computational speed; // up; morph_func.setPdfMode();; ; // Creating the morphed pdf; RooWrapperPdf morph(""morph"", ""morph"", morph_func, true);; ws.import(morph, Silence(true));; RooAbsPdf *morph_ = ws.pdf(""morph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_v",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:6001,Integrability,interface,interface,6001,"l);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Print();; }; }; c#define c(i)Definition RSha256.hxx:101; RooAbsPdf.h; RooDataSet.h; RooGaussian.h; RooMomentMorphFuncND.h; RooPlot.h; RooRealVar.h; RooUniform.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Construct representation of -log(L) of PDF with given dataset.Definition RooAbsPdf.h:163; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definiti",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:9289,Integrability,interface,interface,9289,"roject) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooBinningImplements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choi...Definition RooBinning.h:27; RooDataHistContainer class to hold N-dimensional binned data.Definition RooDataHist.h:40; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooFitResultRooFitResult is a container class to hold the input and output of a PDF fit to a dataset.Definition RooFitResult.h:40; RooFit::EvalBackendDefinition RooGlobalFunc.h:245; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooHistPdfA propability density function sampled from a multidimensional histogram.Definition RooHistPdf.h:30; RooMinimizerWrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer f...Definition RooMinimizer.h:48; RooMomentMorphFuncND::Grid2Definition RooMomentMorphFuncND.h:38; RooMomentMorphFuncNDDefinition RooMomentMorphFuncND.h:33; RooMomentMorphFuncND::SettingSettingDefinition RooMomentMorphFuncND.h:97; RooMomentMorphFuncND::Linear@ LinearDefinition RooMomentMorphFuncND.h:97; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::setGlobalKillBelowvoid setGlobalKillBelow(RooFit::MsgLevel level)Definition RooMsgService.h:169; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooReal",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:3586,Modifiability,variab,variables,3586,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:10378,Modifiability,variab,variable,10378,"er f...Definition RooMinimizer.h:48; RooMomentMorphFuncND::Grid2Definition RooMomentMorphFuncND.h:38; RooMomentMorphFuncNDDefinition RooMomentMorphFuncND.h:33; RooMomentMorphFuncND::SettingSettingDefinition RooMomentMorphFuncND.h:97; RooMomentMorphFuncND::Linear@ LinearDefinition RooMomentMorphFuncND.h:97; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::setGlobalKillBelowvoid setGlobalKillBelow(RooFit::MsgLevel level)Definition RooMsgService.h:169; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooWorkspace::pdfRooAbsPdf * pdf(RooStringView name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::importbool import(const RooAbsArg &arg, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={})Import a RooAbsArg object, e.g.Definition RooWorkspace.cxx:370; RooWorkspace::factoryRooFactoryWSTool & factory()Return instance to factory tool.Definition RooWorkspace.cxx:2067; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWo",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:11224,Modifiability,variab,variable,11224,"n be changed from the outside.Definition RooRealVar.h:37; RooRealVar::setBinsvoid setBins(Int_t nBins, const char *name=nullptr)Create a uniform binning under name 'name' for this variable.Definition RooRealVar.cxx:396; RooWorkspacePersistable container for RooFit projects.Definition RooWorkspace.h:43; RooWorkspace::pdfRooAbsPdf * pdf(RooStringView name) constRetrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1214; RooWorkspace::importbool import(const RooAbsArg &arg, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={})Import a RooAbsArg object, e.g.Definition RooWorkspace.cxx:370; RooWorkspace::factoryRooFactoryWSTool & factory()Return instance to factory tool.Definition RooWorkspace.cxx:2067; RooWorkspace::varRooRealVar * var(RooStringView name) constRetrieve real-valued variable (RooRealVar) with given name. A null pointer is returned if not found.Definition RooWorkspace.cxx:1232; RooWrapperPdfThe RooWrapperPdf is a class that can be used to convert a function into a PDF.Definition RooWrapperPdf.h:24; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::SilenceRooCmdArg Silence(bool flag=true)Definition RooGlobalFunc.cxx:892; RooFit::ShiftToZeroRooCmdArg ShiftToZero()Definition RooGlobalFunc.cxx:191; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; RooFit::WARNING@ WARNINGDefinition RooGlobalFunc.h:60; rf616_morphingDefinition rf616_morphing.py:1; xmlio:",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:5909,Security,access,access,5909,"nuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Print();; }; }; c#define c(i)Definition RSha256.hxx:101; RooAbsPdf.h; RooDataSet.h; RooGaussian.h; RooMomentMorphFuncND.h; RooPlot.h; RooRealVar.h; RooUniform.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Construct representation of -log(L) of PDF with given dataset.Definition RooAbsPdf.h:163; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmd",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:526,Testability,log,log,526,". ROOT: tutorials/roofit/rf616_morphing.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf616_morphing.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/b67830e46d53d5f7cf2d. ; #include ""RooRealVar.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooGaussian.h""; #include ""RooUniform.h""; #include ""RooDataSet.h""; #include ""RooPlot.h""; #include ""RooMomentMorphFuncND.h""; #include ""RooAbsPdf.h""; ; using namespace RooFit;; ; // Number of samples to fill the histograms; const int n_samples = 1000;; ; // Kills warning massages; RooMsgService::instance().setGlobalKillBelow(RooFit::WARNING);; ; // Define the morphing routine; RooPlot *perform_morphing(RooWorkspace &ws, RooMomentMorphFuncND::Setting setting, double sigma); {; // Get Variables from the workspace; RooRealVar *x_var = ws.var(""x"");; RooRealVar *mu_var = ws.var(""mu"");; RooAbsPdf *gauss = ws.pdf(""gauss"");; ; // Initialize a plot; RooPlot *frame1 = x_var->frame();; ; // Define binning for morphing; RooMomentMorphFuncND::Grid grid(RooBinning(4, 0.0, 4.0));; ; // Set binning of histograms, has to be customized for optimal results; x_var->setBins(50);; ; std::vector<int> parampoints = {0, 1, 2, 3, 4};; ; for (auto i : parampoints) {; // Define the sampled gaussians; RooRealVar mu_help(Form(""mu%d"", i), Form(""mu%d"", i), i);; // Use * because RooGaussian expects objects no pointers; RooGaussian help(Form(""g%d"", i), Form(""g%d"", i), *x_var, mu_help, sigma);; ws.import(help, Silence(true));; ; // Fill the histograms use a unique pointer to prevent memory lea",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:3962,Testability,log,log,3962,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:4093,Testability,log,log,4093,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:4319,Testability,log,logarithmic,4319,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:4398,Testability,log,log,4398,"rph"");; morph_->plotOn(frame1, LineColor(kRed));; ; return frame1;; }; ; // Define the workspace; std::unique_ptr<RooWorkspace> build_ws(double mu_observed, double sigma); {; auto ws = std::make_unique<RooWorkspace>();; ws->factory(Form(""Gaussian::gauss(x[-5,15],mu[%f,0,4], %f)"", mu_observed, sigma));; return ws;; }; ; // Do the example; void rf616_morphing(); {; // Define the 'observed' mu; double mu_observed = 2.5;; double sigma = 1.5;; ; // Import variables from workspace; std::unique_ptr<RooWorkspace> ws = build_ws(mu_observed, sigma);; ; RooPlot *frame1 = perform_morphing(*ws, RooMomentMorphFuncND::Linear, sigma);; ; RooRealVar *x_var = ws->var(""x"");; RooRealVar *mu_var = ws->var(""mu"");; RooAbsPdf *gauss = ws->pdf(""gauss"");; RooDataSet *obs_data = gauss->generate(*x_var, n_samples);; ; // Create the exact negative log likelihood function for Gaussian model; RooAbsReal *nll_gauss = gauss->createNLL(*obs_data);; ; // Create the morphed negative log likelihood function; // TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; RooAbsReal *nll_morph = ws->pdf(""morph"")->createNLL(*obs_data, RooFit::EvalBackend(""legacy""));; ; // Plot the negative logarithmic summed likelihood; RooPlot *frame2 = mu_var->frame(Title(""Negative log Likelihood""));; nll_gauss->plotOn(frame2, LineColor(kBlue), ShiftToZero(), Name(""gauss""));; nll_morph->plotOn(frame2, LineColor(kRed), ShiftToZero(), Name(""morph""));; ; TCanvas *c = new TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; ; // Compute the minimum of the nll via minuit; std::vector<RooAbsReal *> nlls = {nll_gauss, nll_morph};; for (auto nll : nlls) {; RooMinimizer minimizer(*nll);; minimizer.setPrintLevel(-1);; minimizer.minimize(""Minuit2"");; RooFitResult *result = minimizer.save();; result->Pr",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8C.html:6214,Testability,log,log,6214,"; RooGaussian.h; RooMomentMorphFuncND.h; RooPlot.h; RooRealVar.h; RooUniform.h; RooWorkspace.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsCollection::getStorage_t const & get() constConst access to the underlying stl container.Definition RooAbsCollection.h:116; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::createNLLRooFit::OwningPtr< RooAbsReal > createNLL(RooAbsData &data, CmdArgs_t const &... cmdArgs)Construct representation of -log(L) of PDF with given dataset.Definition RooAbsPdf.h:163; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const R",MatchSource.WIKI,doc/master/rf616__morphing_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8C.html
https://root.cern/doc/master/rf616__morphing_8py.html:752,Integrability,message,messages,752,". ROOT: tutorials/roofit/rf616_morphing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf616_morphing.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/46fff8d22015e5a26619. ; ; import ROOT; ; # Number of samples to fill the histograms; n_samples = 1000; ; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # morphing as a baseline; def morphing(setting):; # set up a frame for plotting; frame1 = x_var.frame(); ; # define binning for morphing; bin_mu_x = ROOT.RooBinning(4, 0.0, 4.0); grid = ROOT.RooMomentMorphFuncND.Grid(bin_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf616__morphing_8py.html:2112,Integrability,message,messages,2112,"_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu_var], [x_var], grid, setting); ; # Normalizes the morphed object to be a pdf, set it false to prevent warning messages and gain computational speed up; morph_func.setPdfMode(); ; # Creating the morphed pdf; morph = ROOT.RooWrapperPdf(""morph"", ""morph"", morph_func, True); workspace.Import(morph); workspace[""morph""].plotOn(frame1, LineColor=""r""); ; return frame1; ; ; # Define the ""observed"" data in a workspade; def build_ws(mu_observed, sigma):; ws = ROOT.RooWorkspace(); ws.factory(f""Gaussian::gauss(x[-5,15], mu[{mu_observed},0,4], {sigma})"".format(mu_observed=mu_observed)); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace.pdf(""gauss""); obs_data = gauss.generate(x_var, n_samples); ; ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ; # Compute the morphed nll; frame1 = morphing(ROOT.RooMomentMorphFuncND.Linear); ; # TODO: Fix RooAddPdf::fixCoefNorma",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf616__morphing_8py.html:541,Testability,log,log,541,". ROOT: tutorials/roofit/rf616_morphing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf616_morphing.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Morphing in RooFit. ; This tutorial shows how to use template morphing inside RooFit. As input we have several Gaussian distributions. The output is one gaussian, with a specific mean value. Since likelihoods are often used within the framework of morphing, we provide a way to estimate the negative log likelihood (nll).; Based on example of Kyle Cranmer https://gist.github.com/cranmer/46fff8d22015e5a26619. ; ; import ROOT; ; # Number of samples to fill the histograms; n_samples = 1000; ; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; ; # morphing as a baseline; def morphing(setting):; # set up a frame for plotting; frame1 = x_var.frame(); ; # define binning for morphing; bin_mu_x = ROOT.RooBinning(4, 0.0, 4.0); grid = ROOT.RooMomentMorphFuncND.Grid(bin_mu_x); x_var.setBins(50); ; # number of 'sampled' Gaussians, if you change it, adjust the binning properly; for i in range(5):; # Create the sampled Gaussian; workspace.factory(f""Gaussian::g{i}(x, mu{i}[{i}], {sigma})"".format(i=i)); ; # Fill the histograms; hist = workspace[f""g{i}""].generateBinned([x_var], n_samples * 100); # Make sure that every bin is filled and we don't get zero probability; for i_bin in range(hist.numEntries()):; hist.add(hist.get(i_bin), 1.0); ; # Add the pdf to the workspace, the inOrder of 1 is necessary for calculation of the nll; # Adjust it to 0 to see binning; workspace.Import(ROOT.RooHistPdf(f""histpdf{i}"", f""histpdf{i}"", [x_var], hist, intOrder=1)); ; # Add the pdf to the grid and to the plot; grid.addPdf(workspace[f""histpdf{i}""], int(i)); workspace[f""histpdf{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf616__morphing_8py.html:2854,Testability,log,log,2854,"f{i}""].plotOn(frame1); ; # Create the morphing and add it to the workspace; morph_func = ROOT.RooMomentMorphFuncND(""morph_func"", ""morph_func"", [mu_var], [x_var], grid, setting); ; # Normalizes the morphed object to be a pdf, set it false to prevent warning messages and gain computational speed up; morph_func.setPdfMode(); ; # Creating the morphed pdf; morph = ROOT.RooWrapperPdf(""morph"", ""morph"", morph_func, True); workspace.Import(morph); workspace[""morph""].plotOn(frame1, LineColor=""r""); ; return frame1; ; ; # Define the ""observed"" data in a workspade; def build_ws(mu_observed, sigma):; ws = ROOT.RooWorkspace(); ws.factory(f""Gaussian::gauss(x[-5,15], mu[{mu_observed},0,4], {sigma})"".format(mu_observed=mu_observed)); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace.pdf(""gauss""); obs_data = gauss.generate(x_var, n_samples); ; ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ; # Compute the morphed nll; frame1 = morphing(ROOT.RooMomentMorphFuncND.Linear); ; # TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; nll_morph = workspace[""morph""].createNLL(obs_data, EvalBackend=""legacy""); ; # Plot the negative logarithmic summed likelihood; frame2 = mu_var.frame(Title=""Negative log Likelihood""); nll_gauss.plotOn(frame2, LineColor=""b"", ShiftToZero=True, Name=""gauss""); nll_morph.plotOn(frame2, LineColor=""r"", ShiftToZero=True, Name=""morphed""); ; c = ROOT.TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); ; ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setPrintLev",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf616__morphing_8py.html:3199,Testability,log,logarithmic,3199,"g the morphed pdf; morph = ROOT.RooWrapperPdf(""morph"", ""morph"", morph_func, True); workspace.Import(morph); workspace[""morph""].plotOn(frame1, LineColor=""r""); ; return frame1; ; ; # Define the ""observed"" data in a workspade; def build_ws(mu_observed, sigma):; ws = ROOT.RooWorkspace(); ws.factory(f""Gaussian::gauss(x[-5,15], mu[{mu_observed},0,4], {sigma})"".format(mu_observed=mu_observed)); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace.pdf(""gauss""); obs_data = gauss.generate(x_var, n_samples); ; ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ; # Compute the morphed nll; frame1 = morphing(ROOT.RooMomentMorphFuncND.Linear); ; # TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; nll_morph = workspace[""morph""].createNLL(obs_data, EvalBackend=""legacy""); ; # Plot the negative logarithmic summed likelihood; frame2 = mu_var.frame(Title=""Negative log Likelihood""); nll_gauss.plotOn(frame2, LineColor=""b"", ShiftToZero=True, Name=""gauss""); nll_morph.plotOn(frame2, LineColor=""r"", ShiftToZero=True, Name=""morphed""); ; c = ROOT.TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); ; ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UI",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf616__morphing_8py.html:3268,Testability,log,log,3268,"; workspace.Import(morph); workspace[""morph""].plotOn(frame1, LineColor=""r""); ; return frame1; ; ; # Define the ""observed"" data in a workspade; def build_ws(mu_observed, sigma):; ws = ROOT.RooWorkspace(); ws.factory(f""Gaussian::gauss(x[-5,15], mu[{mu_observed},0,4], {sigma})"".format(mu_observed=mu_observed)); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace.pdf(""gauss""); obs_data = gauss.generate(x_var, n_samples); ; ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ; # Compute the morphed nll; frame1 = morphing(ROOT.RooMomentMorphFuncND.Linear); ; # TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; nll_morph = workspace[""morph""].createNLL(obs_data, EvalBackend=""legacy""); ; # Plot the negative logarithmic summed likelihood; frame2 = mu_var.frame(Title=""Negative log Likelihood""); nll_gauss.plotOn(frame2, LineColor=""b"", ShiftToZero=True, Name=""gauss""); nll_morph.plotOn(frame2, LineColor=""r"", ShiftToZero=True, Name=""morphed""); ; c = ROOT.TCanvas(""rf616_morphing"", ""rf616_morphing"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); ; ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectio",MatchSource.WIKI,doc/master/rf616__morphing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf616__morphing_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:1284,Integrability,message,messages,1284,"Tutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of Gaussians for all dimensions; gaussians = []; for j in range(n_dimensions):; gaussian = ROOT.RooGaussian(f""gdim{j}"", f""gdim{j}"", x_vars[j], mu_helps[j], sigmas[j]); gaussians.append(gaussian); ; # Create a product PDF for the multidi",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:1800,Modifiability,variab,variable,1800,"ce and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of Gaussians for all dimensions; gaussians = []; for j in range(n_dimensions):; gaussian = ROOT.RooGaussian(f""gdim{j}"", f""gdim{j}"", x_vars[j], mu_helps[j], sigmas[j]); gaussians.append(gaussian); ; # Create a product PDF for the multidimensional Gaussian; gauss_product = ROOT.RooProdPdf(""gauss_product"", ""gauss_product"", ROOT.RooArgList(*gaussians)); ; templates = dict(); ; # Iterate through each tuple; for idx, nd_idx in enumerate(itertools.product(range(n_bins), repeat=n_dimensions)):; for i_dim in range(n_dimensions):; mu_helps[i_dim].setVal(nd_idx[i_dim]); ; # Fill the histograms; hist = gauss_product.generateBinned(ROOT.RooArgSet(*x_vars), n_samples_morph); ; # Ensure that every bin is filled and there are no zero probabilities; for i_bin in range(hist.numEntries())",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:7091,Modifiability,variab,variables,7091,"sians = [ROOT.RooGaussian(f""gauss{i}"", f""gauss{i}"", x_vars[i], mu_vars[i], sigmas[i]) for i in range(n_vars)]; uniforms = [ROOT.RooUniform(f""uniform{i}"", f""uniform{i}"", x_vars[i]) for i in range(n_vars)]; uniforms_help = [ROOT.RooUniform(f""uniformh{i}"", f""uniformh{i}"", mu_vars[i]) for i in range(n_vars)]; # Create multi-dimensional PDFs; gauss = ROOT.RooProdPdf(""gauss"", ""gauss"", ROOT.RooArgList(*gaussians)); uniform = ROOT.RooProdPdf(""uniform"", ""uniform"", ROOT.RooArgList(*uniforms)); uniform_help = ROOT.RooProdPdf(""uniform_help"", ""uniform_help"", ROOT.RooArgList(*uniforms_help)); obs_data = gauss.generate(ROOT.RooArgSet(*x_vars), n_samples_morph); obs_data.SetName(""obs_data""); ; # Create and return the workspace; ws = ROOT.RooWorkspace(); ws.Import(x_vars); ws.Import(mu_vars); ws.Import(gauss); ws.Import(uniform); ws.Import(uniform_help); ws.Import(obs_data); ; return ws; ; ; # Build the workspace and extract variables; ws = build_ws(mu_observed); ; ; # Export the varibles from ws; x_vars = [ws[f""x{i}""] for i in range(len(mu_observed))]; mu_vars = [ws[f""mu{i}""] for i in range(len(mu_observed))]; ; # Do the morphing; morphing(ROOT.RooMomentMorphFuncND.Linear, len(mu_observed)); ; # Calculate the nll for the moprhed distribution; # TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; nll_morph = ws[""morph""].createNLL(ws[""obs_data""], EvalBackend=""legacy""); ; # Initialize the SBI model; model = SBI(ws, len(mu_observed)); ; # Generate and preprocess training data; model.model_data(""gauss"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train); model.reference_data(; ""uniform"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train, ""uniform_help""; ); model.preprocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a ",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:8359,Modifiability,variab,variable,8359," # Calculate the nll for the moprhed distribution; # TODO: Fix RooAddPdf::fixCoefNormalization(nset) warnings with new CPU backend; nll_morph = ws[""morph""].createNLL(ws[""obs_data""], EvalBackend=""legacy""); ; # Initialize the SBI model; model = SBI(ws, len(mu_observed)); ; # Generate and preprocess training data; model.model_data(""gauss"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train); model.reference_data(; ""uniform"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train, ""uniform_help""; ); model.preprocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineCol",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:1068,Testability,log,log,1068,"t/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; # Create a product of G",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:8816,Testability,log,logarithmic,8816,"odel.reference_data(; ""uniform"", [x.GetName() for x in x_vars], [mu.GetName() for mu in mu_vars], n_samples_train, ""uniform_help""; ); model.preprocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:472,Usability,simpl,simple,472,". ROOT: tutorials/roofit/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; #",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:632,Usability,simpl,simple,632,". ROOT: tutorials/roofit/rf617_simulation_based_inference_multidimensional.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf617_simulation_based_inference_multidimensional.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Use Simulation Based Inference (SBI) in multiple dimensions in RooFit. ; This tutorial shows how to use SBI in higher dimension in ROOT. This tutorial transfers the simple concepts of the 1D case introduced in rf615_simulation_based_inference.py onto the higher dimensional case.; Again as reference distribution we choose a simple uniform distribution. The target distribution is chosen to be Gaussian with different mean values. The classifier is trained to discriminate between the reference and target distribution. We see how the neural networks generalize to unknown mean values.; Furthermore, we compare SBI to the approach of moment morphing. In this case, we can conclude, that SBI is way more sample eficcient when it comes to estimating the negative log likelihood ratio.; For an introductory background see rf615_simulation_based_inference.py. ; import ROOT; import numpy as np; from sklearn.neural_network import MLPClassifier; import itertools; ; # Kills warning messages; ROOT.RooMsgService.instance().setGlobalKillBelow(ROOT.RooFit.WARNING); ; n_samples_morph = 10000 # Number of samples for morphing; n_bins = 4 # Number of 'sampled' Gaussians; n_samples_train = n_samples_morph * n_bins # To have a fair comparison; ; ; # Morphing as baseline; def morphing(setting, n_dimensions):; # Define binning for morphing; ; binning = [ROOT.RooBinning(n_bins, 0.0, n_bins - 1.0) for dim in range(n_dimensions)]; grid = ROOT.RooMomentMorphFuncND.Grid(*binning); ; # Set bins for each x variable; for x_var in x_vars:; x_var.setBins(50); ; # Define mu values as input for morphing for each dimension; mu_helps = [ROOT.RooRealVar(f""mu{i}"", f""mu{i}"", 0.0) for i in range(n_dimensions)]; ; #",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:8912,Usability,learn,learned,8912,"rocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over;",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:8949,Usability,learn,learned,8949,"rocessing(); ; # Train the neural network classifier; model.train_classifier(); sbi_model = model; ; ; # Function to compute the likelihood ratio using the trained classifier; def learned_likelihood_ratio(*args):; n = max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over;",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:9127,Usability,learn,learned,9127,"= max(*(len(a) for a in args)); X = np.zeros((n, len(args))); for i in range(len(args)):; X[:, i] = args[i]; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1.0 - prob); ; ; # Create combined variable list for ROOT; combined_vars = ROOT.RooArgList(); for var in x_vars + mu_vars:; combined_vars.add(var); ; # Create a custom likelihood ratio function using the trained classifier; lhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, combined_vars); ; # Calculate the 'analytical' likelihood ratio; lhr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set)",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:9681,Usability,learn,learned,9681,"hr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().S",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:10892,Usability,learn,learned,10892,"or lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf617_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf617_plot_2.png""); ; ; # Use ROOT's minimizer to compute the minimum and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.m",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:10903,Usability,learn,learned,10903,"or lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf617_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf617_plot_2.png""); ; ; # Use ROOT's minimizer to compute the minimum and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.m",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:11410,Usability,learn,learned,11410,"+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf617_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf617_plot_2.png""); ; ; # Use ROOT's minimizer to compute the minimum and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5); minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); result.Print(); ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const ",MatchSource.WIKI,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:2701,Availability,mask,mask,2701,"ey are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category""] == [""zz""]]; ; ; # Prepare sample weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:2812,Availability,mask,mask,2812,"ey are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category""] == [""zz""]]; ; ; # Prepare sample weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:2907,Availability,mask,mask,2907,"torialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category""] == [""zz""]]; ; ; # Prepare sample weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can't handle them; sample_weight[sample_weight < 0] = 1e-6; ; # Prepare the features and labels; X = np.concatenate((higgs_data, zz_data), axis=0).reshape(-1, 1); y = np.concatenate([np.ones(len(higgs_data)), np.zeros(len(zz_data))]); ; # Train the Classifier to discriminate between higgs and zz; model_xgb = xgb.XGBClassifier(n_estimators=1000, max_depth=5, eta=0.2, min_child_weight=1e-6, nthread=1); model_xgb.fit(X, ",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:7054,Availability,error,error,7054,"mple_category""] == [""data""]]}, [m4l]); nll = pdf_learned_extended.createNLL(data, Extended=True); ; # Plot the nll computet by the mixture model; frame2 = mu_var.frame(Title=""NLL sum;#mu (signal strength);#Delta NLL"", Range=(0.5, 4)); nll.plotOn(frame2, ShiftToZero=True, LineColor=""kP6Blue""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf618_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; if not single_canvas:; c.SaveAs(""rf618_plot_2.png""); ; # Compute the minimum via minuit and display the results; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, True); result.Print(); ; del minimizer; del nll; del pdf_learned_extended; del n_pred; del llh; del nll_ratio; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:1586,Integrability,depend,dependence,1586,"amples from an background hypothesis here the zz samples and a target hypothesis, here the higgs samples. The data preparation is based on the tutorial 'df106_HiggsToFourLeptons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # L",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:8332,Integrability,interface,interface,8332,"gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf618_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; if not single_canvas:; c.SaveAs(""rf618_plot_2.png""); ; # Compute the minimum via minuit and display the results; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, True); result.Print(); ; del minimizer; del nll; del pdf_learned_extended; del n_pred; del llh; del nll_ratio; ; import sys; ; # Hack to bypass ClearProxiedObjects(); del sys.modules[""libROOTPythonizations""]; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; DateSeptember 2024 ; AuthorRobin Syring ; Definition in file rf618_mixture_models.py. tutorialsroofitrf618_mixture_models.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:2324,Safety,avoid,avoid,2324,"{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""] == sample_category; # Normalize each weight; weights = data_dict[""weight""][mask]; # Extract the weight_modified; weight_modified = weights / weight_sum; ; count = np.sum(mask); ; # Store the count and weight sum in the dictionary; results[sample_category] = {; ""weight_sum"": weight_sum,; ""weight_modified"": weight_modified,; ""count"": count,; ""weight"": weights,; }; ; ; # Extract the mass for higgs and zz; higgs_data = data_dict[""m4l""][data_dict[""sample_category""] == [""higgs""]]; zz_data = data_dict[""m4l""][data_dict[""sample_category",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:1673,Usability,simpl,simplify,1673,"tons.py'.; An introduction to mixture models can be found here https://arxiv.org/pdf/1506.02169.; A short summary: We assume the whole probability distribution can be written as a mixture of several components, i.e. $$p(x|\theta)= \sum_{c}w_{c}(\theta)p_{c}(x|\theta)$$ We can write the likelihood ratio in terms of pairwise classification problems \begin{align*} \frac{p(x|\mu)}{p(x|0)}&= \frac{\sum_{c}w_{c}(\mu)p_{c}(x|\mu)}{\sum_{c'}w_{c'}(0)p_{c'}(x|0)}\ &=\sum_{c}\Bigg[\sum_{c'}\frac{w_{c'}(0)}{w_{c}(\mu)}\frac{p_{c'}(x|0)}{p_{c}(x|\mu)}\Bigg]^{-1}, \end{align*} where mu is the signal strength, and a value of 0 corresponds to the background hypothesis. Using this decomposition, one is able to use the pairwise likelihood ratios.; Since the only free parameter in our case is mu, the distributions are independent of this parameter and the dependence on the signal strength can be encoded into the weights. Thus, the subratios simplify dramatically since they are independent of theta and these ratios can be pre-computed and the classifier does not need to be parametrized.; If you wish to see an analysis done with template histograms see 'hf001_example.py'.; ; import ROOT; import os; import numpy as np; import xgboost as xgb; ; # Get Dataframe from tutorial df106_HiggsToFourLeptons.py; # Adjust the path if running locally; df = ROOT.RDataFrame(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root""); ; # Initialize a dictionary to store counts and weight sums for each category; results = {}; ; ; # Extract the relevant columns once and avoid repeated calls; data_dict = df.AsNumpy(columns=[""m4l"", ""sample_category"", ""weight""]); ; ; weights_dict = {; name: data_dict[""weight""][data_dict[""sample_category""] == [name]].sum() for name in (""data"", ""zz"", ""other"", ""higgs""); }; ; # Loop over each sample category; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; ; weight_sum = weights_dict[sample_category]; ; mask = data_dict[""sample_category""]",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf618__mixture__models_8py.html:4314,Usability,learn,learned,4314,"ple weights; sample_weight_higgs = np.array([results[""higgs""][""weight_modified""]]).flatten(); sample_weight_zz = np.array([results[""zz""][""weight_modified""]]).flatten(); ; # Putting sample weights together in the same manner as the training data; sample_weight = np.concatenate([sample_weight_higgs, sample_weight_zz]); ; # For Training purposes we have to get rid of the negative weights, since xgb can't handle them; sample_weight[sample_weight < 0] = 1e-6; ; # Prepare the features and labels; X = np.concatenate((higgs_data, zz_data), axis=0).reshape(-1, 1); y = np.concatenate([np.ones(len(higgs_data)), np.zeros(len(zz_data))]); ; # Train the Classifier to discriminate between higgs and zz; model_xgb = xgb.XGBClassifier(n_estimators=1000, max_depth=5, eta=0.2, min_child_weight=1e-6, nthread=1); model_xgb.fit(X, y, sample_weight=sample_weight); ; ; # Building a RooRealVar based on the observed data; m4l = ROOT.RooRealVar(""m4l"", ""Four Lepton Invariant Mass"", 0.0); ; ; # Define functions to compute the learned likelihood.; def calculate_likelihood_xgb(m4l_arr: np.ndarray) -> np.ndarray:; prob = model_xgb.predict_proba(m4l_arr.T)[:, 0]; return (1 - prob) / prob; ; ; llh = ROOT.RooFit.bindFunction(f""llh"", calculate_likelihood_xgb, m4l); ; # Number of signals and background; n_signal = results[""higgs""][""weight""].sum(); n_back = results[""zz""][""weight""].sum(); ; ; # Define weight functions; def weight_back(mu):; return n_back / (n_back + mu * n_signal); ; ; def weight_signal(mu):; return 1 - weight_back(mu); ; ; # Define the likelihood ratio accordingly to mixture models; def likelihood_ratio(llr: np.ndarray, mu: np.ndarray) -> np.ndarray:; ; m = 2; ; w_0 = np.array([weight_back(0), weight_signal(0)]); w_1 = np.array([weight_back(mu[0]), weight_signal(mu[0])]); ; w = np.outer(w_1, 1.0 / w_0); ; p = np.ones((m, m, len(llr))); p[1, 0] = llr; for i in range(m):; for j in range(i):; p[j, i] = 1.0 / p[i, j]; ; return 1.0 / np.sum(1.0 / np.sum(np.expand_dims(w, axis=2) * p, axis=0), ",MatchSource.WIKI,doc/master/rf618__mixture__models_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf618__mixture__models_8py.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:7473,Availability,error,error,7473,"et &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::EfficiencyRooCmdArg Efficiency(const RooCategory &cat)Definition RooGlobalFunc.cxx:372; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf701_efficiencyfitDefinition rf701_efficiencyfit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf701_efficiencyfit.C. tutorialsroofitrf701_efficiencyfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:967,Modifiability,variab,variables,967,". ROOT: tutorials/roofit/rf701_efficiencyfit.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf701_efficiencyfit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function ; to a dataset D(x,cut), where cut is a category encoding a selection, of which the efficiency as function of x should be described by eff(x). ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooFormulaVar.h""; #include ""RooProdPdf.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooCategory.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf701_efficiencyfit(); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x ); // -------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar a(""a"", ""a"", 0.4, 0, 1);; RooRealVar b(""b"", ""b"", 5);; RooRealVar c(""c"", ""c"", -1, -10, 10);; RooFormulaVar effFunc(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", RooArgList(a, b, c, x));; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x ); // ------------------------------------------------------------------------------------------; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , c u t ) f r o m a t o y m o d e l; // -----------------------------------------------------------------------------; ; // Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); // (These are _only_ needed to generate some toy MC here ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:4304,Modifiability,parameteriz,parameterized,4304,");; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; ca->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooCategory.h; RooConstVar.h; RooDataSet.h; RooEfficiency.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooEfficiencyA PDF helper class to fit efficiencies parameterized by a supplied function F.Definition RooEfficiency.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::S",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:4755,Modifiability,variab,variable,4755,"aussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooEfficiencyA PDF helper class to fit efficiencies parameterized by a supplied function F.Definition RooEfficiency.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttPad::SetLeftMarginvirtual void SetLeftMargin(Float_t leftmargin)Set Pad left margin in fraction of the pad width.Definition TAttPad.cxx:109; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet curre",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:7567,Performance,optimiz,optimization,7567,"et &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::EfficiencyRooCmdArg Efficiency(const RooCategory &cat)Definition RooGlobalFunc.cxx:372; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf701_efficiencyfitDefinition rf701_efficiencyfit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf701_efficiencyfit.C. tutorialsroofitrf701_efficiencyfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8C.html:7664,Performance,optimiz,optimization,7664,"et &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; RooFit::EfficiencyRooCmdArg Efficiency(const RooCategory &cat)Definition RooGlobalFunc.cxx:372; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf701_efficiencyfitDefinition rf701_efficiencyfit.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf701_efficiencyfit.C. tutorialsroofitrf701_efficiencyfit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8C.html
https://root.cern/doc/master/rf701__efficiencyfit_8py.html:3325,Availability,error,error,3325,"------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; effPdf.fitTo(data, ConditionalObservables={x}, PrintLevel=-1); ; # Plot fitted, data efficiency; # --------------------------------------------------------; ; # Plot distribution of all events and accepted fraction of events on frame; frame1 = x.frame(Bins=20, Title=""Data (all, accepted)""); data.plotOn(frame1); data.plotOn(frame1, Cut=""cut==cut::accept"", MarkerColor=""r"", LineColor=""r""); ; # Plot accept/reject efficiency on data overlay fitted efficiency curve; frame2 = x.frame(Bins=20, Title=""Fitted efficiency""); data.plotOn(frame2, Efficiency=cut) # needs ROOT version >= 5.21; effFunc.plotOn(frame2, LineColor=""r""); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf701_efficiency"", ""rf701_efficiency"", 800, 400); ca.Divide(2); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; ca.SaveAs(""rf701_efficiencyfit.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf701_efficiencyfit.py. tutorialsroofitrf701_efficiencyfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
https://root.cern/doc/master/rf701__efficiencyfit_8py.html:600,Modifiability,variab,variables,600,". ROOT: tutorials/roofit/rf701_efficiencyfit.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf701_efficiencyfit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection, which the efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; # Construct efficiency function e(x); # -------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Efficiency function eff(x;a,b); a = ROOT.RooRealVar(""a"", ""a"", 0.4, 0, 1); b = ROOT.RooRealVar(""b"", ""b"", 5); c = ROOT.RooRealVar(""c"", ""c"", -1, -10, 10); effFunc = ROOT.RooFormulaVar(""effFunc"", ""(1-a)+a*cos((x-c)/b)"", [a, b, c, x]); ; # Construct conditional efficiency pdf E(cut|x); # ------------------------------------------------------------------------------------------; ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data (x, cut) from a toy model; # -----------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdf = ROOT.RooPolynomial(""shapePdf"", ""shapePdf"", x, [-0.095]); model = ROOT.RooProdPdf(""model"", ""model"", {shapePdf}, Conditional=({effPdf}, {cut})); ; # Generate some toy data from model; data = model.generate({x, cut}, 10000); ; # Fit conditional efficiency pdf to data; # --------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; ef",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
https://root.cern/doc/master/rf701__efficiencyfit_8py.html:3419,Performance,optimiz,optimization,3419,"------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; effPdf.fitTo(data, ConditionalObservables={x}, PrintLevel=-1); ; # Plot fitted, data efficiency; # --------------------------------------------------------; ; # Plot distribution of all events and accepted fraction of events on frame; frame1 = x.frame(Bins=20, Title=""Data (all, accepted)""); data.plotOn(frame1); data.plotOn(frame1, Cut=""cut==cut::accept"", MarkerColor=""r"", LineColor=""r""); ; # Plot accept/reject efficiency on data overlay fitted efficiency curve; frame2 = x.frame(Bins=20, Title=""Fitted efficiency""); data.plotOn(frame2, Efficiency=cut) # needs ROOT version >= 5.21; effFunc.plotOn(frame2, LineColor=""r""); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf701_efficiency"", ""rf701_efficiency"", 800, 400); ca.Divide(2); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; ca.SaveAs(""rf701_efficiencyfit.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf701_efficiencyfit.py. tutorialsroofitrf701_efficiencyfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
https://root.cern/doc/master/rf701__efficiencyfit_8py.html:3516,Performance,optimiz,optimization,3516,"------------------------------------------------------------------------; ; # Fit conditional efficiency pdf to data; effPdf.fitTo(data, ConditionalObservables={x}, PrintLevel=-1); ; # Plot fitted, data efficiency; # --------------------------------------------------------; ; # Plot distribution of all events and accepted fraction of events on frame; frame1 = x.frame(Bins=20, Title=""Data (all, accepted)""); data.plotOn(frame1); data.plotOn(frame1, Cut=""cut==cut::accept"", MarkerColor=""r"", LineColor=""r""); ; # Plot accept/reject efficiency on data overlay fitted efficiency curve; frame2 = x.frame(Bins=20, Title=""Fitted efficiency""); data.plotOn(frame2, Efficiency=cut) # needs ROOT version >= 5.21; effFunc.plotOn(frame2, LineColor=""r""); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf701_efficiency"", ""rf701_efficiency"", 800, 400); ca.Divide(2); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; ca.SaveAs(""rf701_efficiencyfit.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 8176 events out of 10000 total events; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf701_efficiencyfit.py. tutorialsroofitrf701_efficiencyfit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf701__efficiencyfit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf701__efficiencyfit_8py.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:8497,Availability,error,error,8497,"ditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.C. tutorialsroofitrf702_efficiencyfit_2D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:1004,Modifiability,variab,variables,1004,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf702_efficiencyfit_2D.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooCategory.h""; #include ""RooEfficiency.h""; #include ""RooPolynomial.h""; #include ""RooProdPdf.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf702_efficiencyfit_2D(bool flat = false); {; // C o n s t r u c t e f f i c i e n c y f u n c t i o n e ( x , y ); // -----------------------------------------------------------------------; ; // Declare variables x,mean,sigma with associated name, title, initial value and allowed range; RooRealVar x(""x"", ""x"", -10, 10);; RooRealVar y(""y"", ""y"", -10, 10);; ; // Efficiency function eff(x;a,b); RooRealVar ax(""ax"", ""ay"", 0.6, 0, 1);; RooRealVar bx(""bx"", ""by"", 5);; RooRealVar cx(""cx"", ""cy"", -1, -10, 10);; ; RooRealVar ay(""ay"", ""ay"", 0.2, 0, 1);; RooRealVar by(""by"", ""by"", 5);; RooRealVar cy(""cy"", ""cy"", -1, -10, 10);; ; RooFormulaVar effFunc(""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"",; RooArgList(ax, bx, cx, x, ay, by, cy, y));; ; // Acceptance state cut (1 or 0); RooCategory cut(""cut"", ""cutr"", { {""accept"", 1}, {""reject"", 0} });; ; // C o n s t r u c t c o n d i t i o n a l e f f i c i e n c y p d f E ( c u t | x , y ); // ---------------------------------------------------------------------------------------------; ; // Construct efficiency pdf eff(cut|x); RooEfficiency effPdf(""effPdf"", ""effPdf"", effFunc, cut, ""accept"");; ; // G e n e r a t e d a t a ( x , y , c u t",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:4934,Modifiability,parameteriz,parameterized,4934,";; hh_data_sel->GetZaxis()->SetTitleOffset(1.8);; hh_data_sel->Draw(""lego"");; ca->cd(3);; gPad->SetLeftMargin(0.15);; hh_eff->GetZaxis()->SetTitleOffset(1.8);; hh_eff->Draw(""surf"");; ; return;; }; RooCategory.h; RooConstVar.h; RooDataSet.h; RooEfficiency.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooPolynomial.h; RooProdPdf.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooEfficiencyA PDF helper class to fit efficiencies parameterized by a supplied function F.Definition RooEfficiency.h:24; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttPad::SetLeftMarginvirtual void SetLeftMargin(Float_t leftmargin)Set Pad left margin in fraction of the pad width.Definition TAttPad.cxx:109; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumb",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:7631,Performance,perform,performing,7631,"RooFit::ConditionalRooCmdArg Conditional(const RooArgSet &pdfSet, const RooArgSet &depSet, bool depsAreCond=false)Definition RooGlobalFunc.cxx:805; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::ConditionalObservablesRooCmdArg ConditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:8591,Performance,optimiz,optimization,8591,"ditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.C. tutorialsroofitrf702_efficiencyfit_2D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html:8688,Performance,optimiz,optimization,8688,"ditionalObservables(Args_t &&... argsOrArgSet)Create a RooCmdArg to declare conditional observables.Definition RooGlobalFunc.h:278; RooFit::BinningRooCmdArg Binning(const RooAbsBinning &binning)Definition RooGlobalFunc.cxx:328; RooFit::CutRooCmdArg Cut(const char *cutSpec)Definition RooGlobalFunc.cxx:320; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf702_efficiencyfit_2DDefinition rf702_efficiencyfit_2D.py:1; ; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.C. tutorialsroofitrf702_efficiencyfit_2D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8C.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:4562,Availability,error,error,4562,"tMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.py. tutorialsroofitrf702_efficiencyfit_2D.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:621,Modifiability,variab,variables,621,". ROOT: tutorials/roofit/rf702_efficiencyfit_2D.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf702_efficiencyfit_2D.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: unbinned maximum likelihood fit of an efficiency eff(x) function to a dataset D(x,cut), cut is a category encoding a selection whose efficiency as function of x should be described by eff(x) . ; import ROOT; ; ; flat = False; # Construct efficiency function e(x,y); # -----------------------------------------------------------------------; ; # Declare variables x,mean, with associated name, title, value and allowed; # range; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); y = ROOT.RooRealVar(""y"", ""y"", -10, 10); ; # Efficiency function eff(x;a,b); ax = ROOT.RooRealVar(""ax"", ""ay"", 0.6, 0, 1); bx = ROOT.RooRealVar(""bx"", ""by"", 5); cx = ROOT.RooRealVar(""cx"", ""cy"", -1, -10, 10); ; ay = ROOT.RooRealVar(""ay"", ""ay"", 0.2, 0, 1); by = ROOT.RooRealVar(""by"", ""by"", 5); cy = ROOT.RooRealVar(""cy"", ""cy"", -1, -10, 10); ; effFunc = ROOT.RooFormulaVar(; ""effFunc"", ""((1-ax)+ax*cos((x-cx)/bx))*((1-ay)+ay*cos((y-cy)/by))"", [ax, bx, cx, x, ay, by, cy, y]; ); ; # Acceptance state cut (1 or 0); cut = ROOT.RooCategory(""cut"", ""cutr"", {""accept"": 1, ""reject"": 0}); ; # Construct conditional efficiency pdf E(cut|x,y); # ---------------------------------------------------------------------------------------------; ; # Construct efficiency pdf eff(cut|x); effPdf = ROOT.RooEfficiency(""effPdf"", ""effPdf"", effFunc, cut, ""accept""); ; # Generate data(x,y,cut) from a toy model; # -------------------------------------------------------------------------------; ; # Construct global shape pdf shape(x) and product model(x,cut) = eff(cut|x)*shape(x); # (These are _only_ needed to generate some toy MC here to be used later); shapePdfX = ROOT.RooPolynomial(""shapePdfX"", ""shapePdfX"", x, [0 if flat else -0.095]); shapePdfY = ROOT.RooPolynomial(""shapePdfY"", ""shape",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:3696,Performance,perform,performing,3696," hh_data_all = data.createHistogram(""hh_data_all"", x, Binning=8, YVar=dict(var=y, Binning=8)); hh_data_sel = data.createHistogram(""hh_data_sel"", x, Binning=8, YVar=dict(var=y, Binning=8), Cut=""cut==cut::accept""); hh_eff = effFunc.createHistogram(""hh_eff"", x, Binning=50, YVar=dict(var=y, Binning=50)); ; # Some adjustsment for good visualization; hh_data_all.SetMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:4656,Performance,optimiz,optimization,4656,"tMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.py. tutorialsroofitrf702_efficiencyfit_2D.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html:4753,Performance,optimiz,optimization,4753,"tMinimum(0); hh_data_sel.SetMinimum(0); hh_eff.SetMinimum(0); hh_eff.SetLineColor(ROOT.kBlue); ; # Draw all frames on a canvas; ca = ROOT.TCanvas(""rf702_efficiency_2D"", ""rf702_efficiency_2D"", 1200, 400); ca.Divide(3); ca.cd(1); ROOT.gPad.SetLeftMargin(0.15); hh_data_all.GetZaxis().SetTitleOffset(1.8); hh_data_all.Draw(""lego""); ca.cd(2); ROOT.gPad.SetLeftMargin(0.15); hh_data_sel.GetZaxis().SetTitleOffset(1.8); hh_data_sel.Draw(""lego""); ca.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_eff.GetZaxis().SetTitleOffset(1.8); hh_eff.Draw(""surf""); ; ca.SaveAs(""rf702_efficiency_2D.png""); [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]) WARNING: performing accept/reject sampling on a p.d.f in 2 dimensions without prior knowledge on maximum value of p.d.f. Determining maximum value by taking 200000 trial samples. If p.d.f contains sharp peaks smaller than average distance between trial sampling points these may be missed and p.d.f. may be sampled incorrectly.; [#0] WARNING:Generation -- RooAcceptReject::ctor(effPdf_Int[]_Norm[cut]): WARNING: 200000 trial samples requested by p.d.f for 2-dimensional accept/reject sampling, this may take some time; [#1] INFO:Fitting -- RooAbsPdf::fitTo(effPdf_over_effPdf_Int[cut]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_effPdf_over_effPdf_Int[cut]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf702_efficiencyfit_2D.py. tutorialsroofitrf702_efficiencyfit_2D.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf702__efficiencyfit__2D_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf702__efficiencyfit__2D_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:1027,Availability,error,error,1027,". ROOT: tutorials/roofit/rf703_effpdfprod.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf703_effpdfprod.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooConstVar.h""; #include ""RooExponential.h""; #include ""RooEffProd.h""; #include ""RooFormulaVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf703_effpdfprod(); {; // D e f i n e o b s e r v a b l e s a n d d e c a y p d f; // ---------------------------------------------------------------; ; // Declare observables; RooRealVar t(""t"", ""t"", 0, 5);; ; // Make pdf; RooRealVar tau(""tau"", ""tau"", -1.54, -4, -0.1);; RooExponential model(""model"", ""model"", t, tau);; ; // D e f i n e e f f i c i e n c y f u n c t i o n; // ---------------------------------------------------; ; // Use error function to simulate turn-on slope; RooFormulaVar eff(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", t);; ; // D e f i n e d e c a y p d f w i t h e f f i c i e n c y; // ---------------------------------------------------------------; ; // Multiply pdf(t) with efficiency in t; RooEffProd modelEff(""modelEff"", ""model with efficiency"", model, eff);; ; // P l o t e f f i c i e n c y , p d f; // ----------------------------------------; ; RooPlot *frame1 = t.frame(Title(""Efficiency""));; eff.plotOn(frame1, LineColor(kRed));; ; RooPlot *frame2 = t.frame(Title(""Pdf with and without efficiency""));; ; model.plotOn(frame2, LineStyle(kDashed));; modelEff.plotOn(frame2);; ; // G e n e r a t e t o y d a t a , f i t m o d e l E f f t o d a t a; // ------------------------------------------------------------------------------; ; // Generate events. If the input pdf has an internal generator, the internal generator; // is used and an accept/reject sampling on the efficiency is",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5020,Availability,error,error,5020,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:4609,Deployability,integrat,integrator,4609,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5213,Deployability,integrat,integrator,5213,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5443,Deployability,integrat,integrator,5443,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:4609,Integrability,integrat,integrator,4609,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5213,Integrability,integrat,integrator,5213,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5443,Integrability,integrat,integrator,5443,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:3809,Modifiability,variab,variable,3809,"ine c(i)Definition RSha256.hxx:101; RooConstVar.h; RooDataSet.h; RooEffProd.h; RooExponential.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; gPad#define gPadDefinition TVirtualPad.h:308; RooEffProdThe class RooEffProd implements the product of a PDF with an efficiency function.Definition RooEffProd.h:19; RooExponentialExponential PDF.Definition RooExponential.h:22; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5114,Performance,optimiz,optimization,5114,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8C.html:5344,Performance,optimiz,optimization,5344,"e(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf703_effpdfprodDefinition rf703_effpdfprod.py:1; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf703_effpdfprod.C. tutorialsroofitrf703_effpdfprod.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8C.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:723,Availability,error,error,723,". ROOT: tutorials/roofit/rf703_effpdfprod.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf703_effpdfprod.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using a product of an (acceptance) efficiency and a pdf as pdf . ; import ROOT; ; ; # Define observables and decay pdf; # ---------------------------------------------------------------; ; # Declare observables; t = ROOT.RooRealVar(""t"", ""t"", 0, 5); ; # Make pdf; tau = ROOT.RooRealVar(""tau"", ""tau"", -1.54, -4, -0.1); model = ROOT.RooExponential(""model"", ""model"", t, tau); ; # Define efficiency function; # ---------------------------------------------------; ; # Use error function to simulate turn-on slope; eff = ROOT.RooFormulaVar(""eff"", ""0.5*(TMath::Erf((t-1)/0.5)+1)"", [t]); ; # Define decay pdf with efficiency; # ---------------------------------------------------------------; ; # Multiply pdf(t) with efficiency in t; modelEff = ROOT.RooEffProd(""modelEff"", ""model with efficiency"", model, eff); ; # Plot efficiency, pdf; # ----------------------------------------; ; frame1 = t.frame(Title=""Efficiency""); eff.plotOn(frame1, LineColor=""r""); ; frame2 = t.frame(Title=""Pdf with and without efficiency""); ; model.plotOn(frame2, LineStyle=""--""); modelEff.plotOn(frame2); ; # Generate toy data, fit model eff to data; # ------------------------------------------------------------------------------; ; # Generate events. If the input pdf has an internal generator, internal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); RO",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2804,Availability,error,error,2804,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2393,Deployability,integrat,integrator,2393,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2997,Deployability,integrat,integrator,2997,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:3227,Deployability,integrat,integrator,3227,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2393,Integrability,integrat,integrator,2393,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2997,Integrability,integrat,integrator,2997,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:3227,Integrability,integrat,integrator,3227,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:2898,Performance,optimiz,optimization,2898,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf703__effpdfprod_8py.html:3128,Performance,optimiz,optimization,3128,"nal generator; # is used and an accept/reject sampling on the efficiency is applied.; data = modelEff.generate({t}, 10000); ; # Fit pdf. The normalization integral is calculated numerically.; modelEff.fitTo(data, PrintLevel=-1); ; # Plot generated data and overlay fitted pdf; frame3 = t.frame(Title=""Fitted pdf with efficiency""); data.plotOn(frame3); modelEff.plotOn(frame3); ; c = ROOT.TCanvas(""rf703_effpdfprod"", ""rf703_effpdfprod"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf703_effpdfprod.png""); [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(modelEff_over_modelEff_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_modelEff_over_modelEff_Int[t]_modelEffData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(modelEff_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf703_effpdfprod.py. tutorialsroofitrf703_effpdfprod.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf703__effpdfprod_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf703__effpdfprod_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7544,Availability,error,error,7544,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:6743,Deployability,integrat,integrator,6743,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:6878,Deployability,integrat,integrator,6878,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7013,Deployability,integrat,integrator,7013,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7148,Deployability,integrat,integrator,7148,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7739,Deployability,integrat,integrator,7739,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7874,Deployability,integrat,integrator,7874,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8075,Deployability,integrat,integrates,8075,"tegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8196,Deployability,integrat,integrator,8196,"INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (co",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8331,Deployability,integrat,integrator,8331,"a; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8624,Deployability,integrat,integrates,8624,"ng const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasi",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8745,Deployability,integrat,integrator,8745,"RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8880,Deployability,integrat,integrator,8880,"RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9173,Deployability,integrat,integrates,9173,"t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF compo",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9294,Deployability,integrat,integrator,9294,"inhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9429,Deployability,integrat,integrator,9429,"elected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9536,Deployability,integrat,integrates,9536,"nents: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9654,Deployability,integrat,integrator,9654,"#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9789,Deployability,integrat,integrator,9789,"#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9924,Deployability,integrat,integrator,9924,"#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indire",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10059,Deployability,integrat,integrator,10059,"irectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10355,Deployability,integrat,integrates,10355,"ntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10473,Deployability,integrat,integrator,10473,"#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); Date",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10608,Deployability,integrat,integrator,10608,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10743,Deployability,integrat,integrator,10743,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11039,Deployability,integrat,integrates,11039,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11157,Deployability,integrat,integrator,11157,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11292,Deployability,integrat,integrator,11292,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11427,Deployability,integrat,integrator,11427,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:6743,Integrability,integrat,integrator,6743,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:6878,Integrability,integrat,integrator,6878,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7013,Integrability,integrat,integrator,7013,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7148,Integrability,integrat,integrator,7148,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7739,Integrability,integrat,integrator,7739,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7874,Integrability,integrat,integrator,7874,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8075,Integrability,integrat,integrates,8075,"tegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8196,Integrability,integrat,integrator,8196,"INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (co",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8331,Integrability,integrat,integrator,8331,"a; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8624,Integrability,integrat,integrates,8624,"ng const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasi",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8745,Integrability,integrat,integrator,8745,"RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8880,Integrability,integrat,integrator,8880,"RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9173,Integrability,integrat,integrates,9173,"t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF compo",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9294,Integrability,integrat,integrator,9294,"inhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9429,Integrability,integrat,integrator,9429,"elected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9536,Integrability,integrat,integrates,9536,"nents: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9654,Integrability,integrat,integrator,9654,"#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9789,Integrability,integrat,integrator,9789,"#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9924,Integrability,integrat,integrator,9924,"#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indire",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10059,Integrability,integrat,integrator,10059,"irectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10355,Integrability,integrat,integrates,10355,"ntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10473,Integrability,integrat,integrator,10473,"#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); Date",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10608,Integrability,integrat,integrator,10608,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10743,Integrability,integrat,integrator,10743,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11039,Integrability,integrat,integrates,11039,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11157,Integrability,integrat,integrator,11157,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11292,Integrability,integrat,integrator,11292,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11427,Integrability,integrat,integrator,11427,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:4677,Modifiability,variab,variable,4677,"sin->Draw(""surf"");; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFormulaVar.h; RooGaussian.h; RooPlot.h; RooPolyVar.h; RooProduct.h; RooRealSumPdf.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolyVarA RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients.Definition RooPolyVar.h:25; RooProductRepresents the product of a given set of RooAbsReal objects.Definition RooProduct.h:29; RooRealSumPdfImplements a PDF constructed from a sum of functions:Definition RooRealSumPdf.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definit",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8091,Modifiability,variab,variables,8091,"RealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components:",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8640,Modifiability,variab,variables,8640,"ation; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9189,Modifiability,variab,variables,9189,"c integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1);",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:9552,Modifiability,variab,variables,9552,"shGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:10371,Modifiability,variab,variables,10371,"oRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:11055,Modifiability,variab,variables,11055,"variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:7638,Performance,optimiz,optimization,7638,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8C.html:8005,Performance,optimiz,optimization,8005,"c integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl",MatchSource.WIKI,doc/master/rf704__amplitudefit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4122,Availability,error,error,4122,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3321,Deployability,integrat,integrator,3321,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3456,Deployability,integrat,integrator,3456,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3591,Deployability,integrat,integrator,3591,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3726,Deployability,integrat,integrator,3726,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4317,Deployability,integrat,integrator,4317,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4452,Deployability,integrat,integrator,4452,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4653,Deployability,integrat,integrates,4653,"tegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4774,Deployability,integrat,integrator,4774,"INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (co",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4909,Deployability,integrat,integrator,4909,"a; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5202,Deployability,integrat,integrates,5202,"ng const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasi",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5323,Deployability,integrat,integrator,5323,"RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5458,Deployability,integrat,integrator,5458,"RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5751,Deployability,integrat,integrates,5751,"t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF compo",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5872,Deployability,integrat,integrator,5872,"inhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6007,Deployability,integrat,integrator,6007,"elected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6114,Deployability,integrat,integrates,6114,"nents: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6232,Deployability,integrat,integrator,6232,"#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6367,Deployability,integrat,integrator,6367,"#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6502,Deployability,integrat,integrator,6502,"#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indire",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6637,Deployability,integrat,integrator,6637,"irectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6933,Deployability,integrat,integrates,6933,"ntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7051,Deployability,integrat,integrator,7051,"#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); Date",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7186,Deployability,integrat,integrator,7186,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7321,Deployability,integrat,integrator,7321,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7617,Deployability,integrat,integrates,7617,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7735,Deployability,integrat,integrator,7735,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7870,Deployability,integrat,integrator,7870,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:8005,Deployability,integrat,integrator,8005,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3321,Integrability,integrat,integrator,3321,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3456,Integrability,integrat,integrator,3456,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3591,Integrability,integrat,integrator,3591,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:3726,Integrability,integrat,integrator,3726,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4317,Integrability,integrat,integrator,4317,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4452,Integrability,integrat,integrator,4452,"ntegrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4653,Integrability,integrat,integrates,4653,"tegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4774,Integrability,integrat,integrator,4774,"INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (co",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4909,Integrability,integrat,integrator,4909,"a; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5202,Integrability,integrat,integrates,5202,"ng const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasi",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5323,Integrability,integrat,integrator,5323,"RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5458,Integrability,integrat,integrator,5458,"RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5751,Integrability,integrat,integrates,5751,"t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF compo",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5872,Integrability,integrat,integrator,5872,"inhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6007,Integrability,integrat,integrator,6007,"elected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6114,Integrability,integrat,integrates,6114,"nents: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6232,Integrability,integrat,integrator,6232,"#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6367,Integrability,integrat,integrator,6367,"#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1]",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6502,Integrability,integrat,integrator,6502,"#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indire",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6637,Integrability,integrat,integrator,6637,"irectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables ",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6933,Integrability,integrat,integrates,6933,"ntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericInte",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7051,Integrability,integrat,integrator,7051,"#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); Date",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7186,Integrability,integrat,integrator,7186,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7321,Integrability,integrat,integrator,7321,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7617,Integrability,integrat,integrates,7617,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7735,Integrability,integrat,integrator,7735,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7870,Integrability,integrat,integrator,7870,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:8005,Integrability,integrat,integrator,8005,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4669,Modifiability,variab,variables,4669,"RealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components:",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5218,Modifiability,variab,variables,5218,"ation; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:5767,Modifiability,variab,variables,5767,"c integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1);",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6130,Modifiability,variab,variables,6130,"shGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:6949,Modifiability,variab,variables,6949,"oRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooR",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:7633,Modifiability,variab,variables,7633,"tegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly2,sinhGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on cosa integrates over variables (t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf704_amplitudefit.",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4216,Performance,optimiz,optimization,4216,,MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf704__amplitudefit_8py.html:4583,Performance,optimiz,optimization,4583,"c integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl",MatchSource.WIKI,doc/master/rf704__amplitudefit_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8py.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8790,Availability,error,error,8790,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8980,Availability,error,error,8980,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8995,Availability,avail,available,8995,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8947,Integrability,synchroniz,synchronize,8947,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:1112,Modifiability,variab,variable,1112,"; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf705_linearmorph.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: linear interpolation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; a",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:1229,Modifiability,variab,variable,1229,"als. Detailed Description; Special pdf's: linear interpolation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.set",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:4916,Modifiability,variab,variable,4916,"2->Draw();; ; return;; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooIntegralMorph.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooIntegralMorphClass RooIntegralMorph is an implementation of the histogram interpolation technique described by Ale...Definition RooIntegralMorph.h:26; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:1256,Performance,cache,cache,1256,"olation between pdf shapes using the 'Alex Read' algorithm . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooIntegralMorph.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:1285,Performance,cache,cache,1285,"as.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; // S h o w 2 D d i s t r i b u t i o n o f p d f ( x , a l p h a ); // -----------------------------------------------------------------------; ; // Create 2D histogram; TH1 *hh = lmorph.createHistogram(""hh"", x, B",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:6414,Performance,cache,cache,6414,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:6570,Performance,cache,cache,6570,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:6726,Performance,cache,cache,6726,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:6882,Performance,cache,cache,6882,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7038,Performance,cache,cache,7038,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7194,Performance,cache,cache,7194,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7350,Performance,cache,cache,7350,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7506,Performance,cache,cache,7506,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7662,Performance,cache,cache,7662,"ouble pdf, double weight, int binnedL, int doBinOffset)Definition MathFuncs.h:353; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf705_linearmorphDefinition rf705_linearmorph.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORP",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:7856,Performance,cache,cache,7856,") with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchron",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8012,Performance,cache,cache,8012,") with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchron",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8216,Performance,cache,cache,8216,"lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8343,Performance,cache,cache,8343,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:8884,Performance,optimiz,optimization,8884,") creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b6e4c0d10 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; p",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:9095,Performance,cache,cache,9095,"g content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b7034bfe0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a7b1a0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN = 9770.908995 alpha=0.8, ; prevFCN = 9770.671799 alpha=0.8, ; prevFCN = 9770.909805 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.910615 alpha=0.8, ; prevFCN = 9770.91254 alpha=0.8, ; prevFCN = 9770.912239 alpha=0.8, ; prevFCN = 9770.669355 alpha=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.6",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:10983,Performance,optimiz,optimization,10983,"a=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a5f5d0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf705_linearmorph.C. tutorialsroofitrf705_linearmorph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:11065,Performance,cache,cache,11065,"a=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a5f5d0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf705_linearmorph.C. tutorialsroofitrf705_linearmorph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:11253,Performance,cache,cache,11253,"a=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a5f5d0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf705_linearmorph.C. tutorialsroofitrf705_linearmorph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:11585,Performance,cache,cache,11585,"a=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71f2aa10 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x557b71a5f5d0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf705_linearmorph.C. tutorialsroofitrf705_linearmorph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8C.html:3125,Testability,log,log,3125,"setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; // S h o w 2 D d i s t r i b u t i o n o f p d f ( x , a l p h a ); // -----------------------------------------------------------------------; ; // Create 2D histogram; TH1 *hh = lmorph.createHistogram(""hh"", x, Binning(40), YVar(alpha, Binning(40)));; hh->SetLineColor(kBlue);; ; // F i t p d f t o d a t a s e t w i t h a l p h a = 0 . 8; // -----------------------------------------------------------------; ; // Generate a toy dataset at alpha = 0.8; alpha = 0.8;; std::unique_ptr<RooDataSet> data{lmorph.generate(x, 1000)};; ; // Fit pdf to toy data; lmorph.setCacheAlpha(true);; lmorph.fitTo(*data, Verbose(true), PrintLevel(-1));; ; // Plot fitted pdf and data overlaid; RooPlot *frame2 = x.frame(Bins(100));; data->plotOn(frame2);; lmorph.plotOn(frame2);; ; // S c a n - l o g ( L ) v s a l p h a; // -----------------------------------------; ; // Show scan -log(L) of dataset w.r.t alpha; RooPlot *frame3 = alpha.frame(Bins(100), Range(0.1, 0.9));; ; // Make 2D pdf of histogram; std::unique_ptr<RooAbsReal> nll{lmorph.createNLL(*data)};; nll->plotOn(frame3, ShiftToZero());; ; lmorph.setCacheAlpha(false);; ; TCanvas *c = new TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.6);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; c->cd(3);; gPad->SetLeftMargin(0.15);; frame3->GetYaxis()->SetTitleOffset(1.4);; frame3->Draw();; c->cd(4);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.4);; frame2->Draw();; ; return;; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooIntegralMorph.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h",MatchSource.WIKI,doc/master/rf705__linearmorph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5809,Availability,error,error,5809,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5999,Availability,error,error,5999,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:6014,Availability,avail,available,6014,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5966,Integrability,synchroniz,synchronize,5966,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:873,Modifiability,variab,variable,873,". ROOT: tutorials/roofit/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:995,Modifiability,variab,variable,995,". ROOT: tutorials/roofit/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:1022,Performance,cache,cache,1022,"it/rf705_linearmorph.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -------------------",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:1050,Performance,cache,cache,1050,"  . Loading...; Searching...; No Matches. Namespaces ; rf705_linearmorph.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'SPECIAL PDFS' RooFit tutorial macro #705 ; Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm. ; ; import ROOT; ; ; # Create end point pdf shapes; # ------------------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Lower end point shape: a Gaussian; g1mean = ROOT.RooRealVar(""g1mean"", ""g1mean"", -10); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, g1mean, 2.0); ; # Upper end point shape: a Polynomial; g2 = ROOT.RooPolynomial(""g2"", ""g2"", x, [-0.03, -0.001]); ; # Create interpolating pdf; # -----------------------------------------------; ; # Create interpolation variable; alpha = ROOT.RooRealVar(""alpha"", ""alpha"", 0, 1.0); ; # Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache""); alpha.setBins(50, ""cache""); ; # Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; # and g2(x) at a=a_max; lmorph = ROOT.RooIntegralMorph(""lmorph"", ""lmorph"", g1, g2, x, alpha); ; # Plot interpolating pdf aat various alphas a l p h a; # -----------------------------------------------------------------------------; ; # Show end points as blue curves; frame1 = x.frame(); g1.plotOn(frame1); g2.plotOn(frame1); ; # Show interpolated shapes in red; alpha.setVal(0.125); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.25); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.375); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -----------------------------------------------------------------------; ; # Create 2D histogram; h",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:3493,Performance,cache,cache,3493,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:3644,Performance,cache,cache,3644,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:3795,Performance,cache,cache,3795,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:3946,Performance,cache,cache,3946,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4097,Performance,cache,cache,4097,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4248,Performance,cache,cache,4248,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4399,Performance,cache,cache,4399,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4550,Performance,cache,cache,4550,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4701,Performance,cache,cache,4701,"OT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with cod",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:4890,Performance,cache,cache,4890,"ACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNI",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5041,Performance,cache,cache,5041,"ACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNI",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5240,Performance,cache,cache,5240," -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 fro",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5367,Performance,cache,cache,5367,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:5903,Performance,optimiz,optimization,5903,"::getCache(lmorph) creating new cache 0x8c083e0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x_alpha for nset (x,alpha) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x91bacc0 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x90b1580 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0 from preexisting content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:6114,Performance,cache,cache,6114,"existing content.; [#0] PROGRESS:Eval -- RooIntegralMorph::fillCacheObject(lmorph) filling multi-dimensional cache..................................................; ; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937f4b0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lmorph_over_lmorph_Int[x]_lmorphData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for alpha: using 0.1; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x937e260 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; ; prevFCN = 9770.913047 alpha=0.807, ; prevFCN = 9770.181345 alpha=0.7929, ; prevFCN = 9772.015076 alpha=0.8008, ; prevFCN = 9770.800603 alpha=0.7992, ; prevFCN = 9770.785966 alpha=0.8001, ; prevFCN = 9770.896896 alpha=0.7999, ; prevFCN = 9770.682007 ; prevFCN = 9770.682007 alpha=0.7994, ; prevFCN = 9770.748743 alpha=0.7997, ; prevFCN = 9770.712263 alpha=0.8004, ; prevFCN = 9770.849353 alpha=0.8002, ; prevFCN = 9770.888877 alpha=0.8, ; prevFCN = 9770.908995 alpha=0.8, ; prevFCN = 9770.671799 alpha=0.8, ; prevFCN = 9770.909805 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.910615 alpha=0.8, ; prevFCN = 9770.91254 alpha=0.8, ; prevFCN = 9770.912239 alpha=0.8, ; prevFCN = 9770.669355 alpha=0.8, ; prevFCN = 9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:7997,Performance,optimiz,optimization,7997,"9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x2744ab0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x95fa7c0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x9805940 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf705_linearmorph.py. tutorialsroofitrf705_linearmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:8079,Performance,cache,cache,8079,"9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x2744ab0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x95fa7c0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x9805940 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf705_linearmorph.py. tutorialsroofitrf705_linearmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:8262,Performance,cache,cache,8262,"9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x2744ab0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x95fa7c0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x9805940 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf705_linearmorph.py. tutorialsroofitrf705_linearmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:8589,Performance,cache,cache,8589,"9770.666818 alpha=0.8, ; prevFCN = 9770.66743 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.668617 alpha=0.8, ; prevFCN = 9770.667852 alpha=0.8, ; prevFCN = 9770.667479 alpha=0.8, ; prevFCN = 9770.667297 alpha=0.8, ; prevFCN = 9770.667208 alpha=0.8, ; prevFCN = 9770.667165 alpha=0.8, ; prevFCN = 9770.667144 alpha=0.8, ; prevFCN = 9770.667134 alpha=0.8, ; prevFCN = 9770.667129 alpha=0.8, ; prevFCN = 9770.667126 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.91141 alpha=0.8, ; prevFCN = 9770.670187 alpha=0.8, ; prevFCN = 9770.666827 alpha=0.8, ; prevFCN = 9770.667421 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.667124 alpha=0.8, ; prevFCN = 9770.667064 alpha=0.8, ; prevFCN = 9770.667183 alpha=0.8, ; prevFCN = 9770.66653 alpha=0.8, ; prevFCN = 9770.667718 alpha=0.8, ; prevFCN = 9770.667005 alpha=0.8, ; prevFCN = 9770.667243 alpha=0.8, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x2744ab0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x95fa7c0 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x]_NORM_x for nset (x) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lmorph_over_lmorph_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x9805940 with pdf g1_MORPH_g2_CACHE_Obs[alpha,x] for nset () with code 1 from preexisting content.; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf705_linearmorph.py. tutorialsroofitrf705_linearmorph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:2639,Testability,log,log,2639,"etVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -----------------------------------------------------------------------; ; # Create 2D histogram; hh = lmorph.createHistogram(""hh"", x, Binning=40, YVar=dict(var=alpha, Binning=40)); hh.SetLineColor(ROOT.kBlue); ; # Fit pdf to dataset with alpha=0.8; # -----------------------------------------------------------------; ; # Generate a toy dataset alpha = 0.8; alpha.setVal(0.8); data = lmorph.generate({x}, 1000); ; # Fit pdf to toy data; lmorph.setCacheAlpha(True); lmorph.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot fitted pdf and data overlaid; frame2 = x.frame(Bins=100); data.plotOn(frame2); lmorph.plotOn(frame2); ; # Scan -log(L) vs alpha; # -----------------------------------------; ; # Show scan -log(L) of dataset w.r.t alpha; frame3 = alpha.frame(Bins=100, Range=(0.1, 0.9)); ; # Make 2D pdf of histogram; nll = lmorph.createNLL(data); nll.plotOn(frame3, ShiftToZero=True); ; lmorph.setCacheAlpha(False); ; c = ROOT.TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MOR",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf705__linearmorph_8py.html:2716,Testability,log,log,2716,"etVal(0.50); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.625); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.75); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.875); lmorph.plotOn(frame1, LineColor=""r""); alpha.setVal(0.95); lmorph.plotOn(frame1, LineColor=""r""); ; # Show 2D distribution of pdf(x,alpha); # -----------------------------------------------------------------------; ; # Create 2D histogram; hh = lmorph.createHistogram(""hh"", x, Binning=40, YVar=dict(var=alpha, Binning=40)); hh.SetLineColor(ROOT.kBlue); ; # Fit pdf to dataset with alpha=0.8; # -----------------------------------------------------------------; ; # Generate a toy dataset alpha = 0.8; alpha.setVal(0.8); data = lmorph.generate({x}, 1000); ; # Fit pdf to toy data; lmorph.setCacheAlpha(True); lmorph.fitTo(data, Verbose=True, PrintLevel=-1); ; # Plot fitted pdf and data overlaid; frame2 = x.frame(Bins=100); data.plotOn(frame2); lmorph.plotOn(frame2); ; # Scan -log(L) vs alpha; # -----------------------------------------; ; # Show scan -log(L) of dataset w.r.t alpha; frame3 = alpha.frame(Bins=100, Range=(0.1, 0.9)); ; # Make 2D pdf of histogram; nll = lmorph.createNLL(data); nll.plotOn(frame3, ShiftToZero=True); ; lmorph.setCacheAlpha(False); ; c = ROOT.TCanvas(""rf705_linearmorph"", ""rf705_linearmorph"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetTitleOffset(2.5); hh.Draw(""surf""); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.4); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf705_linearmorph.png""); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MORPH_g2_CACHE_Obs[x]_NORM_x for nset (x) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lmorph) creating new cache 0x8bddf40 with pdf g1_MOR",MatchSource.WIKI,doc/master/rf705__linearmorph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8py.html
https://root.cern/doc/master/rf706__histpdf_8C.html:3003,Modifiability,variab,variable,3003,"plotOn(frame2);; histpdf2.plotOn(frame2);; ; TCanvas *c = new TCanvas(""rf706_histpdf"", ""rf706_histpdf"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame1->GetYaxis()->SetTitleOffset(1.4);; frame1->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; }; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooGaussian.h; RooHistPdf.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; TAxis.h; TCanvas.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooHistPdfA propability density function sampled from a multidimensional histogram.Definition RooHistPdf.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::BinsRooCmdArg Bins(Int_t nbin)Definition RooGlobalFunc.cxx:547; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf706_histpdfDefinition rf706_histpdf.py:1; xmlio::Titleconst c",MatchSource.WIKI,doc/master/rf706__histpdf_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf706__histpdf_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1158,Deployability,configurat,configuration,1158,".h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooAr",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1118,Energy Efficiency,adapt,adaptive,1118,"le Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf707_kernelestimation.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooKeysPdf.h""; #include ""RooNDKeysPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel esti",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1392,Energy Efficiency,adapt,adaptive,1392,".h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooAr",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:2786,Energy Efficiency,adapt,adaptive,2786,"tOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooArgList(0.01, 0.01, -0.0004));; RooProdPdf pxy(""pxy"", ""pxy"", RooArgSet(p, py));; std::unique_ptr<RooDataSet> data2{pxy.generate({x, y}, 1000)};; ; // C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create 2D adaptive kernel estimation pdf with mirroring; RooNDKeysPdf kest4(""kest4"", ""kest4"", RooArgSet(x, y), *data2, ""am"");; ; // Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth; RooNDKeysPdf kest5(""kest5"", ""kest5"", RooArgSet(x, y), *data2, ""am"", 2);; ; // Create a histogram of the data; TH1 *hh_data = data2->createHistogram(""hh_data"", x, Binning(10), YVar(y, Binning(10)));; ; // Create histogram of the 2d kernel estimation pdfs; TH1 *hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning(25), YVar(y, Binning(25)));; TH1 *hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning(25), YVar(y, Binning(25)));; hh_pdf->SetLineColor(kBlue);; hh_pdf2->SetLineColor(kMagenta);; ; TCanvas *c = new TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; hh_data->GetZaxis()->SetTitleOffset(1.4);; hh_data->Draw(""lego"");; c->cd(4);; gPad->SetLeftMargin(0.20);; hh_pdf->Get",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:2918,Energy Efficiency,adapt,adaptive,2918,"tOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooArgList(0.01, 0.01, -0.0004));; RooProdPdf pxy(""pxy"", ""pxy"", RooArgSet(p, py));; std::unique_ptr<RooDataSet> data2{pxy.generate({x, y}, 1000)};; ; // C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create 2D adaptive kernel estimation pdf with mirroring; RooNDKeysPdf kest4(""kest4"", ""kest4"", RooArgSet(x, y), *data2, ""am"");; ; // Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth; RooNDKeysPdf kest5(""kest5"", ""kest5"", RooArgSet(x, y), *data2, ""am"", 2);; ; // Create a histogram of the data; TH1 *hh_data = data2->createHistogram(""hh_data"", x, Binning(10), YVar(y, Binning(10)));; ; // Create histogram of the 2d kernel estimation pdfs; TH1 *hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning(25), YVar(y, Binning(25)));; TH1 *hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning(25), YVar(y, Binning(25)));; hh_pdf->SetLineColor(kBlue);; hh_pdf2->SetLineColor(kMagenta);; ; TCanvas *c = new TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; hh_data->GetZaxis()->SetTitleOffset(1.4);; hh_data->Draw(""lego"");; c->cd(4);; gPad->SetLeftMargin(0.20);; hh_pdf->Get",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1118,Modifiability,adapt,adaptive,1118,"le Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf707_kernelestimation.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooGaussian.h""; #include ""RooPolynomial.h""; #include ""RooKeysPdf.h""; #include ""RooNDKeysPdf.h""; #include ""RooProdPdf.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel esti",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1158,Modifiability,config,configuration,1158,".h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooAr",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:1392,Modifiability,adapt,adaptive,1392,".h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""TH1.h""; #include ""RooPlot.h""; using namespace RooFit;; ; void rf707_kernelestimation(); {; // C r e a t e l o w s t a t s 1 - D d a t a s e t; // -------------------------------------------------------; ; // Create a toy pdf for sampling; RooRealVar x(""x"", ""x"", 0, 20);; RooPolynomial p(""p"", ""p"", x, RooArgList(0.01, -0.01, 0.0004));; ; // Sample 500 events from p; std::unique_ptr<RooDataSet> data1{p.generate(x, 200)};; ; // C r e a t e 1 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create adaptive kernel estimation pdf. In this configuration the input data; // is mirrored over the boundaries to minimize edge effects in distribution; // that do not fall to zero towards the edges; RooKeysPdf kest1(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth);; ; // An adaptive kernel estimation pdf on the same data without mirroring option; // for comparison; RooKeysPdf kest2(""kest2"", ""kest2"", x, *data1, RooKeysPdf::NoMirror);; ; // Adaptive kernel estimation pdf with increased bandwidth scale factor; // (promotes smoothness over detail preservation); RooKeysPdf kest3(""kest1"", ""kest1"", x, *data1, RooKeysPdf::MirrorBoth, 2);; ; // Plot kernel estimation pdfs with and without mirroring over data; RooPlot *frame = x.frame(Title(""Adaptive kernel estimation pdf with and w/o mirroring""), Bins(20));; data1->plotOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooAr",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:2786,Modifiability,adapt,adaptive,2786,"tOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooArgList(0.01, 0.01, -0.0004));; RooProdPdf pxy(""pxy"", ""pxy"", RooArgSet(p, py));; std::unique_ptr<RooDataSet> data2{pxy.generate({x, y}, 1000)};; ; // C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create 2D adaptive kernel estimation pdf with mirroring; RooNDKeysPdf kest4(""kest4"", ""kest4"", RooArgSet(x, y), *data2, ""am"");; ; // Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth; RooNDKeysPdf kest5(""kest5"", ""kest5"", RooArgSet(x, y), *data2, ""am"", 2);; ; // Create a histogram of the data; TH1 *hh_data = data2->createHistogram(""hh_data"", x, Binning(10), YVar(y, Binning(10)));; ; // Create histogram of the 2d kernel estimation pdfs; TH1 *hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning(25), YVar(y, Binning(25)));; TH1 *hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning(25), YVar(y, Binning(25)));; hh_pdf->SetLineColor(kBlue);; hh_pdf2->SetLineColor(kMagenta);; ; TCanvas *c = new TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; hh_data->GetZaxis()->SetTitleOffset(1.4);; hh_data->Draw(""lego"");; c->cd(4);; gPad->SetLeftMargin(0.20);; hh_pdf->Get",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:2918,Modifiability,adapt,adaptive,2918,"tOn(frame);; kest1.plotOn(frame);; kest2.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Plot kernel estimation pdfs with regular and increased bandwidth; RooPlot *frame2 = x.frame(Title(""Adaptive kernel estimation pdf with regular, increased bandwidth""));; kest1.plotOn(frame2);; kest3.plotOn(frame2, LineColor(kMagenta));; ; // C r e a t e l o w s t a t s 2 - D d a t a s e t; // -------------------------------------------------------; ; // Construct a 2D toy pdf for sampling; RooRealVar y(""y"", ""y"", 0, 20);; RooPolynomial py(""py"", ""py"", y, RooArgList(0.01, 0.01, -0.0004));; RooProdPdf pxy(""pxy"", ""pxy"", RooArgSet(p, py));; std::unique_ptr<RooDataSet> data2{pxy.generate({x, y}, 1000)};; ; // C r e a t e 2 - D k e r n e l e s t i m a t i o n p d f; // ---------------------------------------------------------------; ; // Create 2D adaptive kernel estimation pdf with mirroring; RooNDKeysPdf kest4(""kest4"", ""kest4"", RooArgSet(x, y), *data2, ""am"");; ; // Create 2D adaptive kernel estimation pdf with mirroring and double bandwidth; RooNDKeysPdf kest5(""kest5"", ""kest5"", RooArgSet(x, y), *data2, ""am"", 2);; ; // Create a histogram of the data; TH1 *hh_data = data2->createHistogram(""hh_data"", x, Binning(10), YVar(y, Binning(10)));; ; // Create histogram of the 2d kernel estimation pdfs; TH1 *hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning(25), YVar(y, Binning(25)));; TH1 *hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning(25), YVar(y, Binning(25)));; hh_pdf->SetLineColor(kBlue);; hh_pdf2->SetLineColor(kMagenta);; ; TCanvas *c = new TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800);; c->Divide(2, 2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.15);; frame2->GetYaxis()->SetTitleOffset(1.8);; frame2->Draw();; c->cd(3);; gPad->SetLeftMargin(0.15);; hh_data->GetZaxis()->SetTitleOffset(1.4);; hh_data->Draw(""lego"");; c->cd(4);; gPad->SetLeftMargin(0.20);; hh_pdf->Get",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8C.html:5316,Modifiability,variab,variable,5316,"6; kBlue@ kBlueDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooKeysPdfClass RooKeysPdf implements a one-dimensional kernel estimation p.d.f which model the distribution of...Definition RooKeysPdf.h:24; RooKeysPdf::NoMirror@ NoMirrorDefinition RooKeysPdf.h:26; RooKeysPdf::MirrorBoth@ MirrorBothDefinition RooKeysPdf.h:26; RooNDKeysPdfGeneric N-dimensional implementation of a kernel estimation p.d.f.Definition RooNDKeysPdf.h:44; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooProdPdfEfficient implementation of a product of PDFs of the form.Definition RooProdPdf.h:33; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetZaxisTAxis * GetZ",MatchSource.WIKI,doc/master/rf707__kernelestimation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8C.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:791,Deployability,configurat,configuration,791,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:751,Energy Efficiency,adapt,adaptive,751,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:1031,Energy Efficiency,adapt,adaptive,1031,"  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; """,MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:2318,Energy Efficiency,adapt,adaptive,2318," (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:2445,Energy Efficiency,adapt,adaptive,2445,"thout mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""lego""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_pdf.GetZaxis()",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:751,Modifiability,adapt,adaptive,751,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:791,Modifiability,config,configuration,791,". ROOT: tutorials/roofit/rf707_kernelestimation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sam",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:1031,Modifiability,adapt,adaptive,1031,"  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf707_kernelestimation.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Special pdf's: using non-parametric (multi-dimensional) kernel estimation pdfs . ; import ROOT; ; ; # Create low stats 1D dataset; # -------------------------------------------------------; ; # Create a toy pdf for sampling; x = ROOT.RooRealVar(""x"", ""x"", 0, 20); p = ROOT.RooPolynomial(""p"", ""p"", x, [0.01, -0.01, 0.0004]); ; # Sample 500 events from p; data1 = p.generate({x}, 200); ; # Create 1D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create adaptive kernel estimation pdf. In self configuration the input data; # is mirrored over the boundaries to minimize edge effects in distribution; # that do not fall to zero towards the edges; kest1 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth); ; # An adaptive kernel estimation pdf on the same data without mirroring option; # for comparison; kest2 = ROOT.RooKeysPdf(""kest2"", ""kest2"", x, data1, ROOT.RooKeysPdf.NoMirror); ; # Adaptive kernel estimation pdf with increased bandwidth scale factor; # (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; """,MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:2318,Modifiability,adapt,adaptive,2318," (promotes smoothness over detail preservation); kest3 = ROOT.RooKeysPdf(""kest1"", ""kest1"", x, data1, ROOT.RooKeysPdf.MirrorBoth, 2); ; # Plot kernel estimation pdfs with and without mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf707__kernelestimation_8py.html:2445,Modifiability,adapt,adaptive,2445,"thout mirroring over data; frame = x.frame(Title=""Adaptive kernel estimation pdf with and w/o mirroring"", Bins=20); data1.plotOn(frame); kest1.plotOn(frame); kest2.plotOn(frame, LineStyle=""--"", LineColor=""r""); ; # Plot kernel estimation pdfs with regular and increased bandwidth; frame2 = x.frame(Title=""Adaptive kernel estimation pdf with regular, bandwidth""); kest1.plotOn(frame2); kest3.plotOn(frame2, LineColor=""m""); ; # Create low status 2D dataset; # -------------------------------------------------------; ; # Construct a 2D toy pdf for sampleing; y = ROOT.RooRealVar(""y"", ""y"", 0, 20); py = ROOT.RooPolynomial(; ""py"",; ""py"",; y,; [0.01, 0.01, -0.0004],; ); pxy = ROOT.RooProdPdf(""pxy"", ""pxy"", [p, py]); data2 = pxy.generate({x, y}, 1000); ; # Create 2D kernel estimation pdf; # ---------------------------------------------------------------; ; # Create 2D adaptive kernel estimation pdf with mirroring; kest4 = ROOT.RooNDKeysPdf(""kest4"", ""kest4"", [x, y], data2, ""am""); ; # Create 2D adaptive kernel estimation pdf with mirroring and double; # bandwidth; kest5 = ROOT.RooNDKeysPdf(""kest5"", ""kest5"", [x, y], data2, ""am"", 2); ; # Create a histogram of the data; hh_data = data2.createHistogram(""hh_data"", x, Binning=10, YVar=dict(var=y, Binning=10)); ; # Create histogram of the 2d kernel estimation pdfs; hh_pdf = kest4.createHistogram(""hh_pdf"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf2 = kest5.createHistogram(""hh_pdf2"", x, Binning=25, YVar=dict(var=y, Binning=25)); hh_pdf.SetLineColor(ROOT.kBlue); hh_pdf2.SetLineColor(ROOT.kMagenta); ; c = ROOT.TCanvas(""rf707_kernelestimation"", ""rf707_kernelestimation"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); hh_data.GetZaxis().SetTitleOffset(1.4); hh_data.Draw(""lego""); c.cd(4); ROOT.gPad.SetLeftMargin(0.20); hh_pdf.GetZaxis()",MatchSource.WIKI,doc/master/rf707__kernelestimation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf707__kernelestimation_8py.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11238,Deployability,integrat,integrates,11238,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11516,Deployability,integrat,integrates,11516,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11238,Integrability,integrat,integrates,11238,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11516,Integrability,integrat,integrates,11516,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:9687,Modifiability,variab,variable,9687,"fDecayPDF describing decay time distribution of B meson including effects of standard model CP violation.Definition RooBCPEffDecay.h:23; RooBCPEffDecay::DoubleSided@ DoubleSidedDefinition RooBCPEffDecay.h:26; RooBDecayMost general description of B decay time distribution with effects of CP violation,...Definition RooBDecay.h:25; RooBDecay::DoubleSided@ DoubleSidedDefinition RooBDecay.h:29; RooBMixDecayClass RooBMixDecay is a RooAbsAnaConvPdf implementation that describes the decay of B mesons with the...Definition RooBMixDecay.h:23; RooBMixDecay::DoubleSided@ DoubleSidedDefinition RooBMixDecay.h:26; RooCategoryObject to represent discrete states.Definition RooCategory.h:28; RooFormulaVarA RooFormulaVar is a generic implementation of a real-valued object, which takes a RooArgList of serv...Definition RooFormulaVar.h:30; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooTruthModelImplements a RooResolution model that corresponds to a delta function.Definition RooTruthModel.h:21; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFit::RooConstRooConstVar & RooConst(double val)Definition RooGlobalFunc.cxx:1131; RooFit::MarkerColorRooCmdArg MarkerColor(Color_t color)Definition RooGlobalFunc.cxx:352; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Definition RooGlobalFunc.cxx:134; RooFit::CutRooCmdArg Cut(const ",MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11254,Modifiability,variab,variables,11254,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8C.html:11532,Modifiability,variab,variables,11532,,MatchSource.WIKI,doc/master/rf708__bphysics_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8C.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7043,Deployability,integrat,integrates,7043,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7321,Deployability,integrat,integrates,7321,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7043,Integrability,integrat,integrates,7043,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7321,Integrability,integrat,integrates,7321,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7059,Modifiability,variab,variables,7059,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf708__bphysics_8py.html:7337,Modifiability,variab,variables,7337,,MatchSource.WIKI,doc/master/rf708__bphysics_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf708__bphysics_8py.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:3693,Availability,down,down,3693,"sp_ph"", ""sp_ph"",; RooArgList(p_ph_sig1,p_ph_bkg1),; RooArgList(Asig1,Abkg1),; true);; ; // Construct the subsidiary poisson measurements constraining the histogram parameters; // These ensure that the bin contents of the histograms are only allowed to vary within; // the statistical uncertainty of the Monte Carlo.; RooHistConstraint hc_sig(""hc_sig"",""hc_sig"",p_ph_sig1);; RooHistConstraint hc_bkg(""hc_bkg"",""hc_bkg"",p_ph_bkg1);; ; // Construct the joint model with template PDFs and constraints; RooProdPdf model1(""model1"",""model1"",RooArgSet(hc_sig,hc_bkg),Conditional(model_tmp,x));; ; ; ; // ***** Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples) *****; ; // Construct the histogram shapes, using the same parameters for signal and background; // This requires passing the first histogram to the second, so that their common parameters; // can be re-used.; // The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; // This allows bin 0 to fluctuate up and down.; // Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; // synchronously. This reduces the number of parameters.; RooParamHistFunc p_ph_sig2(""p_ph_sig2"", ""p_ph_sig2"", *dh_sig, x);; RooParamHistFunc p_ph_bkg2(""p_ph_bkg2"", ""p_ph_bkg2"", *dh_bkg, x, &p_ph_sig2, true);; ; RooRealVar Asig2(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg2(""Abkg"",""Abkg"",1,0.01,5000);; ; // As before, construct the sum of signal2 and background2; RooRealSumPdf model2_tmp(""sp_ph"",""sp_ph"",; RooArgList(p_ph_sig2,p_ph_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:5272,Availability,error,error,5272,"_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo(sumData, PrintLevel(0), Save());; auto result1 = model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());; ; ; TCanvas* can = new TCanvas(""can"", """", 1500, 600);; can->Divide(3,1);; ; TPaveText pt(-19.5, 1, -2, 25);; pt.SetFillStyle(0);; pt.SetBorderSize(0);; ; ; can->cd(1);; auto frame = x.frame(Title(""No template uncertainties""));; // Plot data to enable automatic determination of model0 normalisation:; sumData.plotOn(frame);; model0.plotOn(frame, LineColor(kBlue), VisualizeError(*result0));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; // Plot model components; model0.plotOn(frame, LineColor(kBlue));; model0.plotOn(frame, Components(p_h_sig), LineColor(kAzure));; model0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:5687,Availability,error,errors,5687,"model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());; ; ; TCanvas* can = new TCanvas(""can"", """", 1500, 600);; can->Divide(3,1);; ; TPaveText pt(-19.5, 1, -2, 25);; pt.SetFillStyle(0);; pt.SetBorderSize(0);; ; ; can->cd(1);; auto frame = x.frame(Title(""No template uncertainties""));; // Plot data to enable automatic determination of model0 normalisation:; sumData.plotOn(frame);; model0.plotOn(frame, LineColor(kBlue), VisualizeError(*result0));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; // Plot model components; model0.plotOn(frame, LineColor(kBlue));; model0.plotOn(frame, Components(p_h_sig), LineColor(kAzure));; model0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston l",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:5749,Availability,error,errors,5749,"model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());; ; ; TCanvas* can = new TCanvas(""can"", """", 1500, 600);; can->Divide(3,1);; ; TPaveText pt(-19.5, 1, -2, 25);; pt.SetFillStyle(0);; pt.SetBorderSize(0);; ; ; can->cd(1);; auto frame = x.frame(Title(""No template uncertainties""));; // Plot data to enable automatic determination of model0 normalisation:; sumData.plotOn(frame);; model0.plotOn(frame, LineColor(kBlue), VisualizeError(*result0));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; // Plot model components; model0.plotOn(frame, LineColor(kBlue));; model0.plotOn(frame, Components(p_h_sig), LineColor(kAzure));; model0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston l",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:6046,Availability,error,error,6046,"frame = x.frame(Title(""No template uncertainties""));; // Plot data to enable automatic determination of model0 normalisation:; sumData.plotOn(frame);; model0.plotOn(frame, LineColor(kBlue), VisualizeError(*result0));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; // Plot model components; model0.plotOn(frame, LineColor(kBlue));; model0.plotOn(frame, Components(p_h_sig), LineColor(kAzure));; model0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2)",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:6587,Availability,error,errors,6587,"r (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2), LineColor(kAzure));; model2.plotOn(frame, Components(p_ph_bkg2), LineColor(kRed));; model2.paramOn(frame, Parameters(RooArgSet(Asig2, Abkg2)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; std::cout << ""Asig [normal ] = "" << Asig0.getVal() << "" +/- "" << Asig0.getError() << std::endl;; std::cout << ""Asig [BB ] = "" << Asi",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:6886,Availability,error,error,6886,");; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg1), LineColor(kRed));; model1.paramOn(frame, Parameters(RooArgSet(Asig1, Abkg1)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2), LineColor(kAzure));; model2.plotOn(frame, Components(p_ph_bkg2), LineColor(kRed));; model2.paramOn(frame, Parameters(RooArgSet(Asig2, Abkg2)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; std::cout << ""Asig [normal ] = "" << Asig0.getVal() << "" +/- "" << Asig0.getError() << std::endl;; std::cout << ""Asig [BB ] = "" << Asig1.getVal() << "" +/- "" << Asig1.getError() << std::endl;; std::cout << ""Asig [BBlight] = "" << Asig2.getVal() << "" +/- "" << Asig2.getError() << std::endl;; ; }; g#define g(i)Definition RSha256.hxx:105; RooDataHist.h; RooDataSet.h; RooGaussian.h; RooHis",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:7359,Availability,error,errors,7359,"t.Clear();; for (auto text : {; ""With gamma parameters, the"",; ""signal & background templates"",; ""can adapt to the data."",; ""Note how the blue signal"",; ""template changes its shape."",; ""This leads to higher errors"",; ""of the scale parameters A.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; can->cd(3);; frame = x.frame(Title(""Barlow Beeston light for (Sig+Bkg)""));; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue), VisualizeError(*result2));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; model2.plotOn(frame, LineColor(kBlue));; model2.plotOn(frame, Components(p_ph_sig2), LineColor(kAzure));; model2.plotOn(frame, Components(p_ph_bkg2), LineColor(kRed));; model2.paramOn(frame, Parameters(RooArgSet(Asig2, Abkg2)));; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; pt.Clear();; for (auto text : {; ""When signal and background"",; ""template share one gamma para-"",; ""meter per bin, they adapt less."",; ""The errors of the A parameters"",; ""also shrink slightly.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; std::cout << ""Asig [normal ] = "" << Asig0.getVal() << "" +/- "" << Asig0.getError() << std::endl;; std::cout << ""Asig [BB ] = "" << Asig1.getVal() << "" +/- "" << Asig1.getError() << std::endl;; std::cout << ""Asig [BBlight] = "" << Asig2.getVal() << "" +/- "" << Asig2.getError() << std::endl;; ; }; g#define g(i)Definition RSha256.hxx:105; RooDataHist.h; RooDataSet.h; RooGaussian.h; RooHistConstraint.h; RooHistFunc.h; RooParamHistFunc.h; RooPlot.h; RooProdPdf.h; RooRealSumPdf.h; RooRealVar.h; RooUniform.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kAzure@ kAzureDefinition Rtypes.h:67; TCanvas.h; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TPaveText.h; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:12094,Availability,error,error,12094,"&paramData, double Z=1)Definition RooGlobalFunc.cxx:300; RooFit::LineColorRooCmdArg LineColor(Color_t color)Definition RooGlobalFunc.cxx:215; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf709_BarlowBeestonDefinition rf709_BarlowBeeston.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:14243,Availability,error,error,14243,"O:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma_bin_13,p_ph_bkg_gamma_bin_14,p_ph_bkg_gamma_bin_15,p_ph_bkg_gamma_bin_16,p_ph_bkg_gamma_bin_17,p_ph_bkg_gamma_bin_18,p_ph_bkg_gamma_bin_19,p_ph_bkg_gamma_bin_2,p_ph_bkg_gamma_bin_20,p_ph_bkg_gamma_bin_21,p_ph_bkg_gamma_bin_22,p_ph_bkg_gamma_bin_23,p_ph_bkg_gamma_bin_24,p_ph_bkg_gamma_bin_3,p_ph_bkg_gamma_bin_4,p_ph_bkg_gamma_bin_5,p_ph_bkg_gamma_bin_6,p_ph_bkg_gamma_bin_7,p_ph_bkg_gamma_bin_8,p_ph_bkg_gamma_bin_9,p_ph_sig_gamma_bin_0,p_ph_sig_gamma_bin_1,p_ph_sig_gamma_bin_10,p_ph_sig_gamma_bin_11,p_ph_sig_gamma_bin_12,p_ph_sig_gamma_bin_13,p_ph_sig_gamma_bin_14,p_ph_sig_gamma_bin_15,p_ph_sig_gamma_bin_16,p_ph_sig_gamma_bin_17,p_ph_sig_gamma_bin_18,p_ph_sig_gamma_bin_19,p_ph_sig_gamma_bin_2,p_ph_sig_gamma_bin_20,p_ph_sig_gamma_bin_21,p_ph_sig_gamma_bin_22,p_ph_sig_gamma_bin_23,p_ph_sig_gamma_bin_24,p_ph_sig_gamma_bin_3,p_ph_sig_gamma_bin_4,p_ph_sig_gamma_bin_5,p_ph_sig_gamma_bin_6,p_ph_sig_gamma_bin_7,p_ph_sig_gamma_bin_8,p_ph_sig_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model1) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model1_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 16000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log foll",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:14478,Availability,error,error,14478,"O:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma_bin_13,p_ph_bkg_gamma_bin_14,p_ph_bkg_gamma_bin_15,p_ph_bkg_gamma_bin_16,p_ph_bkg_gamma_bin_17,p_ph_bkg_gamma_bin_18,p_ph_bkg_gamma_bin_19,p_ph_bkg_gamma_bin_2,p_ph_bkg_gamma_bin_20,p_ph_bkg_gamma_bin_21,p_ph_bkg_gamma_bin_22,p_ph_bkg_gamma_bin_23,p_ph_bkg_gamma_bin_24,p_ph_bkg_gamma_bin_3,p_ph_bkg_gamma_bin_4,p_ph_bkg_gamma_bin_5,p_ph_bkg_gamma_bin_6,p_ph_bkg_gamma_bin_7,p_ph_bkg_gamma_bin_8,p_ph_bkg_gamma_bin_9,p_ph_sig_gamma_bin_0,p_ph_sig_gamma_bin_1,p_ph_sig_gamma_bin_10,p_ph_sig_gamma_bin_11,p_ph_sig_gamma_bin_12,p_ph_sig_gamma_bin_13,p_ph_sig_gamma_bin_14,p_ph_sig_gamma_bin_15,p_ph_sig_gamma_bin_16,p_ph_sig_gamma_bin_17,p_ph_sig_gamma_bin_18,p_ph_sig_gamma_bin_19,p_ph_sig_gamma_bin_2,p_ph_sig_gamma_bin_20,p_ph_sig_gamma_bin_21,p_ph_sig_gamma_bin_22,p_ph_sig_gamma_bin_23,p_ph_sig_gamma_bin_24,p_ph_sig_gamma_bin_3,p_ph_sig_gamma_bin_4,p_ph_sig_gamma_bin_5,p_ph_sig_gamma_bin_6,p_ph_sig_gamma_bin_7,p_ph_sig_gamma_bin_8,p_ph_sig_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model1) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model1_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 16000 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log foll",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:15605,Availability,error,error,15605, follows.; Parameter values: Abkg=0.024352 Asig=0.0100451 p_ph_bkg_gamma_bin_0=0.351482 p_ph_bkg_gamma_bin_1=0.352595 p_ph_bkg_gamma_bin_10=0.342683 p_ph_bkg_gamma_bin_11=0.368891 p_ph_bkg_gamma_bin_12=0.38197 p_ph_bkg_gamma_bin_13=0.365529 p_ph_bkg_gamma_bin_14=0.358098 p_ph_bkg_gamma_bin_15=0.358584 p_ph_bkg_gamma_bin_16=0.367344 p_ph_bkg_gamma_bin_17=0.356263 p_ph_bkg_gamma_bin_18=0.362211 p_ph_bkg_gamma_bin_19=0.340063 p_ph_bkg_gamma_bin_2=0.35054 p_ph_bkg_gamma_bin_20=0.352376 p_ph_bkg_gamma_bin_21=0.351589 p_ph_bkg_gamma_bin_22=0.351615 p_ph_bkg_gamma_bin_23=0.344488 p_ph_bkg_gamma_bin_24=0.365687 p_ph_bkg_gamma_bin_3=0.355197 p_ph_bkg_gamma_bin_4=0.347776 p_ph_bkg_gamma_bin_5=0.348629 p_ph_bkg_gamma_bin_6=0.357616 p_ph_bkg_gamma_bin_7=0.351061 p_ph_bkg_gamma_bin_8=0.342678 p_ph_bkg_gamma_bin_9=0.357292 p_ph_sig_gamma_bin_11=0.3339 p_ph_sig_gamma_bin_12=0.341347 p_ph_sig_gamma_bin_13=0.333434 p_ph_sig_gamma_bin_14=0.328932 p_ph_sig_gamma_bin_15=0.328666; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10425.6) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=0.327409 Asig=0.26768 p_ph_bkg_gamma_bin_0=0.63877 p_ph_bkg_gamma_bin_1=0.639509 p_ph_bkg_gamma_bin_10=0.632897 p_ph_bkg_gamma_bin_11=0.650254 p_ph_bkg_gamma_bin_12=0.658769 p_ph_bkg_gamma_bin_13=0.648049 p_ph_bkg_gamma_bin_14=0.643155 p_ph_bkg_gamma_bin_15=0.643476 p_ph_bkg_gamma_bin_16=0.64924 p_ph_bkg_gamma_bin_17=0.641941 p_ph_bkg_gamma_bin_18=0.645868 p_ph_bkg_gamma_bin_19=0.63114 p_ph_bkg_gamma_bin_2=0.638144 p_ph_bkg_gamma_bin_20=0.639364 p_ph_bkg_gamma_bin_21=0.638841 p_ph_bkg_gamma_bin_22=0.638858 p_ph_bkg_gamma_bin_23=0.634106 p_ph_bkg_gamma_bin_24=0.648153 p_ph_bkg_gamma_bin_3=0.641235 p_ph_bkg_gamma_bin_4=0.636302 p_ph_bkg_gamma_bin_5=0.636871 p_ph_bkg_gamma_bin_6=0.642836 p_ph_bkg_gamma_bin_7=0.63849 p_ph_bkg_gamma_bin_8=0.632894 p_ph_bkg_gamma_bin_9=0.642622 p_ph_sig_gamma_bin_11=0.626988 p_ph_sig_gamma_bin_12=0.6,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:19835,Availability,error,error,19835,"bin_13 = 0.890724 +/- 0.195929 (limited); p_ph_sig_gamma_bin_14 = 0.947374 +/- 0.309135 (limited); p_ph_sig_gamma_bin_15 = 1.14132 +/- 0.81204 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sigbkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_sig2_gamma_bin_0,p_ph_sig2_gamma_bin_1,p_ph_sig2_gamma_bin_10,p_ph_sig2_gamma_bin_11,p_ph_sig2_gamma_bin_12,p_ph_sig2_gamma_bin_13,p_ph_sig2_gamma_bin_14,p_ph_sig2_gamma_bin_15,p_ph_sig2_gamma_bin_16,p_ph_sig2_gamma_bin_17,p_ph_sig2_gamma_bin_18,p_ph_sig2_gamma_bin_19,p_ph_sig2_gamma_bin_2,p_ph_sig2_gamma_bin_20,p_ph_sig2_gamma_bin_21,p_ph_sig2_gamma_bin_22,p_ph_sig2_gamma_bin_23,p_ph_sig2_gamma_bin_24,p_ph_sig2_gamma_bin_3,p_ph_sig2_gamma_bin_4,p_ph_sig2_gamma_bin_5,p_ph_sig2_gamma_bin_6,p_ph_sig2_gamma_bin_7,p_ph_sig2_gamma_bin_8,p_ph_sig2_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model2) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model2_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 13500 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=7.28945 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_b",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:20070,Availability,error,error,20070,"bin_13 = 0.890724 +/- 0.195929 (limited); p_ph_sig_gamma_bin_14 = 0.947374 +/- 0.309135 (limited); p_ph_sig_gamma_bin_15 = 1.14132 +/- 0.81204 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sigbkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_sig2_gamma_bin_0,p_ph_sig2_gamma_bin_1,p_ph_sig2_gamma_bin_10,p_ph_sig2_gamma_bin_11,p_ph_sig2_gamma_bin_12,p_ph_sig2_gamma_bin_13,p_ph_sig2_gamma_bin_14,p_ph_sig2_gamma_bin_15,p_ph_sig2_gamma_bin_16,p_ph_sig2_gamma_bin_17,p_ph_sig2_gamma_bin_18,p_ph_sig2_gamma_bin_19,p_ph_sig2_gamma_bin_2,p_ph_sig2_gamma_bin_20,p_ph_sig2_gamma_bin_21,p_ph_sig2_gamma_bin_22,p_ph_sig2_gamma_bin_23,p_ph_sig2_gamma_bin_24,p_ph_sig2_gamma_bin_3,p_ph_sig2_gamma_bin_4,p_ph_sig2_gamma_bin_5,p_ph_sig2_gamma_bin_6,p_ph_sig2_gamma_bin_7,p_ph_sig2_gamma_bin_8,p_ph_sig2_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model2) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model2_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 13500 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=7.28945 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_b",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:20887,Availability,error,error,20887,"p_ph_sig2_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model2) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model2_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 13500 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=7.28945 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=7.28945 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_",MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:21704,Availability,error,error,21704,ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=7.28945 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=7.28945 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:22521,Availability,error,error,22521,a_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=7.28945 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=7.28945 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_g,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:23338,Availability,error,error,23338,a_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=7.28945 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=7.28945 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinim,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:24155,Availability,error,error,24155,ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=7.28945 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=7.28945 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Min,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:24972,Availability,error,error,24972,a_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=7.28945 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=7.28945 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized functi,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:25789,Availability,error,error,25789,ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=7.28945 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=7.28945 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:26606,Availability,error,error,26606,a_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=7.28945 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Re,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:27423,Availability,error,error,27423,ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=7.28945 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maxim,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:28240,Availability,error,error,28240,0=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=7.28945 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so fa,MatchSource.WIKI,doc/master/rf709__BarlowBeeston_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html
